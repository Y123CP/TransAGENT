[{"source_Lan": "python###ANDequalOR.py", "source_code": "def ANDequalOR( n: int, arr: List[int]) -> int:\n    ans = 0\n    pre = 0\n    count = 0\n    for i in range(n):\n        if arr[i] == arr[pre]:\n            count += 1\n        else:\n            ans += (count * (count + 1)) // 2\n            pre = i\n            count = 1\n    ans += (count * (count + 1)) // 2\n    return ans", "trans_code": "int ANDequalOR ( int n , int * arr ) throw ( ) {\n  int ans = 0 ;\n  int pre = 0 ;\n  int count = 0 ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    if ( arr [ i ] == arr [ pre ] ) {\n      count ++ ;\n    }\n    else {\n      ans += ( count * ( count + 1 ) ) / 2 ;\n      pre = i ;\n      count = 1 ;\n    }\n  }\n  ans += ( count * ( count + 1 ) ) / 2 ;\n  return ans ;\n}\n", "reference_code": "    long long ANDequalOR(int n, vector<int> arr) {\n        long long ans = 0;\n        for (int i = 0; i < n; i++) {\n            int pt = i;\n            long long ct = 0;\n            while (pt < n) {\n                if (arr[pt] == arr[i]) {\n                    pt++;\n                    ct++;\n                } else\n                    break;\n            }\n            ct *= (ct + 1);\n            ct /= 2;\n            ans += ct;\n            i = pt - 1;\n        }\n        return ans;\n    }", "target_Lan": "cpp###ANDequalOR.cpp", "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    cout << ANDequalOR(3, vector<int>{1, 2, 3}) << endl;\n    cout << ANDequalOR(4, vector<int>{2, 2, 2, 2}) << endl;\n    cout << ANDequalOR(5, vector<int>{1, 1, 2, 2, 2}) << endl;\n    cout << ANDequalOR(5, vector<int>{1, 2, 3, 4, 5}) << endl;\n    cout << ANDequalOR(5, vector<int>{1, 1, 1, 1, 1}) << endl;\n    return 0;\n}"}, {"source_Lan": "python###MinSize.py", "source_code": "def MinSize( A: List[int],  n: int) -> int:\n    \n    curr = A[0]\n    count = 1\n    for i in range(1, n):\n        if A[i] == curr:\n            count += 1\n        else:\n            count -= 1\n            if count == 0:\n                curr = A[i]\n                count = 1\n    max_f = A.count(curr)\n    if max_f <= (n + 1) // 2:\n        return n & 1\n    else:\n        return 2 * max_f - n", "trans_code": "int MinSize ( vector < int > & A , int n ) throw ( ) {\n  int curr = A [ 0 ] ;\n  int count = 1 ;\n  for ( int i = 1 ;\n  i < n ;\n  i ++ ) {\n    if ( A [ i ] == curr ) count ++ ;\n    else {\n      count -- ;\n      if ( count == 0 ) {\n        curr = A [ i ] ;\n        count = 1 ;\n      }\n    }\n  }\n  int max_f = A . count ( curr ) ;\n  if ( max_f <= ( n + 1 ) / 2 ) return n & 1 ;\n  else return 2 * max_f - n ;\n}\n", "reference_code": "    int MinSize(vector<int> A, int n) {\n        \n        \n        int curr = A[0];\n        int count = 1;\n        for (int i = 1; i < n; ++i) {\n            if (A[i] == curr) {\n                count += 1;\n            } else {\n                count -= 1;\n                if (count == 0) {\n                    curr = A[i];\n                    count = 1;\n                }\n            }\n        }\n        int max_f = 0;\n        for (int i = 0; i < n; i++)\n            if (curr == A[i])\n                max_f++;\n        if (max_f <= (n + 1) / 2) {\n            return n & 1;\n        } else {\n            return 2 * max_f - n;\n        }\n    }", "target_Lan": "cpp###MinSize.cpp", "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    vector<int> A1 = {0,0,1,1,1};\n    cout << MinSize(A1, 5) << endl;\n    \n    vector<int> A2 = {1,1,1,0,0,0};\n    cout << MinSize(A2, 6) << endl;\n    \n    vector<int> A3 = {0,1,0,1,0,1};\n    cout << MinSize(A3, 6) << endl;\n    \n    vector<int> A4 = {1,1,1,1,0,0};\n    cout << MinSize(A4, 6) << endl;\n    \n    vector<int> A5 = {0,0,0,1,1,1};\n    cout << MinSize(A5, 6) << endl;\n}"}, {"source_Lan": "python###frequency.py", "source_code": "def frequency( n ,a):\n    mp=dict()\n    for i in range(n):\n        if a[i] in mp:\n            mp[a[i]]+=1\n        else:\n            mp[a[i]]=1\n    ans=[]\n    for i in range(n):\n        ans.append(mp[a[i]])\n        mp[a[i]]-=1\n    return ans", "trans_code": "public : vector < int > frequency ( int n , vector < int > a ) {\n  map < int , int > mp ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    if ( a [ i ] < mp [ i ] ) mp [ a [ i ] ] ++ ;\n    else mp [ a [ i ] ] = 1 ;\n  }\n  vector < int > ans ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    ans . push_back ( mp [ a [ i ] ] ) ;\n    mp [ a [ i ] ] -- ;\n  }\n  return ans ;\n}\n", "reference_code": "    vector<int> frequency(int n, vector<int> &a){\n        vector<int>ans(n);\n        unordered_map<int,int>mp;\n        for(int i=n-1;i>-1;i--)\n        {\n            mp[a[i]]++;\n            ans[i]=mp[a[i]];\n        }\n        return ans;\n    }", "target_Lan": "cpp###frequency.cpp", "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <bits/stdc++.h>\n// TOFILL\nint main() {\n    int n1 = 0;\n    vector<int> a1 = {};\n    vector<int> output1 = frequency(n1, a1);\n    for(int i=0; i<output1.size(); i++)\n        cout << output1[i] << \" \";\n    cout << endl;\n\n    int n2 = 1;\n    vector<int> a2 = {1};\n    vector<int> output2 = frequency(n2, a2);\n    for(int i=0; i<output2.size(); i++)\n        cout << output2[i] << \" \";\n    cout << endl;\n\n    int n3 = 2;\n    vector<int> a3 = {1,2};\n    vector<int> output3 = frequency(n3, a3);\n    for(int i=0; i<output3.size(); i++)\n        cout << output3[i] << \" \";\n    cout << endl;\n\n    int n4 = 3;\n    vector<int> a4 = {1,1,2};\n    vector<int> output4 = frequency(n4, a4);\n    for(int i=0; i<output4.size(); i++)\n        cout << output4[i] << \" \";\n    cout << endl;\n\n    int n5 = 5;\n    vector<int> a5 = {1,2,3,2,1};\n    vector<int> output5 = frequency(n5, a5);\n    for(int i=0; i<output5.size(); i++)\n        cout << output5[i] << \" \";\n    cout << endl;\n\n    return 0;\n}"}, {"source_Lan": "python###findGoodPairs.py", "source_code": "def findGoodPairs( a, n, k):\n    mp=dict()\n    for i in range(n):\n        if (a[i] in mp):\n            mp[a[i]].append(i)\n        else:\n            mp[a[i]]=[i]\n    c=0\n    for i in mp:\n        li=mp[i]\n        le=len(li)\n        i=0\n        j=0\n        while(j<le):\n            if (li[j]-li[i])>=k:\n                c+=(le-j)\n                i+=1\n            else:\n                j+=1\n    return c", "trans_code": "int findGoodPairs ( int a [ ] , int n , int k ) {\n  map < int , vector < int >> mp ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    if ( ( a [ i ] < 0 ) || ( a [ i ] > n ) ) {\n      mp [ a [ i ] ] . push_back ( i ) ;\n    }\n    else {\n      mp [ a [ i ] ] . push_back ( i ) ;\n    }\n  }\n  int c = 0 ;\n  for ( int i = 0 ;\n  i < mp . size ( ) ;\n  i ++ ) {\n    vector < int > & li = mp [ i ] ;\n    int le = li . size ( ) ;\n    int i = 0 ;\n    int j = 0 ;\n    while ( ( j < le ) && ( i < le ) ) {\n      if ( ( li [ j ] - li [ i ] ) >= k ) {\n        c += ( le - j ) ;\n        i ++ ;\n      }\n      else {\n        j ++ ;\n      }\n    }\n  }\n  return c ;\n}\n", "reference_code": "    long long findGoodPairs(vector<int> a, int n, int k) {\n        map<int, int > ma;\n        long long ans = 0;\n        for (int i = k; i < n; i++) {\n            ma[a[i - k]]++;\n            ans += ma[a[i]];\n        }\n        return ans;\n    }", "target_Lan": "cpp###findGoodPairs.cpp", "target_code_shell": "#include <iostream>\nusing namespace std;\n#include<bits/stdc++.h>\n// TOFILL\nint main() {\n    cout << findGoodPairs({1,2,3,4,5}, 5, 1) << endl;\n    cout << findGoodPairs({5,5,5,5,5}, 5, 2) << endl;\n    cout << findGoodPairs({1,1,1,1,1}, 5, 3) << endl;\n    cout << findGoodPairs({1,2,1,2,1}, 5, 4) << endl;\n    cout << findGoodPairs({1,1,1,2,2}, 5, 5) << endl;\n    return 0;\n}"}, {"source_Lan": "python###timeTravel.py", "source_code": "def timeTravel( n, arr):\n    ans=0\n    for i in range(1,n):\n        if (arr[i]>arr[i-1]):\n            ans+=1\n        elif (arr[i]<arr[i-1]):\n            ans+=2\n    return ans", "trans_code": "int timeTravel ( int n , int arr [ ] ) {\n  int ans = 0 ;\n  for ( int i = 1 ;\n  i < n ;\n  i ++ ) {\n    if ( ( arr [ i ] > arr [ i - 1 ] ) && ( arr [ i ] < arr [ i - 1 ] ) ) {\n      ans ++ ;\n    }\n    else if ( ( arr [ i ] < arr [ i - 1 ] ) && ( arr [ i ] > arr [ i - 1 ] ) ) {\n      ans += 2 ;\n    }\n  }\n  return ans ;\n}\n", "reference_code": "    int timeTravel(int n, vector<int> &arr) {\n        int ans = 0;\n        for(int i = 1; i < n; i++)\n            ans += (arr[i] > arr[i - 1] ? 1 : (arr[i] < arr[i - 1] ? 2 : 0));\n        return ans;\n    }", "target_Lan": "cpp###timeTravel.cpp", "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    int n1 = 5;\n    vector<int> arr1 = {1, 2, 3, 4, 5};\n    cout << timeTravel(n1, arr1) << endl;\n\n    int n2 = 5;\n    vector<int> arr2 = {5, 4, 3, 2, 1};\n    cout << timeTravel(n2, arr2) << endl;\n\n    int n3 = 5;\n    vector<int> arr3 = {1, 1, 1, 1, 1};\n    cout << timeTravel(n3, arr3) << endl;\n\n    int n4 = 5;\n    vector<int> arr4 = {-1, -2, -3, -4, -5};\n    cout << timeTravel(n4, arr4) << endl;\n\n    int n5 = 5;\n    vector<int> arr5 = {5, 1, 2, 3, 4};\n    cout << timeTravel(n5, arr5) << endl;\n\n    return 0;\n}"}, {"source_Lan": "python###lastFairyStanding.py", "source_code": "def lastFairyStanding( n : int, k : int) -> int:\n    ans = 0\n    for x in range(2, n+1): \n        ans = (ans + k) % x\n    return ans + 1", "trans_code": "int lastFairyStanding ( int n , int k ) throw ( ) {\n  int ans = 0 ;\n  for ( int x = 2 ;\n  x <= n ;\n  x ++ ) ans = ( ans + k ) % x ;\n  return ans + 1 ;\n}\n", "reference_code": "    int lastFairyStanding(int n, int k) {\n        \n        int i = 1, ans = 0;\n        while (i <= n)\n            ans = (ans + k) % i++;\n        return ans + 1;\n    }", "target_Lan": "cpp###lastFairyStanding.cpp", "target_code_shell": "#include <iostream>\nusing namespace std;\n\n// TOFILL\nint main() {\n    cout << lastFairyStanding(1, 1) << endl;\n    cout << lastFairyStanding(10, 2) << endl;\n    cout << lastFairyStanding(0, 0) << endl;\n    cout << lastFairyStanding(10, 10) << endl;\n    cout << lastFairyStanding(100, 20) << endl;\n}"}, {"source_Lan": "python###trafficLights.py", "source_code": "def trafficLights( n: int, q: int, queries: List[List[int]]) -> str:\n    sweap = [0] * (n + 1)\n    for l, r in queries:\n        sweap[l - 1] += 1\n        sweap[r] -= 1\n    curr = 0\n    ans = \"\"\n    for i in range(n):\n        curr = (curr + sweap[i]) % 3\n        if curr == 0:\n            ans += 'R'\n        elif curr == 1:\n            ans += 'Y'\n        else:\n            ans += 'G'\n    return ans", "trans_code": "string trafficLights ( int n , int q , vector < vector < int >> & queries ) throw ( ) {\n  vector < int > sweap ( n + 1 , 0 ) ;\n  for ( int l = 0 , r = 0 ;\n  l < q ;\n  l ++ , r ++ ) {\n    sweap [ l - 1 ] ++ ;\n    sweap [ r ] -- ;\n  }\n  int curr = 0 ;\n  string ans = \"\" ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    curr = ( curr + sweap [ i ] ) % 3 ;\n    if ( curr == 0 ) ans += 'R' ;\n    else if ( curr == 1 ) ans += 'Y' ;\n    else ans += 'G' ;\n  }\n  return ans ;\n}\n", "reference_code": "    string trafficLights(int n, int q, vector<vector<int>>& queries) {\n        \n        vector<int> darr(n + 1, 0);\n        for (vector<int>& Q : queries) {\n            int a = Q[0];\n            int b = Q[1];\n            darr[a - 1]++;\n            darr[b]--;\n        }\n        partial_sum(darr.begin(), darr.end(), darr.begin());\n        string result = \"\";\n        for (int i = 0; i < n; i++) {\n            int X = darr[i] % 3;\n            if (X == 0)\n                result += \"R\";\n            else if (X == 1)\n                result += \"Y\";\n            else if (X == 2)\n                result += \"G\";\n        }\n        return result;\n    }", "target_Lan": "cpp###trafficLights.cpp", "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <bits/stdc++.h>\n// TOFILL\nint main() {\n    vector<vector<int>> queries1 = {{1,2}, {2,3}, {1,3}};\n    cout << trafficLights(3, 3, queries1) << endl;\n\n    vector<vector<int>> queries2 = {{1,3}, {2,4}, {3,5}, {1,5}, {2,3}};\n    cout << trafficLights(5, 5, queries2) << endl;\n\n    vector<vector<int>> queries3 = {{1,1}};\n    cout << trafficLights(1, 1, queries3) << endl;\n\n    vector<vector<int>> queries4 = {{1,2}, {2,3}, {3,4}, {4,1}};\n    cout << trafficLights(4, 4, queries4) << endl;\n\n    vector<vector<int>> queries5 = {{1,2}, {2,1}};\n    cout << trafficLights(2, 2, queries5) << endl;\n\n    return 0;\n}"}, {"source_Lan": "python###findEnemies.py", "source_code": "def findEnemies( n : int, m : int, k : int, col : List[int], count : List[int]) -> List[List[int]]:\n    arr=[[-1]*(m) for _ in range(n)]\n    ind=0\n    for i in range(n):\n        while count[i]>0:\n            arr[i][col[ind]]=ind\n            ind+=1\n            count[i]-=1\n    return arr", "trans_code": "public : vector < vector < int >> findEnemies ( int n , int m , int k , vector < int > col , vector < int > count ) throw ( ) {\n  vector < vector < int >> arr ( n , vector < int > ( m ) ) ;\n  int ind = 0 ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    while ( count [ i ] > 0 ) {\n      arr [ i ] [ col [ ind ] ] = ind ;\n      ind ++ ;\n      count [ i ] -- ;\n    }\n  }\n  return arr ;\n}\n", "reference_code": "    vector<vector<int>> findEnemies(int n, int m, int k, vector<int> &col, vector<int> &count) {\n        vector<vector<int>> answer(n, vector<int>(m, -1));\n        int curr = 0;\n        int ind = 0;\n        while(curr < k && ind < n){\n            int total = count[ind];\n            while(total--){\n                answer[ind][col[curr]] = curr;\n                curr += 1;\n            }\n            ind += 1;\n        }\n        return answer;\n    }", "target_Lan": "cpp###findEnemies.cpp", "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    int n = 0, m = 0, k = 0;\n    vector<int> col = {}, count = {};\n    findEnemies(n, m, k, col, count);\n\n    n = 1, m = 1, k = 1, col = {0}, count = {1};\n    findEnemies(n, m, k, col, count);\n\n    n = 2, m = 2, k = 2, col = {0, 1}, count = {1, 1};\n    findEnemies(n, m, k, col, count);\n\n    n = 3, m = 3, k = 3, col = {0, 1, 2}, count = {1, 1, 1};\n    findEnemies(n, m, k, col, count);\n\n    n = 4, m = 4, k = 4, col = {0, 1, 2, 3}, count = {1, 1, 1, 1};\n    findEnemies(n, m, k, col, count);\n}"}, {"source_Lan": "python###validStrings.py", "source_code": "def validStrings( n : int, k : int, arr : List[str]) -> int:\n    ans=0\n    for el in arr:\n        C=0\n        for e in el:\n            if e in \"aeiou\":\n                C+=1\n        if C==k:\n            ans+=1\n    return ans", "trans_code": "public : int validStrings ( int n , int k , vector < string > arr ) throw ( ) {\n  int ans = 0 ;\n  for ( auto el : arr ) {\n    int C = 0 ;\n    for ( auto e : el ) {\n      if ( e == \"aeiou\" ) C ++ ;\n    }\n    if ( C == k ) ans ++ ;\n  }\n  return ans ;\n}\n", "reference_code": "    int validStrings(int n, int k, vector<string> &arr) {\n        int tot=0;\n        for (auto j:arr){\n            int c=0;\n            for (auto q:j){\n                if (q=='a'||q=='e'||q=='i'||q=='o'||q=='u') c+=1;\n            }\n            if (c==k) tot+=1;\n        }\n        return tot;\n    }", "target_Lan": "cpp###validStrings.cpp", "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <string>\n// TOFILL\nint main() {\n    vector<string> arr1 = {\"abc\", \"def\", \"ghi\"};\n    cout << validStrings(3, 2, arr1) << endl;\n\n    vector<string> arr2 = {\"jkl\", \"mno\", \"pqr\", \"stu\"};\n    cout << validStrings(4, 1, arr2) << endl;\n\n    vector<string> arr3 = {\"vwx\", \"yza\"};\n    cout << validStrings(2, 3, arr3) << endl;\n\n    vector<string> arr4 = {\"bcd\"};\n    cout << validStrings(1, 1, arr4) << endl;\n\n    vector<string> arr5 = {\"efg\", \"hij\", \"klm\", \"nop\", \"qrs\"};\n    cout << validStrings(5, 3, arr5) << endl;\n\n    return 0;\n}"}, {"source_Lan": "python###smallestString.py", "source_code": "def smallestString( n : int, s : str) -> str:\n    \n    if n == 1:\n        return \"-1\"\n    answer = list(s)\n    \n    for i in range(n // 2):\n        \n        if s[i] != 'a':\n            answer[i] = 'a'\n            return ''.join(answer)\n    \n    answer[-1] = 'b'\n    return ''.join(answer)", "trans_code": "string smallestString ( int n , string s ) throw ( ) {\n  if ( n == 1 ) return \"-1\" ;\n  vector < string > answer ( n ) ;\n  for ( int i = 0 ;\n  i < n / 2 ;\n  i ++ ) {\n    if ( s [ i ] != 'a' ) {\n      answer [ i ] = 'a' ;\n      return string ( answer . begin ( ) , answer . end ( ) ) ;\n    }\n  }\n  answer [ n - 1 ] = 'b' ;\n  return string ( answer . begin ( ) , answer . end ( ) ) ;\n}\n", "reference_code": "    string smallestString(int n, string s) {\n        string answer = s;\n        int odd = n%2;\n        if(n == 1){\n            return \"-1\";\n        }\n        for(int i = 0; i < (n/2); i ++){\n            if(s[i] != 'a'){\n                answer[i] = 'a';\n                return answer;\n            }\n        }\n        answer[answer.size() - 1] = 'b';\n        return answer;\n    }", "target_Lan": "cpp###smallestString.cpp", "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <string>\n// TOFILL\nint main() {\n    cout << smallestString(2, \"aa\") << endl;\n    cout << smallestString(3, \"baa\") << endl;\n    cout << smallestString(1, \"b\") << endl;\n    cout << smallestString(5, \"abbaa\") << endl;\n    cout << smallestString(10, \"aaaaaaaaaa\") << endl;\n    return 0;\n}"}, {"source_Lan": "python###AreEqual.py", "source_code": "def AreEqual( a: str, b: str) -> bool:\n    for i in range(len(a) - 1):\n        if (a[i] == b[i] and a[i] == '0' and a[i + 1] == b[i + 1]\n                and a[i + 1] == '1'):\n            return True\n    return False", "trans_code": "bool AreEqual ( string a , string b ) throw ( ) {\n  for ( int i = 0 ;\n  i < a . size ( ) - 1 ;\n  i ++ ) {\n    if ( ( a [ i ] == b [ i ] && a [ i ] == '0' && a [ i + 1 ] == b [ i + 1 ] && a [ i + 1 ] == '1' ) || ( a [ i ] == '0' && a [ i + 1 ] == b [ i + 1 ] && a [ i + 1 ] == '1' ) ) {\n      return true ;\n    }\n  }\n  return false ;\n}\n", "reference_code": "    bool AreEqual(string a, string b) {\n        int n = a.length();\n        bool flag = false;\n        for (int i = 0; i < n - 1; i++) {\n            if (a[i] == '0' && b[i + 1] == '1') {\n                if (a[i] == b[i] && a[i + 1] == b[i + 1]) {\n                    flag = true;\n                }\n            }\n        }\n        return flag;\n    }", "target_Lan": "cpp###AreEqual.cpp", "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <string>\n// TOFILL\nint main() {\n    cout <<(AreEqual(\"001\", \"011\") ? \"true\" : \"false\") << endl;\n    cout <<(AreEqual(\"100\", \"110\") ? \"true\" : \"false\") << endl;\n    cout <<(AreEqual(\"010\", \"011\") ? \"true\" : \"false\") << endl;\n    cout <<(AreEqual(\"111\", \"000\") ? \"true\" : \"false\") << endl;\n    cout <<(AreEqual(\"000\", \"111\") ? \"true\" : \"false\") << endl;\n}"}, {"source_Lan": "python###maxPoints.py", "source_code": "def maxPoints( n: int, arr: List[List[int]]) -> int:\n    dp = [0] * (200000)\n    for i in range(n - 1, -1, -1):\n        dp[i] = max(arr[i][0] + dp[arr[i][1] + i + 1], dp[i + 1])\n    return dp[0]", "trans_code": "public : int maxPoints ( int n , vector < vector < int >> arr ) throw ( ) {\n  vector < int > dp ( 200000 ) ;\n  for ( int i = n - 1 ;\n  i >= 0 ;\n  i -- ) dp [ i ] = max ( arr [ i ] [ 0 ] + dp [ arr [ i ] [ 1 ] + i + 1 ] , dp [ i + 1 ] ) ;\n  return dp [ 0 ] ;\n}\n", "reference_code": "    long long maxPoints(int n, vector<vector<int>> &arr) {\n        long long dp[200001] = {};\n        for (int i = n - 1; i >= 0; --i)\n            dp[i] = max(arr[i][0] + dp[arr[i][1] + i + 1], dp[i + 1]);\n        return dp[0];\n    }", "target_Lan": "cpp###maxPoints.cpp", "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <bits/stdc++.h>\n// TOFILL\nint main() {\n    int n1 = 0;\n    vector<vector<int>> arr1 = {};\n    cout << maxPoints(n1, arr1) << endl;\n\n    int n2 = 1;\n    vector<vector<int>> arr2 = {{1,0}};\n    cout << maxPoints(n2, arr2) << endl;\n\n    int n3 = 2;\n    vector<vector<int>> arr3 = {{1,0}, {2,0}};\n    cout << maxPoints(n3, arr3) << endl;\n\n    int n4 = 3;\n    vector<vector<int>> arr4 = {{1,0}, {2,0}, {3,0}};\n    cout << maxPoints(n4, arr4) << endl;\n\n    int n5 = 4;\n    vector<vector<int>> arr5 = {{1,0}, {2,0}, {3,0}, {4,0}};\n    cout << maxPoints(n5, arr5) << endl;\n\n    return 0;\n}"}, {"source_Lan": "python###matrixConundrum.py", "source_code": "def matrixConundrum( n: int, m: int, mat: List[str]) -> bool:\n    check = ['p', 'l', 'a', 'y']\n    idx = 0\n    for j in range(m):\n        for i in range(n):\n            if mat[i][j] == check[idx]:\n                idx += 1\n                if idx == 4:\n                    return True\n                break\n    return False", "trans_code": "bool matrixConundrum ( int n , int m , std :: vector < std :: string > & mat ) throw ( ) {\n  char check [ ] = {\n    'p' , 'l' , 'a' , 'y' }\n    ;\n    int idx = 0 ;\n    for ( int j = 0 ;\n    j < m ;\n    j ++ ) {\n      for ( int i = 0 ;\n      i < n ;\n      i ++ ) {\n        if ( mat [ i ] [ j ] == check [ idx ] ) {\n          idx ++ ;\n          if ( idx == 4 ) return true ;\n          break ;\n        }\n      }\n    }\n    return false ;\n  }\n  ", "reference_code": "    bool matrixConundrum(int n, int m, vector<string> &mat) {\n        string play = \"play\";\n        int fnd = 0;\n        for (int i = 0; i < m; ++i) {\n            bool check = false;\n            for (int j = 0; j < n; ++j) {\n                if (mat[j][i] == play[fnd]) {\n                    check = true;\n                }\n            }\n            if (check) {\n                ++fnd;\n                if (fnd == 4) {\n                    break;\n                }\n            }\n        }\n        if (fnd == 4)\n            return true;\n        return false;\n    }", "target_Lan": "cpp###matrixConundrum.cpp", "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <string>\n#include <vector>\n// TOFILL\nint main() {\n    int n0 = 0, m0 = 0;\n    vector<string> mat0;\n    cout << matrixConundrum(n0, m0, mat0) << endl;\n\n    int n1 = 1, m1 = 4;\n    vector<string> mat1 = {\"play\"};\n    cout << matrixConundrum(n1, m1, mat1) << endl;\n\n    int n2 = 4, m2 = 1;\n    vector<string> mat2 = {\"p\", \"l\", \"a\", \"y\"};\n    cout << matrixConundrum(n2, m2, mat2) << endl;\n\n    int n3 = 4, m3 = 4;\n    vector<string> mat3 = {\"pabc\", \"bcdz\", \"efgh\", \"ijkl\"};\n    cout << matrixConundrum(n3, m3, mat3) << endl;\n\n    return 0;\n}"}, {"source_Lan": "python###countOperations.py", "source_code": "def countOperations( s: str) -> int:\n    mod = 10**9 + 7\n    ans = 0\n    count_b = 0\n    for i in range(len(s) - 1, -1, -1):\n        if s[i] == 'b':\n            count_b = (count_b + 1) % mod\n        else:\n            ans = (ans + count_b) % mod\n            count_b = (count_b + count_b) % mod\n    return ans", "trans_code": "public : int countOperations ( string s ) throw ( ) {\n  int mod = 10 * 9 + 7 ;\n  int ans = 0 ;\n  int count_b = 0 ;\n  for ( int i = s . length ( ) - 1 ;\n  i >= 0 ;\n  i -- ) {\n    if ( s [ i ] == 'b' ) count_b = ( count_b + 1 ) % mod ;\n    else {\n      ans = ( ans + count_b ) % mod ;\n      count_b = ( count_b + count_b ) % mod ;\n    }\n  }\n  return ans ;\n}\n", "reference_code": "    int countOperations(string s) {\n        const int mod = 1000000007;\n        int ans = 0;\n        int count_b = 0;\n        for (int i = s.length() - 1; i >= 0; --i) {\n            if (s[i] == 'b')\n                count_b = (count_b + 1) % mod;\n            else {\n                ans = (ans + count_b) % mod;\n                count_b = (count_b + count_b) % mod;\n            }\n        }\n        return ans;\n    }", "target_Lan": "cpp###countOperations.cpp", "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <string>\n// TOFILL\nint main() {\n    cout << countOperations(\"b\") << endl;\n    cout << countOperations(\"bb\") << endl;\n    cout << countOperations(\"ab\") << endl;\n    cout << countOperations(\"aabb\") << endl;\n    cout << countOperations(\"abab\") << endl;\n}"}, {"source_Lan": "python###maximumStrongIndices.py", "source_code": "def maximumStrongIndices( n: int, x: int, y: int, a: List[int],\n                         b: List[int]) -> int:\n    j = 0\n    ans = 0\n    for i in range(n):\n        while j < n and b[j] < a[i] - x:\n            j += 1\n        if j < n and b[j] <= a[i] + y:\n            ans += 1\n            j += 1\n    return ans", "trans_code": "int maximumStrongIndices ( int n , int x , int y , std :: vector < int > a , std :: vector < int > b ) throw ( ) {\n  int j = 0 ;\n  int ans = 0 ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    while ( j < n && b [ j ] < a [ i ] - x ) j ++ ;\n    if ( j < n && b [ j ] <= a [ i ] + y ) {\n      ans ++ ;\n      j ++ ;\n    }\n  }\n  return ans ;\n}\n", "reference_code": "    int maximumStrongIndices(int n, int x, int y, vector<int> &a, vector<int> &b) {\n        int j = 0, ans = 0;\n        for (int i = 0; i < n; i++) {\n            while (j < n && b[j] < a[i] - x)\n                j++;\n            if (j < n && b[j] <= a[i] + y) {\n                ans++;\n                j++;\n            }\n        }\n        return ans;\n    }", "target_Lan": "cpp###maximumStrongIndices.cpp", "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    int n1 = 5, x1 = 2, y1 = 3;\n    vector<int> a1 = {1, 3, 5, 7, 9};\n    vector<int> b1 = {0, 2, 4, 6, 8};\n    cout << maximumStrongIndices(n1, x1, y1, a1, b1) << endl;\n\n    int n2 = 5, x2 = 1, y2 = 2;\n    vector<int> a2 = {2, 4, 6, 8, 10};\n    vector<int> b2 = {1, 3, 5, 7, 9};\n    cout << maximumStrongIndices(n2, x2, y2, a2, b2) << endl;\n\n    int n3 = 5, x3 = 3, y3 = 4;\n    vector<int> a3 = {5, 10, 15, 20, 25};\n    vector<int> b3 = {2, 4, 6, 8, 10};\n    cout << maximumStrongIndices(n3, x3, y3, a3, b3) << endl;\n\n    int n4 = 5, x4 = 0, y4 = 1;\n    vector<int> a4 = {3, 6, 9, 12, 15};\n    vector<int> b4 = {2, 5, 8, 11, 14};\n    cout << maximumStrongIndices(n4, x4, y4, a4, b4) << endl;\n\n    int n5 = 5, x5 = 4, y5 = 5;\n    vector<int> a5 = {7, 14, 21, 28, 35};\n    vector<int> b5 = {3, 6, 9, 12, 15};\n    cout << maximumStrongIndices(n5, x5, y5, a5, b5) << endl;\n}"}, {"source_Lan": "python###geeklandElections.py", "source_code": "def geeklandElections( n: int, k: int, s: str) -> bool:\n    ans = s.count(\"1\") + min(k, s.count(\"0\"))\n    return ans > n - ans", "trans_code": "bool geeklandElections ( int n , int k , string s ) throw ( ) {\n  int ans = s . count ( \"1\" ) + min ( k , s . count ( \"0\" ) ) ;\n  return ans > n - ans ;\n}\n", "reference_code": "    bool geeklandElections(int n, int k, string &s) {\n        int votes = 0;\n        for (int i = 0; i < n; i++)\n            votes += (s[i] == '1');\n        return (votes + k) > (n - (votes + k));\n    }", "target_Lan": "cpp###geeklandElections.cpp", "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <string>\n// TOFILL\nint main() {\n    string s1 = \"0\";\n    string s2 = \"1\";\n    string s3 = \"01\";\n    string s4 = \"11\";\n    string s5 = \"011\";\n    cout <<(geeklandElections(1, 1, s1) ? \"True\" : \"False\") << endl;\n    cout <<(geeklandElections(1, 0, s2) ? \"True\" : \"False\") << endl;\n    cout <<(geeklandElections(2, 1, s3) ? \"True\" : \"False\") << endl;\n    cout <<(geeklandElections(2, 0, s4) ? \"True\" : \"False\") << endl;\n    cout <<(geeklandElections(3, 1, s5) ? \"True\" : \"False\") << endl;\n    return 0;\n}"}, {"source_Lan": "python###totalCount.py", "source_code": "def totalCount( n : int, s : str) -> int:\n    mod=10**9+7\n    ans=0\n    for i in range(n):\n        if s[i]==s[0]:\n            ans+=(n-i)\n            ans%=mod\n    return ans", "trans_code": "public : int totalCount ( int n , string s ) throw ( ) {\n  int mod = 10 * 9 + 7 ;\n  int ans = 0 ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    if ( s [ i ] == s [ 0 ] ) {\n      ans += ( n - i ) ;\n      ans %= mod ;\n    }\n  }\n  return ans ;\n}\n", "reference_code": "    int totalCount(int n, string s) {\n        int answer = 0;\n        int mod = 1e9 + 7;\n        char now = s[0];\n        for(int i = 0; i < n; i ++){\n            if(s[i] == now){\n                answer += n - i;\n                answer %= mod;\n            }\n        }\n        return answer;\n    }", "target_Lan": "cpp###totalCount.cpp", "target_code_shell": "#include <iostream>\nusing namespace std;\n#include<iostream>\n#include<string>\n// TOFILL\nint main() {\n    cout << totalCount(0, \"\") << endl;\n    cout << totalCount(1, \"a\") << endl;\n    cout << totalCount(3, \"aaa\") << endl;\n    cout << totalCount(5, \"abcde\") << endl;\n    cout << totalCount(6, \"aaabbb\") << endl;\n}"}, {"source_Lan": "python###geekTasks.py", "source_code": "def geekTasks( n : int, m : int, q : int, tasks : List[List[int]]) -> int:\n    minA=0\n    minB=0\n    for i in range(q):\n        a,b=tasks[i][0],tasks[i][1]\n        a+=1\n        b+=1\n        if i==0:\n            minA=a\n            minB=b\n        else:\n            if minA>a:\n                minA=a\n            if minB>b:\n                minB=b\n    total=0\n    maxi=0\n    col=[0]*(n)\n    for i in range(q):\n        col[tasks[i][0]]=max(col[tasks[i][0]],tasks[i][1]+1)\n    for i in range(n-1,-1,-1):\n        maxi=max(maxi,col[i])\n        total+=maxi\n    total-=minA*minB\n    return total", "trans_code": "int geekTasks ( int n , int m , int q , std :: vector < std :: vector < int >> & tasks ) throw ( ) {\n  int minA = 0 ;\n  int minB = 0 ;\n  for ( int i = 0 ;\n  i < q ;\n  i ++ ) {\n    int a = tasks [ i ] [ 0 ] , b = tasks [ i ] [ 1 ] ;\n    a ++ ;\n    b ++ ;\n    if ( i == 0 ) {\n      minA = a ;\n      minB = b ;\n    }\n    else {\n      if ( minA > a ) minA = a ;\n      if ( minB > b ) minB = b ;\n    }\n  }\n  int total = 0 ;\n  int maxi = 0 ;\n  std :: vector < int > col ( n , 0 ) ;\n  for ( int i = 0 ;\n  i < q ;\n  i ++ ) col [ tasks [ i ] [ 0 ] ] = std :: max ( col [ tasks [ i ] [ 0 ] ] , tasks [ i ] [ 1 ] + 1 ) ;\n  for ( int i = n - 1 ;\n  i >= 0 ;\n  i -- ) {\n    maxi = std :: max ( maxi , col [ i ] ) ;\n    total += maxi ;\n  }\n  total -= minA * minB ;\n  return total ;\n}\n", "reference_code": "    long long geekTasks(int n, int m, int q, vector<vector<int>> &tasks) {\n        long long int total = 0;\n        long long int a,b, minA, minB;\n        for(long long int i=0; i<q; i++)\n        {\n            a = tasks[i][0];\n            b = tasks[i][1];\n            a += 1;\n            b += 1;\n            if(i==0){\n                minA=a;\n                minB=b;\n            }\n            if(a<minA){\n                minA=a;\n            }\n            if(b<minB){\n                minB=b;\n            }\n        }\n        vector<int> col(n, 0);\n        for(auto i : tasks){\n            long long int x = i[1] + 1;\n            col[i[0]] = max((long long int)col[i[0]], x);\n        }\n        long long int maxi = 0;\n        for(int i = n - 1; i >= 0; i--){\n            maxi = max(maxi, (long long int)col[i]);\n            total += maxi;\n        }\n        long long int cellsWithMaxValue = minA*minB;\n        total -= cellsWithMaxValue;\n        return total;\n    }", "target_Lan": "cpp###geekTasks.cpp", "target_code_shell": "#include <iostream>\nusing namespace std;\n#include<iostream>\n#include<vector>\n// TOFILL\nint main() {\n    int n = 3;\n    int m = 3;\n    int q = 3;\n    vector<vector<int>> tasks = {{1, 1}, {1, 2}, {2, 2}};\n    cout << geekTasks(n, m, q, tasks) << endl;\n    return 0;\n}"}, {"source_Lan": "python###validPairs.py", "source_code": "def validPairs( n: int, val: List[int], edges: List[List[int]]) -> int:\n    lift=[[0]*(32) for _ in range(n+1)]\n    dis=[0]*(n+1)\n    dis2=[0]*(n+1)\n    adj=[[] for _ in range(n+1)]\n    for i in edges:\n        adj[i[0]].append((i[1],i[2]))\n        adj[i[1]].append((i[0],i[2]))\n    dis[0]=-(10**15)\n    st=[[1,0,0,0]]\n    while st:\n        top=st.pop()\n        i,par,d,d2=top[0],top[1],top[2],top[3]\n        lift[i][0]=par\n        dis[i]=d\n        dis2[i]=d2\n        for j in range(1,32):\n            lift[i][j]=lift[lift[i][j-1]][j-1]\n        for j in adj[i]:\n            if j[0]==par:\n                continue\n            st.append([j[0],i,d+j[1],d2+1])\n    ans=0\n    for i in range(1,n+1):\n        v=val[i-1]\n        p=i\n        for j in range(31,-1,-1):\n            if v>=dis[p]-dis[lift[p][j]]:\n                v-=dis[p]-dis[lift[p][j]]\n                p=lift[p][j]\n        ans+=dis2[i]-dis2[p]\n    return ans", "trans_code": "public : int validPairs ( int n , std :: vector < int > val , std :: vector < std :: vector < int >> edges ) throw ( ) {\n  std :: vector < std :: vector < int >> lift ( n + 1 ) ;\n  std :: vector < int > dis ( n + 1 ) ;\n  std :: vector < int > dis2 ( n + 1 ) ;\n  std :: vector < std :: pair < int , int >> adj ( n + 1 ) ;\n  for ( auto i : edges ) {\n    adj [ i . first ] . push_back ( std :: make_pair ( i . second , i . first ) ) ;\n    adj [ i . second ] . push_back ( std :: make_pair ( i . first , i . second ) ) ;\n  }\n  dis [ 0 ] = - ( 10 * 15 ) ;\n  std :: vector < std :: pair < int , int >> st ( n + 1 ) ;\n  st . push_back ( {\n    1 , 0 , 0 , 0 }\n    ) ;\n    while ( st . size ( ) > 0 ) {\n      auto top = st . back ( ) ;\n      int i = top . first ;\n      int par = top . second ;\n      int d = top . first ;\n      int d2 = top . second ;\n      lift [ i ] [ 0 ] = par ;\n      dis [ i ] = d ;\n      dis2 [ i ] = d2 ;\n      for ( int j = 1 ;\n      j < 32 ;\n      ++ j ) lift [ i ] [ j ] = lift [ lift [ i ] [ j - 1 ] ] [ j - 1 ] ;\n      for ( auto j : adj [ i ] ) {\n        if ( j . first == par ) continue ;\n        st . push_back ( {\n          j . first , i , d + j . second , d2 + 1 }\n          ) ;\n        }\n      }\n      int ans = 0 ;\n      for ( int i = 1 ;\n      i <= n ;\n      ++ i ) {\n        int v = val [ i - 1 ] ;\n        int p = i ;\n        for ( int j = 31 ;\n        j >= 1 ;\n        -- j ) {\n          if ( v >= dis [ p ] - dis [ lift [ p ] [ j ] ] ) {\n            v -= dis [ p ] - dis [ lift [ p ] [ j ] ] ;\n            p = lift [ p ] [ j ] ;\n          }\n        }\n        ans += dis2 [ i ] - dis2 [ p ] ;\n      }\n      return ans ;\n    }\n    ", "reference_code": "    long long validPairs(int n, vector<int>& val, vector<vector<int>>& edges) {\n        vector<vector<long long>> lift(n + 1, vector<long long>(32, 0));\n        vector<long long> dis(n + 1, 0);\n        vector<long long> dis2(n + 1, 0);\n        vector<vector<vector<long long>>> adj(n + 1);\n        for (auto i : edges) {\n            adj[i[0]].push_back({ i[1], i[2] });\n            adj[i[1]].push_back({ i[0], i[2] });\n        }\n        dis[0] = -1e15;\n        \n        stack<vector<long long>> st;\n        st.push({ 1, 0, 0, 0 }); \n        while (!st.empty()) {\n            auto top = st.top();\n            st.pop();\n            long long i = top[0], par = top[1], d = top[2], d2 = top[3];\n            lift[i][0] = par;\n            dis[i] = d;\n            dis2[i] = d2;\n            for (long long j = 1; j < 32; j++) {\n                lift[i][j] = lift[lift[i][j - 1]][j - 1];\n            }\n            for (auto j : adj[i]) {\n                if (j[0] == par) continue;\n                st.push({ j[0], i, d + j[1], d2 + 1 });\n            }\n        }\n        long long ans = 0;\n        for (long long i = 1; i <= n; i++) {\n            long long v = val[i-1];\n            long long p = i;\n            for (long long j = 31; j >= 0; j--) {\n                if (v >= dis[p] - dis[lift[p][j]]) {\n                    v -= (dis[p] - dis[lift[p][j]]);\n                    p = lift[p][j];\n                }\n            }\n            ans += dis2[i] - dis2[p];\n        }\n        return ans;\n    }", "target_Lan": "cpp###validPairs.cpp", "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <bits/stdc++.h>\n// TOFILL\nint main() {\n    int n1 = 1;\n    vector<int> val1 = {10};\n    vector<vector<int>> edges1 = {};\n    cout << validPairs(n1, val1, edges1) << endl;\n\n    int n2 = 2;\n    vector<int> val2 = {10, 20};\n    vector<vector<int>> edges2 = {{1, 2, 5}};\n    cout << validPairs(n2, val2, edges2) << endl;\n\n    int n3 = 3;\n    vector<int> val3 = {10, 20, 30};\n    vector<vector<int>> edges3 = {{1, 2, 5}, {2, 3, 7}};\n    cout << validPairs(n3, val3, edges3) << endl;\n\n    int n4 = 4;\n    vector<int> val4 = {10, 20, 30, 40};\n    vector<vector<int>> edges4 = {{1, 2, 5}, {2, 3, 7}, {3, 4, 9}};\n    cout << validPairs(n4, val4, edges4) << endl;\n\n    return 0;\n}"}, {"source_Lan": "python###majorityWins.py", "source_code": "def majorityWins( arr, n, x, y):\n    count_x=0;\n    count_y=0;\n    for i in range(0,n):\n        \n        \n        if(arr[i]==x):\n            count_x+=1\n        if(arr[i]==y):\n            count_y+=1\n    \n    \n    if(count_x>count_y or (count_x==count_y and x<y)):\n        \n        return x\n    else:\n        \n        return y", "trans_code": "int majorityWins ( int arr [ ] , int n , int x , int y ) {\n  int countX = 0 ;\n  ;\n  int countY = 0 ;\n  ;\n  for ( int i = 0 ;\n  i <= n ;\n  i ++ ) {\n    if ( ( arr [ i ] == x ) && ( arr [ i + 1 ] == y ) ) countX ++ ;\n    if ( ( arr [ i ] == y ) && ( arr [ i + 1 ] == x ) ) countY ++ ;\n  }\n  if ( ( countX > countY || ( countX == countY && x < y ) ) ) return x ;\n  else return y ;\n}\n", "reference_code": "    int majorityWins(int arr[], int n, int x, int y) {\n        int count_x = 0;\n        int count_y = 0;\n        \n        \n        for (int i = 0; i < n; i++) {\n            if (arr[i] == x) count_x++;\n            if (arr[i] == y) count_y++;\n        }\n        \n        if (count_x > count_y)\n            \n            return x;\n        else if (count_y > count_x)\n            \n            return y;\n        \n        else\n            return x < y ? x : y;\n    }", "target_Lan": "cpp###majorityWins.cpp", "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n// TOFILL\nint main() {\n    int arr1[] = {2, 2, 2, 2, 3};\n    int arr2[] = {1, 1, 2, 2, 3, 3, 3};\n    int arr3[] = {1, 1, 2, 2, 2, 2, 3, 3};\n    int arr4[] = {1, 1, 1, 1, 1, 1, 1};\n    int arr5[] = {10, 20, 30, 40, 50, 60, 70, 80, 10, 10};\n\n    cout << majorityWins(arr1, 5, 2, 3) << endl;\n    cout << majorityWins(arr2, 7, 1, 3) << endl;\n    cout << majorityWins(arr3, 8, 2, 3) << endl;\n    cout << majorityWins(arr4, 7, 1, 2) << endl;\n    cout << majorityWins(arr5, 10, 10, 80) << endl;\n\n    return 0;\n}"}, {"source_Lan": "python###areaOfMaxDiagonal.py", "source_code": "def areaOfMaxDiagonal( dimensions: List[List[int]]) -> int:\n    return max((x * x + y * y, x * y) for x, y in dimensions)[1]", "trans_code": "int areaOfMaxDiagonal ( const std :: vector < std :: vector < int >> & dimensions ) throw ( ) {\n  return std :: max ( ( int ) dimensions [ 0 ] . size ( ) , dimensions [ 1 ] . size ( ) ) ;\n}\n", "reference_code": "    int areaOfMaxDiagonal(vector<vector<int>> &dimensions) {\n        int ans = 0, max_l = 0;\n        for (auto &d: dimensions) {\n            int x = d[0], y = d[1];\n            int l = x * x + y * y;\n            if (l > max_l || (l == max_l && x * y > ans)) {\n                max_l = l;\n                ans = x * y;\n            }\n        }\n        return ans;\n    }", "target_Lan": "cpp###areaOfMaxDiagonal.cpp", "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <vector>\n#include <iostream>\n// TOFILL\nint main() {\n    vector<vector<int>> dimensions1 = {{1,2},{3,4},{5,6},{7,8}};\n    vector<vector<int>> dimensions2 = {{10,20},{30,40},{50,60},{70,80}};\n    vector<vector<int>> dimensions3 = {{100,200},{300,400},{500,600},{700,800}};\n    vector<vector<int>> dimensions4 = {{1,1},{1,1},{1,1},{1,1}};\n    vector<vector<int>> dimensions5 = {{1000,2000},{3000,4000},{5000,6000},{7000,8000}};\n\n    cout << areaOfMaxDiagonal(dimensions1) << endl;\n    cout << areaOfMaxDiagonal(dimensions2) << endl;\n    cout << areaOfMaxDiagonal(dimensions3) << endl;\n    cout << areaOfMaxDiagonal(dimensions4) << endl;\n    cout << areaOfMaxDiagonal(dimensions5) << endl;\n\n    return 0;\n}"}, {"source_Lan": "python###countSubmatrices.py", "source_code": "def countSubmatrices( grid: List[List[int]], k: int) -> int:\n    ans = 0\n    m, n = len(grid), len(grid[0])\n    s = [[0] * (n + 1) for _ in range(m + 1)]\n    for i, row in enumerate(grid):\n        for j, x in enumerate(row):\n            s[i + 1][j + 1] = s[i + 1][j] + s[i][j + 1] - s[i][j] + x\n            if s[i + 1][j + 1] <= k:\n                ans += 1\n    return ans", "trans_code": "public : int countSubmatrices ( vector < vector < int >> & grid , int k ) throw ( ) {\n  int ans = 0 ;\n  int m = grid . size ( ) ;\n  int n = grid [ 0 ] . size ( ) ;\n  vector < vector < int >> s ( m + 1 , vector < int > ( n + 1 , 0 ) ) ;\n  for ( int i = 0 , row = grid . size ( ) ;\n  i < m ;\n  i ++ ) {\n    for ( int j = 0 , x = row [ i ] ;\n    j < n ;\n    j ++ ) {\n      s [ i + 1 ] [ j + 1 ] = s [ i + 1 ] [ j ] + s [ i ] [ j + 1 ] - s [ i ] [ j ] + x ;\n      if ( s [ i + 1 ] [ j + 1 ] <= k ) ans ++ ;\n    }\n  }\n  return ans ;\n}\n", "reference_code": "    int countSubmatrices(vector<vector<int>> &grid, int k) {\n        int ans = 0, m = grid.size(), n = grid[0].size();\n        vector<vector<int>> sum(m + 1, vector<int>(n + 1));\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                sum[i + 1][j + 1] = sum[i + 1][j] + sum[i][j + 1] - sum[i][j] + grid[i][j];\n                ans += sum[i + 1][j + 1] <= k;\n            }\n        }\n        return ans;\n    }", "target_Lan": "cpp###countSubmatrices.cpp", "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    vector<vector<int>> grid1 = {{1,0,1},{0,1,0},{1,0,1}};\n    cout << countSubmatrices(grid1, 1) << endl;\n\n    vector<vector<int>> grid2 = {{1,1,1},{1,1,1},{1,1,1}};\n    cout << countSubmatrices(grid2, 2) << endl;\n\n    vector<vector<int>> grid3 = {{0,0,0},{0,0,0},{0,0,0}};\n    cout << countSubmatrices(grid3, 0) << endl;\n\n    vector<vector<int>> grid4 = {{1,0,0},{0,1,0},{0,0,1}};\n    cout << countSubmatrices(grid4, 1) << endl;\n\n    vector<vector<int>> grid5 = {{1,1,1,1},{1,1,1,1},{1,1,1,1},{1,1,1,1}};\n    cout << countSubmatrices(grid5, 2) << endl;\n\n    return 0;\n}"}, {"source_Lan": "python###minimumOperationsToWriteY.py", "source_code": "def minimumOperationsToWriteY( grid: List[List[int]]) -> int:\n    cnt1 = [0] * 3\n    cnt2 = [0] * 3\n    n = len(grid)\n    m = n // 2\n    for i, row in enumerate(grid[:m]):\n        cnt1[row[i]] += 1\n        cnt1[row[-1 - i]] += 1\n        for j, x in enumerate(row):\n            if j != i and j != n - 1 - i:\n                cnt2[x] += 1\n    for row in grid[m:]:\n        cnt1[row[m]] += 1\n        for j, x in enumerate(row):\n            if j != m:\n                cnt2[x] += 1\n    max_not_change = 0\n    for i, c1 in enumerate(cnt1):\n        for j, c2 in enumerate(cnt2):\n            if i != j:\n                max_not_change = max(max_not_change, c1 + c2)\n    return n * n - max_not_change", "trans_code": "public : int minimumOperationsToWriteY ( vector < vector < int >> & grid ) throw ( ) {\n  vector < int > cnt1 ( 3 , 0 ) ;\n  vector < int > cnt2 ( 3 , 0 ) ;\n  int n = grid . size ( ) ;\n  int m = n / 2 ;\n  for ( int i = 0 , n = grid [ 0 ] . size ( ) ;\n  i < n ;\n  i ++ ) {\n    cnt1 [ grid [ 0 ] [ i ] ] ++ ;\n    cnt1 [ grid [ n - 1 - i ] ] ++ ;\n    for ( int j = 0 , n = grid [ m ] . size ( ) ;\n    j < n ;\n    j ++ ) {\n      if ( j != i && j != n - 1 - i ) {\n        cnt2 [ grid [ m ] [ j ] ] ++ ;\n      }\n    }\n  }\n  for ( vector < int > & row : grid ) {\n    cnt1 [ row [ m ] ] ++ ;\n    for ( int j = 0 , n = row [ m ] . size ( ) ;\n    j < n ;\n    j ++ ) {\n      if ( j != m ) {\n        cnt2 [ row [ m ] [ j ] ] ++ ;\n      }\n    }\n  }\n  int maxNotChange = 0 ;\n  for ( int i = 0 , c1 = cnt1 . size ( ) ;\n  i < n ;\n  i ++ ) {\n    for ( int j = 0 , c2 = cnt2 . size ( ) ;\n    j < n ;\n    j ++ ) {\n      if ( i != j ) {\n        maxNotChange = max ( maxNotChange , c1 + c2 ) ;\n      }\n    }\n  }\n  return n * n - maxNotChange ;\n}\n", "reference_code": "    int minimumOperationsToWriteY(vector<vector<int>> &grid) {\n        int cnt1[3]{}, cnt2[3]{};\n        int n = grid.size();\n        int m = n / 2;\n        for (int i = 0; i < m; i++) {\n            cnt1[grid[i][i]]++;\n            cnt1[grid[i][n - 1 - i]]++;\n            for (int j = 0; j < n; j++) {\n                if (j != i && j != n - 1 - i) {\n                    cnt2[grid[i][j]]++;\n                }\n            }\n        }\n        for (int i = m; i < n; i++) {\n            cnt1[grid[i][m]]++;\n            for (int j = 0; j < n; j++) {\n                if (j != m) {\n                    cnt2[grid[i][j]]++;\n                }\n            }\n        }\n        int max_not_change = 0;\n        for (int i = 0; i < 3; i++) {\n            for (int j = 0; j < 3; j++) {\n                if (i != j) {\n                    max_not_change = max(max_not_change, cnt1[i] + cnt2[j]);\n                }\n            }\n        }\n        return n * n - max_not_change;\n    }", "target_Lan": "cpp###minimumOperationsToWriteY.cpp", "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    vector<vector<int>> grid1 = {{1, 0, 1}, {0, 1, 0}, {1, 0, 1}};\n    cout << minimumOperationsToWriteY(grid1) << endl;\n    \n    vector<vector<int>> grid2 = {{0, 0, 0}, {0, 0, 0}, {0, 0, 0}};\n    cout << minimumOperationsToWriteY(grid2) << endl;\n    \n    vector<vector<int>> grid3 = {{1, 1, 1}, {1, 1, 1}, {1, 1, 1}};\n    cout << minimumOperationsToWriteY(grid3) << endl;\n    \n    vector<vector<int>> grid4 = {{1, 2, 0}, {0, 1, 2}, {2, 0, 1}};\n    cout << minimumOperationsToWriteY(grid4) << endl;\n    \n    vector<vector<int>> grid5 = {{2, 2, 2}, {2, 2, 2}, {2, 2, 2}};\n    cout << minimumOperationsToWriteY(grid5) << endl;\n    \n    return 0;\n}"}, {"source_Lan": "python###maximumLengthSubstring.py", "source_code": "def maximumLengthSubstring( s: str) -> int:\n    ans = left = 0\n    cnt = Counter()\n    for i, c in enumerate(s):\n        cnt[c] += 1\n        while cnt[c] > 2:\n            cnt[s[left]] -= 1\n            left += 1\n        ans = max(ans, i - left + 1)\n    return ans", "trans_code": "public : int maximumLengthSubstring ( string s ) -> int {\n  int ans = left = 0 ;\n  Counter cnt ;\n  for ( int i = 0 , n = s . size ( ) ;\n  i < n ;\n  i ++ ) {\n    cnt [ s [ left ] ] ++ ;\n    while ( cnt [ s [ left ] ] > 2 ) {\n      cnt [ s [ left ] ] -- ;\n      left ++ ;\n    }\n    ans = max ( ans , i - left + 1 ) ;\n  }\n  return ans ;\n}\n", "reference_code": "    int maximumLengthSubstring(string s) {\n        int ans = 0, left = 0, cnt[26]{};\n        for (int i = 0; i < s.length(); i++) {\n            int b = s[i] - 'a';\n            cnt[b]++;\n            while (cnt[b] > 2) {\n                cnt[s[left++] - 'a']--;\n            }\n            ans = max(ans, i - left + 1);\n        }\n        return ans;\n    }", "target_Lan": "cpp###maximumLengthSubstring.cpp", "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <string>\n// TOFILL\nint main() {\n    cout << maximumLengthSubstring(\"\") << endl;\n    cout << maximumLengthSubstring(\"abc\") << endl;\n    cout << maximumLengthSubstring(\"aaaa\") << endl;\n    cout << maximumLengthSubstring(\"abcdabc\") << endl;\n    cout << maximumLengthSubstring(\"abcabc\") << endl;\n    return 0;\n}"}, {"source_Lan": "python###getSmallestString2.py", "source_code": "def getSmallestString2( s: str, k: int) -> str:\n    s = list(s)\n    for i, c in enumerate(map(ord, s)):\n        dis = min(c - ord('a'), ord('z') - c + 1)\n        if dis > k:\n            s[i] = chr(c - k)\n            break\n        s[i] = 'a'\n        k -= dis\n    return ''.join(s)", "trans_code": "string getSmallestString2 ( string s , int k ) throw ( ) {\n  s . clear ( ) ;\n  for ( int i = 0 , n = s . size ( ) ;\n  i < n ;\n  i ++ ) {\n    int dis = min ( s [ i ] - 'a' , s [ i ] - 'z' - s [ i ] + 1 ) ;\n    if ( dis > k ) {\n      s [ i ] = ( char ) ( s [ i ] - k ) ;\n      break ;\n    }\n    s [ i ] = 'a' ;\n    k -= dis ;\n  }\n  return s ;\n}\n", "reference_code": "    string getSmallestString2(string s, int k) {\n        for (int i = 0; i < s.length(); i++) {\n            int dis = min(s[i] - 'a', 'z' - s[i] + 1);\n            if (dis > k) {\n                s[i] -= k;\n                break;\n            }\n            s[i] = 'a';\n            k -= dis;\n        }\n        return s;\n    }", "target_Lan": "cpp###getSmallestString2.cpp", "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <string>\n// TOFILL\nint main() {\n    cout << getSmallestString2(\"abc\", 1) << endl;\n    cout << getSmallestString2(\"xyz\", 5) << endl;\n    cout << getSmallestString2(\"aaa\", 3) << endl;\n    cout << getSmallestString2(\"zzz\", 10) << endl;\n    cout << getSmallestString2(\"pqr\", 7) << endl;\n}"}, {"source_Lan": "python###compressedString.py", "source_code": "def compressedString( word: str) -> str:\n    t = []\n    i0 = -1\n    for i, c in enumerate(word):\n        if i + 1 == len(word) or c != word[i + 1]:\n            k, rem = divmod(i - i0, 9)\n            t.append((\"9\" + c) * k)\n            if rem:\n                t.append(str(rem))\n                t.append(c)\n            i0 = i\n    return ''.join(t)", "trans_code": "QString compressedString ( const QString & word ) throw ( ) {\n  QString t ;\n  int i0 = - 1 ;\n  for ( int i = 0 , n = word . size ( ) ;\n  i < n ;\n  ++ i ) {\n    QChar c = word [ i ] ;\n    if ( i + 1 == n || c != word [ i + 1 ] ) {\n      int k = i - i0 ;\n      int rem = i - i0 ;\n      t . append ( ( \"9\" + c ) * k ) ;\n      if ( rem > 0 ) {\n        t . append ( QString :: number ( rem , 16 ) ) ;\n        t . append ( c ) ;\n      }\n      i0 = i ;\n    }\n  }\n  return t ;\n}\n", "reference_code": "    string compressedString(string word) {\n        string t;\n        int i0 = -1;\n        for (int i = 0; i < word.length(); i++) {\n            char c = word[i];\n            if (i + 1 == word.length() || c != word[i + 1]) {\n                int k = i - i0;\n                for (int j = 0; j < k / 9; j++) {\n                    t += '9';\n                    t += c;\n                }\n                if (k % 9) {\n                    t += '0' + (k % 9);\n                    t += c;\n                }\n                i0 = i;\n            }\n        }\n        return t;\n    }", "target_Lan": "cpp###compressedString.cpp", "target_code_shell": "#include <iostream>\nusing namespace std;\n\n// TOFILL\nint main() {\n    cout << compressedString(\"a\") << endl;\n    cout << compressedString(\"aaaaaaaaaa\") << endl;\n    cout << compressedString(\"abc\") << endl;\n    cout << compressedString(\"abbbbbbbbb\") << endl;\n    cout << compressedString(\"aaabbbccc\") << endl;\n    return 0;\n}"}, {"source_Lan": "python###numberOfChild.py", "source_code": "def numberOfChild( n: int, k: int) -> int:\n    k, t = divmod(k, n - 1)\n    return n - t - 1 if k % 2 else t", "trans_code": "int numberOfChild ( int n , int k ) throw ( ) {\n  k = k % n - 1 ;\n  return n - t - 1 == k ? t : n ;\n}\n", "reference_code": "   int numberOfChild(int n, int k) {\n       int a = k / (n - 1), b = k % (n - 1);\n       return (a & 1) == 0 ? b : n - 1 - b;\n   }", "target_Lan": "cpp###numberOfChild.cpp", "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n// TOFILL\nint main() {\n    cout << numberOfChild(10, 10) << endl;\n    cout << numberOfChild(10, 9) << endl;\n    cout << numberOfChild(10, 8) << endl;\n    cout << numberOfChild(10, 7) << endl;\n}"}, {"source_Lan": "python###minimumArea.py", "source_code": "def minimumArea( grid: List[List[int]]) -> int:\n    left, right = len(grid[0]), 0\n    top, bottom = len(grid), 0\n    for i, row in enumerate(grid):\n        for j, x in enumerate(row):\n            if x:\n                left = min(left, j)\n                right = max(right, j)\n                top = min(top, i)\n                bottom = i\n    return (right - left + 1) * (bottom - top + 1)", "trans_code": "public : int minimumArea ( vector < vector < int >> & grid ) throw ( ) {\n  int left = grid [ 0 ] . size ( ) , right = 0 ;\n  int top = grid . size ( ) , bottom = 0 ;\n  for ( int i = 0 , row = grid . size ( ) ;\n  i < grid . size ( ) ;\n  i ++ ) {\n    for ( int j = 0 , x = grid [ i ] [ 0 ] ;\n    j < grid [ i ] [ 1 ] ;\n    j ++ ) {\n      if ( grid [ i ] [ j ] ) {\n        left = min ( left , j ) ;\n        right = max ( right , j ) ;\n        top = min ( top , i ) ;\n        bottom = i ;\n      }\n    }\n  }\n  return ( right - left + 1 ) * ( bottom - top + 1 ) ;\n}\n", "reference_code": "    int minimumArea(vector<vector<int>>& grid) {\n        int left = grid[0].size(), right = 0, top = grid.size(), bottom = 0;\n        for (int i = 0; i < grid.size(); i++) {\n            for (int j = 0; j < grid[i].size(); j++) {\n                if (grid[i][j]) {\n                    left = min(left, j);\n                    right = max(right, j);\n                    top = min(top, i);\n                    bottom = i;\n                }\n            }\n        }\n        return (right - left + 1) * (bottom - top + 1);\n    }", "target_Lan": "cpp###minimumArea.cpp", "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    vector<vector<int>> grid1 = {{0, 0, 0}, {0, 0, 0}, {0, 0, 0}};\n    cout << minimumArea(grid1) << endl;\n    \n    vector<vector<int>> grid2 = {{1, 1, 1}, {1, 1, 1}, {1, 1, 1}};\n    cout << minimumArea(grid2) << endl;\n    \n    vector<vector<int>> grid3 = {{1, 0, 0}, {0, 0, 0}, {0, 0, 1}};\n    cout << minimumArea(grid3) << endl;\n    \n    vector<vector<int>> grid4 = {{0, 0, 1, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}, {1, 0, 0, 0}};\n    cout << minimumArea(grid4) << endl;\n    \n    vector<vector<int>> grid5 = {{1, 0, 1, 1, 1}, {1, 0, 1, 1, 1}, {1, 1, 1, 1, 1}, {1, 1, 1, 1, 1}};\n    cout << minimumArea(grid5) << endl;\n    \n    return 0;\n}"}, {"source_Lan": "python###triangleType.py", "source_code": "def triangleType( nums: List[int]) -> str:\n    nums.sort()\n    x, y, z = nums\n    if x + y <= z:  \n        return \"none\"\n    if x == z:  \n        return \"equilateral\"\n    if x == y or y == z:\n        return \"isosceles\"\n    return \"scalene\"", "trans_code": "string triangleType ( vector < int > & nums ) throw ( ) {\n  sort ( nums . begin ( ) , nums . end ( ) ) ;\n  int x = nums [ 0 ] ;\n  int y = nums [ 1 ] ;\n  int z = nums [ 2 ] ;\n  if ( x + y <= z ) return \"none\" ;\n  if ( x == z ) return \"equilateral\" ;\n  if ( x == y || y == z ) return \"isosceles\" ;\n  return \"scalene\" ;\n}\n", "reference_code": "    string triangleType(vector<int> &nums) {\n        sort(nums.begin(), nums.end());\n        int x = nums[0], y = nums[1], z = nums[2];\n        if (x + y <= z) { \n            return \"none\";\n        }\n        if (x == z) { \n            return \"equilateral\";\n        }\n        if (x == y || y == z) {\n            return \"isosceles\";\n        }\n        return \"scalene\";\n    }", "target_Lan": "cpp###triangleType.cpp", "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <algorithm>\n// TOFILL\nint main() {\n    vector<int> nums1 = {3, 3, 3};\n    cout << triangleType(nums1) << endl;\n\n    vector<int> nums2 = {3, 4, 5};\n    cout << triangleType(nums2) << endl;\n\n    vector<int> nums3 = {5, 5, 7};\n    cout << triangleType(nums3) << endl;\n\n    vector<int> nums4 = {7, 12, 15};\n    cout << triangleType(nums4) << endl;\n\n    vector<int> nums5 = {10, 20, 30};\n    cout << triangleType(nums5) << endl;\n\n    return 0;\n}"}, {"source_Lan": "python###minOperations.py", "source_code": "def minOperations( h: List[int], k: int) -> int:\n    ans = 0\n    heapify(h)\n    while h[0] < k:\n        x = heappop(h)\n        heapreplace(h, x * 2 + h[0])\n        ans += 1\n    return ans", "trans_code": "public : int minOperations ( vector < int > h , int k ) throw ( ) {\n  int ans = 0 ;\n  heapify ( h ) ;\n  while ( h [ 0 ] < k ) {\n    int x = heappop ( h ) ;\n    heapify ( h , x * 2 + h [ 0 ] ) ;\n    ans ++ ;\n  }\n  return ans ;\n}\n", "reference_code": "    int minOperations(vector<int> nums, int k) {\n        int ans = 0;\n        priority_queue<long long, vector<long long>, greater<>> pq;\n        for (int x : nums) {\n            pq.push((long long) x);\n        }\n        while (pq.top() < k) {\n            long long x = pq.top(); pq.pop();\n            long long y = pq.top(); pq.pop();\n            pq.push(x * 2 + y);\n            ans++;\n        }\n        return ans;\n    }", "target_Lan": "cpp###minOperations.cpp", "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <bits/stdc++.h>\n// TOFILL\nint main() {\n    vector<int> h1 = {1,2,3,4};\n    cout << minOperations(h1, 5) << endl;\n\n    vector<int> h2 = {1,2,3,4,5,6,7,8,9,10};\n    cout << minOperations(h2, 50) << endl;\n\n    vector<int> h3 = {1};\n    cout << minOperations(h3, 1) << endl;\n\n    vector<int> h4 = {1,1,1,1,1,1,1,1,1,1};\n    cout << minOperations(h4, 10) << endl;\n\n    vector<int> h5 = {1,2,3,4,5,6,7,8,9,10};\n    cout << minOperations(h5, 55) << endl;\n\n    return 0;\n}"}, {"source_Lan": "python###sumOfPower.py", "source_code": "def sumOfPower( nums: List[int], k: int) -> int:\n    MOD = 1_000_000_007\n    n = len(nums)\n    f = [[0] * (n + 1) for _ in range(k + 1)]\n    f[0][0] = 1\n    for i, x in enumerate(nums):\n        for j in range(k, x - 1, -1):\n            for c in range(i + 1, 0, -1):\n                f[j][c] = (f[j][c] + f[j - x][c - 1]) % MOD\n    ans = 0\n    pow2 = 1\n    for i in range(n, 0, -1):\n        ans = (ans + f[k][i] * pow2) % MOD\n        pow2 = pow2 * 2 % MOD\n    return ans", "trans_code": "public : int sumOfPower ( vector < int > & nums , int k ) throw ( ) {\n  const int MOD = 1 _000_000_007 ;\n  int n = nums . size ( ) ;\n  vector < vector < int >> f ( k + 1 , vector < int > ( k + 1 , 0 ) ) ;\n  f [ 0 ] [ 0 ] = 1 ;\n  for ( int i = 1 , x = nums . size ( ) ;\n  i < x ;\n  i ++ ) {\n    for ( int j = k ;\n    j > x - 1 ;\n    j -- ) {\n      for ( int c = i + 1 ;\n      c > 0 ;\n      c -- ) {\n        f [ j ] [ c ] = ( f [ j ] [ c ] + f [ j - x ] [ c - 1 ] ) % MOD ;\n      }\n    }\n  }\n  int ans = 0 ;\n  int pow2 = 1 ;\n  for ( int i = n ;\n  i > 0 ;\n  i -- ) {\n    ans = ( ans + f [ k ] [ i ] * pow2 ) % MOD ;\n    pow2 = pow2 * 2 % MOD ;\n  }\n  return ans ;\n}\n", "reference_code": "    int sumOfPower(vector<int> &nums, int k) {\n        const int MOD = 1'000'000'007;\n        int n = nums.size();\n        vector<vector<int>> f(k + 1, vector<int>(n + 1));\n        f[0][0] = 1;\n        for (int i = 0; i < n; i++) {\n            for (int j = k; j >= nums[i]; j--) {\n                for (int c = i + 1; c > 0; c--) {\n                    f[j][c] = (f[j][c] + f[j - nums[i]][c - 1]) % MOD;\n                }\n            }\n        }\n        int ans = 0;\n        int pow2 = 1;\n        for (int i = n; i > 0; i--) {\n            ans = (ans + (long long) f[k][i] * pow2) % MOD;\n            pow2 = pow2 * 2 % MOD;\n        }\n        return ans;\n    }", "target_Lan": "cpp###sumOfPower.cpp", "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <vector>\n#include <iostream>\n// TOFILL\nint main() {\n    vector<int> nums1 = {1,2,3};\n    cout << sumOfPower(nums1, 3) << endl;\n\n    vector<int> nums2 = {1,1,1,1};\n    cout << sumOfPower(nums2, 2) << endl;\n\n    vector<int> nums3 = {1,2,3,4};\n    cout << sumOfPower(nums3, 5) << endl;\n\n    vector<int> nums4 = {10,20,30,40};\n    cout << sumOfPower(nums4, 100) << endl;\n\n    vector<int> nums5 = {1,2,3,4,5};\n    cout << sumOfPower(nums5, 15) << endl;\n\n    return 0;\n}"}, {"source_Lan": "python###countAlternatingSubarrays.py", "source_code": "def countAlternatingSubarrays( nums: List[int]) -> int:\n    res = cur = 0\n    pre = -1\n    for a in nums:\n        if pre != a:\n            cur += 1\n        else:\n            cur = 1\n        pre = a\n        res += cur\n    return res", "trans_code": "public : int countAlternatingSubarrays ( vector < int > & nums ) throw ( ) {\n  int res = cur = 0 ;\n  int pre = - 1 ;\n  for ( int a : nums ) {\n    if ( pre != a ) {\n      cur ++ ;\n    }\n    else {\n      cur = 1 ;\n    }\n    pre = a ;\n    res += cur ;\n  }\n  return res ;\n}\n", "reference_code": "    long long countAlternatingSubarrays(vector<int>& nums) {\n        long long res = 0, cur = 0;\n        int pre = -1;\n        for (int a : nums) {\n            cur = (pre != a) ? cur + 1 : 1;\n            pre = a;\n            res += cur;\n        }\n        return res;\n    }", "target_Lan": "cpp###countAlternatingSubarrays.cpp", "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    vector<int> nums1 = {1,2,3,4,5};\n    cout << countAlternatingSubarrays(nums1) << endl;\n    \n    vector<int> nums2 = {2,2,2,2,2};\n    cout << countAlternatingSubarrays(nums2) << endl;\n    \n    vector<int> nums3 = {-1,-2,-3,-4,-5};\n    cout << countAlternatingSubarrays(nums3) << endl;\n    \n    vector<int> nums4 = {1,2,1,2,1};\n    cout << countAlternatingSubarrays(nums4) << endl;\n    \n    vector<int> nums5 = {5,4,3,2,1};\n    cout << countAlternatingSubarrays(nums5) << endl;\n    \n    return 0;\n}"}, {"source_Lan": "python###accountBalanceAfterPurchase.py", "source_code": "def accountBalanceAfterPurchase( purchaseAmount: int) -> int:\n    r = purchaseAmount % 10\n    purchaseAmount = purchaseAmount - r if r < 5 else purchaseAmount + 10 - r\n    return 100 - purchaseAmount", "trans_code": "int accountBalanceAfterPurchase ( int purchaseAmount ) throw ( ) {\n  int r = purchaseAmount % 10 ;\n  purchaseAmount = purchaseAmount - r < 5 ? purchaseAmount + 10 - r : r ;\n  return 100 - purchaseAmount ;\n}\n", "reference_code": "    int accountBalanceAfterPurchase(int purchaseAmount) {\n        int r = purchaseAmount % 10;\n        if (r < 5) {\n            purchaseAmount -= r;\n        } else {\n            purchaseAmount += 10 - r;\n        }\n        return 100 - purchaseAmount;\n    }", "target_Lan": "cpp###accountBalanceAfterPurchase.cpp", "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n// TOFILL\nint main() {\n    std::cout << accountBalanceAfterPurchase(0) << std::endl;\n    std::cout << accountBalanceAfterPurchase(5) << std::endl;\n    std::cout << accountBalanceAfterPurchase(10) << std::endl;\n    std::cout << accountBalanceAfterPurchase(15) << std::endl;\n    std::cout << accountBalanceAfterPurchase(20) << std::endl;\n    return 0;\n}"}, {"source_Lan": "python###maxOperations.py", "source_code": "def maxOperations( nums: List[int]) -> int:\n    n, t = len(nums), 0\n    for i in range(1, n, 2):\n        if nums[i] + nums[i - 1] != nums[1] + nums[0]:\n            break\n        t += 1\n    return t", "trans_code": "public : int maxOperations ( vector < int > & nums ) throw ( ) {\n  int n = nums . size ( ) , t = 0 ;\n  for ( int i = 1 ;\n  i < n ;\n  i += 2 ) {\n    if ( nums [ i ] + nums [ i - 1 ] != nums [ 1 ] + nums [ 0 ] ) break ;\n    t ++ ;\n  }\n  return t ;\n}\n", "reference_code": "    int maxOperations(vector<int>& nums) {\n        int n = nums.size(), t = 0;\n        for (int i = 1; i < n; i += 2) {\n            if (nums[i] + nums[i - 1] != nums[1] + nums[0]) {\n                break;\n            }\n            t++;\n        }\n        return t;\n    }", "target_Lan": "cpp###maxOperations.cpp", "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    vector<int> nums1 = {1,2,3,4};\n    cout << maxOperations(nums1) << endl;\n\n    vector<int> nums2 = {5,6,7,8,9,10};\n    cout << maxOperations(nums2) << endl;\n\n    vector<int> nums3 = {1,1,2,2,3,3};\n    cout << maxOperations(nums3) << endl;\n\n    vector<int> nums4 = {10,20,30,40,50};\n    cout << maxOperations(nums4) << endl;\n\n    vector<int> nums5 = {2,2,2,2,2,2};\n    cout << maxOperations(nums5) << endl;\n\n    return 0;\n}"}, {"source_Lan": "python###distributeCandies2.py", "source_code": "def distributeCandies2( n: int, limit: int) -> int:\n    ans = 0\n    for i in range(min(limit, n) + 1):\n        if n - i > 2 * limit:\n            continue\n        ans += min(n - i, limit) - max(0, n - i - limit) + 1\n    return ans", "trans_code": "int distributeCandies2 ( int n , int limit ) throw ( ) {\n  int ans = 0 ;\n  for ( int i = 0 ;\n  i < min ( limit , n ) + 1 ;\n  i ++ ) {\n    if ( n - i > 2 * limit ) continue ;\n    ans += min ( n - i , limit ) - max ( 0 , n - i - limit ) + 1 ;\n  }\n  return ans ;\n}\n", "reference_code": "    long long distributeCandies2(int n, int limit) {\n        long long ans = 0;\n        for (int i = 0; i <= min(limit, n); i++) {\n            if (n - i > 2 * limit) {\n                continue;\n            }\n            ans += min(n - i, limit) - max(0, n - i - limit) + 1;\n        }\n        return ans;\n    }", "target_Lan": "cpp###distributeCandies2.cpp", "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n// TOFILL\nint main() {\n    cout << distributeCandies2(0, 10) << endl;\n    cout << distributeCandies2(10, 0) << endl;\n    cout << distributeCandies2(10, 10) << endl;\n    cout << distributeCandies2(10, 5) << endl;\n    cout << distributeCandies2(5, 10) << endl;\n}"}, {"source_Lan": "python###distributeCandies.py", "source_code": "def distributeCandies( n: int, limit: int) -> int:\n    ans = 0\n    for i in range(limit + 1):\n        for j in range(limit + 1):\n            if i + j > n:\n                break\n            if n - i - j <= limit:\n                ans += 1\n    return ans", "trans_code": "int distributeCandies ( int n , int limit ) throw ( ) {\n  int ans = 0 ;\n  for ( int i = 0 ;\n  i < limit + 1 ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < limit + 1 ;\n    j ++ ) {\n      if ( i + j > n ) break ;\n      if ( n - i - j <= limit ) ans ++ ;\n    }\n  }\n  return ans ;\n}\n", "reference_code": "    int distributeCandies(int n, int limit) {\n        int ans = 0;\n        for (int i = 0; i <= limit; i++) {\n            for (int j = 0; j <= limit; j++) {\n                if (i + j > n) {\n                    break;\n                }\n                if (n - i - j <= limit) {\n                    ans++;\n                }\n            }\n        }\n        return ans;\n    }", "target_Lan": "cpp###distributeCandies.cpp", "target_code_shell": "#include <iostream>\nusing namespace std;\n\n// TOFILL\nint main() {\n    cout << distributeCandies(1, 1) << endl;\n    cout << distributeCandies(10, 5) << endl;\n    cout << distributeCandies(20, 10) << endl;\n    cout << distributeCandies(100, 50) << endl;\n    cout << distributeCandies(1000, 500) << endl;\n}"}, {"source_Lan": "python###theMaximumAchievableX.py", "source_code": "def theMaximumAchievableX( num: int, t: int) -> int:\n    return num + 2 * t", "trans_code": "int theMaximumAchievableX ( int num , int t ) throw ( ) {\n  return num + 2 * t ;\n}\n", "reference_code": "    int theMaximumAchievableX(int num, int t) {\n        return num + 2 * t;\n    }", "target_Lan": "cpp###theMaximumAchievableX.cpp", "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n// TOFILL\nint main() {\n    cout << theMaximumAchievableX(0, 0) << endl;\n    cout << theMaximumAchievableX(1, 1) << endl;\n    cout << theMaximumAchievableX(-1, 1) << endl;\n    cout << theMaximumAchievableX(10, 5) << endl;\n    cout << theMaximumAchievableX(5, 10) << endl;\n    return 0;\n}"}, {"source_Lan": "python###numberOfEmployeesWhoMetTarget.py", "source_code": "def numberOfEmployeesWhoMetTarget( hours, target):\n    ans = 0\n    for i in range(0, len(hours)):\n        if hours[i] >= target:\n            ans += 1\n    return ans", "trans_code": "public : int numberOfEmployeesWhoMetTarget ( vector < int > hours , int target ) {\n  int ans = 0 ;\n  for ( int i = 0 ;\n  i != hours . size ( ) ;\n  i ++ ) {\n    if ( hours [ i ] >= target ) {\n      ans ++ ;\n    }\n  }\n  return ans ;\n}\n", "reference_code": "    int numberOfEmployeesWhoMetTarget(vector<int>& hours, int target) {\n        int ans = 0;\n        for (int i = 0; i < hours.size(); i++) {\n            if (hours[i] >= target) {\n                ans++;\n            }\n        }\n        return ans;\n    }", "target_Lan": "cpp###numberOfEmployeesWhoMetTarget.cpp", "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    vector<int> hours1 = {0, 1, 2, 3, 4};\n    cout << numberOfEmployeesWhoMetTarget(hours1, 2) << endl;\n\n    vector<int> hours2 = {5, 6, 7, 8, 9};\n    cout << numberOfEmployeesWhoMetTarget(hours2, 5) << endl;\n\n    vector<int> hours3 = {10, 11, 12, 13, 14};\n    cout << numberOfEmployeesWhoMetTarget(hours3, 10) << endl;\n\n    vector<int> hours4 = {15, 16, 17, 18, 19};\n    cout << numberOfEmployeesWhoMetTarget(hours4, 15) << endl;\n\n    vector<int> hours5 = {20, 21, 22, 23, 24};\n    cout << numberOfEmployeesWhoMetTarget(hours5, 20) << endl;\n\n    return 0;\n}"}, {"source_Lan": "python###countTestedDevices.py", "source_code": "def countTestedDevices( batteryPercentages: List[int]) -> int:\n    n = len(batteryPercentages)\n    need = 0\n    for i in range(n):\n        if batteryPercentages[i] > 0:\n            need += 1\n            for j in range(i + 1, n):\n                batteryPercentages[j] = max(batteryPercentages[j] - 1, 0)\n    return need", "trans_code": "int countTestedDevices ( vector < int > & batteryPercentages ) throw ( ) {\n  int n = batteryPercentages . size ( ) ;\n  int need = 0 ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    if ( batteryPercentages [ i ] > 0 ) {\n      need ++ ;\n      for ( int j = i + 1 ;\n      j < n ;\n      j ++ ) {\n        batteryPercentages [ j ] = max ( batteryPercentages [ j ] - 1 , 0 ) ;\n      }\n    }\n  }\n  return need ;\n}\n", "reference_code": "    int countTestedDevices(vector<int>& batteryPercentages) {\n        int n = batteryPercentages.size();\n        int need = 0;\n        for (int i = 0; i < n; i++) {\n            if (batteryPercentages[i] > 0) {\n                need++;\n                for (int j = i + 1; j < n; j++) {\n                    batteryPercentages[j] = max(batteryPercentages[j] - 1, 0);\n                }\n            }\n        }\n        return need;\n    }", "target_Lan": "cpp###countTestedDevices.cpp", "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    vector<int> batteryPercentages1 = {100, 0, 0, 0, 0};\n    vector<int> batteryPercentages2 = {100, 100, 100, 100, 100};\n    vector<int> batteryPercentages3 = {0, 0, 0, 0, 0};\n    vector<int> batteryPercentages4 = {100, 99, 98, 97, 96};\n    vector<int> batteryPercentages5 = {100, 100, 100, 100, 99};\n\n    cout << countTestedDevices(batteryPercentages1) << endl;\n    cout << countTestedDevices(batteryPercentages2) << endl;\n    cout << countTestedDevices(batteryPercentages3) << endl;\n    cout << countTestedDevices(batteryPercentages4) << endl;\n    cout << countTestedDevices(batteryPercentages5) << endl;\n\n    return 0;\n}"}, {"source_Lan": "python###maximumBinaryString.py", "source_code": "def maximumBinaryString( binary: str) -> str:\n    n = len(binary)\n    s = list(binary)\n    j = 0\n    for i in range(n):\n        if s[i] == '0':\n            while j <= i or (j < n and s[j] == '1'):\n                j += 1\n            if j < n:\n                s[j] = '1'\n                s[i] = '1'\n                s[i + 1] = '0'\n    return ''.join(s)", "trans_code": "public : string maximumBinaryString ( string binary ) throw ( ) {\n  int n = binary . size ( ) ;\n  string s ( binary . begin ( ) , binary . end ( ) ) ;\n  int j = 0 ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    if ( s [ i ] == '0' ) {\n      while ( j <= i || ( j < n && s [ j ] == '1' ) ) j ++ ;\n      if ( j < n ) {\n        s [ j ] = '1' ;\n        s [ i ] = '1' ;\n        s [ i + 1 ] = '0' ;\n      }\n    }\n  }\n  return s ;\n}\n", "reference_code": "    string maximumBinaryString(string binary) {\n        int n = binary.size();\n        int j = 0;\n        for (int i = 0; i < n; i++) {\n            if (binary[i] == '0') {\n                while (j <= i || (j < n && binary[j] == '1')) {\n                    j++;\n                }\n                if (j < n) {\n                    binary[j] = '1';\n                    binary[i] = '1';\n                    binary[i + 1] = '0';\n                }\n            }\n        }\n        return binary;\n    }", "target_Lan": "cpp###maximumBinaryString.cpp", "target_code_shell": "#include <iostream>\nusing namespace std;\n\n// TOFILL\nint main() {\n    cout << maximumBinaryString(\"0001\") << endl;\n    cout << maximumBinaryString(\"1110\") << endl;\n    cout << maximumBinaryString(\"010101\") << endl;\n    cout << maximumBinaryString(\"101010\") << endl;\n    cout << maximumBinaryString(\"000000\") << endl;\n    return 0;\n}"}, {"source_Lan": "python###maxArrayValue.py", "source_code": "def maxArrayValue( nums: List[int]) -> int:\n    for i in range(len(nums) - 2, -1, -1):\n        if nums[i] <= nums[i + 1]:\n            nums[i] += nums[i + 1]\n    return nums[0]", "trans_code": "public : int maxArrayValue ( vector < int > & nums ) throw ( ) {\n  for ( int i = nums . size ( ) - 2 ;\n  i >= 0 ;\n  i -- ) if ( nums [ i ] <= nums [ i + 1 ] ) nums [ i ] += nums [ i + 1 ] ;\n  return nums [ 0 ] ;\n}\n", "reference_code": "    long long maxArrayValue(vector<int> nums) {\n        long long sum = nums.back();\n        for (int i = nums.size() - 2; i >= 0; i--) {\n            sum = nums[i] <= sum ? nums[i] + sum : nums[i];\n        }\n        return sum;\n    }", "target_Lan": "cpp###maxArrayValue.cpp", "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    vector<int> nums1 = {1, 2, 3, 4, 5};\n    vector<int> nums2 = {10, 20, 30, 40, 50};\n    vector<int> nums3 = {-1, -2, -3, -4, -5};\n    vector<int> nums4 = {1000000000, 1000000000, 1000000000, 1000000000};\n    vector<int> nums5 = {1, 1, 1, 1, 1};\n\n    cout << maxArrayValue(nums1) << endl;\n    cout << maxArrayValue(nums2) << endl;\n    cout << maxArrayValue(nums3) << endl;\n    cout << maxArrayValue(nums4) << endl;\n    cout << maxArrayValue(nums5) << endl;\n\n    return 0;\n}"}, {"source_Lan": "python###findKOr.py", "source_code": "def findKOr( nums: List[int], k: int) -> int:\n    ans = 0\n    for i in range(31):\n        cnt = sum(1 for num in nums if ((num >> i) & 1) > 0)\n        if cnt >= k:\n            ans |= 1 << i\n    return ans", "trans_code": "public : int findKOr ( vector < int > & nums , int k ) throw ( ) {\n  int ans = 0 ;\n  for ( int i = 0 ;\n  i < 31 ;\n  i ++ ) {\n    int cnt = sum ( 1 , nums ) ;\n    if ( cnt >= k ) ans |= 1 << i ;\n  }\n  return ans ;\n}\n", "reference_code": "    int findKOr(vector<int>& nums, int k) {\n        int ans = 0;\n        for (int i = 0; i < 31; ++i) {\n            int cnt = 0;\n            for (int num: nums) {\n                if ((num >> i) & 1) {\n                    ++cnt;\n                }\n            }\n            if (cnt >= k) {\n                ans |= 1 << i;\n            }\n        }\n        return ans;\n    }", "target_Lan": "cpp###findKOr.cpp", "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    vector<int> nums1 = {1, 2, 3, 4, 5};\n    cout << findKOr(nums1, 2) << endl;\n\n    vector<int> nums2 = {1, 1, 1, 1, 1};\n    cout << findKOr(nums2, 1) << endl;\n\n    vector<int> nums3 = {10, 20, 30, 40, 50};\n    cout << findKOr(nums3, 3) << endl;\n\n    vector<int> nums4 = {1, 3, 5, 7, 9};\n    cout << findKOr(nums4, 5) << endl;\n\n    vector<int> nums5 = {2, 4, 6, 8, 10};\n    cout << findKOr(nums5, 1) << endl;\n\n    return 0;\n}"}, {"source_Lan": "python###maxNumberOfAlloys.py", "source_code": "def maxNumberOfAlloys( n: int, k: int, budget: int, composition: List[List[int]], stock: List[int], cost: List[int]) -> int:\n    left, right, ans = 1, 2 * 10**8, 0\n    while left <= right:\n        mid = (left + right) // 2\n        valid = False\n        for i in range(k):\n            spend = 0\n            for j, (composition_j, stock_j, cost_j) in enumerate(zip(composition[i], stock, cost)):\n                spend += max(composition_j * mid - stock_j, 0) * cost_j\n            if spend <= budget:\n                valid = True\n                break\n        if valid:\n            ans = mid\n            left = mid + 1\n        else:\n            right = mid - 1\n    return ans", "trans_code": "public : int maxNumberOfAlloys ( int n , int k , int budget , std :: vector < std :: vector < int >> composition , std :: vector < int > stock , std :: vector < int > cost ) throw ( ) {\n  int left = 1 , right = 2 * 10 * 8 , ans = 0 ;\n  while ( left <= right ) {\n    int mid = ( left + right ) / 2 ;\n    bool valid = false ;\n    for ( int i = 0 ;\n    i < k ;\n    i ++ ) {\n      int spend = 0 ;\n      for ( int j = 0 , ( composition_j = composition [ i ] . size ( ) ) ;\n      j < composition [ i ] . size ( ) ;\n      j ++ ) {\n        spend += std :: max ( composition_j * mid - stock_j , 0 ) * cost_j ;\n      }\n      if ( spend <= budget ) {\n        valid = true ;\n        break ;\n      }\n    }\n    if ( valid ) {\n      ans = mid ;\n      left = mid + 1 ;\n    }\n    else {\n      right = mid - 1 ;\n    }\n  }\n  return ans ;\n}\n", "reference_code": "    int maxNumberOfAlloys(int n, int k, int budget, vector<vector<int>>& composition, vector<int>& stock, vector<int>& cost) {\n        int left = 1, right = 2e8, ans = 0;\n        while (left <= right) {\n            int mid = (left + right) / 2;\n            bool valid = false;\n            for (int i = 0; i < k; ++i) {\n                long long spend = 0;\n                for (int j = 0; j < n; ++j) {\n                    spend += max(static_cast<long long>(composition[i][j]) * mid - stock[j], 0LL) * cost[j];\n                }\n                if (spend <= budget) {\n                    valid = true;\n                    break;\n                }\n            }\n            if (valid) {\n                ans = mid;\n                left = mid + 1;\n            }\n            else {\n                right = mid - 1;\n            }\n        }\n        return ans;\n    }", "target_Lan": "cpp###maxNumberOfAlloys.cpp", "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    int n = 0, k = 0, budget = 0;\n    vector<vector<int>> composition;\n    vector<int> stock, cost;\n    cout << maxNumberOfAlloys(n, k, budget, composition, stock, cost) << endl;\n\n    n = 1, k = 1, budget = 100;\n    composition = {{1}};\n    stock = {0};\n    cost = {10};\n    cout << maxNumberOfAlloys(n, k, budget, composition, stock, cost) << endl;\n\n    n = 2, k = 2, budget = 1000;\n    composition = {{1, 1}, {1, 1}};\n    stock = {0, 0};\n    cost = {10, 20};\n    cout << maxNumberOfAlloys(n, k, budget, composition, stock, cost) << endl;\n\n    n = 3, k = 3, budget = 10000;\n    composition = {{1, 1, 1}, {1, 1, 1}, {1, 1, 1}};\n    stock = {0, 0, 0};\n    cost = {10, 20, 30};\n    cout << maxNumberOfAlloys(n, k, budget, composition, stock, cost) << endl;\n\n    n = 4, k = 4, budget = 100000;\n    composition = {{1, 1, 1, 1}, {1, 1, 1, 1}, {1, 1, 1, 1}, {1, 1, 1, 1}};\n    stock = {0, 0, 0, 0};\n    cost = {10, 20, 30, 40};\n    cout << maxNumberOfAlloys(n, k, budget, composition, stock, cost) << endl;\n\n    return 0;\n}"}, {"source_Lan": "python###maximumSumOfHeights.py", "source_code": "def maximumSumOfHeights( maxHeights: List[int]) -> int:\n    n = len(maxHeights)\n    res = 0\n    for i in range(n):\n        pre, psum = maxHeights[i], maxHeights[i]\n        for j in range(i - 1, -1, -1):\n            pre = min(pre, maxHeights[j])\n            psum += pre\n        suf = maxHeights[i]\n        for j in range(i + 1, n):\n            suf = min(suf, maxHeights[j])\n            psum += suf\n        res = max(res, psum)\n    return res", "trans_code": "public : int maximumSumOfHeights ( vector < int > maxHeights ) throw ( ) {\n  int n = maxHeights . size ( ) ;\n  int res = 0 ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    int pre = maxHeights [ i ] , psum = maxHeights [ i ] ;\n    for ( int j = i - 1 ;\n    j >= 0 ;\n    j -- ) {\n      pre = min ( pre , maxHeights [ j ] ) ;\n      psum += pre ;\n    }\n    int suf = maxHeights [ i ] ;\n    for ( int j = i + 1 ;\n    j < n ;\n    j ++ ) {\n      suf = min ( suf , maxHeights [ j ] ) ;\n      psum += suf ;\n    }\n    res = max ( res , psum ) ;\n  }\n  return res ;\n}\n", "reference_code": "    long long maximumSumOfHeights(vector<int>& maxHeights) {\n        int n = maxHeights.size();\n        long long res = 0;\n        for (int i = 0; i < n; i++) {\n            int pre = maxHeights[i];\n            long long sum = pre;\n            for (int j = i - 1; j >= 0; j--) {\n                pre = min(pre, maxHeights[j]);\n                sum += pre;\n            }\n            int suf = maxHeights[i];\n            for (int j = i + 1; j < n; j++) {\n                suf = min(suf, maxHeights[j]);\n                sum += suf;\n            }\n            res = max(res, sum);\n        }\n        return res;\n    }", "target_Lan": "cpp###maximumSumOfHeights.cpp", "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    vector<int> maxHeights1 = {1,2,3,4,5};\n    cout << maximumSumOfHeights(maxHeights1) << endl;\n\n    vector<int> maxHeights2 = {5,4,3,2,1};\n    cout << maximumSumOfHeights(maxHeights2) << endl;\n\n    vector<int> maxHeights3 = {1,1,1,1,1};\n    cout << maximumSumOfHeights(maxHeights3) << endl;\n\n    vector<int> maxHeights4 = {2,4,6,8,10};\n    cout << maximumSumOfHeights(maxHeights4) << endl;\n\n    vector<int> maxHeights5 = {10,8,6,4,2};\n    cout << maximumSumOfHeights(maxHeights5) << endl;\n\n    return 0;\n}"}, {"source_Lan": "python###alternatingSubarray.py", "source_code": "def alternatingSubarray( nums: List[int]) -> int:\n    res = -1\n    n = len(nums)\n    for firstIndex in range(n):\n        for i in range(firstIndex + 1, n):\n            length = i - firstIndex + 1\n            if nums[i] - nums[firstIndex] == (length - 1) % 2:\n                res = max(res, length)\n            else:\n                break\n    return res", "trans_code": "public : int alternatingSubarray ( vector < int > & nums ) throw ( ) {\n  int res = - 1 ;\n  int n = nums . size ( ) ;\n  for ( int firstIndex = 0 ;\n  firstIndex < n ;\n  firstIndex ++ ) {\n    for ( int i = firstIndex + 1 ;\n    i < n ;\n    i ++ ) {\n      int length = i - firstIndex + 1 ;\n      if ( nums [ i ] - nums [ firstIndex ] == ( length - 1 ) % 2 ) {\n        res = max ( res , length ) ;\n      }\n      else {\n        break ;\n      }\n    }\n  }\n  return res ;\n}\n", "reference_code": "    int alternatingSubarray(vector<int>& nums) {\n        int res = -1;\n        int n = nums.size();\n        for (int firstIndex = 0; firstIndex < n; firstIndex++) {\n            for (int i = firstIndex + 1; i < n; i++) {\n                int length = i - firstIndex + 1;\n                if (nums[i] - nums[firstIndex] == (length - 1) % 2) {\n                    res = max(res, length);\n                } else {\n                    break;\n                }\n            }\n        }\n        return res;\n    }", "target_Lan": "cpp###alternatingSubarray.cpp", "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    vector<int> nums1 = {1,2,3,4,5};\n    cout << alternatingSubarray(nums1) << endl;\n\n    vector<int> nums2 = {1,3,5,7,9};\n    cout << alternatingSubarray(nums2) << endl;\n\n    vector<int> nums3 = {-1,-2,-3,-4,-5};\n    cout << alternatingSubarray(nums3) << endl;\n\n    vector<int> nums4 = {0,0,0,0,0};\n    cout << alternatingSubarray(nums4) << endl;\n\n    vector<int> nums5 = {1,1,1,1,1};\n    cout << alternatingSubarray(nums5) << endl;\n\n    return 0;\n}"}, {"source_Lan": "python###minimumTime.py", "source_code": "def minimumTime( nums1: List[int], nums2: List[int], x: int) -> int:\n    n = len(nums1)\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    for j, (b, a) in enumerate(sorted(zip(nums2, nums1)), 1):\n        for i in range(j, 0, -1):\n            dp[j][i] = max(dp[j - 1][i], dp[j - 1][i - 1] + i * b + a)\n    sa, sb = sum(nums1), sum(nums2)\n    for i in range(0, n + 1):\n        if sb * i + sa - dp[n][i] <= x:\n            return i\n    return -1", "trans_code": "public : int minimumTime ( vector < int > & nums1 , vector < int > & nums2 , int x ) throw ( ) {\n  int n = nums1 . size ( ) ;\n  vector < vector < int >> dp ( n + 1 , vector < int > ( n + 1 , 0 ) ) ;\n  for ( int j = 0 , ( b = nums2 . size ( ) ) ;\n  j < n ;\n  ++ j ) for ( int i = j ;\n  i > 0 ;\n  -- i ) dp [ j ] [ i ] = max ( dp [ j - 1 ] [ i ] , dp [ j - 1 ] [ i - 1 ] + i * b + a ) ;\n  int sa = sum ( nums1 ) , sb = sum ( nums2 ) ;\n  for ( int i = 0 ;\n  i <= n ;\n  ++ i ) if ( sb * i + sa - dp [ n ] [ i ] <= x ) return i ;\n  return - 1 ;\n}\n", "reference_code": "    int minimumTime(vector<int>& nums1, vector<int>& nums2, int x) {\n        int n = nums1.size();\n        vector<vector<int>> dp(n + 1, vector<int>(n + 1, 0));\n        vector<pair<int, int>> nums(n);\n        for (int i = 0; i < n; i++) {\n            nums[i] = {nums2[i], nums1[i]};\n        }\n        sort(nums.begin(), nums.end());\n        for (int j = 1; j <= n; j++) {\n            int b = nums[j - 1].first, a = nums[j - 1].second;\n            for (int i = j; i > 0; i--) {\n                dp[j][i] = max(dp[j - 1][i], dp[j - 1][i - 1] + i * b + a);\n            }\n        }\n        int s1 = accumulate(nums1.begin(), nums1.end(), 0);\n        int s2 = accumulate(nums2.begin(), nums2.end(), 0);\n        for (int i = 0; i <= n; i++) {\n            if (s2 * i + s1 - dp[n][i] <= x) {\n                return i;\n            }\n        }\n        return -1;\n    }", "target_Lan": "cpp###minimumTime.cpp", "target_code_shell": "#include <iostream>\nusing namespace std;\n    #include <bits/stdc++.h>\n// TOFILL\nint main() {\n        vector<int> nums1 = {1, 2, 3, 4};\n        vector<int> nums2 = {1, 2, 3, 4};\n        cout << minimumTime(nums1, nums2, 10) << endl;\n\n        nums1 = {10, 20, 30, 40};\n        nums2 = {1, 2, 3, 4};\n        cout << minimumTime(nums1, nums2, 100) << endl;\n\n        nums1 = {1, 1, 1, 1};\n        nums2 = {1, 1, 1, 1};\n        cout << minimumTime(nums1, nums2, 5) << endl;\n\n        nums1 = {5, 5, 5, 5};\n        nums2 = {1, 1, 1, 1};\n        cout << minimumTime(nums1, nums2, 15) << endl;\n\n        nums1 = {10, 20, 30, 40};\n        nums2 = {4, 3, 2, 1};\n        cout << minimumTime(nums1, nums2, 100) << endl;\n\n        return 0;\n    }"}, {"source_Lan": "python###equality.py", "source_code": "def equality( A, B):\n    if A > B:\n        return 0\n    if A == B:\n        return 1\n    if B % 2 == 0:\n        return 1\n    return 0", "trans_code": "int equality ( int A , int B ) {\n  if ( A > B ) return 0 ;\n  if ( A == B ) return 1 ;\n  if ( B % 2 == 0 ) return 1 ;\n  return 0 ;\n}\n", "reference_code": "    int equality(int A, int B) {\n        if (B<A) return 0;\n        if (A==B) return 1;\n        if (B%2==0) return 1;\n        return 0;\n    }", "target_Lan": "cpp###equality.cpp", "target_code_shell": "#include <iostream>\nusing namespace std;\n\n// TOFILL\nint main() {\n    cout << equality(0, 0) << endl;\n    cout << equality(1, 1) << endl;\n    cout << equality(-1, -1) << endl;\n    cout << equality(10, 10) << endl;\n    cout << equality(5, 5) << endl;\n}"}, {"source_Lan": "python###isMagicArray.py", "source_code": "def isMagicArray( n : int, arr : List[int]) -> bool:\n    for i in range(n-1):\n        if (arr[i]&1)==(arr[i+1]&1):\n            return 0\n    return 1", "trans_code": "bool isMagicArray ( int n , int * arr ) throw ( ) {\n  for ( int i = 0 ;\n  i < n - 1 ;\n  i ++ ) if ( ( arr [ i ] & 1 ) == ( arr [ i + 1 ] & 1 ) ) return 0 ;\n  return 1 ;\n}\n", "reference_code": "    bool isMagicArray(int n, vector<int> &arr) {\n        for (int i=1;i<n;i++){\n            if ((arr[i]%2==0 && arr[i-1]%2==0) || (arr[i]%2!=0 && arr[i-1]%2!=0)) return 0;\n        }\n        return 1;\n    }", "target_Lan": "cpp###isMagicArray.cpp", "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    vector<int> arr1 = {1, 2, 3, 4, 5};\n    cout << isMagicArray(5, arr1) << endl;\n\n    vector<int> arr2 = {2, 4, 6, 8};\n    cout << isMagicArray(4, arr2) << endl;\n\n    vector<int> arr3 = {1, 3, 5};\n    cout << isMagicArray(3, arr3) << endl;\n\n    vector<int> arr4 = {2, 4};\n    cout << isMagicArray(2, arr4) << endl;\n\n    vector<int> arr5 = {1};\n    cout << isMagicArray(1, arr5) << endl;\n\n    return 0;\n}"}, {"source_Lan": "python###isPossible.py", "source_code": "def isPossible( a: int, b: int, c: int) -> str:\n    \n    if (a + b) > c and (a + c) > b and (b + c) > a:\n        return \"YES\"\n    else:\n        return \"NO\"", "trans_code": "string isPossible ( int a , int b , int c ) throw ( ) {\n  if ( ( a + b ) > c && ( a + c ) > b && ( b + c ) > a ) return \"YES\" ;\n  else return \"NO\" ;\n}\n", "reference_code": "    string isPossible(int a, int b, int c) {\n        \n        if ((a + b) > c && (a + c) > b && (b + c) > a)\n            return \"YES\";\n        else\n            return \"NO\";\n    }", "target_Lan": "cpp###isPossible.cpp", "target_code_shell": "#include <iostream>\nusing namespace std;\n\n// TOFILL\nint main() {\n    cout << isPossible(1, 2, 3) << endl;\n    cout << isPossible(3, 2, 1) << endl;\n    cout << isPossible(0, 0, 0) << endl;\n    cout << isPossible(-1, -2, -3) << endl;\n    cout << isPossible(1000000, 1000000, 1000000) << endl;\n    return 0;\n}"}, {"source_Lan": "python###isFriend.py", "source_code": "def isFriend( n : int, x : int, y : int, arr : List[int]) -> str:\n    if y-x in arr:\n        return \"yes\"\n    else:\n        return \"no\"", "trans_code": "string isFriend ( int n , int x , int y , vector < int > arr ) throw ( ) {\n  if ( y - x < arr . size ( ) ) return \"yes\" ;\n  else return \"no\" ;\n}\n", "reference_code": "    string isFriend(int n, int x, int y, vector<int> &arr) {\n        for (auto j:arr){\n            if (x+j==y) return \"yes\";\n        }\n        return \"no\";\n    }", "target_Lan": "cpp###isFriend.cpp", "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    vector<int> arr1 = {1, 2, 3};\n    cout << isFriend(3, 5, 10, arr1) << endl;\n\n    vector<int> arr2 = {5, 5, 5, 5};\n    cout << isFriend(4, 10, 20, arr2) << endl;\n\n    vector<int> arr3 = {-5, 5};\n    cout << isFriend(2, -5, 0, arr3) << endl;\n\n    vector<int> arr4 = {0};\n    cout << isFriend(1, 100, 100, arr4) << endl;\n\n    vector<int> arr5 = {};\n    cout << isFriend(0, 0, 0, arr5) << endl;\n\n    return 0;\n}"}, {"source_Lan": "python###chocolateDistribution.py", "source_code": "def chocolateDistribution( N, M, arr, brr):\n    arr.sort()\n    brr.sort()\n    ans = 0\n    i, j = 0, 0\n    while i < N and j < M:\n        if arr[i] <= brr[j]:\n            ans += 1\n            i += 1\n            j += 1\n        else:\n            j += 1\n    return ans", "trans_code": "int chocolateDistribution ( int N , int M , vector < int > & arr , vector < int > & brr ) {\n  sort ( arr . begin ( ) , arr . end ( ) ) ;\n  sort ( brr . begin ( ) , brr . end ( ) ) ;\n  int ans = 0 ;\n  int i = 0 , j = 0 ;\n  while ( i < N && j < M ) {\n    if ( arr [ i ] <= brr [ j ] ) {\n      ans ++ ;\n      i ++ ;\n      j ++ ;\n    }\n    else {\n      j ++ ;\n    }\n  }\n  return ans ;\n}\n", "reference_code": "    int chocolateDistribution(int N, int M, vector<int> &arr, vector<int> &brr) {\n        sort(arr.begin(), arr.end());\n        sort(brr.begin(), brr.end());\n        int ans = 0;\n        int i = 0, j = 0;\n        while (i < N && j < M) {\n            if (arr[i] <= brr[j]) {\n                ans++;\n                i++;\n                j++;\n            } else {\n                j++;\n            }\n        }\n        return ans;\n    }", "target_Lan": "cpp###chocolateDistribution.cpp", "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <algorithm>\n// TOFILL\nint main() {\n    vector<int> arr1 = {1, 2, 3, 4, 5};\n    vector<int> brr1 = {1, 2, 3, 4, 5};\n    cout << chocolateDistribution(5, 5, arr1, brr1) << endl;\n\n    vector<int> arr2 = {1, 2, 3, 4, 5};\n    vector<int> brr2 = {6, 7, 8, 9, 10};\n    cout << chocolateDistribution(5, 5, arr2, brr2) << endl;\n\n    vector<int> arr3 = {6, 7, 8, 9, 10};\n    vector<int> brr3 = {1, 2, 3, 4, 5};\n    cout << chocolateDistribution(5, 5, arr3, brr3) << endl;\n\n    vector<int> arr4 = {1, 3, 5, 7, 9};\n    vector<int> brr4 = {2, 4, 6, 8, 10};\n    cout << chocolateDistribution(5, 5, arr4, brr4) << endl;\n\n    vector<int> arr5 = {2, 4, 6, 8, 10};\n    vector<int> brr5 = {1, 3, 5, 7, 9};\n    cout << chocolateDistribution(5, 5, arr5, brr5) << endl;\n\n    return 0;\n}"}, {"source_Lan": "python###minOrAfterOperations.py", "source_code": "def minOrAfterOperations( nums: List[int], k: int) -> int:\n    ans = mask = 0\n    for b in range(max(nums).bit_length() - 1, -1, -1):\n        mask |= 1 << b\n        cnt = 0  \n        and_res = -1  \n        for x in nums:\n            and_res &= x & mask\n            if and_res:\n                cnt += 1  \n            else:\n                and_res = -1  \n        if cnt > k:\n            ans |= 1 << b  \n            mask ^= 1 << b  \n    return ans", "trans_code": "public : int minOrAfterOperations ( vector < int > & nums , int k ) throw ( ) {\n  int ans = 0 ;\n  int mask = 0 ;\n  for ( int b = max ( nums ) . size ( ) - 1 ;\n  b >= 0 ;\n  -- b ) {\n    mask |= 1 << b ;\n    int cnt = 0 ;\n    int and_res = - 1 ;\n    for ( int x : nums ) {\n      and_res &= x & mask ;\n      if ( and_res ) ++ cnt ;\n      else and_res = - 1 ;\n    }\n    if ( cnt > k ) {\n      ans |= 1 << b ;\n      mask ^= 1 << b ;\n    }\n  }\n  return ans ;\n}\n", "reference_code": "    int minOrAfterOperations(vector<int> &nums, int k) {\n        int ans = 0, mask = 0;\n        for (int b = 29; b >= 0; b--) {\n            mask |= 1 << b;\n            int cnt = 0, and_res = -1; \n            for (int x : nums) {\n                and_res &= x & mask;\n                if (and_res) {\n                    cnt++; \n                } else {\n                    and_res = -1; \n                }\n            }\n            if (cnt > k) {\n                ans |= 1 << b; \n                mask ^= 1 << b; \n            }\n        }\n        return ans;\n    }", "target_Lan": "cpp###minOrAfterOperations.cpp", "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    vector<int> nums1 = {1, 2, 3, 4, 5};\n    cout << minOrAfterOperations(nums1, 2) << endl;\n\n    vector<int> nums2 = {10, 20, 30, 40, 50};\n    cout << minOrAfterOperations(nums2, 3) << endl;\n\n    vector<int> nums3 = {100, 200, 300, 400, 500};\n    cout << minOrAfterOperations(nums3, 4) << endl;\n\n    vector<int> nums4 = {1000, 2000, 3000, 4000, 5000};\n    cout << minOrAfterOperations(nums4, 5) << endl;\n\n    vector<int> nums5 = {10000, 20000, 30000, 40000, 50000};\n    cout << minOrAfterOperations(nums5, 6) << endl;\n\n    return 0;\n}"}, {"source_Lan": "python###resultArray.py", "source_code": "def resultArray( nums: List[int]) -> List[int]:\n    a = nums[:1]\n    b = nums[1:2]\n    for x in nums[2:]:\n        if a[-1] > b[-1]:\n            a.append(x)\n        else:\n            b.append(x)\n    return a + b", "trans_code": "public : vector < int > resultArray ( vector < int > & nums ) throw ( ) {\n  vector < int > a = nums . begin ( ) ;\n  vector < int > b = nums . end ( ) ;\n  for ( int x = 0 ;\n  x < nums . size ( ) ;\n  x ++ ) {\n    if ( a . back ( ) > b . back ( ) ) a . push_back ( x ) ;\n    else b . push_back ( x ) ;\n  }\n  return a + b ;\n}\n", "reference_code": "    vector<int> resultArray(vector<int> &nums) {\n        vector<int> a{nums[0]}, b{nums[1]};\n        for (int i = 2; i < nums.size(); i++) {\n            (a.back() > b.back() ? a : b).push_back(nums[i]);\n        }\n        a.insert(a.end(), b.begin(), b.end());\n        return a;\n    }", "target_Lan": "cpp###resultArray.cpp", "target_code_shell": "#include <iostream>\nusing namespace std;\n    #include <iostream>\n    #include <vector>\n// TOFILL\nint main() {\n        vector<int> nums1 = {1, 2, 3, 4, 5};\n        vector<int> nums2 = {5, 4, 3, 2, 1};\n        vector<int> nums3 = {1, 1, 1, 1, 1};\n        vector<int> nums4 = {-1, -2, -3, -4, -5};\n        vector<int> nums5 = {10, 20, 30, 40, 50};\n\n        vector<int> result1 = resultArray(nums1);\n        vector<int> result2 = resultArray(nums2);\n        vector<int> result3 = resultArray(nums3);\n        vector<int> result4 = resultArray(nums4);\n        vector<int> result5 = resultArray(nums5);\n\n        for(int i = 0; i < result1.size(); i++) {\n            cout << result1[i] << \" \";\n        }\n        cout << endl;\n\n        for(int i = 0; i < result2.size(); i++) {\n            cout << result2[i] << \" \";\n        }\n        cout << endl;\n\n        for(int i = 0; i < result3.size(); i++) {\n            cout << result3[i] << \" \";\n        }\n        cout << endl;\n\n        for(int i = 0; i < result4.size(); i++) {\n            cout << result4[i] << \" \";\n        }\n        cout << endl;\n\n        for(int i = 0; i < result5.size(); i++) {\n            cout << result5[i] << \" \";\n        }\n        cout << endl;\n\n        return 0;\n    }"}, {"source_Lan": "python###maxBottlesDrunk.py", "source_code": "def maxBottlesDrunk( numBottles: int, numExchange: int) -> int:\n    ans = numBottles  \n    while numBottles >= numExchange:  \n        ans += 1  \n        numBottles += 1 - numExchange\n        numExchange += 1\n    return ans", "trans_code": "int maxBottlesDrunk ( int numBottles , int numExchange ) throw ( ) {\n  int ans = numBottles ;\n  while ( numBottles >= numExchange ) {\n    ans ++ ;\n    numBottles ++ - numExchange ;\n    numExchange ++ ;\n  }\n  return ans ;\n}\n", "reference_code": "    int maxBottlesDrunk(int numBottles, int numExchange) {\n        int ans = numBottles; \n        while (numBottles >= numExchange) { \n            ans++; \n            numBottles += 1 - numExchange++;\n        }\n        return ans;\n    }", "target_Lan": "cpp###maxBottlesDrunk.cpp", "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n// TOFILL\nint main() {\n    cout << maxBottlesDrunk(0, 0) << endl;\n    cout << maxBottlesDrunk(10, 0) << endl;\n    cout << maxBottlesDrunk(0, 10) << endl;\n    cout << maxBottlesDrunk(10, 10) << endl;\n    cout << maxBottlesDrunk(100, 10) << endl;\n    return 0;\n}"}, {"source_Lan": "python###minimumSteps.py", "source_code": "def minimumSteps( s):\n    ans, sum = 0, 0\n    for i in range(len(s)):\n        if s[i] == '1':\n            sum += 1\n        else:\n            ans += sum\n    return ans", "trans_code": "public : int minimumSteps ( string s ) {\n  int ans = 0 , sum = 0 ;\n  for ( int i = 0 ;\n  i < s . length ( ) ;\n  i ++ ) {\n    if ( s [ i ] == '1' ) sum ++ ;\n    else ans += sum ;\n  }\n  return ans ;\n}\n", "reference_code": "    long long minimumSteps(string s) {\n        long long ans = 0;\n        int sum = 0;\n        for (int i = 0; i < s.size(); i++) {\n            if (s[i] == '1') {\n                sum++;\n            } else {\n                ans += sum;\n            }\n        }\n        return ans;\n    }", "target_Lan": "cpp###minimumSteps.cpp", "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <string>\n// TOFILL\nint main() {\n    cout << minimumSteps(\"0\") << endl;\n    cout << minimumSteps(\"11111\") << endl;\n    cout << minimumSteps(\"00000\") << endl;\n    return 0;\n}"}, {"source_Lan": "python###findIndices.py", "source_code": "def findIndices( nums: List[int], indexDifference: int, valueDifference: int) -> List[int]:\n    for i in range(len(nums)):\n        for j in range(i, len(nums)):\n            if j - i >= indexDifference and abs(nums[j] - nums[i]) >= valueDifference:\n                return [i, j]\n    return [-1, -1]", "trans_code": "public : vector < int > findIndices ( vector < int > & nums , int indexDifference , int valueDifference ) throw ( ) {\n  for ( int i = 0 ;\n  i < nums . size ( ) ;\n  i ++ ) {\n    for ( int j = i ;\n    j < nums . size ( ) ;\n    j ++ ) {\n      if ( j - i >= indexDifference && abs ( nums [ j ] - nums [ i ] ) >= valueDifference ) {\n        return {\n          i , j }\n          ;\n        }\n      }\n    }\n    return {\n      - 1 , - 1 }\n      ;\n    }\n    ", "reference_code": "    vector<int> findIndices(vector<int>& nums, int indexDifference, int valueDifference) {\n        for (int i = 0; i < nums.size(); i++) {\n            for (int j = i; j < nums.size(); j++) {\n                if (j - i >= indexDifference && abs(nums[j] - nums[i]) >= valueDifference) {\n                    return {i, j};\n                }\n            }\n        }\n        return {-1, -1};\n    }", "target_Lan": "cpp###findIndices.cpp", "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    vector<int> nums1 = {1,2,3,4,5};\n    vector<int> nums2 = {5,4,3,2,1};\n    vector<int> nums3 = {1,1,1,1,1};\n    vector<int> nums4 = {1,2,3,4,5};\n    vector<int> nums5 = {1,2,3,4,5};\n\n    vector<int> res = findIndices(nums1, 2, 1);\n    for(int i=0; i<res.size(); i++)\n        cout << res[i] << \" \";\n    cout << endl;\n\n    res = findIndices(nums2, 1, 1);\n    for(int i=0; i<res.size(); i++)\n        cout << res[i] << \" \";\n    cout << endl;\n\n    res = findIndices(nums3, 1, 0);\n    for(int i=0; i<res.size(); i++)\n        cout << res[i] << \" \";\n    cout << endl;\n\n    res = findIndices(nums4, 1, 1);\n    for(int i=0; i<res.size(); i++)\n        cout << res[i] << \" \";\n    cout << endl;\n\n    res = findIndices(nums5, 0, 0);\n    for(int i=0; i<res.size(); i++)\n        cout << res[i] << \" \";\n    cout << endl;\n\n    return 0;\n}"}, {"source_Lan": "python###findChampion.py", "source_code": "def findChampion( n: int, edges: List[List[int]]) -> int:\n    degree = [0] * n\n    for x, y in edges:\n        degree[y] += 1\n    champion = -1\n    for i, d in enumerate(degree):\n        if d == 0:\n            if champion == -1:\n                champion = i\n            else:\n                return -1\n    return champion", "trans_code": "int findChampion ( int n , vector < vector < int >> & edges ) throw ( ) {\n  vector < int > degree ( n , 0 ) ;\n  for ( int x = 0 ;\n  x < n ;\n  x ++ ) degree [ x ] ++ ;\n  int champion = - 1 ;\n  for ( int i = 0 , d = degree . size ( ) ;\n  i < d ;\n  i ++ ) {\n    if ( degree [ i ] == 0 ) {\n      if ( champion == - 1 ) champion = i ;\n      else return - 1 ;\n    }\n  }\n  return champion ;\n}\n", "reference_code": "    int findChampion(int n, vector<vector<int>>& edges) {\n        vector<int> degree(n);\n        for (auto e : edges) {\n            degree[e[1]]++;\n        }\n        int champion = -1;\n        for (int i = 0; i < n; i++) {\n            if (degree[i] == 0) {\n                if (champion == -1) {\n                    champion = i;\n                } else {\n                    return -1;\n                }\n            }\n        }\n        return champion;\n    }", "target_Lan": "cpp###findChampion.cpp", "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    int n;\n    vector<vector<int>> edges;\n\n    n = 0;\n    edges = {};\n    cout << findChampion(n, edges) << endl;\n\n    n = 1;\n    edges = {};\n    cout << findChampion(n, edges) << endl;\n\n    n = 2;\n    edges = {{0,1}};\n    cout << findChampion(n, edges) << endl;\n\n    n = 3;\n    edges = {{0,1},{1,2}};\n    cout << findChampion(n, edges) << endl;\n\n    n = 3;\n    edges = {{0,1},{0,2}};\n    cout << findChampion(n, edges) << endl;\n\n    return 0;\n}"}, {"source_Lan": "python###minIncrements.py", "source_code": "def minIncrements( n: int, cost: List[int]) -> int:\n    ans = 0\n    for i in range(n - 2, 0, -2):\n        ans += abs(cost[i] - cost[i + 1])\n        \n        cost[i // 2] += max(cost[i], cost[i + 1])\n    return ans", "trans_code": "public : int minIncrements ( int n , vector < int > & cost ) throw ( ) {\n  int ans = 0 ;\n  for ( int i = n - 2 ;\n  i > 0 ;\n  i -- ) {\n    ans += abs ( cost [ i ] - cost [ i + 1 ] ) ;\n    cost [ i / 2 ] += max ( cost [ i ] , cost [ i + 1 ] ) ;\n  }\n  return ans ;\n}\n", "reference_code": "    int minIncrements(int n, vector<int>& cost) {\n        int ans = 0;\n        for (int i = n - 2; i > 0; i -= 2) {\n            ans += abs(cost[i] - cost[i + 1]);\n            \n            cost[i / 2] += max(cost[i], cost[i + 1]);\n        }\n        return ans;\n    }", "target_Lan": "cpp###minIncrements.cpp", "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    int n1 = 0;\n    vector<int> cost1 = {};\n    cout << minIncrements(n1, cost1) << endl;\n\n    int n2 = 1;\n    vector<int> cost2 = {1};\n    cout << minIncrements(n2, cost2) << endl;\n\n    int n3 = 2;\n    vector<int> cost3 = {1, 2};\n    cout << minIncrements(n3, cost3) << endl;\n\n    int n4 = 3;\n    vector<int> cost4 = {1, 2, 3};\n    cout << minIncrements(n4, cost4) << endl;\n\n    int n5 = 4;\n    vector<int> cost5 = {1, 2, 3, 4};\n    cout << minIncrements(n5, cost5) << endl;\n\n    return 0;\n}"}, {"source_Lan": "python###BeautifulBits.py", "source_code": "def BeautifulBits( n : int, arr : List[int], q : int, queries : List[List[int]]) -> List[int]:\n    pref = [[0] * 32 for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(32):\n            pref[i][j] = pref[i - 1][j] + ((arr[i - 1] >> j) & 1)\n    ans = [0] * q\n    for i in range(q):\n        for j in range(32):\n            if pref[queries[i][1]][j] - pref[queries[i][0] - 1][j] != 0:\n                ans[i] += 1 << j\n    return ans", "trans_code": "public : vector < int > BeautifulBits ( int n , vector < int > arr , int q , vector < vector < int >> queries ) throw ( ) {\n  vector < vector < int >> pref ( n + 1 , vector < int > ( 32 ) ) ;\n  for ( int i = 1 ;\n  i <= n ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < 32 ;\n    j ++ ) {\n      pref [ i ] [ j ] = pref [ i - 1 ] [ j ] + ( ( arr [ i - 1 ] >> j ) & 1 ) ;\n    }\n  }\n  vector < int > ans ( q , 0 ) ;\n  for ( int i = 0 ;\n  i < q ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < 32 ;\n    j ++ ) {\n      if ( pref [ queries [ i ] [ 1 ] ] [ j ] - pref [ queries [ i ] [ 0 ] - 1 ] [ j ] != 0 ) {\n        ans [ i ] += 1 << j ;\n      }\n    }\n  }\n  return ans ;\n}\n", "reference_code": "    vector<int> BeautifulBits(int n, vector<int> &arr, int q,\n                              vector<vector<int> > &queries) {\n        vector<vector<long long> > pref(n + 1, vector<long long>(32, 0));\n        for (int i = 1; i <= n; i++) {\n            for (int j = 0; j < 32; j++) {\n                pref[i][j] = pref[i - 1][j] + ((arr[i - 1] >> j) & 1);\n            }\n        }\n        vector<int> ans(q, 0);\n        for (int i = 0; i < q; i++) {\n            for (int j = 0; j < 32; j++) {\n                if (pref[queries[i][1]][j] - pref[queries[i][0] - 1][j] != 0) {\n                    ans[i] += 1 << j;\n                }\n            }\n        }\n        return ans;\n    }", "target_Lan": "cpp###BeautifulBits.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// TOFILL\nint main() {\n    vector<int> arr1 = {1, 2, 3, 4, 5};\n    vector<vector<int>> queries1 = {{1, 3}, {2, 4}};\n    vector<int> result1 = BeautifulBits(5, arr1, 2, queries1);\n    for(int i = 0; i < result1.size(); i++) {\n        cout << result1[i] << \" \";\n    }\n    cout << endl;\n\n    vector<int> arr2 = {10, 20, 30, 40, 50, 60, 70, 80, 90, 100};\n    vector<vector<int>> queries2 = {{1, 5}, {3, 7}, {6, 10}};\n    vector<int> result2 = BeautifulBits(10, arr2, 3, queries2);\n    for(int i = 0; i < result2.size(); i++) {\n        cout << result2[i] << \" \";\n    }\n    cout << endl;\n\n    vector<int> arr3 = {1, 3, 5, 7};\n    vector<vector<int>> queries3 = {{1, 4}};\n    vector<int> result3 = BeautifulBits(4, arr3, 1, queries3);\n    for(int i = 0; i < result3.size(); i++) {\n        cout << result3[i] << \" \";\n    }\n    cout << endl;\n\n    vector<int> arr4 = {2, 4, 6, 8, 10, 12, 14};\n    vector<vector<int>> queries4 = {{1, 5}, {4, 7}};\n    vector<int> result4 = BeautifulBits(7, arr4, 2, queries4);\n    for(int i = 0; i < result4.size(); i++) {\n        cout << result4[i] << \" \";\n    }\n    cout << endl;\n\n    vector<int> arr5 = {1, 3, 5, 7, 9, 11};\n    vector<vector<int>> queries5 = {{1, 3}, {2, 5}, {4, 6}};\n    vector<int> result5 = BeautifulBits(6, arr5, 3, queries5);\n    for(int i = 0; i < result5.size(); i++) {\n        cout << result5[i] << \" \";\n    }\n    cout << endl;\n}"}, {"source_Lan": "python###maxAlternatingSubstring.py", "source_code": "def maxAlternatingSubstring( N: int, S: str) -> int:\n    diff = []\n    i = 0\n    while i < N:\n        j = i + 1\n        while j < N and S[j] != S[j - 1]:\n            j += 1\n        diff.append(j - i)\n        i = j\n    diff.append(0)\n    ans_before = 0\n    for x in diff:\n        ans_before += ((x * (x + 1)) // 2)\n    ans = 0\n    for i in range(len(diff) - 1):\n        a = diff[i]\n        b = diff[i + 1]\n        currAns = (ans_before - ((a * (a + 1)) // 2) -\n                   ((b * (b + 1)) // 2) + ((a + b + 1) * (a + b + 2)) // 2)\n        ans = max(ans, currAns)\n    return ans", "trans_code": "public : int maxAlternatingSubstring ( int N , string S ) throw ( ) {\n  vector < int > diff ;\n  int i = 0 ;\n  while ( i < N ) {\n    int j = i + 1 ;\n    while ( j < N && S [ j ] != S [ j - 1 ] ) j ++ ;\n    diff . push_back ( j - i ) ;\n    i = j ;\n  }\n  diff . push_back ( 0 ) ;\n  int ansBefore = 0 ;\n  for ( int x : diff ) ansBefore += ( ( x * ( x + 1 ) ) / 2 ) ;\n  int ans = 0 ;\n  for ( int i = 0 ;\n  i < diff . size ( ) - 1 ;\n  i ++ ) {\n    int a = diff [ i ] ;\n    int b = diff [ i + 1 ] ;\n    int currAns = ( ansBefore - ( ( a * ( a + 1 ) ) / 2 ) - ( ( b * ( b + 1 ) ) / 2 ) + ( ( a + b + 1 ) * ( a + b + 2 ) ) / 2 ) ;\n    ans = max ( ans , currAns ) ;\n  }\n  return ans ;\n}\n", "reference_code": "    long long maxAlternatingSubstring(int N, string S) {\n        vector<long long> diff;\n        for (int i = 0; i < N;) {\n            int j = i + 1;\n            while (j < N && S[j] != S[j - 1])\n                j++;\n            diff.push_back(j - i);\n            i = j;\n        }\n        diff.push_back(0);\n        long long ans_before = 0;\n        for (long long x : diff) {\n            ans_before += ((x * (x + 1)) / 2);\n        }\n        long long ans = 0;\n        for (int i = 0; i < diff.size() - 1; ++i) {\n            long long a = diff[i];\n            long long b = diff[i + 1];\n            long long currAns = ans_before - ((a * (a + 1)) / 2) - ((b * (b + 1)) / 2) +\n                                ((a + b + 1) * (a + b + 2)) / 2;\n            ans = max(ans, currAns);\n        }\n        return ans;\n    }", "target_Lan": "cpp###maxAlternatingSubstring.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\nusing namespace std;\n#include <iostream>\n// TOFILL\nint main() {\n    cout << maxAlternatingSubstring(0, \"\") << endl;\n    cout << maxAlternatingSubstring(1, \"a\") << endl;\n    cout << maxAlternatingSubstring(2, \"ab\") << endl;\n    cout << maxAlternatingSubstring(3, \"aba\") << endl;\n    cout << maxAlternatingSubstring(4, \"abab\") << endl;\n}"}, {"source_Lan": "python###canTrade.py", "source_code": "def canTrade( n: int, beautifulness: List[int], q: int,\n             queries: List[List[int]]) -> List[int]:\n    par = [i for i in range(n)]\n    for i in range(1, n):\n        if beautifulness[i] == beautifulness[i - 1]:\n            par[i] = par[i - 1]\n        else:\n            pass\n    ans = []\n    for el in queries:\n        a, b = el[0] - 1, el[1] - 1\n        if par[a] == par[b]:\n            ans.append(1)\n        else:\n            ans.append(0)\n    return ans", "trans_code": "public : vector < int > canTrade ( int n , vector < int > & beautifulness , int q , vector < vector < int >> & queries ) throw ( ) {\n  vector < int > par ( n ) ;\n  for ( int i = 1 ;\n  i < n ;\n  i ++ ) {\n    if ( beautifulness [ i ] == beautifulness [ i - 1 ] ) {\n      par [ i ] = par [ i - 1 ] ;\n    }\n    else {\n    }\n  }\n  vector < int > ans ;\n  for ( vector < int > :: iterator el = queries . begin ( ) ;\n  el != queries . end ( ) ;\n  el ++ ) {\n    int a = el -> first - 1 , b = el -> second - 1 ;\n    if ( par [ a ] == par [ b ] ) {\n      ans . push_back ( 1 ) ;\n    }\n    else {\n      ans . push_back ( 0 ) ;\n    }\n  }\n  return ans ;\n}\n", "reference_code": "    vector<int> canTrade(int n, vector<int>& beautifulness, int q,\n                         vector<vector<int>>& queries) {\n        int prev = beautifulness[0];\n        beautifulness[0] = 0;\n        for (int i = 1; i < n; i++) {\n            int curr = beautifulness[i];\n            if (beautifulness[i] == prev)\n                beautifulness[i] = beautifulness[i - 1];\n            else\n                beautifulness[i] = i;\n            prev = curr;\n        }\n        vector<int> ans(q);\n        for (int i = 0; i < q; i++) {\n            int u = queries[i][0], v = queries[i][1];\n            u--;\n            v--;\n            if (beautifulness[v] <= u)\n                ans[i] = 1;\n        }\n        return ans;\n    }", "target_Lan": "cpp###canTrade.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// TOFILL\nint main() {\n    vector<int> beautifulness1 = {1, 2, 3, 2, 1};\n    vector<vector<int>> queries1 = {{1, 2}, {2, 3}, {3, 4}};\n    int n1 = 5, q1 = 3;\n    vector<int> result1 = canTrade(n1, beautifulness1, q1, queries1);\n    for(int i = 0; i < result1.size(); i++) {\n        cout << result1[i] << \" \";\n    }\n    cout << endl;\n\n    vector<int> beautifulness2 = {10, 9, 8, 7, 6, 5, 4, 3, 2, 1};\n    vector<vector<int>> queries2 = {{1, 2}, {2, 3}, {3, 4}, {4, 5}, {5, 6}};\n    int n2 = 10, q2 = 5;\n    vector<int> result2 = canTrade(n2, beautifulness2, q2, queries2);\n    for(int i = 0; i < result2.size(); i++) {\n        cout << result2[i] << \" \";\n    }\n    cout << endl;\n\n    vector<int> beautifulness3 = {1, 1, 1};\n    vector<vector<int>> queries3 = {{1, 2}, {2, 3}};\n    int n3 = 3, q3 = 2;\n    vector<int> result3 = canTrade(n3, beautifulness3, q3, queries3);\n    for(int i = 0; i < result3.size(); i++) {\n        cout << result3[i] << \" \";\n    }\n    cout << endl;\n\n    vector<int> beautifulness4 = {1, 2, 3, 4};\n    vector<vector<int>> queries4 = {{1, 2}};\n    int n4 = 4, q4 = 1;\n    vector<int> result4 = canTrade(n4, beautifulness4, q4, queries4);\n    for(int i = 0; i < result4.size(); i++) {\n        cout << result4[i] << \" \";\n    }\n    cout << endl;\n\n    vector<int> beautifulness5 = {1, 2, 3, 3, 2, 1};\n    vector<vector<int>> queries5 = {{1, 2}, {2, 3}, {3, 4}, {4, 5}};\n    int n5 = 6, q5 = 4;\n    vector<int> result5 = canTrade(n5, beautifulness5, q5, queries5);\n    for(int i = 0; i < result5.size(); i++) {\n        cout << result5[i] << \" \";\n    }\n    cout << endl;\n}"}, {"source_Lan": "python###countCompleteDayPairs.py", "source_code": "def countCompleteDayPairs( hours: List[int]) -> int:\n    ans = 0\n    cnt = [0] * 24\n    for t in hours:\n        \n        \n        ans += cnt[(24 - t % 24) % 24]\n        cnt[t % 24] += 1\n    return ans", "trans_code": "int countCompleteDayPairs ( vector < int > hours ) throw ( ) {\n  int ans = 0 ;\n  int cnt [ 24 ] = {\n    0 }\n    ;\n    for ( int t = 0 ;\n    t < hours . size ( ) ;\n    t ++ ) {\n      ans += cnt [ ( 24 - t % 24 ) % 24 ] ;\n      cnt [ t % 24 ] ++ ;\n    }\n    return ans ;\n  }\n  ", "reference_code": "    long long countCompleteDayPairs(vector<int> &hours) {\n        long long ans = 0;\n        int cnt[24]{};\n        for (int t : hours) {\n            \n            \n            ans += cnt[(24 - t % 24) % 24];\n            cnt[t % 24]++;\n        }\n        return ans;\n    }", "target_Lan": "cpp###countCompleteDayPairs.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    vector<int> hours1 = {0, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1};\n    vector<int> hours2 = {23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23};\n    vector<int> hours3 = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n    vector<int> hours4 = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23};\n    vector<int> hours5 = {2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22};\n\n    cout << countCompleteDayPairs(hours1) << endl;\n    cout << countCompleteDayPairs(hours2) << endl;\n    cout << countCompleteDayPairs(hours3) << endl;\n    cout << countCompleteDayPairs(hours4) << endl;\n    cout << countCompleteDayPairs(hours5) << endl;\n}"}, {"source_Lan": "python###sumOfEncryptedInt.py", "source_code": "def sumOfEncryptedInt( nums: List[int]) -> int:\n    ans = 0\n    for x in nums:\n        mx = base = 0\n        while x:\n            x, d = divmod(x, 10)\n            mx = max(mx, d)\n            base = base * 10 + 1\n        ans += mx * base\n    return ans", "trans_code": "public : int sumOfEncryptedInt ( vector < int > & nums ) throw ( ) {\n  int ans = 0 ;\n  for ( auto x : nums ) {\n    int mx = base = 0 ;\n    while ( x ) {\n      x = x / 10 ;\n      int d = x % 10 ;\n      mx = max ( mx , d ) ;\n      base = base * 10 + 1 ;\n    }\n    ans += mx * base ;\n  }\n  return ans ;\n}\n", "reference_code": "    int sumOfEncryptedInt(vector<int> &nums) {\n        int ans = 0;\n        for (int x: nums) {\n            int mx = 0, base = 0;\n            for (; x; x /= 10) {\n                mx = max(mx, x % 10);\n                base = base * 10 + 1;\n            }\n            ans += mx * base;\n        }\n        return ans;\n    }", "target_Lan": "cpp###sumOfEncryptedInt.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    vector<int> nums1 = {1, 2, 3, 4, 5};\n    vector<int> nums2 = {10, 20, 30, 40, 50};\n    vector<int> nums3 = {100, 200, 300, 400, 500};\n    vector<int> nums4 = {1000, 2000, 3000, 4000, 5000};\n    vector<int> nums5 = {10000, 20000, 30000, 40000, 50000};\n\n    cout << sumOfEncryptedInt(nums1) << endl;\n    cout << sumOfEncryptedInt(nums2) << endl;\n    cout << sumOfEncryptedInt(nums3) << endl;\n    cout << sumOfEncryptedInt(nums4) << endl;\n    cout << sumOfEncryptedInt(nums5) << endl;\n\n    return 0;\n}"}, {"source_Lan": "python###satisfiesConditions.py", "source_code": "def satisfiesConditions( grid: List[List[int]]) -> bool:\n    for i, row in enumerate(grid):\n        for j, x in enumerate(row):\n            if j and x == row[j - 1] or i and x != grid[i - 1][j]:\n                return False\n    return True", "trans_code": "bool satisfiesConditions ( std :: vector < std :: vector < int >> & grid ) throw ( ) {\n  for ( int i = 0 , n = grid . size ( ) ;\n  i < n ;\n  ++ i ) {\n    for ( int j = 0 , x = grid [ i ] . size ( ) ;\n    j < n ;\n    ++ j ) {\n      if ( j && x == grid [ i - 1 ] [ j ] || i && x != grid [ i - 1 ] [ j ] ) {\n        return false ;\n      }\n    }\n  }\n  return true ;\n}\n", "reference_code": "    bool satisfiesConditions(vector<vector<int>>& grid) {\n        for (int i = 0; i < grid.size(); i++) {\n            for (int j = 0; j < grid[i].size(); j++) {\n                if (j && grid[i][j] == grid[i][j - 1] || i && grid[i][j] != grid[i - 1][j]) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }", "target_Lan": "cpp###satisfiesConditions.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// TOFILL\nint main() {\n    vector<vector<int>> input1 = {{1, 1, 1}, {1, 1, 1}, {1, 1, 1}};\n    vector<vector<int>> input2 = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};\n    vector<vector<int>> input3 = {{1, 1, 1}, {2, 2, 2}, {3, 3, 3}};\n    vector<vector<int>> input4 = {{1, 2, 3}, {1, 2, 3}, {1, 2, 3}};\n    vector<vector<int>> input5 = {{1, 2, 3, 4}, {1, 2, 3, 4}, {1, 2, 3, 4}};\n\n    cout << satisfiesConditions(input1) << endl;\n    cout << satisfiesConditions(input2) << endl;\n    cout << satisfiesConditions(input3) << endl;\n    cout << satisfiesConditions(input4) << endl;\n    cout << satisfiesConditions(input5) << endl;\n}"}, {"source_Lan": "python###modifiedMatrix.py", "source_code": "def modifiedMatrix( matrix: List[List[int]]) -> List[List[int]]:\n    n, m = len(matrix), len(matrix[0])\n    for j in range(m):\n        zd = -1\n        for i in range(n):\n            zd = max(zd, matrix[i][j])\n        for i in range(n):\n            if matrix[i][j] == -1:\n                matrix[i][j] = zd\n    return matrix", "trans_code": "void modifiedMatrix ( vector < vector < int >> & matrix ) throw ( ) {\n  int n = matrix . size ( ) ;\n  int m = matrix [ 0 ] . size ( ) ;\n  for ( int j = 0 ;\n  j < m ;\n  j ++ ) {\n    int zd = - 1 ;\n    for ( int i = 0 ;\n    i < n ;\n    i ++ ) zd = max ( zd , matrix [ i ] [ j ] ) ;\n    for ( int i = 0 ;\n    i < n ;\n    i ++ ) if ( matrix [ i ] [ j ] == - 1 ) matrix [ i ] [ j ] = zd ;\n  }\n}\n", "reference_code": "    vector<vector<int>> modifiedMatrix(vector<vector<int>>& matrix) {\n        int n = matrix.size();\n        int m = matrix[0].size();\n        for (int j = 0; j < m; j++) {\n            int zd = -1;\n            for (int i = 0; i < n; i++) {\n                zd = max(zd, matrix[i][j]);\n            }\n            for (int i = 0; i < n; i++) {\n                if (matrix[i][j] == -1) {\n                    matrix[i][j] = zd;\n                }\n            }\n        }\n        return matrix;\n    }", "target_Lan": "cpp###modifiedMatrix.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    vector<vector<int>> input1 = {{1,2,3},{4,5,6},{7,8,9}};\n    vector<vector<int>> input2 = {{0,0,0},{0,0,0},{0,0,0}};\n    vector<vector<int>> input3 = {{-1,-2,-3},{-4,-5,-6},{-7,-8,-9}};\n    vector<vector<int>> input4 = {{10,20,30},{40,50,60},{70,80,90}};\n    vector<vector<int>> input5 = {{100,200,300},{400,500,600},{700,800,900}};\n\n    vector<vector<int>> output1 = modifiedMatrix(input1);\n    vector<vector<int>> output2 = modifiedMatrix(input2);\n    vector<vector<int>> output3 = modifiedMatrix(input3);\n    vector<vector<int>> output4 = modifiedMatrix(input4);\n    vector<vector<int>> output5 = modifiedMatrix(input5);\n\n    for(int i = 0; i < output1.size(); i++) {\n        for(int j = 0; j < output1[i].size(); j++) {\n            cout << output1[i][j] << \" \";\n        }\n        cout << endl;\n    }\n\n    for(int i = 0; i < output2.size(); i++) {\n        for(int j = 0; j < output2[i].size(); j++) {\n            cout << output2[i][j] << \" \";\n        }\n        cout << endl;\n    }\n\n    for(int i = 0; i < output3.size(); i++) {\n        for(int j = 0; j < output3[i].size(); j++) {\n            cout << output3[i][j] << \" \";\n        }\n        cout << endl;\n    }\n\n    for(int i = 0; i < output4.size(); i++) {\n        for(int j = 0; j < output4[i].size(); j++) {\n            cout << output4[i][j] << \" \";\n        }\n        cout << endl;\n    }\n\n    for(int i = 0; i < output5.size(); i++) {\n        for(int j = 0; j < output5[i].size(); j++) {\n            cout << output5[i][j] << \" \";\n        }\n        cout << endl;\n    }\n\n    return 0;\n}"}, {"source_Lan": "python###maximumPrimeDifference.py", "source_code": "def maximumPrimeDifference( nums: List[int]) -> int:\n    primes = {\n        2, 3, 5, 7, 11,\n        13, 17, 19, 23, 29,\n        31, 37, 41, 43, 47,\n        53, 59, 61, 67, 71,\n        73, 79, 83, 89, 97\n    }\n    first, ans = -1, 0\n    for i, num in enumerate(nums):\n        if num in primes:\n            if first != -1:\n                ans = max(ans, i - first)\n            else:\n                first = i\n    return ans", "trans_code": "public : int maximumPrimeDifference ( vector < int > & nums ) -> int {\n  int primes [ ] = {\n    2 , 3 , 5 , 7 , 11 , 13 , 17 , 19 , 23 , 29 , 31 , 37 , 41 , 43 , 47 , 53 , 59 , 61 , 67 , 71 , 73 , 79 , 83 , 89 , 97 }\n    ;\n    int first = - 1 , ans = 0 ;\n    for ( int i = 0 , num = nums . size ( ) ;\n    i < num ;\n    i ++ ) {\n      if ( nums [ i ] == primes [ i ] ) {\n        if ( first != - 1 ) {\n          ans = max ( ans , i - first ) ;\n        }\n        else {\n          first = i ;\n        }\n      }\n    }\n    return ans ;\n  }\n  ", "reference_code": "    int maximumPrimeDifference(vector<int>& nums) {\n        unordered_set<int> primes = {\n            2, 3, 5, 7, 11,\n            13, 17, 19, 23, 29,\n            31, 37, 41, 43, 47,\n            53, 59, 61, 67, 71,\n            73, 79, 83, 89, 97\n        };\n        int n = nums.size();\n        int first = -1, ans = 0;\n        for (int i = 0; i < n; ++i) {\n            if (primes.count(nums[i])) {\n                if (first != -1) {\n                    ans = max(ans, i - first);\n                }\n                else {\n                    first = i;\n                }\n            }\n        }\n        return ans;\n    }", "target_Lan": "cpp###maximumPrimeDifference.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <unordered_set>\n// TOFILL\nint main() {\n    vector<int> nums1 = {2, 3, 5, 7, 11};\n    vector<int> nums2 = {10, 11, 13, 17, 19};\n    vector<int> nums3 = {4, 6, 8, 10, 12};\n    vector<int> nums4 = {100, 101, 103, 107, 109};\n    vector<int> nums5 = {200, 201, 203, 207, 209};\n\n    cout << maximumPrimeDifference(nums1) << endl;\n    cout << maximumPrimeDifference(nums2) << endl;\n    cout << maximumPrimeDifference(nums3) << endl;\n    cout << maximumPrimeDifference(nums4) << endl;\n    cout << maximumPrimeDifference(nums5) << endl;\n}"}, {"source_Lan": "python###findMaximumElegance.py", "source_code": "def findMaximumElegance( items: List[List[int]], k: int) -> int:\n    items.sort(key = lambda item: -item[0])\n    categorySet = set()\n    res, profit = 0, 0\n    st = []\n    for i, item in enumerate(items):\n        if i < k:\n            profit += item[0]\n            if item[1] in categorySet:\n                st.append(item[0])\n            else:\n                categorySet.add(item[1])\n        elif item[1] not in categorySet and len(st) > 0:\n            profit += item[0] - st.pop()\n            categorySet.add(item[1])\n        res = max(res, profit + len(categorySet) * len(categorySet))\n    return res", "trans_code": "public : int findMaximumElegance ( vector < vector < int >> & items , int k ) throw ( ) {\n  sort ( items . begin ( ) , items . end ( ) ) ;\n  set < int > categorySet ;\n  int res = 0 , profit = 0 ;\n  vector < int > st ;\n  for ( int i = 0 , n = items . size ( ) ;\n  i < n ;\n  ++ i ) {\n    if ( i < k ) {\n      profit += items [ i ] [ 0 ] ;\n      if ( items [ i ] [ 1 ] < categorySet ) st . push_back ( items [ i ] [ 0 ] ) ;\n      else categorySet . insert ( items [ i ] [ 1 ] ) ;\n    }\n    else if ( items [ i ] [ 1 ] != categorySet && st . size ( ) > 0 ) {\n      profit += items [ i ] [ 0 ] - st . back ( ) ;\n      categorySet . insert ( items [ i ] [ 1 ] ) ;\n    }\n    res = max ( res , profit + categorySet . size ( ) * categorySet . size ( ) ) ;\n  }\n  return res ;\n}\n", "reference_code": "    long long findMaximumElegance(vector<vector<int>>& items, int k) {\n        sort(items.begin(), items.end(), [&](const vector<int> &item1, const vector<int> &item2) -> bool {\n            return item1[0] > item2[0];\n        });\n        unordered_set<int> categorySet;\n        long long res = 0, profit = 0;\n        stack<int> st;\n        for (int i = 0; i < items.size(); i++) {\n            if (i < k) {\n                profit += items[i][0];\n                if (categorySet.count(items[i][1]) == 0) {\n                    categorySet.insert(items[i][1]);\n                } else {\n                    st.push(items[i][0]);\n                }\n            } else if (categorySet.count(items[i][1]) == 0 && !st.empty()) {\n                profit += items[i][0] - st.top();\n                st.pop();\n                categorySet.insert(items[i][1]);\n            }\n            res = max(res, (long long)(profit + categorySet.size() * categorySet.size()));\n        }\n        return res;\n    }", "target_Lan": "cpp###findMaximumElegance.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <unordered_set>\n#include <stack>\n// TOFILL\nint main() {\n    vector<vector<int>> items1 = {{1,1},{2,2},{3,3},{4,4},{5,5}};\n    int k1 = 3;\n    cout << findMaximumElegance(items1, k1) << endl;\n\n    vector<vector<int>> items2 = {{1,1},{2,2},{3,3},{4,4},{5,5}};\n    int k2 = 1;\n    cout << findMaximumElegance(items2, k2) << endl;\n\n    vector<vector<int>> items3 = {{1,1},{2,2},{3,3},{4,4},{5,5}};\n    int k3 = 5;\n    cout << findMaximumElegance(items3, k3) << endl;\n\n    vector<vector<int>> items4 = {{1,1},{2,2},{3,3},{4,4},{5,5}};\n    int k4 = 0;\n    cout << findMaximumElegance(items4, k4) << endl;\n\n    vector<vector<int>> items5 = {{1,1},{2,2},{3,3},{4,4},{5,5}};\n    int k5 = 2;\n    cout << findMaximumElegance(items5, k5) << endl;\n}"}, {"source_Lan": "python###findMissingAndRepeatedValues.py", "source_code": "def findMissingAndRepeatedValues( grid: List[List[int]]) -> List[int]:\n    n = len(grid)\n    count = [0] * (n * n + 1)\n    count[0] = -1\n    for i in range(n):\n        for j in range(n):\n            count[grid[i][j]] += 1\n    return [count.index(2), count.index(0)]", "trans_code": "public : vector < int > findMissingAndRepeatedValues ( vector < vector < int >> & grid ) throw ( ) {\n  int n = grid . size ( ) ;\n  vector < int > count ( n * n + 1 ) ;\n  count [ 0 ] = - 1 ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < n ;\n    j ++ ) {\n      count [ grid [ i ] [ j ] ] ++ ;\n    }\n  }\n  return {\n    count . begin ( ) , count . end ( ) }\n    ;\n  }\n  ", "reference_code": "    vector<int> findMissingAndRepeatedValues(vector<vector<int>>& grid) {\n        int n = grid.size();\n        vector<int> count(n * n + 1);\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                count[grid[i][j]]++;\n            }\n        }\n        vector<int> res(2);\n        for (int i = 1; i <= n * n; i++) {\n            if (count[i] == 2) {\n                res[0] = i;\n            }\n            if (count[i] == 0) {\n                res[1] = i;\n            }\n        }\n        return res;\n    }", "target_Lan": "cpp###findMissingAndRepeatedValues.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    vector<vector<int>> grid = {{1, 2, 3}, {4, 5, 6}, {7, 8, 8}};\n    vector<int> result = findMissingAndRepeatedValues(grid);\n    for(int i = 0; i < result.size(); i++) {\n        cout << result[i] << \" \";\n    }\n    return 0;\n}"}, {"source_Lan": "python###MaxDiff.py", "source_code": "def MaxDiff( A: List[int], n: int) -> int:\n    \n    mx = [-1] * 1001\n    mn = [n + 1] * 1001\n    \n    for i in range(n):\n        mx[A[i]] = max(mx[A[i]], i)\n        mn[A[i]] = min(mn[A[i]], i)\n    ans = -1\n    \n    for i in range(1, 1001):\n        for j in range(i, 1001):\n            era = gcd(i, j)\n            if era != 1:\n                continue\n            if mx[i] != -1 and mx[j] != -1:\n                ans = max(ans, abs(mx[i] - mn[j]))\n                ans = max(ans, abs(mx[j] - mn[i]))\n    return ans", "trans_code": "int MaxDiff ( int A [ 1001 ] , int n ) throw ( ) {\n  int mx [ 1001 ] = {\n    - 1 }\n    ;\n    int mn [ 1001 ] = {\n      n + 1 }\n      ;\n      for ( int i = 0 ;\n      i < n ;\n      i ++ ) {\n        mx [ A [ i ] ] = max ( mx [ A [ i ] ] , i ) ;\n        mn [ A [ i ] ] = min ( mn [ A [ i ] ] , i ) ;\n      }\n      int ans = - 1 ;\n      for ( int i = 1 ;\n      i < 1001 ;\n      i ++ ) {\n        for ( int j = i ;\n        j < 1001 ;\n        j ++ ) {\n          int era = gcd ( i , j ) ;\n          if ( era != 1 ) continue ;\n          if ( mx [ i ] != - 1 && mx [ j ] != - 1 ) {\n            ans = max ( ans , abs ( mx [ i ] - mn [ j ] ) ) ;\n            ans = max ( ans , abs ( mx [ j ] - mn [ i ] ) ) ;\n          }\n        }\n      }\n      return ans ;\n    }\n    ", "reference_code": "    int MaxDiff(vector<int> &A, int n) {\n        vector<int> mx(1001, -1), mn(1001, n + 1);\n        for (int i = 0; i < n; i++) {\n            mx[A[i]] = max(mx[A[i]], i);\n            mn[A[i]] = min(mn[A[i]], i);\n        }\n        int ans = -1;\n        for (int i = 1; i <= 1000; i++) {\n            for (int j = i; j <= 1000; j++) {\n                int era = __gcd(i, j);\n                if (era != 1)\n                    continue;\n                if (mx[i] != -1 && mx[j] != -1) {\n                    ans = max(ans, abs(mx[i] - mn[j]));\n                    ans = max(ans, abs(mx[j] - mn[i]));\n                }\n            }\n        }\n        return ans;\n    }", "target_Lan": "cpp###MaxDiff.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n// TOFILL\nint main() {\n    vector<int> A1 = {1, 2, 3, 4, 5};\n    cout << MaxDiff(A1, 5) << endl;\n\n    vector<int> A2 = {1000, 1000, 1000, 1000, 1000};\n    cout << MaxDiff(A2, 5) << endl;\n\n    vector<int> A3 = {1, 1, 1, 1, 1};\n    cout << MaxDiff(A3, 5) << endl;\n\n    vector<int> A4 = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n    cout << MaxDiff(A4, 10) << endl;\n\n    vector<int> A5 = {1000, 999, 998, 997, 996, 995, 994, 993, 992, 991};\n    cout << MaxDiff(A5, 10) << endl;\n\n    return 0;\n}"}, {"source_Lan": "python###findFun.py", "source_code": "def findFun( n : int) -> int:\n    dp = [2,5,9,7]\n    if n<=3:\n        return dp[n]\n    mod = 10**9+7\n    for i in range(4,n+1):\n        if i&1==0:\n            z = dp[2]*(i-2) + dp[0]*(i-4)\n        else:\n            z = dp[3]*(i-1) + dp[1]*(i-3)\n        z = z%mod  \n        dp[0] = dp[1]\n        dp[1] = dp[2]\n        dp[2] = dp[3]\n        dp[3] = z\n    return dp[-1]", "trans_code": "int findFun ( int n ) throw ( ) {\n  static int dp [ ] = {\n    2 , 5 , 9 , 7 }\n    ;\n    if ( n <= 3 ) return dp [ n ] ;\n    int mod = 10 * 9 + 7 ;\n    for ( int i = 4 ;\n    i <= n ;\n    i ++ ) {\n      if ( i & 1 == 0 ) {\n        int z = dp [ 2 ] * ( i - 2 ) + dp [ 0 ] * ( i - 4 ) ;\n        if ( z != 0 ) {\n          dp [ 0 ] = dp [ 1 ] ;\n          dp [ 1 ] = dp [ 2 ] ;\n          dp [ 2 ] = dp [ 3 ] ;\n          dp [ 3 ] = z ;\n        }\n      }\n    }\n    return dp [ n - 1 ] ;\n  }\n  ", "reference_code": "    int findFun(int n){\n        int mod=1000000007;\n        vector<long long>dp={2,5,9,7};\n        if (n<=3) return dp[n];\n        long long p1=2;\n        long long p2=5;\n        long long p3=9;\n        long long p4=7;\n        for (int i=4;i<=n;i++){\n            if (i%2==0){\n                int a=(p3*(i-2))%mod;\n                int b=(p1*(i-4))%mod;\n                int ele=(a+b)%mod;\n                p1=p2;\n                p2=p3;\n                p3=p4;\n                p4=ele;\n            }\n            else{\n                int a=(p4*(i-1))%mod;\n                int b=(p2*(i-3))%mod;\n                int ele=(a+b)%mod;\n                p1=p2;\n                p2=p3;\n                p3=p4;\n                p4=ele;\n            }\n        }\n        return p4;\n    }", "target_Lan": "cpp###findFun.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    cout << findFun(0) << endl;\n    cout << findFun(1) << endl;\n    cout << findFun(2) << endl;\n    cout << findFun(3) << endl;\n    cout << findFun(10) << endl;\n}"}, {"source_Lan": "python###CompatibleStrings.py", "source_code": "def CompatibleStrings( N : int, A1 : List[str], A2 : List[str]) -> List[int]:\n    ans = [0]*N\n    for i in range(N):\n        s1 = A1[i]\n        s2 = A2[i]\n        if len(s1)!=len(s2):\n            continue\n        mp1 = Counter(s1)\n        mp2 = Counter(s2)\n        f = True\n        c2 = 0\n        c3 = 0\n        g = 0\n        r = 0\n        for c in range(97,123):\n            c = chr(c)\n            if mp1[c]==mp2[c]:\n                continue\n            d = abs(mp1[c]-mp2[c])\n            if mp2[c]>mp1[c]:\n                if r<d:\n                    f = False\n                    break\n                else:\n                    r-=d\n            else:\n                r += d\n            g = gcd(g,d)\n            if g==1:\n                f = False\n                break\n        if f:\n            ans[i] = 1\n    return ans", "trans_code": "public : vector < int > CompatibleStrings ( int N , vector < string > A1 , vector < string > A2 ) throw ( ) {\n  vector < int > ans ( N , 0 ) ;\n  for ( int i = 0 ;\n  i < N ;\n  i ++ ) {\n    string s1 = A1 [ i ] ;\n    string s2 = A2 [ i ] ;\n    if ( s1 . size ( ) != s2 . size ( ) ) continue ;\n    Counter mp1 ( s1 ) ;\n    Counter mp2 ( s2 ) ;\n    bool f = true ;\n    int c2 = 0 ;\n    int c3 = 0 ;\n    int g = 0 ;\n    int r = 0 ;\n    for ( int c = 97 ;\n    c <= 123 ;\n    c ++ ) {\n      c = toupper ( c ) ;\n      if ( mp1 [ c ] == mp2 [ c ] ) continue ;\n      int d = abs ( mp1 [ c ] - mp2 [ c ] ) ;\n      if ( mp2 [ c ] > mp1 [ c ] ) {\n        if ( r < d ) {\n          f = false ;\n          break ;\n        }\n        else r -= d ;\n      }\n      else r += d ;\n      g = gcd ( g , d ) ;\n      if ( g == 1 ) {\n        f = false ;\n        break ;\n      }\n    }\n    if ( f ) ans [ i ] = 1 ;\n  }\n  return ans ;\n}\n", "reference_code": "    vector<int> CompatibleStrings(int N, vector<string> &A1, vector<string> &A2) {\n        \n        \n        \n        vector<int> ans(N);\n        for(int j=0;j<N;j++){\n            vector<int> v1(26),v2(26);\n            for(auto i:A1[j]){\n                v1[i-'a']++;\n            }\n            for(auto i:A2[j]){\n                v2[i-'a']++;\n            }\n            vector<int> temp;\n            int p = 0;\n            int l = 0;\n            while(l<25){\n                p+=v1[l];\n                if(p<v2[l]){\n                    break;\n                }\n                else{\n                    p-=v2[l];\n                }\n                if(p!=0)\n                temp.push_back(p);\n                l++;\n            }\n            if(l!=25) ans[j]=0;\n            else if(p+v1[l]!=v2[l]) ans[j]=0;\n            else{\n                if(temp.size()==0){\n                    ans[j] = 1;\n                    continue;\n                }\n                int x = temp[0];\n                for(auto i:temp){\n                    x = __gcd(i,x);\n                }\n                if(x==1){\n                    ans[j] = 0;\n                }\n                else{\n                    ans[j] = 1;\n                }\n            }\n        }\n        return ans;\n    }", "target_Lan": "cpp###CompatibleStrings.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n// TOFILL\nint main() {\n    int N = 3;\n    vector<string> A1 = {\"abc\", \"def\", \"ghi\"};\n    vector<string> A2 = {\"abc\", \"def\", \"ghi\"};\n    vector<int> ans = CompatibleStrings(N, A1, A2);\n    for(int i=0; i<ans.size(); i++) {\n        cout << ans[i] << \" \";\n    }\n    cout << endl;\n\n    A2 = {\"abc\", \"def\", \"jkl\"};\n    ans = CompatibleStrings(N, A1, A2);\n    for(int i=0; i<ans.size(); i++) {\n        cout << ans[i] << \" \";\n    }\n    cout << endl;\n\n    A2 = {\"abc\", \"def\", \"gh\"};\n    ans = CompatibleStrings(N, A1, A2);\n    for(int i=0; i<ans.size(); i++) {\n        cout << ans[i] << \" \";\n    }\n    cout << endl;\n\n    A2 = {\"abc\", \"def\", \"ghij\"};\n    ans = CompatibleStrings(N, A1, A2);\n    for(int i=0; i<ans.size(); i++) {\n        cout << ans[i] << \" \";\n    }\n    cout << endl;\n\n    A2 = {\"abc\", \"def\", \"ghi\"};\n    ans = CompatibleStrings(N, A1, A2);\n    for(int i=0; i<ans.size(); i++) {\n        cout << ans[i] << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}"}, {"source_Lan": "python###collectingCoins.py", "source_code": "def collectingCoins( N: int, Coins: List[List[int]]) -> int:\n    \n    hor = defaultdict(int)\n    ver = defaultdict(int)\n    diaa = defaultdict(int)\n    diab = defaultdict(int)\n    \n    m = 0\n    \n    for el in Coins:\n        a, b = el[0], el[1]\n        \n        hor[a] += 1\n        ver[b] += 1\n        diaa[a + b] += 1\n        diab[a - b] += 1\n        \n        m = max(m, hor[a], ver[b], diaa[a + b], diab[a - b])\n    \n    return m", "trans_code": "int collectingCoins ( int N , vector < vector < int >> & Coins ) throw ( ) {\n  map < int , int > hor ;\n  map < int , int > ver ;\n  map < int , int > diaa ;\n  map < int , int > diab ;\n  int m = 0 ;\n  for ( auto & el : Coins ) {\n    int a = el [ 0 ] , b = el [ 1 ] ;\n    hor [ a ] ++ ;\n    ver [ b ] ++ ;\n    diaa [ a + b ] ++ ;\n    diab [ a - b ] ++ ;\n    m = max ( m , hor [ a ] , ver [ b ] , diaa [ a + b ] , diab [ a - b ] ) ;\n  }\n  return m ;\n}\n", "reference_code": "    int collectingCoins(int N, std::vector<std::vector<int>>& Coins)\n    {\n        \n        \n        unordered_map<int, int> hor,ver,diaa,diab;\n        int m = 0;\n        \n        for (auto& el : Coins)\n        {\n            \n            int a = el[0];\n            int b = el[1];\n            \n            \n            hor[a]++;\n            ver[b]++;\n            diaa[a + b]++;\n            diab[a - b]++;\n            \n            m = max(m, hor[a]);\n            m = max(m, ver[b]);\n            m = max(m, diaa[a + b]);\n            m = max(m, diab[a - b]);\n        }\n        \n        return m;\n    }", "target_Lan": "cpp###collectingCoins.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <algorithm>\n// TOFILL\nint main() {\n    vector<vector<int>> Coins1 = {};\n    cout << collectingCoins(0, Coins1) << endl;\n    \n    vector<vector<int>> Coins2 = {{1,2}};\n    cout << collectingCoins(1, Coins2) << endl;\n    \n    vector<vector<int>> Coins3 = {{1,2},{2,3}};\n    cout << collectingCoins(2, Coins3) << endl;\n    \n    vector<vector<int>> Coins4 = {{1,2},{2,3},{3,4}};\n    cout << collectingCoins(3, Coins4) << endl;\n    \n    vector<vector<int>> Coins5 = {{1,2},{2,3},{3,4},{4,5}};\n    cout << collectingCoins(4, Coins5) << endl;\n    \n    return 0;\n}"}, {"source_Lan": "python###ForYou.py", "source_code": "def ForYou( n : int, arr : List[int], m : int, order : List[List[int]]) -> int:\n    diff = [0] * (n + 1)\n    for it in order:\n        diff[it[0] - 1] += 1\n        diff[it[1]] -= 1\n    for i in range(1, n):\n        diff[i] += diff[i - 1]\n    diff.pop()\n    diff.sort()\n    arr.sort()\n    ans = 0\n    mod = int(1e9) + 7\n    for i in range(n):\n        ans += diff[i] * arr[i]\n        ans %= mod\n    return ans", "trans_code": "int ForYou ( int n , std :: vector < int > arr , int m , std :: vector < std :: vector < int >> order ) throw ( ) {\n  std :: vector < int > diff ( n + 1 , 0 ) ;\n  for ( auto it : order ) {\n    diff [ it . first - 1 ] ++ ;\n    diff [ it . second ] -- ;\n  }\n  for ( int i = 1 ;\n  i < n ;\n  ++ i ) diff [ i ] += diff [ i - 1 ] ;\n  diff . pop_back ( ) ;\n  std :: sort ( diff . begin ( ) , diff . end ( ) ) ;\n  std :: sort ( arr . begin ( ) , arr . end ( ) ) ;\n  int ans = 0 ;\n  int mod = static_cast < int > ( 1e9 ) + 7 ;\n  for ( int i = 0 ;\n  i < n ;\n  ++ i ) {\n    ans += diff [ i ] * arr [ i ] ;\n    ans %= mod ;\n  }\n  return ans ;\n}\n", "reference_code": "    long long ForYou(int n, vector<int> &arr, int m, vector<vector<int> > &order)\n    {\n        vector<int> diff(n+1,0);\n        for(auto it:order)\n        {\n            diff[it[0]-1]++;\n            diff[it[1]]--;\n        }\n        for(int i=1;i<=n;i++)\n        {\n            diff[i] += diff[i-1];\n        }\n        diff.pop_back();\n        sort(diff.begin(),diff.end());\n        sort(arr.begin(),arr.end());\n        long long ans=0;\n        int mod = 1e9+7;\n        for(int i=0;i<n;i++)\n        {\n            ans += (1ll * diff[i]) * (1ll * arr[i]);\n            ans%=mod;\n        }\n        return ans;\n    }", "target_Lan": "cpp###ForYou.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <algorithm>\n// TOFILL\nint main() {\n    int n1 = 5, m1 = 3;\n    vector<int> arr1 = {1, 2, 3, 4, 5};\n    vector<vector<int> > order1 = {{1, 3}, {2, 4}, {1, 5}};\n    cout << ForYou(n1, arr1, m1, order1) << endl;\n\n    int n2 = 4, m2 = 2;\n    vector<int> arr2 = {10, 20, 30, 40};\n    vector<vector<int> > order2 = {{1, 2}, {3, 4}};\n    cout << ForYou(n2, arr2, m2, order2) << endl;\n\n    int n3 = 3, m3 = 1;\n    vector<int> arr3 = {100, 200, 300};\n    vector<vector<int> > order3 = {{1, 3}};\n    cout << ForYou(n3, arr3, m3, order3) << endl;\n\n    int n4 = 2, m4 = 0;\n    vector<int> arr4 = {50, 100};\n    vector<vector<int> > order4 = {};\n    cout << ForYou(n4, arr4, m4, order4) << endl;\n\n    int n5 = 1, m5 = 0;\n    vector<int> arr5 = {1000};\n    vector<vector<int> > order5 = {};\n    cout << ForYou(n5, arr5, m5, order5) << endl;\n\n    return 0;\n}"}, {"source_Lan": "python###createString.py", "source_code": "def createString( n : int, k : int, s : str) -> str:\n    c=Counter(s)\n    t=[(c[el],el) for el in c]\n    t.sort(key=lambda x:(x[1]))\n    ans=\"\"\n    while t:\n        ca,cb=t.pop()\n        if ca>k:\n            ca-=k\n            ans+=cb*k\n            if len(t)==0:\n                return ans\n            else:\n                da,db=t.pop()\n                if da>1:\n                    ans+=db\n                    t.append((da-1,db))\n                else:\n                    ans+=db\n            t.append((ca,cb))\n        else:\n            ans+=cb*ca\n    return ans", "trans_code": "string createString ( int n , int k , string s ) throw ( ) {\n  Counter c ( s ) ;\n  std :: vector < std :: pair < int , int >> t ( n ) ;\n  std :: sort ( t . begin ( ) , t . end ( ) , [ & c ] ( int el ) {\n    return ( el > k ) ;\n  }\n  ) ;\n  string ans = \"\" ;\n  while ( t . size ( ) > 0 ) {\n    int ca = t . back ( ) . first ;\n    int cb = t . back ( ) . second ;\n    if ( ca > k ) {\n      ca -= k ;\n      ans += cb * k ;\n      if ( t . size ( ) == 0 ) {\n        return ans ;\n      }\n      else {\n        int da = t . back ( ) . first ;\n        int db = t . back ( ) . second ;\n        if ( da > 1 ) {\n          ans += db ;\n          t . pop_back ( ) ;\n        }\n        else {\n          ans += db ;\n        }\n      }\n      t . pop_back ( ) ;\n    }\n    else {\n      ans += cb * ca ;\n    }\n  }\n  return ans ;\n}\n", "reference_code": "    string createString(int n, int k, string s) {\n        string answer = \"\";\n        unordered_map<char, int> m;\n        for(auto i : s){\n            m[i] += 1;\n        }\n        set<pair<char, int>> st;\n        for(auto i : m){\n            st.insert({i.first, i.second});\n        }\n        int curr = 0;\n        while(st.size()){\n            auto largest = st.end();\n            largest--;\n            if(curr == k){\n                if(st.size() == 1){\n                    break;\n                }else{\n                    largest--;\n                }\n                curr = -1;\n            }\n            char now = largest->first;\n            int count = largest->second;\n            st.erase({now, count});\n            count -= 1;\n            if(count){\n                st.insert({now, count});\n                curr += 1;\n            }else{\n                curr = 0;\n            }\n            answer += now;\n        }\n        return answer;\n    }", "target_Lan": "cpp###createString.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <set>\n// TOFILL\nint main() {\n    cout << createString(5, 2, \"abcde\") << endl;\n    cout << createString(10, 3, \"aaabbbccc\") << endl;\n    cout << createString(7, 1, \"abcdefg\") << endl;\n    cout << createString(10, 4, \"aabbccddee\") << endl;\n    cout << createString(5, 1, \"aaaaa\") << endl;\n}"}, {"source_Lan": "python###maximumBattalions.py", "source_code": "def maximumBattalions( N : int, names : List[str]) -> int:\n    d={}\n    for i in range(N):\n        if names[i] not in d:\n            d[names[i]]=[]\n        d[names[i]].append(i)\n    seen=set()\n    ans=0\n    for i in range(N):\n        if names[i] not in seen:\n            seen.add(names[i])\n        if d[names[i]][-1]==i:\n            seen.remove(names[i])\n        if len(seen)==0:\n            ans+=1\n    return ans", "trans_code": "public : int maximumBattalions ( int N , vector < string > names ) throw ( ) {\n  map < string , vector < int >> map ;\n  for ( int i = 0 ;\n  i < N ;\n  i ++ ) {\n    if ( names [ i ] != \"\" ) map [ names [ i ] ] . push_back ( i ) ;\n    map [ names [ i ] ] . push_back ( i ) ;\n  }\n  set < int > seen ;\n  int ans = 0 ;\n  for ( int i = 0 ;\n  i < N ;\n  i ++ ) {\n    if ( names [ i ] != \"\" ) seen . insert ( names [ i ] ) ;\n    if ( map [ names [ i ] ] . back ( ) == i ) seen . erase ( names [ i ] ) ;\n    if ( seen . size ( ) == 0 ) ans ++ ;\n  }\n  return ans ;\n}\n", "reference_code": "    int maximumBattalions(int N, vector<string> &names) {\n        unordered_map<string, int> m;\n        for(int i = 0; i < N; i++){\n            m[names[i]] = i;\n        }\n        int answer = 0;\n        int maxi = 0;\n        int ind = 0;\n        for(auto i : names){\n            maxi = max(maxi, m[i]);\n            if(maxi == ind){\n                answer += 1;\n            }\n            ind += 1;\n        }\n        return answer;\n    }", "target_Lan": "cpp###maximumBattalions.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <string>\n// TOFILL\nint main() {\n    vector<string> names1 = {};\n    cout << maximumBattalions(0, names1) << endl;\n\n    vector<string> names2 = {\"John\"};\n    cout << maximumBattalions(1, names2) << endl;\n\n    vector<string> names3 = {\"John\", \"John\"};\n    cout << maximumBattalions(2, names3) << endl;\n\n    vector<string> names4 = {\"John\", \"John\", \"Doe\"};\n    cout << maximumBattalions(3, names4) << endl;\n\n    vector<string> names5 = {\"John\", \"Doe\", \"John\", \"Doe\"};\n    cout << maximumBattalions(4, names5) << endl;\n\n    return 0;\n}"}, {"source_Lan": "python###minimumDis.py", "source_code": "def minimumDis( N: int, X: List[int]) -> int:\n    X.sort()\n    return X[(N - 1) // 2]", "trans_code": "int minimumDis ( int N , vector < int > & X ) throw ( ) {\n  sort ( X . begin ( ) , X . end ( ) ) ;\n  return X [ ( N - 1 ) / 2 ] ;\n}\n", "reference_code": "    int minimumDis(int N, vector<int> X) {\n        sort(X.begin(), X.end());\n        return X[(N - 1) / 2];\n    }", "target_Lan": "cpp###minimumDis.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <algorithm>\n// TOFILL\nint main() {\n    cout << minimumDis(1, {5}) << endl;\n    cout << minimumDis(2, {5, 10}) << endl;\n    cout << minimumDis(3, {5, 10, 15}) << endl;\n    cout << minimumDis(4, {5, 10, 15, 20}) << endl;\n}"}, {"source_Lan": "python###substringsAndPermutations.py", "source_code": "def substringsAndPermutations( n: int, m: int, s: str,\n                              arr: List[str]) -> List[int]:\n    vec = [[] for _ in range(10)]\n    for i in range(n):\n        vec[int(s[i])].append(i + 1)\n    fans = []\n    for i in range(m):\n        brr = [0] * 10\n        for j in range(len(arr[i])):\n            brr[int(arr[i][j])] += 1\n        ans = -1\n        f = 0\n        for j in range(10):\n            if brr[j] != 0:\n                if len(vec[j]) < brr[j]:\n                    f = 1\n                else:\n                    ans = max(ans, vec[j][brr[j] - 1])\n        if f == 1:\n            ans = -1\n        fans.append(ans)\n    return fans", "trans_code": "public : vector < int > substringsAndPermutations ( int n , int m , string s , vector < string > arr ) throw ( ) {\n  vector < vector < int >> vec ( 10 ) ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) vec [ int ( s [ i ] ) ] . push_back ( i + 1 ) ;\n  vector < int > fans ;\n  for ( int i = 0 ;\n  i < m ;\n  i ++ ) {\n    vector < int > brr ( 10 ) ;\n    for ( int j = 0 ;\n    j < arr [ i ] . size ( ) ;\n    j ++ ) brr [ int ( arr [ i ] [ j ] ) ] ++ ;\n    int ans = - 1 ;\n    int f = 0 ;\n    for ( int j = 0 ;\n    j < 10 ;\n    j ++ ) {\n      if ( brr [ j ] != 0 ) {\n        if ( vec [ j ] . size ( ) < brr [ j ] ) f = 1 ;\n        else ans = max ( ans , vec [ j ] [ brr [ j ] - 1 ] ) ;\n      }\n    }\n    if ( f == 1 ) ans = - 1 ;\n    fans . push_back ( ans ) ;\n  }\n  return fans ;\n}\n", "reference_code": "    vector<int> substringsAndPermutations(int n, int m, string s, vector<string>&arr){\n        map<char,vector<int>>mp;\n        for (int i=0;i<n;i++){\n            char ch=s[i];\n            mp[ch].push_back(i);\n        }\n        vector<int>ans;\n        for (auto j:arr){\n            int ma=0;\n            unordered_map<char,int>ct;\n            for (auto k:j){\n                ct[k]+=1;\n            }\n            for (auto k:j){\n                int ele=ct[k];\n                if (ele>mp[k].size()){\n                    ma=-1;\n                    break;\n                }\n                else {\n                    ma=max(ma,mp[k][ele-1]+1);\n                }\n            }\n            ans.push_back(ma);\n        }\n        return ans;\n    }", "target_Lan": "cpp###substringsAndPermutations.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <unordered_map>\n// TOFILL\nint main() {\n    int n = 0, m = 0;\n    string s = \"\";\n    vector<string> arr;\n    vector<int> ans = substringsAndPermutations(n, m, s, arr);\n    for(int i = 0; i < ans.size(); i++) {\n        cout << ans[i] << \" \";\n    }\n    cout << endl;\n    return 0;\n}"}, {"source_Lan": "python###matchingCnt.py", "source_code": "def matchingCnt( n: int, X: List[str]) -> List[int]:\n    mp = []\n    ans = [0] * n\n    for i in range(n - 1, -1, -1):\n        s = X[i]\n        for j in range(len(s)):\n            \n            if len(mp) == j:\n                mp.append([0] * 26)\n            \n            ans[i] += mp[j][ord(s[j]) - 97]\n            mp[j][ord(s[j]) - 97] += 1\n    return ans", "trans_code": "public : vector < int > matchingCnt ( int n , vector < string > X ) throw ( ) {\n  vector < vector < int >> mp ;\n  vector < int > ans ( n ) ;\n  for ( int i = n - 1 ;\n  i >= 0 ;\n  i -- ) {\n    string s = X [ i ] ;\n    for ( int j = 0 ;\n    j < s . length ( ) ;\n    j ++ ) {\n      if ( mp . size ( ) == j ) mp . push_back ( vector < int > ( 26 ) ) ;\n      ans [ i ] += mp [ j ] [ ( int ) s [ j ] - 97 ] ;\n      mp [ j ] [ ( int ) s [ j ] - 97 ] ++ ;\n    }\n  }\n  return ans ;\n}\n", "reference_code": "    vector<int> matchingCnt(int n, vector<string>& X) {\n        unordered_map<int, array<int, 26>> map;\n        vector<int> ans(n);\n        for (int i = n - 1; i >= 0; i--) {\n            string x = X[i];\n            int cans = 0;\n            for (int j = 0; j < x.length(); j++) {\n                if (map.find(j) == map.end()) {\n                    map[j] = array<int, 26>{};\n                }\n                cans += map[j][x[j] - 'a'];\n                map[j][x[j] - 'a']++;\n            }\n            ans[i] = cans;\n        }\n        return ans;\n    }", "target_Lan": "cpp###matchingCnt.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <array>\n// TOFILL\nint main() {\n    vector<string> X1 = {};\n    vector<string> X2 = {\"a\"};\n    vector<string> X3 = {\"a\", \"b\"};\n    vector<string> X4 = {\"a\", \"b\", \"c\"};\n    vector<string> X5 = {\"a\", \"b\", \"c\", \"d\"};\n\n    vector<int> ans1 = matchingCnt(0, X1);\n    vector<int> ans2 = matchingCnt(1, X2);\n    vector<int> ans3 = matchingCnt(2, X3);\n    vector<int> ans4 = matchingCnt(3, X4);\n    vector<int> ans5 = matchingCnt(4, X5);\n\n    for(int i : ans1) {\n        cout << i << \" \";\n    }\n    cout << endl;\n\n    for(int i : ans2) {\n        cout << i << \" \";\n    }\n    cout << endl;\n\n    for(int i : ans3) {\n        cout << i << \" \";\n    }\n    cout << endl;\n\n    for(int i : ans4) {\n        cout << i << \" \";\n    }\n    cout << endl;\n\n    for(int i : ans5) {\n        cout << i << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}"}, {"source_Lan": "python###countSuperPalindrome.py", "source_code": "def countSuperPalindrome( l: int, r: int) -> int:\n    count = 0\n    start = ceil(sqrt(l))\n    while start * start <= r:\n        s = str(start * start)\n        \n        if s == s[::-1]:\n            count += 1\n        start += 1\n    return count", "trans_code": "int countSuperPalindrome ( int l , int r ) throw ( ) {\n  int count = 0 ;\n  int start = ceil ( sqrt ( l ) ) ;\n  while ( start * start <= r ) {\n    string s = to_string ( start * start ) ;\n    if ( s == s . substr ( 0 , s . length ( ) - 1 ) ) count ++ ;\n    start ++ ;\n  }\n  return count ;\n}\n", "reference_code": "    int countSuperPalindrome(int l, int r) {\n        int count = 0;\n        \n        int start = static_cast<int>(ceil(sqrt(l)));\n        \n        while (start * start <= r) {\n            \n            int square = start * start;\n            string s = to_string(square);\n            \n            if (s == string(s.rbegin(), s.rend())) {\n                count++;\n            }\n            start++;\n        }\n        return count;\n    }", "target_Lan": "cpp###countSuperPalindrome.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <cmath>\n#include <string>\n// TOFILL\nint main() {\n    cout << countSuperPalindrome(1, 10) << endl;\n    cout << countSuperPalindrome(100, 1000) << endl;\n    cout << countSuperPalindrome(1000, 10000) << endl;\n    cout << countSuperPalindrome(10000, 100000) << endl;\n    cout << countSuperPalindrome(100000, 1000000) << endl;\n}"}, {"source_Lan": "python###candyShop2.py", "source_code": "def candyShop2( n : int, candies : List[int]) -> int:\n    s=set(el for el in candies)\n    return sum(s)", "trans_code": "int candyShop2 ( int n , vector < int > & candies ) throw ( ) {\n  set < int > s ;\n  s . insert ( el ) ;\n  return sum ( s ) ;\n}\n", "reference_code": "    int candyShop2(int n, vector<int> &candies) {\n        int answer = 0;\n        unordered_map<int, int> m;\n        for(auto i : candies){\n            if(m.find(i) == m.end()){\n                answer += i;\n                m[i] = 1;\n            }\n        }\n        return answer;\n    }", "target_Lan": "cpp###candyShop2.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    vector<int> candies1 = {};\n    cout << candyShop2(0, candies1) << endl;\n\n    vector<int> candies2 = {1};\n    cout << candyShop2(1, candies2) << endl;\n\n    vector<int> candies3 = {1, 2};\n    cout << candyShop2(2, candies3) << endl;\n\n    vector<int> candies4 = {1, 1, 2};\n    cout << candyShop2(3, candies4) << endl;\n\n    vector<int> candies5 = {1, 2, 2, 3};\n    cout << candyShop2(4, candies5) << endl;\n\n    return 0;\n}"}, {"source_Lan": "python###candyShop.py", "source_code": "def candyShop( n : int, candies : List[int]) -> int:\n    s=set(el for el in candies)\n    t=Counter()\n    l=0\n    p=0\n    ans=float(\"inf\")\n    for el in candies:\n        p+=el\n        t[el]+=1\n        while len(t)==len(s):\n            ans=min(ans,p)\n            t[candies[l]]-=1\n            p-=candies[l]\n            if t[candies[l]]==0:\n                del t[candies[l]]\n            l+=1\n    return ans", "trans_code": "int candyShop ( int n , std :: vector < int > & candies ) throw ( ) {\n  std :: set < int > s ;\n  s . insert ( el ) ;\n  std :: map < int , int > t ;\n  int l = 0 ;\n  int p = 0 ;\n  int ans = std :: numeric_limits < int > :: infinity ( ) ;\n  for ( int el : candies ) {\n    p += el ;\n    t [ el ] ++ ;\n    while ( t . size ( ) == s . size ( ) ) {\n      ans = std :: min ( ans , p ) ;\n      t [ candies [ l ] ] -- ;\n      p -= candies [ l ] ;\n      if ( t [ candies [ l ] ] == 0 ) std :: swap ( t [ candies [ l ] ] , t [ candies [ l ] ] ) ;\n      l ++ ;\n    }\n  }\n  return ans ;\n}\n", "reference_code": "    int candyShop(int n, vector<int> &candies) {\n        int answer = INT_MAX;\n        unordered_map<int, int> m;\n        for(auto i : candies){\n            m[i] += 1;\n        }\n        int k = m.size();\n        m.clear();\n        int l = 0, r = 0;\n        int total = 0;\n        while(r < n){\n            m[candies[r]] += 1;\n            total += candies[r];\n            while(m[candies[l]] > 1){\n                m[candies[l]] -= 1;\n                total -= candies[l];\n                l += 1;\n            }\n            if(m.size() == k){\n                answer = min(answer, total);\n            }\n            r += 1;\n        }\n        return answer;\n    }", "target_Lan": "cpp###candyShop.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <climits>\n// TOFILL\nint main() {\n    vector<int> candies1 = {1, 2, 3, 4, 5};\n    cout << candyShop(5, candies1) << endl;\n\n    vector<int> candies2 = {1, 1, 2, 2, 3, 3, 4, 4, 5, 5};\n    cout << candyShop(10, candies2) << endl;\n\n    vector<int> candies3 = {1, 1, 1};\n    cout << candyShop(3, candies3) << endl;\n\n    vector<int> candies4 = {1, 2, 3, 4};\n    cout << candyShop(4, candies4) << endl;\n\n    vector<int> candies5 = {1, 1, 2, 2, 3, 3};\n    cout << candyShop(6, candies5) << endl;\n\n    return 0;\n}"}, {"source_Lan": "python###minimizeArr.py", "source_code": "def minimizeArr( n: int, arr: List[int]) -> int:\n    min_element = min(arr)\n    if arr.count(min_element) == 1:\n        return 1\n    else:\n        count = arr.count(min_element)\n        for el in arr:\n            if el % min_element != 0:\n                return 1\n        return (count + 1) // 2", "trans_code": "public : int minimizeArr ( int n , vector < int > arr ) throw ( ) {\n  int minElement = min ( arr . begin ( ) , arr . end ( ) ) ;\n  if ( arr . count ( minElement ) == 1 ) return 1 ;\n  else {\n    int count = arr . count ( minElement ) ;\n    for ( int el : arr ) {\n      if ( el % minElement != 0 ) return 1 ;\n    }\n    return ( count + 1 ) / 2 ;\n  }\n}\n", "reference_code": "    int minimizeArr(int n, vector<int>&arr){\n        int mi=INT_MAX;\n        for (auto j:arr) mi=min(mi,j);\n        int ct=0;\n        for (auto j:arr){\n            if (j==mi)ct+=1;\n        }\n        if (ct==1) return 1;\n        for (auto j:arr){\n            if (j%mi!=0) return 1;\n        }\n        return ceil((float)ct / 2);\n    }", "target_Lan": "cpp###minimizeArr.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <climits>\n#include <cmath>\n// TOFILL\nint main() {\n    vector<int> arr1 = {1};\n    cout << minimizeArr(1, arr1) << endl;\n\n    vector<int> arr2 = {1, 1};\n    cout << minimizeArr(2, arr2) << endl;\n\n    vector<int> arr3 = {1, 2, 3};\n    cout << minimizeArr(3, arr3) << endl;\n\n    vector<int> arr4 = {2, 2, 2, 2};\n    cout << minimizeArr(4, arr4) << endl;\n\n    return 0;\n}"}, {"source_Lan": "python###minElements.py", "source_code": "def minElements( n : int, m : int, arr1 : List[int], arr2 : List[int]) -> int:\n    s=sum(arr1)\n    arr2.sort(reverse=True)\n    ind=0\n    curr=0\n    for el in arr2:\n        curr+=el\n        if curr>=s:\n            return ind+1\n        ind+=1\n    return -1", "trans_code": "int minElements ( int n , int m , vector < int > & arr1 , vector < int > & arr2 ) throw ( ) {\n  int s = accumulate ( arr1 . begin ( ) , arr1 . end ( ) , 0 ) ;\n  sort ( arr2 . begin ( ) , arr2 . end ( ) ) ;\n  int ind = 0 ;\n  int curr = 0 ;\n  for ( int el : arr2 ) {\n    curr += el ;\n    if ( curr >= s ) return ind + 1 ;\n    ind ++ ;\n  }\n  return - 1 ;\n}\n", "reference_code": "    int minElements(int n, int m, vector<int> &arr1, vector<int> &arr2) {\n        long long s=0;\n        for (auto j:arr1) s+=j;\n        sort(arr2.begin(),arr2.end());\n        long long cur=0;\n        int ans=0;\n        for (int i=m-1;i>=0;i--){\n            cur+=arr2[i];\n            ans+=1;\n            if (cur>=s)break;\n        }\n        if (cur>=s) return ans;\n        return -1;\n    }", "target_Lan": "cpp###minElements.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <algorithm>\n// TOFILL\nint main() {\n    vector<int> arr1 = {1, 2, 3, 4, 5};\n    vector<int> arr2 = {1, 2, 3, 4, 5};\n    cout << minElements(5, 5, arr1, arr2) << endl;\n\n    arr2 = {5, 4, 3, 2, 1};\n    cout << minElements(5, 5, arr1, arr2) << endl;\n\n    arr2 = {1, 1, 1, 1, 1};\n    cout << minElements(5, 5, arr1, arr2) << endl;\n\n    arr2 = {5, 5, 5, 5, 5};\n    cout << minElements(5, 5, arr1, arr2) << endl;\n\n    arr2 = {1, 2, 3, 3, 4};\n    cout << minElements(5, 5, arr1, arr2) << endl;\n\n    return 0;\n}"}, {"source_Lan": "python###maxScoreSubseq.py", "source_code": "def maxScoreSubseq( n : int, arr : List[int]) -> int:\n    d=defaultdict(int)\n    v=max(arr)\n    for i in range(n):\n        d[arr[i]-i]+=max(0,arr[i])\n    c=(1 if 0 in arr else 0)\n    for el in d:\n        if d[el]>0:\n            v=max(v,d[el])\n        elif d[el]==0 and c:\n            v=max(0,v)\n    return v", "trans_code": "public : int maxScoreSubseq ( int n , vector < int > arr ) throw ( ) {\n  map < int , int > map ;\n  int v = max ( arr . begin ( ) , arr . end ( ) ) ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) map [ arr [ i ] - i ] += max ( 0 , arr [ i ] ) ;\n  bool c = ( 1 == arr . size ( ) ) ;\n  for ( int el = 0 ;\n  el < map . size ( ) ;\n  el ++ ) {\n    if ( map [ el ] > 0 ) v = max ( v , map [ el ] ) ;\n    else if ( map [ el ] == 0 && c ) v = max ( 0 , v ) ;\n  }\n  return v ;\n}\n", "reference_code": "    int maxScoreSubseq(int n, vector<int> &arr) {\n        unordered_map<int,int>mp;\n        int ma=INT_MIN;\n        for (int i=0;i<n;i++){\n            if (arr[i]>=0)mp[arr[i]-i]+=arr[i];\n            ma=max(ma,arr[i]);\n        }\n        int ele=INT_MIN;\n        for (auto j:mp) ele=max(ele,j.second);\n        return max(ele,ma);\n    }", "target_Lan": "cpp###maxScoreSubseq.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <climits>\n// TOFILL\nint main() {\n    vector<int> arr1 = {1};\n    cout << maxScoreSubseq(1, arr1) << endl;\n\n    vector<int> arr2 = {1, 2};\n    cout << maxScoreSubseq(2, arr2) << endl;\n\n    vector<int> arr3 = {1, 2, 3};\n    cout << maxScoreSubseq(3, arr3) << endl;\n\n    vector<int> arr4 = {1, 2, 3, 4};\n    cout << maxScoreSubseq(4, arr4) << endl;\n\n    return 0;\n}"}, {"source_Lan": "python###minJumps.py", "source_code": "def minJumps( n: int, arr: List[int]) -> int:\n    occ = {}\n    ans = float('inf')\n    for i in range(n):\n        if arr[i] not in occ:\n            ans = min(ans, n - 1)\n            occ[arr[i]] = i\n        else:\n            ans = min(occ[arr[i]] + n - i, ans)\n    return ans", "trans_code": "public : int minJumps ( int n , vector < int > arr ) throw ( ) {\n  unordered_map < int , int > occ ;\n  int ans = INT_MAX ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    if ( arr [ i ] != 0 ) {\n      ans = min ( ans , n - 1 ) ;\n      occ [ arr [ i ] ] = i ;\n    }\n    else {\n      ans = min ( occ [ arr [ i ] ] + n - i , ans ) ;\n    }\n  }\n  return ans ;\n}\n", "reference_code": "    int minJumps(int n, vector<int> &arr) {\n        map<int, int> m;\n        int ans = n - 1;\n        for (int i = n - 1; i >= 0; i--) {\n            if (m.count(arr[i])) {\n                ans = min(ans, n - (m[arr[i]] - i));\n            } else {\n                m[arr[i]] = i;\n            }\n        }\n        return ans;\n    }", "target_Lan": "cpp###minJumps.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\n// TOFILL\nint main() {\n    vector<int> arr1 = {1,2,3,4,5};\n    cout << minJumps(5, arr1) << endl;\n\n    vector<int> arr2 = {1,1,1};\n    cout << minJumps(3, arr2) << endl;\n\n    vector<int> arr3 = {1,2,1,2};\n    cout << minJumps(4, arr3) << endl;\n\n    vector<int> arr4 = {1,2};\n    cout << minJumps(2, arr4) << endl;\n\n    vector<int> arr5 = {1,2,3,1,2,3};\n    cout << minJumps(6, arr5) << endl;\n\n    return 0;\n}"}, {"source_Lan": "python###maximumSetSize.py", "source_code": "def maximumSetSize( nums1: List[int], nums2: List[int]) -> int:\n    set1 = set(nums1)\n    set2 = set(nums2)\n    common = len(set1 & set2)\n    n1 = len(set1)\n    n2 = len(set2)\n    ans = n1 + n2 - common\n    m = len(nums1) // 2\n    if n1 > m:\n        mn = min(n1 - m, common)\n        ans -= n1 - mn - m\n        common -= mn\n    if n2 > m:\n        n2 -= min(n2 - m, common)\n        ans -= n2 - m\n    return ans", "trans_code": "public : int maximumSetSize ( vector < int > & nums1 , vector < int > & nums2 ) throw ( ) {\n  set < int > set1 ( nums1 ) ;\n  set < int > set2 ( nums2 ) ;\n  int common = set1 . size ( ) & set2 . size ( ) ;\n  int n1 = set1 . size ( ) ;\n  int n2 = set2 . size ( ) ;\n  int ans = n1 + n2 - common ;\n  int m = nums1 . size ( ) / 2 ;\n  if ( n1 > m ) {\n    int mn = min ( n1 - m , common ) ;\n    ans -= n1 - mn - m ;\n    common -= mn ;\n  }\n  if ( n2 > m ) {\n    n2 -= min ( n2 - m , common ) ;\n    ans -= n2 - m ;\n  }\n  return ans ;\n}\n", "reference_code": "    int maximumSetSize(vector<int> &nums1, vector<int> &nums2) {\n        unordered_set<int> set1(nums1.begin(), nums1.end());\n        unordered_set<int> set2(nums2.begin(), nums2.end());\n        int common = 0;\n        for (int x : set1) {\n            common += set2.count(x);\n        }\n        int n1 = set1.size();\n        int n2 = set2.size();\n        int ans = n1 + n2 - common;\n        int m = nums1.size() / 2;\n        if (n1 > m) {\n            int mn = min(n1 - m, common);\n            ans -= n1 - mn - m;\n            common -= mn;\n        }\n        if (n2 > m) {\n            n2 -= min(n2 - m, common);\n            ans -= n2 - m;\n        }\n        return ans;\n    }", "target_Lan": "cpp###maximumSetSize.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <unordered_set>\n// TOFILL\nint main() {\n    vector<int> nums1 = {1, 2, 3, 4, 5};\n    vector<int> nums2 = {3, 4, 5, 6, 7};\n    cout << maximumSetSize(nums1, nums2) << endl;\n\n    nums1 = {1, 1, 1, 1, 1};\n    nums2 = {2, 2, 2, 2, 2};\n    cout << maximumSetSize(nums1, nums2) << endl;\n\n    nums1 = {1, 2, 3, 4, 5};\n    nums2 = {1, 2, 3, 4, 5};\n    cout << maximumSetSize(nums1, nums2) << endl;\n\n    nums1 = {1, 2, 3, 4, 5};\n    nums2 = {6, 7, 8, 9, 10};\n    cout << maximumSetSize(nums1, nums2) << endl;\n\n    nums1 = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n    nums2 = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n    cout << maximumSetSize(nums1, nums2) << endl;\n\n    return 0;\n}"}, {"source_Lan": "python###maxFrequencyElements.py", "source_code": "def maxFrequencyElements( nums: List[int]) -> int:\n    ans = max_cnt = 0\n    cnt = Counter()\n    for x in nums:\n        cnt[x] += 1\n        c = cnt[x]\n        if c > max_cnt:\n            max_cnt = ans = c\n        elif c == max_cnt:\n            ans += c\n    return ans", "trans_code": "public : int maxFrequencyElements ( vector < int > & nums ) throw ( ) {\n  int ans = max_cnt = 0 ;\n  counter cnt ;\n  for ( int x : nums ) {\n    cnt [ x ] ++ ;\n    int c = cnt [ x ] ;\n    if ( c > max_cnt ) max_cnt = ans = c ;\n    else if ( c == max_cnt ) ans += c ;\n  }\n  return ans ;\n}\n", "reference_code": "    int maxFrequencyElements(vector<int> &nums) {\n        int ans = 0, maxCnt = 0;\n        unordered_map<int, int> cnt;\n        for (int x : nums) {\n            int c = ++cnt[x];\n            if (c > maxCnt) {\n                maxCnt = ans = c;\n            } else if (c == maxCnt) {\n                ans += c;\n            }\n        }\n        return ans;\n    }", "target_Lan": "cpp###maxFrequencyElements.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    vector<int> nums1 = {1, 2, 3, 4, 5};\n    vector<int> nums2 = {1, 1, 1, 1, 1};\n    vector<int> nums3 = {1, 2, 2, 3, 3};\n    vector<int> nums4 = {1, 2, 3, 4, 5, 5, 5};\n    vector<int> nums5 = {1, 2, 2, 3, 3, 3};\n\n    cout << maxFrequencyElements(nums1) << endl;\n    cout << maxFrequencyElements(nums2) << endl;\n    cout << maxFrequencyElements(nums3) << endl;\n    cout << maxFrequencyElements(nums4) << endl;\n    cout << maxFrequencyElements(nums5) << endl;\n\n    return 0;\n}"}, {"source_Lan": "python###minimumPushes.py", "source_code": "def minimumPushes( word: str) -> int:\n    k, rem = divmod(len(word), 8)\n    return (k * 4 + rem) * (k + 1)", "trans_code": "public : int minimumPushes ( string word ) throw ( ) {\n  int k = 0 , rem = word . size ( ) ;\n  return ( k * 4 + rem ) * ( k + 1 ) ;\n}\n", "reference_code": "    int minimumPushes(string &word) {\n        int n = word.length();\n        int k = n / 8;\n        return (k * 4 + n % 8) * (k + 1);\n    }", "target_Lan": "cpp###minimumPushes.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <string>\n// TOFILL\nint main() {\n    string word1 = \"\";\n    string word2 = \"a\";\n    string word3 = \"abcdefgh\";\n    string word4 = \"abcdefghi\";\n    string word5 = \"abcdefghijklmnopqrstuvwxyz\";\n\n    cout << minimumPushes(word1) << endl;\n    cout << minimumPushes(word2) << endl;\n    cout << minimumPushes(word3) << endl;\n    cout << minimumPushes(word4) << endl;\n    cout << minimumPushes(word5) << endl;\n\n    return 0;\n}"}, {"source_Lan": "python###minimumOperationsToMakeKPeriodic.py", "source_code": "def minimumOperationsToMakeKPeriodic( word: str, k: int) -> int:\n    n = len(word)\n    cnt = Counter(word[i - k: i] for i in range(k, n + 1, k))\n    mx = max(cnt.values())\n    return n // k - mx", "trans_code": "int minimumOperationsToMakeKPeriodic ( string word , int k ) throw ( ) {\n  int n = word . size ( ) ;\n  Counter cnt ( word . begin ( ) + k - k , word . end ( ) ) ;\n  int mx = max ( cnt . begin ( ) , cnt . end ( ) ) ;\n  return n / k - mx ;\n}\n", "reference_code": "    int minimumOperationsToMakeKPeriodic(string word, int k) {\n        int n = word.size(), mx = 0;\n        unordered_map<string, int> cnt;\n        for (int i = k; i <= n; i += k) {\n            mx = max(mx, ++cnt[word.substr(i - k, k)]);\n        }\n        return n / k - mx;\n    }", "target_Lan": "cpp###minimumOperationsToMakeKPeriodic.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <algorithm>\n// TOFILL\nint main() {\n    cout << minimumOperationsToMakeKPeriodic(\"abcabcabcabc\", 3) << endl;\n    cout << minimumOperationsToMakeKPeriodic(\"aaaa\", 1) << endl;\n    cout << minimumOperationsToMakeKPeriodic(\"abcabcabcabc\", 4) << endl;\n    cout << minimumOperationsToMakeKPeriodic(\"abcabcabcabc\", 6) << endl;\n    cout << minimumOperationsToMakeKPeriodic(\"abcabcabcabc\", 12) << endl;\n    return 0;\n}"}, {"source_Lan": "python###maxScore.py", "source_code": "def maxScore( grid: List[List[int]]) -> int:\n    ans = -inf\n    m, n = len(grid), len(grid[0])\n    f = [[inf] * (n + 1) for _ in range(m + 1)]\n    for i, row in enumerate(grid):\n        for j, x in enumerate(row):\n            mn = min(f[i + 1][j], f[i][j + 1])\n            ans = max(ans, x - mn)\n            f[i + 1][j + 1] = min(mn, x)\n    return ans", "trans_code": "public : int maxScore ( vector < vector < int >> & grid ) throw ( ) {\n  int ans = - inf ;\n  int m = grid . size ( ) ;\n  int n = grid [ 0 ] . size ( ) ;\n  vector < vector < int >> f ( m + 1 , vector < int > ( n + 1 ) ) ;\n  for ( int i = 0 , row = grid . size ( ) ;\n  i < m ;\n  i ++ ) {\n    for ( int j = 0 , x = row [ i ] ;\n    j < n ;\n    j ++ ) {\n      int mn = min ( f [ i + 1 ] [ j ] , f [ i ] [ j + 1 ] ) ;\n      ans = max ( ans , x - mn ) ;\n      f [ i + 1 ] [ j + 1 ] = min ( mn , x ) ;\n    }\n  }\n  return ans ;\n}\n", "reference_code": "    int maxScore(vector<vector<int>>& grid) {\n        int ans = INT_MIN;\n        int m = grid.size(), n = grid[0].size();\n        vector<vector<int>> f(m + 1, vector<int>(n + 1, INT_MAX));\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                int mn = min(f[i + 1][j], f[i][j + 1]);\n                ans = max(ans, grid[i][j] - mn);\n                f[i + 1][j + 1] = min(mn, grid[i][j]);\n            }\n        }\n        return ans;\n    }", "target_Lan": "cpp###maxScore.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <climits>\n// TOFILL\nint main() {\n    vector<vector<int>> grid1 = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};\n    cout << maxScore(grid1) << endl;\n\n    vector<vector<int>> grid2 = {{10, 20, 30}, {40, 50, 60}, {70, 80, 90}};\n    cout << maxScore(grid2) << endl;\n\n    vector<vector<int>> grid3 = {{100, 200, 300}, {400, 500, 600}, {700, 800, 900}};\n    cout << maxScore(grid3) << endl;\n\n    vector<vector<int>> grid4 = {{1, 1, 1}, {1, 1, 1}, {1, 1, 1}};\n    cout << maxScore(grid4) << endl;\n\n    vector<vector<int>> grid5 = {{9, 9, 9}, {9, 9, 9}, {9, 9, 9}};\n    cout << maxScore(grid5) << endl;\n\n    return 0;\n}"}, {"source_Lan": "python###sumDigitDifferences.py", "source_code": "def sumDigitDifferences( nums: List[int]) -> int:\n    ans = 0\n    cnt = [[0] * 10 for _ in str(nums[0])]\n    for k, x in enumerate(nums):\n        i = 0\n        while x:\n            x, d = divmod(x, 10)\n            ans += k - cnt[i][d]\n            cnt[i][d] += 1\n            i += 1\n    return ans", "trans_code": "public : int sumDigitDifferences ( vector < int > & nums ) throw ( ) {\n  int ans = 0 ;\n  vector < vector < int >> cnt ( 10 ) ;\n  for ( int k = 0 , x = 0 ;\n  k < nums . size ( ) ;\n  k ++ ) {\n    int i = 0 ;\n    while ( x ) {\n      x = nums [ k ] , d = nums [ i ] ;\n      ans += k - cnt [ i ] [ d ] ;\n      cnt [ i ] [ d ] ++ ;\n      i ++ ;\n    }\n  }\n  return ans ;\n}\n", "reference_code": "    long long sumDigitDifferences(vector<int>& nums) {\n        long long ans = 0;\n        vector<array<int, 10>> cnt(to_string(nums[0]).length());\n        for (int k = 0; k < nums.size(); k++) {\n            int x = nums[k];\n            for (int i = 0; x; x /= 10, i++) {\n                int d = x % 10;\n                ans += k - cnt[i][d]++;\n            }\n        }\n        return ans;\n    }", "target_Lan": "cpp###sumDigitDifferences.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    vector<int> nums1 = {1, 2, 3, 4, 5};\n    vector<int> nums2 = {10, 20, 30, 40, 50};\n    vector<int> nums3 = {100, 200, 300, 400, 500};\n    vector<int> nums4 = {1000, 2000, 3000, 4000, 5000};\n    vector<int> nums5 = {10000, 20000, 30000, 40000, 50000};\n\n    cout << sumDigitDifferences(nums1) << endl;\n    cout << sumDigitDifferences(nums2) << endl;\n    cout << sumDigitDifferences(nums3) << endl;\n    cout << sumDigitDifferences(nums4) << endl;\n    cout << sumDigitDifferences(nums5) << endl;\n\n    return 0;\n}"}, {"source_Lan": "python###minimumCost.py", "source_code": "def minimumCost( nums: List[int]) -> int:\n    return nums[0] + sum(sorted(nums[1:])[:2])", "trans_code": "public : int minimumCost ( vector < int > & nums ) throw ( ) {\n  return nums [ 0 ] + std :: accumulate ( nums . begin ( ) , nums . end ( ) , 0 ) ;\n}\n", "reference_code": "    int minimumCost(vector<int> &nums) {\n        sort(nums.begin() + 1, nums.end());\n        return accumulate(nums.begin(), nums.begin() + 3, 0);\n    }", "target_Lan": "cpp###minimumCost.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <numeric>\n#include <algorithm>\n// TOFILL\nint main() {\n    vector<int> nums1 = {1,2,3,4,5};\n    cout << minimumCost(nums1) << endl;\n\n    vector<int> nums2 = {5,4,3,2,1};\n    cout << minimumCost(nums2) << endl;\n\n    vector<int> nums3 = {1,1,1,1,1};\n    cout << minimumCost(nums3) << endl;\n\n    vector<int> nums4 = {-1,-2,-3,-4,-5};\n    cout << minimumCost(nums4) << endl;\n\n    vector<int> nums5 = {100,200,300,400,500};\n    cout << minimumCost(nums5) << endl;\n\n    return 0;\n}"}, {"source_Lan": "python###minimumLevels.py", "source_code": "def minimumLevels( possible: List[int]) -> int:\n    \n    s = sum(possible) * 2 - len(possible)\n    pre = 0\n    for i, x in enumerate(possible[:-1]):\n        pre += 2 if x else -2\n        if pre > s:\n            return i + 1\n    return -1", "trans_code": "int minimumLevels ( vector < int > possible ) throw ( ) {\n  int s = sum ( possible ) * 2 - possible . size ( ) ;\n  int pre = 0 ;\n  for ( int i = 0 , x = possible . size ( ) - 1 ;\n  i < x ;\n  i ++ ) {\n    pre += 2 == x ? - 2 : 1 ;\n    if ( pre > s ) return i + 1 ;\n  }\n  return - 1 ;\n}\n", "reference_code": "    int minimumLevels(vector<int> &possible) {\n        \n        int n = possible.size();\n        int s = accumulate(possible.begin(), possible.end(), 0) * 2 - n;\n        int pre = 0;\n        for (int i = 0; i < n - 1; i++) {\n            pre += possible[i] ? 2 : -2;\n            if (pre > s) {\n                return i + 1;\n            }\n        }\n        return -1;\n    }", "target_Lan": "cpp###minimumLevels.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <numeric>\n// TOFILL\nint main() {\n    vector<int> possible1 = {1, 1, 1, 1, 1};\n    cout << minimumLevels(possible1) << endl;\n\n    vector<int> possible2 = {0, 0, 0, 0, 0};\n    cout << minimumLevels(possible2) << endl;\n\n    vector<int> possible3 = {1, 0, 1, 0, 1};\n    cout << minimumLevels(possible3) << endl;\n\n    vector<int> possible4 = {1, 1, 1, 1, 0};\n    cout << minimumLevels(possible4) << endl;\n\n    vector<int> possible5 = {0, 1, 0, 1, 0};\n    cout << minimumLevels(possible5) << endl;\n\n    return 0;\n}"}, {"source_Lan": "python###numberGame.py", "source_code": "def numberGame( nums: List[int]) -> List[int]:\n    nums.sort()\n    for i in range(0, len(nums), 2):\n        nums[i], nums[i + 1] = nums[i + 1], nums[i]\n    return nums", "trans_code": "public : vector < int > numberGame ( vector < int > & nums ) throw ( ) {\n  sort ( nums . begin ( ) , nums . end ( ) ) ;\n  for ( int i = 0 ;\n  i < nums . size ( ) ;\n  i += 2 ) nums [ i ] = nums [ i + 1 ] ;\n  return nums ;\n}\n", "reference_code": "    vector<int> numberGame(vector<int>& nums) {\n        sort(nums.begin(), nums.end());\n        for (int i = 0; i < nums.size(); i += 2) {\n            swap(nums[i], nums[i + 1]);\n        }\n        return nums;\n    }", "target_Lan": "cpp###numberGame.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <algorithm>\n// TOFILL\nint main() {\n    vector<int> nums1 = {1, 2, 3, 4, 5, 6};\n    vector<int> nums2 = {6, 5, 4, 3, 2, 1};\n    vector<int> nums3 = {1, 1, 1, 1, 1, 1};\n    vector<int> nums4 = {-1, -2, -3, -4, -5, -6};\n    vector<int> nums5 = {100, 200, 300, 400, 500, 600};\n\n    vector<int> result1 = numberGame(nums1);\n    vector<int> result2 = numberGame(nums2);\n    vector<int> result3 = numberGame(nums3);\n    vector<int> result4 = numberGame(nums4);\n    vector<int> result5 = numberGame(nums5);\n\n    for(int i : result1) {\n        cout << i << \" \";\n    }\n    cout << endl;\n\n    for(int i : result2) {\n        cout << i << \" \";\n    }\n    cout << endl;\n\n    for(int i : result3) {\n        cout << i << \" \";\n    }\n    cout << endl;\n\n    for(int i : result4) {\n        cout << i << \" \";\n    }\n    cout << endl;\n\n    for(int i : result5) {\n        cout << i << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}"}, {"source_Lan": "python###minimumDistance.py", "source_code": "def minimumDistance( points: List[List[int]]) -> int:\n    sx = SortedList(p[0] - p[1] for p in points)\n    sy = SortedList(p[0] + p[1] for p in points)\n    res = float('inf')\n    for p in points:\n        sx.remove(p[0] - p[1])\n        sy.remove(p[0] + p[1])\n        res = min(res, max(sx[-1] - sx[0], sy[-1] - sy[0]))\n        sx.add(p[0] - p[1])\n        sy.add(p[0] + p[1])\n    return res", "trans_code": "double minimumDistance ( const std :: vector < std :: pair < double , double >> & points ) throw ( ) {\n  SortedList < double > sx ( points . begin ( ) , points . end ( ) ) ;\n  SortedList < double > sy ( points . begin ( ) , points . end ( ) ) ;\n  double res = std :: numeric_limits < double > :: infinity ( ) ;\n  for ( const auto & p : points ) {\n    sx . erase ( p . first - p . second ) ;\n    sy . erase ( p . first + p . second ) ;\n    res = std :: min ( res , std :: max ( sx . end ( ) - sx . begin ( ) , sy . end ( ) - sy . begin ( ) ) ) ;\n    sx . insert ( p . first - p . second ) ;\n    sy . insert ( p . first + p . second ) ;\n  }\n  return res ;\n}\n", "reference_code": "    int minimumDistance(vector<vector<int>>& points) {\n        multiset<int> sx, sy;\n        for (auto & p : points) {\n            sx.emplace(p[0] - p[1]);\n            sy.emplace(p[0] + p[1]);\n        }\n        int res = INT_MAX;\n        for (auto &p : points) {\n            sx.erase(sx.find(p[0] - p[1]));\n            sy.erase(sy.find(p[0] + p[1]));\n            res = min(res, max(*sx.rbegin() - *sx.begin(), *sy.rbegin() - *sy.begin()));\n            sx.emplace(p[0] - p[1]);\n            sy.emplace(p[0] + p[1]);\n        }\n        return res;\n    }", "target_Lan": "cpp###minimumDistance.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\n#include <climits>\n// TOFILL\nint main() {\n    vector<vector<int>> points1 = {{1,1},{2,2},{3,3}};\n    cout << minimumDistance(points1) << endl;\n\n    vector<vector<int>> points2 = {{1,1},{2,2},{3,3},{4,4}};\n    cout << minimumDistance(points2) << endl;\n\n    vector<vector<int>> points3 = {{1,1},{2,2},{3,3},{4,4},{5,5}};\n    cout << minimumDistance(points3) << endl;\n\n    vector<vector<int>> points4 = {{1,1},{2,2},{3,3},{4,4},{5,5},{6,6}};\n    cout << minimumDistance(points4) << endl;\n\n    vector<vector<int>> points5 = {{1,1},{2,2},{3,3},{4,4},{5,5},{6,6},{7,7}};\n    cout << minimumDistance(points5) << endl;\n\n    return 0;\n}"}, {"source_Lan": "python###findMinimumTime.py", "source_code": "def findMinimumTime( tasks: List[List[int]]) -> int:\n    tasks.sort(key = lambda task: task[1])\n    run, res = [False] * (tasks[-1][1] + 1), 0\n    for start, end, duration in tasks:\n        duration -= sum(run[start : end+1])\n        res += max(duration, 0)\n        for j in range(end, -1, -1):\n            if duration <= 0:\n                break\n            if not run[j]:\n                run[j], duration = True, duration - 1\n    return res", "trans_code": "public : int findMinimumTime ( vector < vector < int >> & tasks ) throw ( ) {\n  sort ( tasks . begin ( ) , tasks . end ( ) ) ;\n  vector < bool > run ( tasks . size ( ) , false ) , res ( tasks . size ( ) , 0 ) ;\n  for ( int start = 0 ;\n  start < tasks . size ( ) ;\n  start ++ ) {\n    int end = tasks [ start ] . size ( ) ;\n    int duration = tasks [ end ] . size ( ) ;\n    duration -= std :: distance ( run . begin ( ) , run . end ( ) ) ;\n    res += std :: max ( duration , 0 ) ;\n    for ( int j = end ;\n    j >= start ;\n    j -- ) {\n      if ( duration <= 0 ) break ;\n      if ( ! run [ j ] ) run [ j ] = true , duration = duration - 1 ;\n    }\n  }\n  return res ;\n}\n", "reference_code": "    int findMinimumTime(vector<vector<int>>& tasks) {\n        int n = tasks.size();\n        sort(tasks.begin(), tasks.end(), [&](const vector<int> &t1, const vector<int> &t2) -> bool {\n            return t1[1] < t2[1];\n        });\n        vector<int> run(tasks[n - 1][1] + 1);\n        int res = 0;\n        for (int i = 0; i < n; i++) {\n            int start = tasks[i][0], end = tasks[i][1], duration = tasks[i][2];\n            duration -= accumulate(run.begin() + start, run.begin() + end + 1, 0);\n            res += max(duration, 0);\n            for (int j = end; j >= 0 && duration > 0; j--) {\n                if (run[j] == 0) {\n                    duration--;\n                    run[j] = 1;\n                }\n            }\n        }\n        return res;\n    }", "target_Lan": "cpp###findMinimumTime.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <numeric>\n#include <algorithm>\n// TOFILL\nint main() {\n    vector<vector<int>> tasks1 = {{1,3,2},{2,5,3},{5,6,2}};\n    cout << findMinimumTime(tasks1) << endl;\n\n    vector<vector<int>> tasks2 = {{1,3,2},{2,5,3},{5,6,2},{7,9,1}};\n    cout << findMinimumTime(tasks2) << endl;\n\n    vector<vector<int>> tasks3 = {{1,3,2},{2,5,3},{5,6,2},{7,9,1},{10,12,1}};\n    cout << findMinimumTime(tasks3) << endl;\n\n    vector<vector<int>> tasks4 = {{1,3,2},{2,5,3},{5,6,2},{7,9,1},{10,12,1},{13,15,1}};\n    cout << findMinimumTime(tasks4) << endl;\n\n    vector<vector<int>> tasks5 = {{1,3,2},{2,5,3},{5,6,2},{7,9,1},{10,12,1},{13,15,1},{16,18,1}};\n    cout << findMinimumTime(tasks5) << endl;\n\n    return 0;\n}"}, {"source_Lan": "python###garbageCollection.py", "source_code": "def garbageCollection( garbage: List[str], travel: List[int]) -> int:\n    distance = {}\n    res = 0\n    cur_dis = 0\n    for i in range(len(garbage)):\n        res += len(garbage[i])\n        if i > 0:\n            cur_dis += travel[i - 1]\n        for c in garbage[i]:\n            distance[c] = cur_dis\n    return res + sum(distance.values())", "trans_code": "int garbageCollection ( vector < string > garbage , vector < int > travel ) throw ( ) {\n  map < string , int > distance ;\n  int res = 0 ;\n  int cur_dis = 0 ;\n  for ( int i = 0 ;\n  i < garbage . size ( ) ;\n  i ++ ) {\n    res += garbage [ i ] . size ( ) ;\n    if ( i > 0 ) cur_dis += travel [ i - 1 ] ;\n    for ( int c = 0 ;\n    c < garbage [ i ] . size ( ) ;\n    c ++ ) distance [ c ] = cur_dis ;\n  }\n  return res + std :: accumulate ( distance . begin ( ) , distance . end ( ) , 0 ) ;\n}\n", "reference_code": "    int garbageCollection(vector<string>& garbage, vector<int>& travel) {\n        unordered_map<char, int> distance;\n        int res = 0, cur_dis = 0;\n        for (int i = 0; i < garbage.size(); i++) {\n            res += garbage[i].size();\n            if (i > 0) {\n                cur_dis += travel[i - 1];\n            }\n            for (auto c : garbage[i]) {\n                distance[c] = cur_dis;\n            }\n        }\n        for (auto &[k, v] : distance) {\n            res += v;\n        }\n        return res;\n    }", "target_Lan": "cpp###garbageCollection.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <string>\n// TOFILL\nint main() {\n    vector<string> garbage1 = {\"G\",\"P\",\"GP\",\"GG\"};\n    vector<int> travel1 = {2,4,3};\n    cout << garbageCollection(garbage1, travel1) << endl;\n\n    vector<string> garbage2 = {\"MMM\",\"PGM\",\"GP\"};\n    vector<int> travel2 = {3,10};\n    cout << garbageCollection(garbage2, travel2) << endl;\n\n    vector<string> garbage3 = {\"MMM\",\"PGM\",\"GP\",\"MMM\",\"GP\"};\n    vector<int> travel3 = {3,10,1,2};\n    cout << garbageCollection(garbage3, travel3) << endl;\n\n    return 0;\n}"}, {"source_Lan": "python###totalCost.py", "source_code": "def totalCost( costs: List[int], k: int, candidates: int) -> int:\n    n = len(costs)\n    q = list()\n    left, right = candidates - 1, n - candidates\n    if left + 1 < right:\n        for i in range(left + 1):\n            heappush(q, (costs[i], i))\n        for i in range(right, n):\n            heappush(q, (costs[i], i))\n    else:\n        for i in range(n):\n            heappush(q, (costs[i], i))\n    ans = 0\n    for _ in range(k):\n        cost, idx = heappop(q)\n        ans += cost\n        if left + 1 < right:\n            if idx <= left:\n                left += 1\n                heappush(q, (costs[left], left))\n            else:\n                right -= 1\n                heappush(q, (costs[right], right))\n    return ans", "trans_code": "public : int totalCost ( vector < int > & costs , int k , int candidates ) throw ( ) {\n  int n = costs . size ( ) ;\n  vector < int > q ;\n  int left = candidates - 1 , right = n - candidates ;\n  if ( left + 1 < right ) {\n    for ( int i = 0 ;\n    i < left + 1 ;\n    i ++ ) {\n      heappush ( q , ( int ) costs [ i ] ) ;\n    }\n    for ( int i = right ;\n    i < n ;\n    i ++ ) {\n      heappush ( q , ( int ) costs [ i ] ) ;\n    }\n  }\n  else {\n    for ( int i = 0 ;\n    i < n ;\n    i ++ ) {\n      heappush ( q , ( int ) costs [ i ] ) ;\n    }\n  }\n  int ans = 0 ;\n  for ( ;\n  ;\n  ) {\n    int cost , idx = heappop ( q ) ;\n    ans += cost ;\n    if ( left + 1 < right ) {\n      if ( idx <= left ) {\n        left ++ ;\n        heappush ( q , ( int ) costs [ left ] ) ;\n      }\n      else {\n        right -- ;\n        heappush ( q , ( int ) costs [ right ] ) ;\n      }\n    }\n  }\n  return ans ;\n}\n", "reference_code": "    long long totalCost(vector<int>& costs, int k, int candidates) {\n        int n = costs.size();\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> q;\n        int left = candidates - 1, right = n - candidates;\n        if (left + 1 < right) {\n            for (int i = 0; i <= left; ++i) {\n                q.emplace(costs[i], i);\n            }\n            for (int i = right; i < n; ++i) {\n                q.emplace(costs[i], i);\n            }\n        }\n        else {\n            for (int i = 0; i < n; ++i) {\n                q.emplace(costs[i], i);\n            }\n        }\n        long long ans = 0;\n        for (int _ = 0; _ < k; ++_) {\n            auto [cost, id] = q.top();\n            q.pop();\n            ans += cost;\n            if (left + 1 < right) {\n                if (id <= left) {\n                    ++left;\n                    q.emplace(costs[left], left);\n                }\n                else {\n                    --right;\n                    q.emplace(costs[right], right);\n                }\n            }\n        }\n        return ans;\n    }", "target_Lan": "cpp###totalCost.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <utility>\n// TOFILL\nint main() {\n    vector<int> costs1 = {1,2,3,4,5};\n    vector<int> costs2 = {10,20,30,40,50};\n    vector<int> costs3 = {100,200,300,400,500};\n    vector<int> costs4 = {1000,2000,3000,4000,5000};\n    vector<int> costs5 = {10000,20000,30000,40000,50000};\n    cout << totalCost(costs1, 2, 2) << endl;\n    cout << totalCost(costs2, 3, 1) << endl;\n    cout << totalCost(costs3, 5, 3) << endl;\n    cout << totalCost(costs4, 1, 4) << endl;\n    cout << totalCost(costs5, 4, 5) << endl;\n    return 0;\n}"}, {"source_Lan": "python###distinctIntegers.py", "source_code": "def distinctIntegers( n: int) -> int:\n    nums = [0] * (n + 1)\n    nums[n] = 1\n    for _ in range(0, n):\n        for x in range(1, n + 1):\n            if nums[x] == 0:\n                continue\n            for i in range(1, n + 1):\n                if x % i == 1:\n                    nums[i] = 1\n    return sum(nums)", "trans_code": "public : int distinctIntegers ( int n ) throw ( ) {\n  vector < int > nums ( n + 1 , 0 ) ;\n  nums [ n ] = 1 ;\n  for ( ;\n  ;\n  ) {\n    for ( int x = 1 ;\n    x <= n ;\n    x ++ ) {\n      if ( nums [ x ] == 0 ) continue ;\n      for ( int i = 1 ;\n      i <= n ;\n      i ++ ) {\n        if ( x % i == 1 ) nums [ i ] = 1 ;\n      }\n    }\n  }\n  return sum ( nums ) ;\n}\n", "reference_code": "    int distinctIntegers(int n) {\n        vector<int> nums(n + 1);\n        nums[n] = 1;\n        for (int k = 0; k < n; k++) {\n            for (int x = 1; x <= n; x++) {\n                if (nums[x] == 0) {\n                    continue;\n                }\n                for (int i = 1; i <= n; i++) {\n                    if (x % i == 1) {\n                        nums[i] = 1;\n                    }\n                }\n            }\n        }\n        return accumulate(nums.begin(), nums.end(), 0);\n    }", "target_Lan": "cpp###distinctIntegers.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <numeric>\n// TOFILL\nint main() {\n    cout << distinctIntegers(0) << endl;\n    cout << distinctIntegers(1) << endl;\n    cout << distinctIntegers(5) << endl;\n    cout << distinctIntegers(10) << endl;\n    cout << distinctIntegers(100) << endl;\n}"}, {"source_Lan": "python###minLength.py", "source_code": "def minLength( s: str) -> int:\n    stack = []\n    for c in s:\n        stack.append(c)\n        if len(stack) >= 2 and ((stack[-2] == 'A' and stack[-1] == 'B') or (stack[-2] == 'C' and stack[-1] == 'D')):\n            stack.pop()\n            stack.pop()\n    return len(stack)", "trans_code": "int minLength ( string s ) throw ( ) {\n  stack < char > stack ;\n  for ( int i = 0 ;\n  i < s . length ( ) ;\n  i ++ ) {\n    stack . push ( s [ i ] ) ;\n    if ( stack . size ( ) >= 2 && ( ( stack [ stack . size ( ) - 2 ] == 'A' && stack [ stack . size ( ) - 1 ] == 'B' ) || ( stack [ stack . size ( ) - 2 ] == 'C' && stack [ stack . size ( ) - 1 ] == 'D' ) ) ) {\n      stack . pop ( ) ;\n      stack . pop ( ) ;\n    }\n  }\n  return stack . size ( ) ;\n}\n", "reference_code": "    int minLength(string s) {\n        vector<int> st;\n        for (char c : s) {\n            st.push_back(c);\n            int m = st.size();\n            if (m >= 2 &&\n                (st[m - 2] == 'A' && st[m - 1] == 'B' ||\n                st[m - 2] == 'C' && st[m - 1] == 'D')) {\n                st.pop_back();\n                st.pop_back();\n            }\n        }\n        return st.size();\n    }", "target_Lan": "cpp###minLength.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <string>\n// TOFILL\nint main() {\n    cout << minLength(\"AB\") << endl;\n    cout << minLength(\"CD\") << endl;\n    cout << minLength(\"ABCD\") << endl;\n    cout << minLength(\"AA\") << endl;\n    cout << minLength(\"BB\") << endl;\n}"}, {"source_Lan": "python###addMinimum.py", "source_code": "def addMinimum( word: str) -> int:\n    n = len(word)\n    d = [0] * (n + 1)\n    for i in range(1, n + 1):\n        d[i] = d[i - 1] + 2\n        if i > 1 and word[i - 1] > word[i - 2]:\n            d[i] = d[i - 1] - 1\n    return d[n]", "trans_code": "int addMinimum ( string word ) throw ( ) {\n  int n = word . size ( ) ;\n  int d [ n + 1 ] = {\n    0 }\n    ;\n    for ( int i = 1 ;\n    i <= n ;\n    i ++ ) {\n      d [ i ] = d [ i - 1 ] + 2 ;\n      if ( i > 1 && word [ i - 1 ] > word [ i - 2 ] ) d [ i ] = d [ i - 1 ] - 1 ;\n    }\n    return d [ n ] ;\n  }\n  ", "reference_code": "    int addMinimum(string word) {\n        int n = word.size();\n        vector<int> d(n + 1);\n        for (int i = 1; i <= n; i++) {\n            d[i] = d[i - 1] + 2;\n            if (i > 1 && word[i - 1] > word[i - 2]) {\n                d[i] = d[i - 1] - 1;\n            }\n        }\n        return d[n];\n    }", "target_Lan": "cpp###addMinimum.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <string>\n// TOFILL\nint main() {\n    cout << addMinimum(\"a\") << endl;\n    cout << addMinimum(\"ab\") << endl;\n    cout << addMinimum(\"ba\") << endl;\n    cout << addMinimum(\"abc\") << endl;\n    cout << addMinimum(\"cba\") << endl;\n    return 0;\n}"}, {"source_Lan": "python###minOPs.py", "source_code": "def minOPs( n : int, A : List[int]) -> int:\n    c=Counter(A)\n    t=[]\n    for el in c.values():\n        t.append(el)\n    t.sort()\n    s=0\n    ans=0\n    while s<=(n/2):\n        s+=t.pop()\n        ans+=1\n    return ans-1", "trans_code": "public : int minOPs ( int n , vector < int > A ) throw ( ) {\n  Counter c ( A ) ;\n  vector < int > t ;\n  for ( auto el : c . values ( ) ) t . push_back ( el ) ;\n  sort ( t . begin ( ) , t . end ( ) ) ;\n  int s = 0 ;\n  int ans = 0 ;\n  while ( s <= ( n / 2 ) ) {\n    s += t . back ( ) ;\n    ans ++ ;\n  }\n  return ans - 1 ;\n}\n", "reference_code": "    int minOPs(int n, vector<int> &A)\n    {\n        map<int,int> m;\n        for(auto it:A) m[it]++;\n        vector<int> v;\n        for(auto it:m) v.push_back(it.second);\n        sort(v.begin(),v.end());\n        int sum=0;\n        for(int i=v.size()-1;i>=0;i--)\n        {\n          sum+=v[i];\n          if(sum>(n/2)) return v.size()-1-i;\n        }\n    }", "target_Lan": "cpp###minOPs.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <bits/stdc++.h>\n// TOFILL\nint main() {\n    vector<int> A1 = {1,2,3,4,5};\n    cout << minOPs(5, A1) << endl;\n\n    vector<int> A2 = {1,1,1,1,1,1,1,1,1,1};\n    cout << minOPs(10, A2) << endl;\n\n    vector<int> A3 = {1,2,3};\n    cout << minOPs(3, A3) << endl;\n\n    vector<int> A4 = {1,2,3,4,5,6,7};\n    cout << minOPs(7, A4) << endl;\n\n    vector<int> A5 = {1,2,3,4,5,6,7,8,9};\n    cout << minOPs(9, A5) << endl;\n\n    return 0;\n}"}, {"source_Lan": "python###consecutiveVal.py", "source_code": "def consecutiveVal( n: int, a: List[int]) -> str:\n    \n    Set = set(a)\n    ans = \"\"\n    \n    for e in a:\n        \n        if e - 1 in Set or e + 1 in Set:\n            ans += '1'\n        else:\n            ans += '0'\n    return ans", "trans_code": "string consecutiveVal ( int n , vector < int > a ) throw ( ) {\n  set < int > Set ;\n  Set . insert ( n ) ;\n  string ans = \"\" ;\n  for ( int e = 0 ;\n  e < a . size ( ) ;\n  e ++ ) {\n    if ( a [ e - 1 ] == Set || a [ e + 1 ] == Set ) ans += '1' ;\n    else ans += '0' ;\n  }\n  return ans ;\n}\n", "reference_code": "    string consecutiveVal(int n, vector<int> &a) {\n        \n        string result = \"\";\n        unordered_map<int, bool> mp;\n        for (int i = 0; i < n; i++) {\n            mp[a[i]] = true;\n        }\n        for (int i = 0; i < n; i++) {\n            if (mp[a[i] - 1] == true || mp[a[i] + 1] == true) {\n                result += '1';\n            } else\n                result += '0';\n        }\n        return result;\n    }", "target_Lan": "cpp###consecutiveVal.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <string>\n// TOFILL\nint main() {\n    vector<int> a1 = {1, 2, 3, 4, 5};\n    cout << consecutiveVal(5, a1) << endl;\n\n    vector<int> a2 = {5, 4, 3, 2, 1};\n    cout << consecutiveVal(5, a2) << endl;\n\n    vector<int> a3 = {1, 1, 1, 1, 1};\n    cout << consecutiveVal(5, a3) << endl;\n\n    vector<int> a4 = {10, 20, 30, 40, 50};\n    cout << consecutiveVal(5, a4) << endl;\n\n    vector<int> a5 = {-1, -2, -3, -4, -5};\n    cout << consecutiveVal(5, a5) << endl;\n\n    return 0;\n}"}, {"source_Lan": "python###prefixDistinct.py", "source_code": "def prefixDistinct(n,arr):\n    ans=[]\n    s=set()\n    for el in arr:\n        s.add(el)\n        ans.append(len(s))\n    return ans", "trans_code": "public : vector < int > prefixDistinct ( int n , vector < int > arr ) {\n  vector < int > ans ;\n  set < int > s ;\n  for ( int el : arr ) {\n    s . insert ( el ) ;\n    ans . push_back ( s . size ( ) ) ;\n  }\n  return ans ;\n}\n", "reference_code": "    vector<int> prefixDistinct(int n, vector<int> &arr)\n    {\n        vector<int>ans(n);\n        set<int>s;\n        for(int i=0;i<n;i++)\n        {\n            s.insert(arr[i]);\n            ans[i]=s.size();\n        }\n        return ans;\n    }", "target_Lan": "cpp###prefixDistinct.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <set>\n// TOFILL\nint main() {\n    vector<int> arr;\n    arr = prefixDistinct(0, arr);\n    for(int i=0; i<arr.size(); i++)\n        cout << arr[i] << \" \";\n    cout << endl;\n\n    arr = {1};\n    arr = prefixDistinct(1, arr);\n    for(int i=0; i<arr.size(); i++)\n        cout << arr[i] << \" \";\n    cout << endl;\n\n    arr = {1, 1};\n    arr = prefixDistinct(2, arr);\n    for(int i=0; i<arr.size(); i++)\n        cout << arr[i] << \" \";\n    cout << endl;\n\n    arr = {1, 2, 1};\n    arr = prefixDistinct(3, arr);\n    for(int i=0; i<arr.size(); i++)\n        cout << arr[i] << \" \";\n    cout << endl;\n\n    arr = {1, 2, 3, 2, 1};\n    arr = prefixDistinct(5, arr);\n    for(int i=0; i<arr.size(); i++)\n        cout << arr[i] << \" \";\n    cout << endl;\n\n    return 0;\n}"}, {"source_Lan": "python###goodSubsetofBinaryMatrix.py", "source_code": "def goodSubsetofBinaryMatrix( grid: List[List[int]]) -> List[int]:\n    ans = []\n    mp = {}\n    m = len(grid)\n    n = len(grid[0])\n    for j in range(m):\n        st = 0\n        for i in range(n):\n            st |= (grid[j][i] << i)\n        mp[st] = j\n    if 0 in mp:\n        ans.append(mp[0])\n        return ans\n    for x, i in mp.items():\n        for y, j in mp.items():\n            if not (x & y):\n                return [min(i, j), max(i, j)]\n    return ans", "trans_code": "public : vector < vector < int >> goodSubsetofBinaryMatrix ( vector < vector < int >> & grid ) throw ( ) {\n  vector < vector < int >> ans ;\n  map < int , int > mp ;\n  int m = grid . size ( ) ;\n  int n = grid [ 0 ] . size ( ) ;\n  for ( int j = 0 ;\n  j < m ;\n  j ++ ) {\n    int st = 0 ;\n    for ( int i = 0 ;\n    i < n ;\n    i ++ ) {\n      st |= ( grid [ j ] [ i ] << i ) ;\n    }\n    mp [ st ] = j ;\n  }\n  if ( 0 == mp . size ( ) ) {\n    ans . push_back ( mp [ 0 ] ) ;\n    return ans ;\n  }\n  for ( auto x : mp ) {\n    for ( auto y : mp ) {\n      if ( ! ( x & y ) ) {\n        return {\n          min ( i , j ) , max ( i , j ) }\n          ;\n        }\n      }\n    }\n    return ans ;\n  }\n  ", "reference_code": "    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid) {\n        vector<int> ans;\n        unordered_map<int, int> mp;\n        int m = grid.size();\n        int n = grid[0].size();\n        for (int j = 0; j < m; j++) {\n            int st = 0;\n            for (int i = 0; i < n; i++) {\n                st |= (grid[j][i] << i);\n            }\n            mp[st] = j;\n        }\n        if (mp.count(0)) {\n            ans.push_back(mp[0]);\n            return ans;\n        }\n        for (auto [x, i]: mp) {\n            for (auto [y, j]: mp) {\n                if (!(x & y)) {\n                    return {min(i, j), max(i, j)};\n                }\n            }\n        }\n        return ans;\n    }", "target_Lan": "cpp###goodSubsetofBinaryMatrix.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <algorithm>\n// TOFILL\nint main() {\n    vector<vector<int>> grid1 = {{0,0,0,0,0},{0,0,0,0,0}};\n    vector<vector<int>> grid2 = {{1,1,1,1,1},{1,1,1,1,1}};\n    vector<vector<int>> grid3 = {{0,0,0,0,1},{0,0,0,0,1}};\n    vector<vector<int>> grid4 = {{1,0,0,0,0},{1,0,0,0,0}};\n    vector<vector<int>> grid5 = {{0,1,0,0,0},{0,1,0,0,0}};\n\n    vector<int> result1 = goodSubsetofBinaryMatrix(grid1);\n    vector<int> result2 = goodSubsetofBinaryMatrix(grid2);\n    vector<int> result3 = goodSubsetofBinaryMatrix(grid3);\n    vector<int> result4 = goodSubsetofBinaryMatrix(grid4);\n    vector<int> result5 = goodSubsetofBinaryMatrix(grid5);\n\n    for(int i: result1) cout << i << \" \";\n    cout << endl;\n    for(int i: result2) cout << i << \" \";\n    cout << endl;\n    for(int i: result3) cout << i << \" \";\n    cout << endl;\n    for(int i: result4) cout << i << \" \";\n    cout << endl;\n    for(int i: result5) cout << i << \" \";\n    cout << endl;\n\n    return 0;\n}"}, {"source_Lan": "python###maximumBeauty.py", "source_code": "def maximumBeauty( nums: List[int], k: int) -> int:\n    res, j, n = 0, 0, len(nums)\n    nums.sort()\n    for i in range(n):\n        while nums[i] - 2 * k > nums[j]:\n            j += 1\n        res = max(res, i - j + 1)\n    return res", "trans_code": "public : int maximumBeauty ( vector < int > & nums , int k ) throw ( ) {\n  int res = 0 , j = 0 , n = nums . size ( ) ;\n  sort ( nums . begin ( ) , nums . end ( ) ) ;\n  for ( int i = 0 ;\n  i < n ;\n  ++ i ) {\n    while ( nums [ i ] - 2 * k > nums [ j ] ) ++ j ;\n    res = max ( res , i - j + 1 ) ;\n  }\n  return res ;\n}\n", "reference_code": "    int maximumBeauty(vector<int>& nums, int k) {\n        int res = 0, n = nums.size();\n        sort(nums.begin(), nums.end());\n        for (int i = 0, j = 0; i < n; i++) {\n            while (nums[i] - 2 * k > nums[j]) {\n                j++;\n            }\n            res = max(res, i - j + 1);\n        }\n        return res;\n    }", "target_Lan": "cpp###maximumBeauty.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <algorithm>\n// TOFILL\nint main() {\n    vector<int> nums1 = {1,2,3,4,5};\n    cout << maximumBeauty(nums1, 1) << endl;\n    cout << maximumBeauty(nums1, 2) << endl;\n    cout << maximumBeauty(nums1, 3) << endl;\n    cout << maximumBeauty(nums1, 4) << endl;\n    cout << maximumBeauty(nums1, 5) << endl;\n    return 0;\n}"}, {"source_Lan": "python###stoneGameVI.py", "source_code": "def stoneGameVI( aliceValues: List[int], bobValues: List[int]) -> int:\n    values = [[a+b, a, b] for a, b in zip(aliceValues, bobValues)]\n    values.sort(reverse=True)\n    aliceSum, bobSum = sum(value[1] for value in values[::2]), sum(value[2] for value in values[1::2])\n    if aliceSum > bobSum:\n        return 1\n    elif aliceSum == bobSum:\n        return 0\n    else:\n        return -1", "trans_code": "int stoneGameVI ( const std :: vector < int > & aliceValues , const std :: vector < int > & bobValues ) throw ( ) {\n  std :: vector < std :: pair < int , int >> values ( aliceValues . size ( ) ) ;\n  std :: sort ( values . begin ( ) , values . end ( ) ) ;\n  int aliceSum = std :: accumulate ( values . begin ( ) , values . end ( ) , 0 ) , bobSum = std :: accumulate ( values . begin ( ) , values . end ( ) , 0 ) ;\n  if ( aliceSum > bobSum ) return 1 ;\n  else if ( aliceSum == bobSum ) return 0 ;\n  else return - 1 ;\n}\n", "reference_code": "    int stoneGameVI(vector<int>& aliceValues, vector<int>& bobValues) {\n        int n = aliceValues.size();\n        vector<tuple<int, int, int>> values;\n        for (int i = 0; i < aliceValues.size(); i++) {\n            values.emplace_back(aliceValues[i] + bobValues[i], aliceValues[i], bobValues[i]);\n        }\n        sort(values.begin(), values.end(), [](tuple<int, int, int> &a, tuple<int, int, int> &b) {\n            return get<0>(a) > get<0>(b);\n        });\n        int aliceSum = 0, bobSum = 0;\n        for (int i = 0; i < n; i++) {\n            if (i % 2 == 0) {\n                aliceSum += get<1>(values[i]);\n            } else {\n                bobSum += get<2>(values[i]);\n            }\n        }\n        if (aliceSum > bobSum) {\n            return 1;\n        } else if (aliceSum == bobSum) {\n            return 0;\n        } else {\n            return -1;\n        }\n    }", "target_Lan": "cpp###stoneGameVI.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <tuple>\n// TOFILL\nint main() {\n    vector<int> aliceValues1 = {1,2,3,4};\n    vector<int> bobValues1 = {2,3,4,5};\n    cout << stoneGameVI(aliceValues1, bobValues1) << endl;\n\n    vector<int> aliceValues2 = {1,1,1,1};\n    vector<int> bobValues2 = {1,1,1,1};\n    cout << stoneGameVI(aliceValues2, bobValues2) << endl;\n\n    vector<int> aliceValues3 = {1,2,3,4};\n    vector<int> bobValues3 = {4,3,2,1};\n    cout << stoneGameVI(aliceValues3, bobValues3) << endl;\n\n    vector<int> aliceValues4 = {10,20,30,40};\n    vector<int> bobValues4 = {40,30,20,10};\n    cout << stoneGameVI(aliceValues4, bobValues4) << endl;\n\n    vector<int> aliceValues5 = {1,2,3,4};\n    vector<int> bobValues5 = {1,2,3,4};\n    cout << stoneGameVI(aliceValues5, bobValues5) << endl;\n\n    return 0;\n}"}, {"source_Lan": "python###distinctDifferenceArray.py", "source_code": "def distinctDifferenceArray( nums: List[int]) -> List[int]:\n    st = set()\n    sufCnt = [0] * (len(nums) + 1)\n    for i in range(len(nums) - 1, 0, -1):\n        st.add(nums[i])\n        sufCnt[i] = len(st)\n    res = []\n    st.clear()\n    for i in range(len(nums)):\n        st.add(nums[i])\n        res.append(len(st) - sufCnt[i + 1])\n    return res", "trans_code": "public : vector < int > distinctDifferenceArray ( vector < int > & nums ) throw ( ) {\n  set < int > st ;\n  vector < int > sufCnt ( nums . size ( ) + 1 ) ;\n  for ( int i = nums . size ( ) - 1 ;\n  i > 0 ;\n  -- i ) {\n    st . insert ( nums [ i ] ) ;\n    sufCnt [ i ] = st . size ( ) ;\n  }\n  vector < int > res ;\n  st . clear ( ) ;\n  for ( int i = 0 ;\n  i < nums . size ( ) ;\n  ++ i ) {\n    st . insert ( nums [ i ] ) ;\n    res . push_back ( st . size ( ) - sufCnt [ i + 1 ] ) ;\n  }\n  return res ;\n}\n", "reference_code": "    vector<int> distinctDifferenceArray(vector<int>& nums) {\n        int n = nums.size();\n        unordered_set<int> st;\n        vector<int> sufCnt(n + 1, 0);\n        for (int i = n - 1; i > 0; i--) {\n            st.insert(nums[i]);\n            sufCnt[i] = st.size();\n        }\n        vector<int> res;\n        st.clear();\n        for (int i = 0; i < n; i++) {\n            st.insert(nums[i]);\n            res.push_back(int(st.size()) - sufCnt[i + 1]);\n        }\n        return res;\n    }", "target_Lan": "cpp###distinctDifferenceArray.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <unordered_set>\n// TOFILL\nint main() {\n    vector<int> nums1 = {1, 2, 3, 4, 5};\n    vector<int> nums2 = {5, 5, 5, 5, 5};\n    vector<int> nums3 = {-1, -2, -3, -4, -5};\n    vector<int> nums4 = {10, 20, 30, 40, 50};\n    vector<int> nums5 = {1, 3, 5, 7, 9};\n\n    vector<int> res1 = distinctDifferenceArray(nums1);\n    vector<int> res2 = distinctDifferenceArray(nums2);\n    vector<int> res3 = distinctDifferenceArray(nums3);\n    vector<int> res4 = distinctDifferenceArray(nums4);\n    vector<int> res5 = distinctDifferenceArray(nums5);\n\n    for(int i : res1) cout << i << \" \";\n    cout << endl;\n    for(int i : res2) cout << i << \" \";\n    cout << endl;\n    for(int i : res3) cout << i << \" \";\n    cout << endl;\n    for(int i : res4) cout << i << \" \";\n    cout << endl;\n    for(int i : res5) cout << i << \" \";\n    cout << endl;\n\n    return 0;\n}"}, {"source_Lan": "python###Towerheight.py", "source_code": "def Towerheight( n: int, k: int, arr: List[int]) -> int:\n    \n    st = []\n    total_height = 0\n    i = 0\n    \n    for j in range(n):\n        total_height += arr[j]\n        st.append(arr[j])\n        \n        if total_height > k:\n            \n            remove_boxes = i + 1\n            while remove_boxes > 0 and st:\n                total_height -= st.pop()\n                remove_boxes -= 1\n            i += 1\n    \n    return total_height", "trans_code": "int Towerheight ( int n , int k , int arr [ ] ) throw ( ) {\n  std :: vector < int > st ;\n  int total_height = 0 ;\n  int i = 0 ;\n  for ( int j = 0 ;\n  j < n ;\n  j ++ ) {\n    total_height += arr [ j ] ;\n    st . push_back ( arr [ j ] ) ;\n    if ( total_height > k ) {\n      int remove_boxes = i + 1 ;\n      while ( remove_boxes > 0 && st . size ( ) > 0 ) {\n        total_height -= st . back ( ) ;\n        remove_boxes -- ;\n      }\n      i ++ ;\n    }\n  }\n  return total_height ;\n}\n", "reference_code": "    int Towerheight(int n, int k, vector<int>& a) {\n        \n        stack<int> st;\n        int totalHeight = 0;\n        int i = 0;\n        \n        for (int j = 0; j < n; j++) {\n            totalHeight += a[j];\n            st.push(a[j]);\n            \n            if (totalHeight > k) {\n                \n                int removeBoxes = i + 1;\n                while (removeBoxes > 0 && !st.empty()) {\n                    totalHeight -= st.top();\n                    st.pop();\n                    removeBoxes--;\n                }\n                i++;\n            }\n        }\n        \n        return totalHeight;\n    }", "target_Lan": "cpp###Towerheight.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <stack>\n// TOFILL\nint main() {\n    vector<int> arr1 = {1, 2, 3, 4, 5};\n    cout << Towerheight(5, 10, arr1) << endl;\n\n    vector<int> arr2 = {6, 7, 8, 9, 10};\n    cout << Towerheight(5, 5, arr2) << endl;\n\n    vector<int> arr3 = {1, 2, -10};\n    cout << Towerheight(3, 5, arr3) << endl;\n\n    vector<int> arr4 = {5, 5, 5, 5};\n    cout << Towerheight(4, 15, arr4) << endl;\n\n    return 0;\n}"}, {"source_Lan": "python###arrangingHorses.py", "source_code": "def arrangingHorses( n: int, m: int,\n                    data: List[List[int]]) -> List[int]:\n    deg = [0] * (n)\n    g = [[] for _ in range(n)]\n    for el in data:\n        deg[el[0]] += 1\n        g[el[1]].append(el[0])\n    q = []\n    ans = []\n    for i in range(n):\n        if deg[i] == 0:\n            heappush(q, i)\n    while q:\n        node = heappop(q)\n        ans.append(node)\n        for el in g[node]:\n            deg[el] -= 1\n            if deg[el] == 0:\n                heappush(q, el)\n    return ans", "trans_code": "public : vector < int > arrangingHorses ( int n , int m , vector < vector < int >> & data ) throw ( ) {\n  vector < int > deg ( n , 0 ) ;\n  vector < vector < int >> g ( n , vector < int > ( n ) ) ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    deg [ i ] ++ ;\n    g [ i ] . push_back ( i ) ;\n  }\n  queue < int > q ;\n  vector < int > ans ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) if ( deg [ i ] == 0 ) heappush ( q , i ) ;\n  while ( q . size ( ) > 0 ) {\n    int node = heappop ( q ) ;\n    ans . push_back ( node ) ;\n    for ( int el : g [ node ] ) {\n      deg [ el ] -- ;\n      if ( deg [ el ] == 0 ) heappush ( q , el ) ;\n    }\n  }\n  return ans ;\n}\n", "reference_code": "    vector<int> arrangingHorses(int n, int m, vector<vector<int>>& data) {\n        vector<int> inDegree(n, 0);\n        vector<vector<int>> adjList(n);\n        for (const auto& edge : data) {\n            int a = edge[0], b = edge[1];\n            adjList[b].push_back(a); \n            ++inDegree[a];\n        }\n        priority_queue<int, vector<int>, greater<int>> pq; \n        for (int i = 0; i < n; ++i) {\n            if (inDegree[i] == 0)\n                pq.push(i);\n        }\n        vector<int> order;\n        while (!pq.empty()) {\n            int horse = pq.top();\n            pq.pop();\n            order.push_back(horse);\n            for (int neigh : adjList[horse]) {\n                --inDegree[neigh];\n                if (inDegree[neigh] == 0)\n                    pq.push(neigh);\n            }\n        }\n        return order;\n    }", "target_Lan": "cpp###arrangingHorses.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <queue>\n// TOFILL\nint main() {\n    vector<vector<int>> horses1 = {};\n    vector<vector<int>> horses2 = {};\n    vector<vector<int>> horses3 = {};\n    vector<vector<int>> horses4 = {{1, 0}};\n    vector<vector<int>> horses5 = {{1, 0}, {2, 0}, {3, 1}, {3, 2}};\n\n    vector<int> result1 = arrangingHorses(0, 0, horses1);\n    vector<int> result2 = arrangingHorses(1, 0, horses2);\n    vector<int> result3 = arrangingHorses(3, 0, horses3);\n    vector<int> result4 = arrangingHorses(2, 1, horses4);\n    vector<int> result5 = arrangingHorses(4, 4, horses5);\n\n    for(int h : result1) cout << h << \" \";\n    cout << endl;\n    for(int h : result2) cout << h << \" \";\n    cout << endl;\n    for(int h : result3) cout << h << \" \";\n    cout << endl;\n    for(int h : result4) cout << h << \" \";\n    cout << endl;\n    for(int h : result5) cout << h << \" \";\n    cout << endl;\n\n    return 0;\n}"}, {"source_Lan": "python###findAnswer.py", "source_code": "def findAnswer( n : int, A : List[int]) -> List[int]:\n    pref=[A[0]]\n    for i in range(1,n):\n        pref.append(pref[-1]+A[i])\n    s=[]\n    res=[0]*(n+1)\n    for i in range(n):\n        if pref[i]>0:\n            res[0]=i+1\n            break\n    for i in range(n-1,-1,-1):\n        while s and pref[s[-1]]<=pref[i]:\n            s.pop()\n        if not s:\n            res[i+1]=0\n        elif i<n-1:\n            res[i+1]=s[-1]-i\n        s.append(i)\n    res.pop()\n    return res", "trans_code": "public : vector < int > findAnswer ( int n , vector < int > A ) throw ( ) {\n  vector < int > pref ;\n  pref . push_back ( A [ 0 ] ) ;\n  for ( int i = 1 ;\n  i < n ;\n  i ++ ) {\n    pref . push_back ( pref . back ( ) + A [ i ] ) ;\n  }\n  vector < int > s ;\n  vector < int > res ( n + 1 , 0 ) ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    if ( pref [ i ] > 0 ) {\n      res [ 0 ] = i + 1 ;\n      break ;\n    }\n  }\n  for ( int i = n - 1 ;\n  i >= 0 ;\n  i -- ) {\n    while ( s . size ( ) > 0 && pref [ s [ s . size ( ) - 1 ] ] <= pref [ i ] ) {\n      s . pop_back ( ) ;\n    }\n    if ( s . empty ( ) ) {\n      res [ i + 1 ] = 0 ;\n    }\n    else if ( i < n - 1 ) {\n      res [ i + 1 ] = s . back ( ) - i ;\n    }\n    s . pop_back ( ) ;\n  }\n  res . pop_back ( ) ;\n  return res ;\n}\n", "reference_code": "  vector<int> findAnswer(int n, vector<int> &A)\n  {\n    vector<long long> pref(n, A[0]);\n    for (int i = 1; i < n; i++)\n    {\n      pref[i] = pref[i - 1] + A[i];\n    }\n    stack<int> s;\n    vector<int> res(n+1, 0);\n    for (int i = 0; i < n; i++)\n    {\n      if (pref[i] > 0)\n      {\n        res[0] = i + 1;\n        break;\n      }\n    }\n    for (int i = n - 1; i >= 0; i--)\n    {\n      while (!s.empty() && pref[s.top()] <= pref[i])\n        s.pop();\n      if (s.empty())\n        res[i+1] = 0;\n      else if (i < n - 1)\n        res[i + 1] = s.top() - i;\n      s.push(i);\n    }\n    res.pop_back();\n    return res;\n  }", "target_Lan": "cpp###findAnswer.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <stack>\n// TOFILL\nint main() {\n    vector<int> input1 = {1, 2, 3, 4, 5};\n    vector<int> output1 = findAnswer(5, input1);\n    for(int x : output1) cout << x << \" \";\n    cout << endl;\n\n    vector<int> input2 = {-1, -2, -3, -4};\n    vector<int> output2 = findAnswer(4, input2);\n    for(int x : output2) cout << x << \" \";\n    cout << endl;\n\n    vector<int> input3 = {1, -1, 2, -2, 3, -3};\n    vector<int> output3 = findAnswer(6, input3);\n    for(int x : output3) cout << x << \" \";\n    cout << endl;\n\n    vector<int> input4 = {5};\n    vector<int> output4 = findAnswer(1, input4);\n    for(int x : output4) cout << x << \" \";\n    cout << endl;\n\n    vector<int> input5 = {int(1e9), int(1e9), int(1e9)};\n    vector<int> output5 = findAnswer(3, input5);\n    for(int x : output5) cout << x << \" \";\n    cout << endl;\n\n    return 0;\n}"}, {"source_Lan": "python###countKeyChanges.py", "source_code": "def countKeyChanges( s: str) -> int:\n    return sum(x != y for x, y in pairwise(s.lower()))", "trans_code": "int countKeyChanges ( const std :: string & s ) throw ( ) {\n  return std :: distance ( pairwise ( s . begin ( ) , s . end ( ) ) , pairwise ( s . begin ( ) , s . end ( ) ) ) ;\n}\n", "reference_code": "    int countKeyChanges(string s) {\n        int ans = 0;\n        for (int i = 1; i < s.length(); i++) {\n            ans += (s[i - 1] & 31) != (s[i] & 31);\n        }\n        return ans;\n    }", "target_Lan": "cpp###countKeyChanges.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <string>\n// TOFILL\nint main() {\n    cout << countKeyChanges(\"\") << endl;      // Test input 1: s=\"\"\n    cout << countKeyChanges(\"abcde\") << endl; // Test input 2: s=\"abcde\"\n    cout << countKeyChanges(\"ABCDE\") << endl; // Test input 3: s=\"ABCDE\"\n    cout << countKeyChanges(\"aBcDe\") << endl; // Test input 4: s=\"aBcDe\"\n    cout << countKeyChanges(\"!@#$%\") << endl; // Test input 5: s=\"!@#$%\"\n}"}, {"source_Lan": "python###numberOfSubarrays.py", "source_code": "def numberOfSubarrays( nums: List[int]) -> int:\n    ans = len(nums)\n    st = [[inf, 0]]  \n    for x in nums:\n        while x > st[-1][0]:\n            st.pop()\n        if x == st[-1][0]:\n            ans += st[-1][1]\n            st[-1][1] += 1\n        else:\n            st.append([x, 1])\n    return ans", "trans_code": "public : int numberOfSubarrays ( vector < int > & nums ) throw ( ) {\n  int ans = nums . size ( ) ;\n  vector < pair < int , int >> st ;\n  st . push_back ( make_pair ( inf , 0 ) ) ;\n  for ( int x : nums ) {\n    while ( x > st [ st . size ( ) - 1 ] . first ) st . pop_back ( ) ;\n    if ( x == st [ st . size ( ) - 1 ] . first ) {\n      ans += st [ st . size ( ) - 1 ] . second ;\n      st [ st . size ( ) - 1 ] . second ++ ;\n    }\n    else st . push_back ( make_pair ( x , 1 ) ) ;\n  }\n  return ans ;\n}\n", "reference_code": "    long long numberOfSubarrays(vector<int>& nums) {\n        long long ans = nums.size();\n        stack<pair<int, int>> st;\n        st.emplace(INT_MAX, 0); \n        for (int x : nums) {\n            while (x > st.top().first) {\n                st.pop();\n            }\n            if (x == st.top().first) {\n                ans += st.top().second++;\n            } else {\n                st.emplace(x, 1);\n            }\n        }\n        return ans;\n    }", "target_Lan": "cpp###numberOfSubarrays.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <stack>\n#include <utility>\n#include <climits>\n// TOFILL\nint main() {\n    vector<int> input1 = {};\n    vector<int> input2 = {1, 1, 1};\n    vector<int> input3 = {1, 2, 3, 4, 5};\n    vector<int> input4 = {5, 4, 3, 2, 1};\n    vector<int> input5 = {-2, -1, 0, 1, 1};\n\n    cout << numberOfSubarrays(input1) << endl;\n    cout << numberOfSubarrays(input2) << endl;\n    cout << numberOfSubarrays(input3) << endl;\n    cout << numberOfSubarrays(input4) << endl;\n    cout << numberOfSubarrays(input5) << endl;\n\n    return 0;\n}"}, {"source_Lan": "python###paintWalls.py", "source_code": "def paintWalls( cost: List[int], time: List[int]) -> int:\n    n = len(cost)\n    f = [inf] * (n * 2 + 1)\n    f[n] = 0\n    for (cost_i, time_i) in zip(cost, time):\n        g = [inf] * (n * 2 + 1)\n        for j in range(n * 2 + 1):\n            \n            g[min(j + time_i, n * 2)] = min(g[min(j + time_i, n * 2)], f[j] + cost_i)\n            \n            if j > 0:\n                g[j - 1] = min(g[j - 1], f[j])\n        f = g\n    return min(f[n:])", "trans_code": "int paintWalls ( vector < int > cost , vector < int > time ) throw ( ) {\n  int n = cost . size ( ) ;\n  vector < int > f ( n * 2 + 1 , inf ) ;\n  f [ n ] = 0 ;\n  for ( int cost_i = 0 ;\n  ( cost_i < n ) && ( time_i < n ) ;\n  cost_i ++ ) {\n    vector < int > g ( n * 2 + 1 , inf ) ;\n    for ( int j = 0 ;\n    j < n * 2 + 1 ;\n    j ++ ) {\n      g [ min ( j + time_i , n * 2 ) ] = min ( g [ min ( j + time_i , n * 2 ) ] , f [ j ] + cost_i ) ;\n      if ( j > 0 ) g [ j - 1 ] = min ( g [ j - 1 ] , f [ j ] ) ;\n    }\n    f = g ;\n  }\n  return min ( f . begin ( ) , f . end ( ) ) ;\n}\n", "reference_code": "    int paintWalls(vector<int>& cost, vector<int>& time) {\n        int n = cost.size();\n        vector<int> f(n * 2 + 1, INT_MAX / 2);\n        f[n] = 0;\n        for (int i = 0; i < n; ++i) {\n            vector<int> g(n * 2 + 1, INT_MAX / 2);\n            for (int j = 0; j <= n * 2; ++j) {\n                \n                g[min(j + time[i], n * 2)] = min(g[min(j + time[i], n * 2)], f[j] + cost[i]);\n                \n                if (j > 0) {\n                    g[j - 1] = min(g[j - 1], f[j]);\n                }\n            }\n            f = move(g);\n        }\n        return *min_element(f.begin() + n, f.end());\n    }", "target_Lan": "cpp###paintWalls.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n// TOFILL\nint main() {\n    vector<int> cost1 = {}, time1 = {};\n    vector<int> cost2 = {10}, time2 = {3};\n    vector<int> cost3 = {1, 2, 3}, time3 = {1, 2, 3};\n    vector<int> cost4 = {5, 10, 15}, time4 = {3, 2, 1};\n    vector<int> cost5 = {8, 16, 24}, time5 = {2, 4, 6};\n\n    cout << paintWalls(cost1, time1) << endl;\n    cout << paintWalls(cost2, time2) << endl;\n    cout << paintWalls(cost3, time3) << endl;\n    cout << paintWalls(cost4, time4) << endl;\n    cout << paintWalls(cost5, time5) << endl;\n\n    return 0;\n}"}, {"source_Lan": "python###maxResult.py", "source_code": "def maxResult( nums: List[int], k: int) -> int:\n    n = len(nums)\n    dp = [0] * n\n    dp[0] = nums[0]\n    queue = deque([0])\n    for i in range(1, n):\n        while queue and queue[0] < i - k:\n            queue.popleft()\n        dp[i] = dp[queue[0]] + nums[i]\n        while queue and dp[queue[-1]] <= dp[i]:\n            queue.pop()\n        queue.append(i)\n    return dp[n - 1]", "trans_code": "public : int maxResult ( vector < int > & nums , int k ) throw ( ) {\n  int n = nums . size ( ) ;\n  vector < int > dp ( n , 0 ) ;\n  dp [ 0 ] = nums [ 0 ] ;\n  deque < int > queue ( n , 0 ) ;\n  for ( int i = 1 ;\n  i < n ;\n  i ++ ) {\n    while ( queue . size ( ) > 0 && queue [ 0 ] < i - k ) queue . pop_back ( ) ;\n    dp [ i ] = dp [ queue [ 0 ] ] + nums [ i ] ;\n    while ( queue . size ( ) > 0 && dp [ queue [ queue . size ( ) - 1 ] ] <= dp [ i ] ) queue . pop_back ( ) ;\n    queue . push_back ( i ) ;\n  }\n  return dp [ n - 1 ] ;\n}\n", "reference_code": "    int maxResult(vector<int>& nums, int k) {\n        int n = nums.size();\n        vector<int> dp(n);\n        dp[0] = nums[0];\n        deque<int> queue;\n        queue.push_back(0);\n        for (int i = 1; i < n; i++) {\n            while (!queue.empty() && queue.front() < i - k) {\n                queue.pop_front();\n            }\n            dp[i] = dp[queue.front()] + nums[i];\n            while (!queue.empty() && dp[queue.back()] <= dp[i]) {\n                queue.pop_back();\n            }\n            queue.push_back(i);\n        }\n        return dp[n - 1];\n    }", "target_Lan": "cpp###maxResult.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <deque>\n// TOFILL\nint main() {\n    vector<int> nums1 = {1, 2, 3, 4};\n    int k1 = 2;\n    cout << maxResult(nums1, k1) << endl;\n\n    vector<int> nums2 = {10, -10, 20, 30, -5};\n    int k2 = 2;\n    cout << maxResult(nums2, k2) << endl;\n\n    vector<int> nums3 = {-1, -2, -3, -4};\n    int k3 = 1;\n    cout << maxResult(nums3, k3) << endl;\n\n    vector<int> nums4 = {5, 2, 8, 1, 6};\n    int k4 = 5;\n    cout << maxResult(nums4, k4) << endl;\n\n    vector<int> nums5 = {1000000000, 1000000000, -1000000000, -1000000000};\n    int k5 = 3;\n    cout << maxResult(nums5, k5) << endl;\n\n    return 0;\n}"}, {"source_Lan": "python###numberOfStableArrays.py", "source_code": "def numberOfStableArrays( zero: int, one: int, limit: int) -> int:\n        dp = [[[0, 0] for _ in range(one + 1)] for _ in range(zero + 1)]\n        mod = int(1e9 + 7)\n        for i in range(min(zero, limit) + 1):\n            dp[i][0][0] = 1\n        for j in range(min(one, limit) + 1):\n            dp[0][j][1] = 1\n        for i in range(1, zero + 1):\n            for j in range(1, one + 1):\n                if i > limit:\n                    dp[i][j][0] = dp[i - 1][j][0] + dp[i - 1][j][1] - dp[i - limit - 1][j][1]\n                else:\n                    dp[i][j][0] = dp[i - 1][j][0] + dp[i - 1][j][1]\n                dp[i][j][0] = (dp[i][j][0] % mod + mod) % mod\n                if j > limit:\n                    dp[i][j][1] = dp[i][j - 1][1] + dp[i][j - 1][0] - dp[i][j - limit - 1][0]\n                else:\n                    dp[i][j][1] = dp[i][j - 1][1] + dp[i][j - 1][0]\n                dp[i][j][1] = (dp[i][j][1] % mod + mod) % mod\n        return (dp[zero][one][0] + dp[zero][one][1]) % mod\n", "trans_code": "public : int numberOfStableArrays ( int zero , int one , int limit ) throw ( ) {\n  vector < vector < pair < int , int >>> dp ( zero + 1 , zero + 1 ) ;\n  int mod = static_cast < int > ( 1e9 + 7 ) ;\n  for ( int i = 0 ;\n  i < min ( zero , limit ) + 1 ;\n  i ++ ) dp [ i ] [ 0 ] [ 0 ] = 1 ;\n  for ( int j = 0 ;\n  j < min ( one , limit ) + 1 ;\n  j ++ ) dp [ 0 ] [ j ] [ 1 ] = 1 ;\n  for ( int i = 1 ;\n  i <= zero ;\n  i ++ ) {\n    for ( int j = 1 ;\n    j <= one ;\n    j ++ ) {\n      if ( i > limit ) dp [ i ] [ j ] [ 0 ] = dp [ i - 1 ] [ j ] [ 0 ] + dp [ i - 1 ] [ j ] [ 1 ] - dp [ i - limit - 1 ] [ j ] [ 1 ] ;\n      else dp [ i ] [ j ] [ 0 ] = dp [ i - 1 ] [ j ] [ 0 ] + dp [ i - 1 ] [ j ] [ 1 ] ;\n      dp [ i ] [ j ] [ 0 ] = ( dp [ i ] [ j ] [ 0 ] % mod + mod ) % mod ;\n      if ( j > limit ) dp [ i ] [ j ] [ 1 ] = dp [ i ] [ j - 1 ] [ 1 ] + dp [ i ] [ j - 1 ] [ 0 ] - dp [ i ] [ j - limit - 1 ] [ 0 ] ;\n      else dp [ i ] [ j ] [ 1 ] = dp [ i ] [ j - 1 ] [ 1 ] + dp [ i ] [ j - 1 ] [ 0 ] ;\n      dp [ i ] [ j ] [ 1 ] = ( dp [ i ] [ j ] [ 1 ] % mod + mod ) % mod ;\n    }\n  }\n  return ( dp [ zero ] [ one ] [ 0 ] + dp [ zero ] [ one ] [ 1 ] ) % mod ;\n}\n", "reference_code": "int numberOfStableArrays(int zero, int one, int limit) {\n        vector<vector<vector<long long>>> dp(zero + 1, vector<vector<long long>>(one + 1, vector<long long>(2)));\n        long long mod = 1e9 + 7;\n        for (int i = 0; i <= min(zero, limit); i++) {\n            dp[i][0][0] = 1;\n        }\n        for (int j = 0; j <= min(one, limit); j++) {\n            dp[0][j][1] = 1;\n        }\n        for (int i = 1; i <= zero; i++) {\n            for (int j = 1; j <= one; j++) {\n                if (i > limit) {\n                    dp[i][j][0] = dp[i - 1][j][0] + dp[i - 1][j][1] - dp[i - limit - 1][j][1];\n                } else {\n                    dp[i][j][0] = dp[i - 1][j][0] + dp[i - 1][j][1];\n                }\n                dp[i][j][0] = (dp[i][j][0] % mod + mod) % mod;\n                if (j > limit) {\n                    dp[i][j][1] = dp[i][j - 1][1] + dp[i][j - 1][0] - dp[i][j - limit - 1][0];\n                } else {\n                    dp[i][j][1] = dp[i][j - 1][1] + dp[i][j - 1][0];\n                }\n                dp[i][j][1] = (dp[i][j][1] % mod + mod) % mod;\n            }\n        }\n        return (dp[zero][one][0] + dp[zero][one][1]) % mod;\n    }", "target_Lan": "cpp###numberOfStableArrays.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\nusing namespace std;\n// TOFILL\nint main() {\n      \n    int zero1 = 0, one1 = 0, limit1 = 1;\n    int zero2 = 1, one2 = 1, limit2 = 1;\n    int zero3 = 2, one3 = 2, limit3 = 2;\n    int zero4 = 3, one4 = 3, limit4 = 1;\n    int zero5 = 5, one5 = 5, limit5 = 3;\n\n    \n    cout << numberOfStableArrays(zero1, one1, limit1) << endl; \n    cout << numberOfStableArrays(zero2, one2, limit2) << endl; \n    cout << numberOfStableArrays(zero3, one3, limit3) << endl; \n    cout << numberOfStableArrays(zero4, one4, limit4) << endl; \n    cout << numberOfStableArrays(zero5, one5, limit5) << endl; \n\n    return 0;\n}"}, {"source_Lan": "python###numberOfRightTriangles.py", "source_code": "def numberOfRightTriangles( grid: List[List[int]]) -> int:\n        n, m = len(grid), len(grid[0])\n        col = [0] * m\n        for j in range(m):\n            for i in range(n):\n                col[j] += grid[i][j]\n        res = 0\n        for i in range(n):\n            row = sum(grid[i])\n            for j in range(m):\n                if grid[i][j] == 1:\n                    res += (row - 1) * (col[j] - 1)\n        return res", "trans_code": "public : int numberOfRightTriangles ( vector < vector < int >> & grid ) throw ( ) {\n  int n = grid . size ( ) ;\n  int m = grid [ 0 ] . size ( ) ;\n  vector < int > col ( m , 0 ) ;\n  for ( int j = 0 ;\n  j < m ;\n  j ++ ) for ( int i = 0 ;\n  i < n ;\n  i ++ ) col [ j ] += grid [ i ] [ j ] ;\n  int res = 0 ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    int row = sum ( grid [ i ] ) ;\n    for ( int j = 0 ;\n    j < m ;\n    j ++ ) if ( grid [ i ] [ j ] == 1 ) res += ( row - 1 ) * ( col [ j ] - 1 ) ;\n  }\n  return res ;\n}\n", "reference_code": "long long numberOfRightTriangles(vector<vector<int>>& grid) {\n        int n = grid.size(), m = grid[0].size();\n        vector<int> col(m);\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                col[j] += grid[i][j];\n            }\n        }\n        long long res = 0;\n        for (int i = 0; i < n; i++) {\n            int row = accumulate(grid[i].begin(), grid[i].end(), 0);\n            for (int j = 0; j < m; j++) {\n                if (grid[i][j] == 1) {\n                    res += (row - 1) * (col[j] - 1);\n                }\n            }\n        }\n        return res;\n    }", "target_Lan": "cpp###numberOfRightTriangles.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <numeric> // for accumulate\nusing namespace std;\n// TOFILL\nint main() {\n    \n    vector<vector<int>> grid1 = {{0}};\n    vector<vector<int>> grid2 = {{1}};\n    vector<vector<int>> grid3 = {{1, 0}, {0, 1}};\n    vector<vector<int>> grid4 = {{1, 1}, {1, 1}};\n    vector<vector<int>> grid5 = {{0, 1, 0}, {1, 0, 1}, {0, 1, 0}};\n    \n    \n    cout  << numberOfRightTriangles(grid1) << endl;\n    cout  << numberOfRightTriangles(grid2) << endl;\n    cout  << numberOfRightTriangles(grid3) << endl;\n    cout  << numberOfRightTriangles(grid4) << endl;\n    cout  << numberOfRightTriangles(grid5) << endl;\n\n    return 0;\n}"}, {"source_Lan": "python###maxmiumScore.py", "source_code": "def maxmiumScore( cards: List[int], cnt: int) -> int:\n        cards.sort(reverse=True)\n        ans = 0\n        tmp = 0\n        odd = even = -1\n        end = len(cards) - cnt\n        for i in range(cnt):\n            tmp += cards[i]\n            if cards[i] % 2 == 1:\n                odd = cards[i]\n            else:\n                even = cards[i]\n        if tmp % 2 == 0:\n            return tmp\n        for i in range(cnt, len(cards)):\n            if cards[i] % 2 == 1:\n                if even != -1:\n                    ans = max(ans, tmp - even + cards[i])\n            else:\n                if odd != -1:\n                    ans = max(ans, tmp - odd + cards[i])\n\n        return ans", "trans_code": "public : int maxmiumScore ( vector < int > & cards , int cnt ) throw ( ) {\n  sort ( cards . begin ( ) , cards . end ( ) ) ;\n  int ans = 0 ;\n  int tmp = 0 ;\n  int odd = - 1 ;\n  int even = - 1 ;\n  int end = cards . size ( ) - cnt ;\n  for ( int i = 0 ;\n  i < cnt ;\n  i ++ ) {\n    tmp += cards [ i ] ;\n    if ( cards [ i ] % 2 == 1 ) odd = cards [ i ] ;\n    else even = cards [ i ] ;\n  }\n  if ( tmp % 2 == 0 ) return tmp ;\n  for ( int i = cnt ;\n  i < end ;\n  i ++ ) {\n    if ( cards [ i ] % 2 == 1 ) {\n      if ( even != - 1 ) ans = max ( ans , tmp - even + cards [ i ] ) ;\n    }\n    else {\n      if ( odd != - 1 ) ans = max ( ans , tmp - odd + cards [ i ] ) ;\n    }\n  }\n  return ans ;\n}\n", "reference_code": "int maxmiumScore(vector<int>& cards, int cnt) {\n        sort(cards.begin(), cards.end());\n        \n        int ans = 0;\n        int tmp = 0;\n        int odd, even = -1;\n        int end = cards.size() - cnt;\n        for (int i = cards.size() - 1; i >= end; i--) {\n            tmp += cards[i];\n            if (cards[i] & 1) {\n                odd = cards[i];\n            } else {\n                even = cards[i];\n            }\n        }\n\n        if (!(tmp & 1)) {\n            return tmp;\n        }\n\n        for (int i = cards.size() - cnt - 1; i >= 0; i--) {\n            if (cards[i] & 1) {\n                if (even != -1) {\n                    ans = max(ans, tmp - even + cards[i]);\n                }\n            } else {\n                if (odd != -1) {\n                    ans = max(ans, tmp - odd + cards[i]);\n                }\n            }\n        }\n        return ans;\n    }", "target_Lan": "cpp###maxmiumScore.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <algorithm> // for sort and max\nusing namespace std;\n// TOFILL\nint main() {\n    \n    vector<int> cards1 = {1};\n    int cnt1 = 1;\n\n    vector<int> cards2 = {2, 4, 6};\n    int cnt2 = 2;\n\n    vector<int> cards3 = {1, 3, 5, 7};\n    int cnt3 = 3;\n\n    vector<int> cards4 = {1, 2, 3, 4, 5, 6};\n    int cnt4 = 4;\n\n    vector<int> cards5 = {10, 20, 30, 40, 50};\n    int cnt5 = 3;\n\n    \n    cout << maxmiumScore(cards1, cnt1) << endl;\n    cout << maxmiumScore(cards2, cnt2) << endl;\n    cout << maxmiumScore(cards3, cnt3) << endl;\n    cout << maxmiumScore(cards4, cnt4) << endl;\n    cout << maxmiumScore(cards5, cnt5) << endl;\n\n    return 0;\n}"}, {"source_Lan": "python###minRectanglesToCoverPoints.py", "source_code": "def minRectanglesToCoverPoints( points: List[List[int]], w: int) -> int:\n        points.sort()\n        res = 0\n        bound = -1\n        for p in points:\n            if p[0] > bound:\n                bound = p[0] + w\n                res += 1\n        return res\n", "trans_code": "int minRectanglesToCoverPoints ( vector < vector < int >> & points , int w ) throw ( ) {\n  sort ( points . begin ( ) , points . end ( ) ) ;\n  int res = 0 ;\n  int bound = - 1 ;\n  for ( auto p : points ) {\n    if ( p . first > bound ) {\n      bound = p . first + w ;\n      res ++ ;\n    }\n  }\n  return res ;\n}\n", "reference_code": "int minRectanglesToCoverPoints(vector<vector<int>>& points, int w) {\n        sort(points.begin(), points.end());\n        int res = 0;\n        int bound = -1;\n        for (auto &p : points) {\n            if (p[0] > bound) {\n                bound = p[0] + w;\n                res++;\n            }\n        }\n        return res;\n    }", "target_Lan": "cpp###minRectanglesToCoverPoints.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n// TOFILL\nint main() {\n    \n    vector<vector<int>> points1 = {{0, 0}};\n    int w1 = 1;\n\n    vector<vector<int>> points2 = {{0, 0}, {2, 0}};\n    int w2 = 1;\n\n    vector<vector<int>> points3 = {{0, 0}, {1, 0}, {2, 0}};\n    int w3 = 2;\n\n    vector<vector<int>> points4 = {{1, 0}, {3, 0}, {5, 0}, {7, 0}};\n    int w4 = 3;\n\n    vector<vector<int>> points5 = {{0, 0}, {100, 0}, {200, 0}};\n    int w5 = 50;\n\n    \n    cout << minRectanglesToCoverPoints(points1, w1) << endl;\n    cout << minRectanglesToCoverPoints(points2, w2) << endl;\n    cout << minRectanglesToCoverPoints(points3, w3) << endl;\n    cout << minRectanglesToCoverPoints(points4, w4) << endl;\n    cout << minRectanglesToCoverPoints(points5, w5) << endl;\n\n    return 0;\n}"}, {"source_Lan": "python###getSmallestString.py", "source_code": "def getSmallestString( s: str, k: int) -> str:\n        ans = list(s)\n        for i, ch in enumerate(s):\n            dis = min(ord(s[i]) - ord('a'), ord('z') - ord(s[i]) + 1)\n            if dis <= k:\n                ans[i] = 'a'\n                k -= dis\n            else:\n                ans[i] = chr(ord(ans[i]) - k)\n                break\n        return \"\".join(ans)", "trans_code": "string getSmallestString ( string s , int k ) throw ( ) {\n  string ans = vector < char > ( s . size ( ) ) ;\n  for ( int i = 0 , n = s . size ( ) ;\n  i < n ;\n  i ++ ) {\n    int dis = min ( ( char ) s [ i ] - 'a' , ( char ) 'z' - s [ i ] + 1 ) ;\n    if ( dis <= k ) {\n      ans [ i ] = 'a' ;\n      k -= dis ;\n    }\n    else {\n      ans [ i ] = ( char ) ( ( int ) ans [ i ] - k ) ;\n      break ;\n    }\n  }\n  return ans ;\n}\n", "reference_code": "string getSmallestString(string s, int k) {\n        for (int i = 0; i < s.size(); ++i) {\n            int dis = min(s[i] - 'a', 'z' - s[i] + 1);\n            if (dis <= k) {\n                s[i] = 'a';\n                k -= dis;\n            }\n            else {\n                s[i] -= k;\n                break;\n            }\n        }\n        return s;\n    }", "target_Lan": "cpp###getSmallestString.cpp", "target_code_shell": "#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\n// TOFILL\nint main() {\n    \n    string s1 = \"abc\";\n    int k1 = 1;\n    string s2 = \"abc\";\n    int k2 = 2;\n    string s3 = \"azb\";\n    int k3 = 3;\n    string s4 = \"xyz\";\n    int k4 = 5;\n    string s5 = \"hello\";\n    int k5 = 5;\n\n    \n    cout << getSmallestString(s1, k1) << endl;\n    cout << getSmallestString(s2, k2) << endl;\n    cout << getSmallestString(s3, k3) << endl;\n    cout << getSmallestString(s4, k4) << endl;\n    cout << getSmallestString(s5, k5) << endl;\n\n    return 0;\n}"}, {"source_Lan": "python###relocateMarbles.py", "source_code": "def relocateMarbles( nums: List[int], moveFrom: List[int], moveTo: List[int]) -> List[int]:\n        mp = {}\n        ans = []\n        for num in nums:\n            mp[num] = True\n        for i in range(len(moveFrom)):\n            if moveFrom[i] in mp:\n                del mp[moveFrom[i]]\n            mp[moveTo[i]] = True\n        ans = list(mp.keys())\n        ans.sort()\n        return ans", "trans_code": "public : vector < int > relocateMarbles ( vector < int > & nums , vector < int > & moveFrom , vector < int > & moveTo ) throw ( ) {\n  unordered_map < int , bool > mp ;\n  vector < int > ans ;\n  for ( int num : nums ) mp [ num ] = true ;\n  for ( int i = 0 ;\n  i < moveFrom . size ( ) ;\n  i ++ ) {\n    if ( moveFrom [ i ] < mp [ moveFrom [ i ] ] ) {\n      swap ( mp [ moveFrom [ i ] ] , mp [ moveFrom [ i ] ] ) ;\n    }\n    mp [ moveTo [ i ] ] = true ;\n  }\n  ans = vector < int > ( mp . begin ( ) , mp . end ( ) ) ;\n  sort ( ans . begin ( ) , ans . end ( ) ) ;\n  return ans ;\n}\n", "reference_code": "vector<int> relocateMarbles(vector<int>& nums, vector<int>& moveFrom, vector<int>& moveTo) {\n        vector<int> ans;\n        unordered_map<int, bool> mp;\n\n        for (int i = 0; i < nums.size(); i++) {\n            mp[nums[i]] = true;\n        }\n\n        for (int i = 0; i < moveFrom.size(); i++) {\n            mp.erase(moveFrom[i]);\n            mp[moveTo[i]] = true;\n        }\n\n        for (const auto& pair : mp) {\n            ans.push_back(pair.first);\n        }\n        sort(ans.begin(), ans.end());\n        return ans;\n    }", "target_Lan": "cpp###relocateMarbles.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <algorithm>\nusing namespace std;\n// TOFILL\nint main() {\n    \n    vector<int> nums1 = {1, 2, 3};\n    vector<int> moveFrom1 = {1};\n    vector<int> moveTo1 = {4};\n\n    vector<int> nums2 = {1, 2, 3};\n    vector<int> moveFrom2 = {1, 2};\n    vector<int> moveTo2 = {5, 6};\n\n    vector<int> nums3 = {1, 2, 3};\n    vector<int> moveFrom3 = {1};\n    vector<int> moveTo3 = {1};\n\n    vector<int> nums4 = {1, 2, 3, 4};\n    vector<int> moveFrom4 = {1, 2};\n    vector<int> moveTo4 = {5, 6};\n\n    vector<int> nums5 = {1, 2, 3};\n    vector<int> moveFrom5 = {};\n    vector<int> moveTo5 = {};\n\n    \n    vector<int> result1 = relocateMarbles(nums1, moveFrom1, moveTo1);\n    for(int i : result1) cout << i << \" \";\n    cout << endl;\n\n    vector<int> result2 = relocateMarbles(nums2, moveFrom2, moveTo2);\n    for(int i : result2) cout << i << \" \";\n    cout << endl;\n\n    vector<int> result3 = relocateMarbles(nums3, moveFrom3, moveTo3);\n    for(int i : result3) cout << i << \" \";\n    cout << endl;\n\n    vector<int> result4 = relocateMarbles(nums4, moveFrom4, moveTo4);\n    for(int i : result4) cout << i << \" \";\n    cout << endl;\n\n    vector<int> result5 = relocateMarbles(nums5, moveFrom5, moveTo5);\n    for(int i : result5) cout << i << \" \";\n    cout << endl;\n\n    return 0;\n}"}, {"source_Lan": "python###findValueOfPartition.py", "source_code": "def findValueOfPartition( nums: List[int]) -> int:\n        nums.sort()\n        res = float('inf')\n        for i in range(1, len(nums)):\n            res = min(res, nums[i] - nums[i - 1])\n        return res", "trans_code": "public : int findValueOfPartition ( vector < int > & nums ) throw ( ) {\n  sort ( nums . begin ( ) , nums . end ( ) ) ;\n  int res = numeric_limits < int > :: infinity ( ) ;\n  for ( int i = 1 ;\n  i < nums . size ( ) ;\n  ++ i ) {\n    res = min ( res , nums [ i ] - nums [ i - 1 ] ) ;\n  }\n  return res ;\n}\n", "reference_code": "int findValueOfPartition(vector<int>& nums) {\n        sort(nums.begin(), nums.end());\n        int res = INT_MAX;\n        for (int i = 1; i < nums.size(); i++) {\n            res = min(res, nums[i] - nums[i - 1]);\n        }\n        return res;\n    }", "target_Lan": "cpp###findValueOfPartition.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\nusing namespace std;\n// TOFILL\nint main() {\n    \n    vector<int> nums1 = {1, 3, 6, 10};\n    cout << findValueOfPartition(nums1) << endl;  \n\n    \n    vector<int> nums2 = {1, 2, 2, 4, 6};\n    cout << findValueOfPartition(nums2) << endl;  \n\n    \n    vector<int> nums3 = {1};\n    cout << findValueOfPartition(nums3) << endl;  \n\n    \n    vector<int> nums4 = {10, 20, 30, 40, 50};\n    cout << findValueOfPartition(nums4) << endl;  \n\n    \n    vector<int> nums5 = {1, 1000000000, 500000000};\n    cout << findValueOfPartition(nums5) << endl;  \n\n    return 0;\n}"}, {"source_Lan": "python###maximumSubarraySum.py", "source_code": "def maximumSubarraySum( nums: List[int], k: int) -> int:\n    ans = -inf\n    min_s = defaultdict(lambda: inf)\n    s = 0\n    for x in nums:\n        ans = max(ans, s + x - min(min_s[x - k], min_s[x + k]))\n        min_s[x] = min(min_s[x], s)\n        s += x\n    return ans if ans > -inf else 0", "trans_code": "public : int maximumSubarraySum ( vector < int > & nums , int k ) throw ( ) {\n  int ans = - inf ;\n  map < int , int > min_s ;\n  int s = 0 ;\n  for ( int x : nums ) {\n    ans = max ( ans , s + x - min ( min_s [ x - k ] , min_s [ x + k ] ) ) ;\n    min_s [ x ] = min ( min_s [ x ] , s ) ;\n    s += x ;\n  }\n  return ans == - inf ? 0 : ans ;\n}\n", "reference_code": "    long long maximumSubarraySum(vector<int> nums, int k) {\n        long long ans = LLONG_MIN, sum = 0;\n        unordered_map<int, long long> min_s;\n        for (int x: nums) {\n            auto it = min_s.find(x + k);\n            if (it != min_s.end()) {\n                ans = max(ans, sum + x - it->second);\n            }\n            it = min_s.find(x - k);\n            if (it != min_s.end()) {\n                ans = max(ans, sum + x - it->second);\n            }\n            it = min_s.find(x);\n            if (it == min_s.end() || sum < it->second) {\n                min_s[x] = sum;\n            }\n            sum += x;\n        }\n        return ans == LLONG_MIN ? 0 : ans;\n    }", "target_Lan": "cpp###maximumSubarraySum.cpp", "target_code_shell": "#include <vector>\n#include <unordered_map>\n#include <limits>\n#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <climits>\n// TOFILL\nint main() {\n    vector<int> nums1 = {1, 2, 3, 4, 5};\n    cout << maximumSubarraySum(nums1, 2) << endl;\n\n    vector<int> nums2 = {5, 4, 3, 2, 1};\n    cout << maximumSubarraySum(nums2, 1) << endl;\n\n    vector<int> nums3 = {-1, -2, -3, -4, -5};\n    cout << maximumSubarraySum(nums3, 3) << endl;\n\n    vector<int> nums4 = {10, 20, 30, 40, 50};\n    cout << maximumSubarraySum(nums4, 10) << endl;\n\n    vector<int> nums5 = {5, 5, 5, 5, 5};\n    cout << maximumSubarraySum(nums5, 5) << endl;\n\n    return 0;\n}"}, {"source_Lan": "python###maxPointsInsideSquare.py", "source_code": " def maxPointsInsideSquare( points: List[List[int]], s: str) -> int:\n        min1 = [inf] * 26\n        min2 = inf\n        n = len(s)\n        for i in range(n):\n            x, y = points[i]\n            j = ord(s[i]) - ord('a')\n            d = max(abs(x), abs(y))\n            if d < min1[j]:\n                min2 = min(min2, min1[j])\n                min1[j] = d\n            elif d < min2:\n                min2 = d\n        return sum(d < min2 for d in min1)", "trans_code": "public : int maxPointsInsideSquare ( vector < vector < int >> points , string s ) throw ( ) {\n  int min1 [ 26 ] = {\n    inf }\n    ;\n    int min2 = inf ;\n    int n = s . size ( ) ;\n    for ( int i = 0 ;\n    i < n ;\n    i ++ ) {\n      int x = points [ i ] [ 0 ] ;\n      int y = points [ i ] [ 1 ] ;\n      int j = toupper ( s [ i ] [ 0 ] ) - toupper ( s [ i ] [ 1 ] ) ;\n      int d = max ( abs ( x ) , abs ( y ) ) ;\n      if ( d < min1 [ j ] ) {\n        min2 = min ( min2 , min1 [ j ] ) ;\n        min1 [ j ] = d ;\n      }\n      else if ( d < min2 ) {\n        min2 = d ;\n      }\n    }\n    return sum ( d < min2 ) ;\n  }\n  ", "reference_code": "int maxPointsInsideSquare(vector<vector<int>>& points, string s) {\n        vector<int> min1(26, 1000000001);\n        int min2 = 1000000001;\n        int n = s.length();\n        for (int i = 0; i < n; ++i) {\n            int x = points[i][0], y = points[i][1], j = s[i] - 'a';\n            int d = max(abs(x), abs(y));\n            if (d < min1[j]) {\n                min2 = min(min2, min1[j]);\n                min1[j] = d;\n            } else if (d < min2) {\n                min2 = d;\n            }\n        }\n        int res = 0;\n        for (int d : min1) {\n            if (d < min2) {\n                ++res;\n            }\n        }\n        return res;\n    }", "target_Lan": "cpp###maxPointsInsideSquare.cpp", "target_code_shell": "#include <vector>\n#include <string>\n#include <algorithm>\n#include <cmath>\n#include <limits>\n#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n// TOFILL\nint main() {\n    \n    vector<vector<int>> points1 = {{0, 0}};\n    string s1 = \"a\";\n    \n    vector<vector<int>> points2 = {{1, 1}, {-1, -1}, {2, 2}};\n    string s2 = \"abc\";\n    \n    vector<vector<int>> points3 = {{1, 1}, {2, 2}, {3, 3}};\n    string s3 = \"aaa\";\n    \n    vector<vector<int>> points4 = {{1, 1}, {0, 0}, {-1, -1}, {2, 2}};\n    string s4 = \"aabb\";\n    \n    vector<vector<int>> points5 = {{1000000, 1000000}, {-1000000, -1000000}, {500000, 500000}};\n    string s5 = \"xyz\";\n\n    \n    cout << maxPointsInsideSquare(points1, s1) << endl;  \n    cout << maxPointsInsideSquare(points2, s2) << endl;  \n    cout << maxPointsInsideSquare(points3, s3) << endl;  \n    cout << maxPointsInsideSquare(points4, s4) << endl;  \n    cout << maxPointsInsideSquare(points5, s5) << endl;  \n\n    return 0;\n}"}, {"source_Lan": "python###minimumOperations.py", "source_code": " def minimumOperations( num: str) -> int:\n        n = len(num)\n        find0 = find5 = False\n        for i in range(n - 1, -1, -1):\n            if num[i] in ['0', '5']:\n                if find0:\n                    return n - i - 2\n                if num[i] == '0':\n                    find0 = True\n                else:\n                    find5 = True\n            elif num[i] in ['2', '7']:\n                if find5:\n                    return n - i - 2\n        if find0:\n            return n - 1\n        return n", "trans_code": "public : int minimumOperations ( string num ) throw ( ) {\n  int n = num . size ( ) ;\n  bool find0 = find5 = false ;\n  for ( int i = n - 1 ;\n  i >= 0 ;\n  i -- ) {\n    if ( num [ i ] == '0' || num [ i ] == '5' ) {\n      if ( find0 ) return n - i - 2 ;\n      if ( num [ i ] == '0' ) find0 = true ;\n      else find5 = true ;\n    }\n    else if ( num [ i ] == '2' || num [ i ] == '7' ) {\n      if ( find5 ) return n - i - 2 ;\n    }\n  }\n  if ( find0 ) return n - 1 ;\n  return n ;\n}\n", "reference_code": "int minimumOperations(string num) {\n        int n = num.length();\n        bool find0 = false, find5 = false;\n        for (int i = n - 1; i >= 0; --i) {\n            if (num[i] == '0' || num[i] == '5') {\n                if (find0) {\n                    return n - i - 2;\n                }\n                if (num[i] == '0') {\n                    find0 = true;\n                } else {\n                    find5 = true;\n                }\n            } else if (num[i] == '2' || num[i] == '7') {\n                if (find5) {\n                    return n - i - 2;\n                }\n            }\n        }\n        if (find0) {\n            return n - 1;\n        }\n        return n;\n    }", "target_Lan": "cpp###minimumOperations.cpp", "target_code_shell": "#include <string>\n#include <iostream>\n#include <string>\nusing namespace std;\n// TOFILL\nint main() {\n    \n    string num1 = \"123450\";\n    string num2 = \"1234050\";\n    string num3 = \"1750\";\n    string num4 = \"122567\";\n    string num5 = \"000\";\n\n    \n    cout << minimumOperations(num1) << endl;\n    cout << minimumOperations(num2) << endl;\n    cout << minimumOperations(num3) << endl;\n    cout << minimumOperations(num4) << endl;\n    cout << minimumOperations(num5) << endl;\n\n    return 0;\n}"}, {"source_Lan": "python###minimumAddedCoins.py", "source_code": "def minimumAddedCoins( coins: List[int], target: int) -> int:\n        coins.sort()\n        ans, x = 0, 1\n        length, index = len(coins), 0\n        while x <= target:\n            if index < length and coins[index] <= x:\n                x += coins[index]\n                index += 1\n            else:\n                x <<= 1\n                ans += 1\n        return ans", "trans_code": "public : int minimumAddedCoins ( vector < int > coins , int target ) throw ( ) {\n  sort ( coins . begin ( ) , coins . end ( ) ) ;\n  int ans = 0 , x = 1 ;\n  int length = coins . size ( ) , index = 0 ;\n  while ( x <= target ) {\n    if ( index < length && coins [ index ] <= x ) {\n      x += coins [ index ] ;\n      index ++ ;\n    }\n    else {\n      x <<= 1 ;\n      ans ++ ;\n    }\n  }\n  return ans ;\n}\n", "reference_code": "int minimumAddedCoins(vector<int>& coins, int target) {\n        sort(coins.begin(), coins.end());\n        int ans = 0;\n        int x = 1;\n        int length = coins.size(), index = 0;\n        while (x <= target) {\n            if (index < length && coins[index] <= x) {\n                x += coins[index];\n                index++;\n            } else {\n                x <<= 1;\n                ans++;\n            }\n        }\n        return ans;\n    }", "target_Lan": "cpp###minimumAddedCoins.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <algorithm>\n// TOFILL\nint main() {\n    vector<int> coins1 = {};\n    cout << minimumAddedCoins(coins1, 10) << endl;\n\n    vector<int> coins2 = {5, 7, 9};\n    cout << minimumAddedCoins(coins2, 1) << endl;\n\n    vector<int> coins3 = {1, 2, 3};\n    cout << minimumAddedCoins(coins3, 6) << endl;\n\n    vector<int> coins4 = {1, 2};\n    cout << minimumAddedCoins(coins4, 12) << endl;\n\n    vector<int> coins5 = {2, 4, 8};\n    cout << minimumAddedCoins(coins5, 15) << endl;\n\n    return 0;\n}"}, {"source_Lan": "python###maximumSumOfHeights.py", "source_code": "def maximumSumOfHeights(maxHeights: List[int]) -> int:\n    n = len(maxHeights)\n    res = 0\n    prefix, suffix = [0] * n, [0] * n\n    stack1, stack2 = [], []\n    for i in range(n):\n        while len(stack1) > 0 and maxHeights[i] < maxHeights[stack1[-1]]:\n            stack1.pop()\n        if len(stack1) == 0:\n            prefix[i] = (i + 1) * maxHeights[i]\n        else:\n            prefix[i] = prefix[stack1[-1]] + (i - stack1[-1]) * maxHeights[i]\n        stack1.append(i)\n    for i in range(n - 1, -1, -1):\n        while len(stack2) > 0 and maxHeights[i] < maxHeights[stack2[-1]]:\n            stack2.pop()\n        if len(stack2) == 0:\n            suffix[i] = (n - i) * maxHeights[i]\n        else:\n            suffix[i] = suffix[stack2[-1]] + (stack2[-1] - i) * maxHeights[i]\n        stack2.append(i)\n        res = max(res, prefix[i] + suffix[i] - maxHeights[i])\n    return res\n    ", "trans_code": "public : int maximumSumOfHeights ( vector < int > maxHeights ) throw ( ) {\n  int n = maxHeights . size ( ) ;\n  int res = 0 ;\n  vector < int > prefix ( n ) , suffix ( n ) ;\n  vector < int > stack1 ( n ) , stack2 ( n ) ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    while ( stack1 . size ( ) > 0 && maxHeights [ i ] < maxHeights [ stack1 [ stack1 . size ( ) - 1 ] ] ) stack1 . pop_back ( ) ;\n    if ( stack1 . size ( ) == 0 ) prefix [ i ] = ( i + 1 ) * maxHeights [ i ] ;\n    else prefix [ i ] = prefix [ stack1 [ stack1 . size ( ) - 1 ] ] + ( i - stack1 [ stack1 . size ( ) - 1 ] ) * maxHeights [ i ] ;\n    stack1 . push_back ( i ) ;\n  }\n  for ( int i = n - 1 ;\n  i >= 0 ;\n  i -- ) {\n    while ( stack2 . size ( ) > 0 && maxHeights [ i ] < maxHeights [ stack2 [ stack2 . size ( ) - 1 ] ] ) stack2 . pop_back ( ) ;\n    if ( stack2 . size ( ) == 0 ) suffix [ i ] = ( n - i ) * maxHeights [ i ] ;\n    else suffix [ i ] = suffix [ stack2 [ stack2 . size ( ) - 1 ] ] + ( stack2 [ stack2 . size ( ) - 1 ] - i ) * maxHeights [ i ] ;\n    stack2 . push_back ( i ) ;\n    res = max ( res , prefix [ i ] + suffix [ i ] - maxHeights [ i ] ) ;\n  }\n  return res ;\n}\n", "reference_code": "long long maximumSumOfHeights(vector<int>& maxHeights) {\n        int n = maxHeights.size();\n        long long res = 0;\n        vector<long long> prefix(n), suffix(n);\n        stack<int> stack1, stack2;\n        for (int i = 0; i < n; i++) {\n            while (!stack1.empty() && maxHeights[i] < maxHeights[stack1.top()]) {\n                stack1.pop();\n            }\n            if (stack1.empty()) {\n                prefix[i] = (long long)(i + 1) * maxHeights[i];\n            } else {\n                prefix[i] = prefix[stack1.top()] + (long long)(i - stack1.top()) * maxHeights[i];\n            }\n            stack1.emplace(i);\n        }\n        for (int i = n - 1; i >= 0; i--) {\n            while (!stack2.empty() && maxHeights[i] < maxHeights[stack2.top()]) {\n                stack2.pop();\n            }\n            if (stack2.empty()) {\n                suffix[i] = (long long)(n - i) * maxHeights[i];\n            } else {\n                suffix[i] = suffix[stack2.top()] + (long long)(stack2.top() - i) * maxHeights[i];\n            }\n            stack2.emplace(i);\n            res = max(res, prefix[i] + suffix[i] - maxHeights[i]);\n        }\n        return res;\n    }", "target_Lan": "cpp###maximumSumOfHeights.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <stack>\n// TOFILL\nint main() {\n    vector<int> heights1 = {0, 0, 0, 0};\n    vector<int> heights2 = {1, 2, 3, 4, 5};\n    vector<int> heights3 = {5, 4, 3, 2, 1};\n    vector<int> heights4 = {1000000000, 1000000000, 1000000000, 1000000000};\n    vector<int> heights5 = {10, 1, 10, 1, 10};\n\n    cout << maximumSumOfHeights(heights1) << endl;\n    cout << maximumSumOfHeights(heights2) << endl;\n    cout << maximumSumOfHeights(heights3) << endl;\n    cout << maximumSumOfHeights(heights4) << endl;\n    cout << maximumSumOfHeights(heights5) << endl;\n\n    return 0;\n}"}, {"source_Lan": "python###isAcronym.py", "source_code": "def isAcronym( words: List[str], s: str) -> bool:\n        return len(words) == len(s) and all(words[i][0] == s[i] for i in range(len(s)))", "trans_code": "bool isAcronym ( const std :: vector < std :: string > & words , const std :: string & s ) throw ( ) {\n  return words . size ( ) == s . size ( ) && std :: equal ( words . begin ( ) , words . end ( ) , s . begin ( ) ) ;\n}\n", "reference_code": "bool isAcronym(vector<string>& words, string s) {\n        if (s.size() != words.size()) {\n            return false;\n        }\n        for (int i = 0; i < s.size(); i++) {\n            if (words[i][0] != s[i]) {\n                return false;\n            }\n        }\n        return true;\n    }", "target_Lan": "cpp###isAcronym.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <string>\n// TOFILL\nint main() {\n    vector<string> words1 = {\"apple\", \"banana\"};\n    cout << isAcronym(words1, \"ab\") << endl; \n\n    vector<string> words2 = {\"apple\", \"banana\"};\n    cout << isAcronym(words2, \"abc\") << endl; \n\n    vector<string> words3 = {\"apple\", \"banana\"};\n    cout << isAcronym(words3, \"az\") << endl; \n\n    vector<string> words4 = {};\n    cout << isAcronym(words4, \"\") << endl; \n\n    vector<string> words5 = {\"apple\"};\n    cout << isAcronym(words5, \"a\") << endl; \n\n    return 0;\n}"}, {"source_Lan": "python###possibleToStamp.py", "source_code": "def possibleToStamp( grid: List[List[int]], stampHeight: int, stampWidth: int) -> bool:\n        m, n = len(grid), len(grid[0])\n        psum = [[0] * (n + 2) for _ in range(m + 2)]\n        diff = [[0] * (n + 2) for _ in range(m + 2)]\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                psum[i][j] = psum[i - 1][j] + psum[i][j - 1] - psum[i - 1][j - 1] + grid[i - 1][j - 1]\n        for i in range(1, m + 2 - stampHeight):\n            for j in range(1, n + 2 - stampWidth):\n                x = i + stampHeight - 1\n                y = j + stampWidth - 1\n                if psum[x][y] - psum[x][j - 1] - psum[i - 1][y] + psum[i - 1][j - 1] == 0:\n                    diff[i][j] += 1\n                    diff[i][y + 1] -= 1\n                    diff[x + 1][j] -= 1\n                    diff[x + 1][y + 1] += 1\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                diff[i][j] += diff[i - 1][j] + diff[i][j - 1] - diff[i - 1][j - 1]\n                if diff[i][j] == 0 and grid[i - 1][j - 1] == 0:\n                    return False\n        return True", "trans_code": "bool possibleToStamp ( vector < vector < int >> & grid , int stampHeight , int stampWidth ) throw ( ) {\n  int m = grid . size ( ) ;\n  int n = grid [ 0 ] . size ( ) ;\n  vector < vector < int >> psum ( m + 2 ) ;\n  vector < vector < int >> diff ( m + 2 ) ;\n  for ( int i = 1 ;\n  i <= m ;\n  i ++ ) {\n    for ( int j = 1 ;\n    j <= n ;\n    j ++ ) {\n      psum [ i ] [ j ] = psum [ i - 1 ] [ j ] + psum [ i ] [ j - 1 ] - psum [ i - 1 ] [ j - 1 ] + grid [ i - 1 ] [ j - 1 ] ;\n    }\n  }\n  for ( int i = 1 ;\n  i <= m + 2 - stampHeight ;\n  i ++ ) {\n    for ( int j = 1 ;\n    j <= n + 2 - stampWidth ;\n    j ++ ) {\n      int x = i + stampHeight - 1 ;\n      int y = j + stampWidth - 1 ;\n      if ( psum [ x ] [ y ] - psum [ x ] [ j - 1 ] - psum [ i - 1 ] [ y ] + psum [ i - 1 ] [ j - 1 ] == 0 ) {\n        diff [ i ] [ j ] ++ ;\n        diff [ i ] [ y + 1 ] -- ;\n        diff [ x + 1 ] [ j ] -- ;\n        diff [ x + 1 ] [ y + 1 ] ++ ;\n      }\n    }\n  }\n  for ( int i = 1 ;\n  i <= m + 1 ;\n  i ++ ) {\n    for ( int j = 1 ;\n    j <= n + 1 ;\n    j ++ ) {\n      diff [ i ] [ j ] += diff [ i - 1 ] [ j ] + diff [ i ] [ j - 1 ] - diff [ i - 1 ] [ j - 1 ] ;\n      if ( diff [ i ] [ j ] == 0 && grid [ i - 1 ] [ j - 1 ] == 0 ) return false ;\n    }\n  }\n  return true ;\n}\n", "reference_code": "bool possibleToStamp(vector<vector<int>>& grid, int stampHeight, int stampWidth) {\n        int m = grid.size(), n = grid[0].size();\n        vector<vector<int>> sum(m + 2, vector<int>(n + 2, 0));\n        vector<vector<int>> diff(m + 2, vector<int>(n + 2, 0));\n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                sum[i][j] = sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1] + grid[i - 1][j - 1];\n            }\n        }\n        for (int i = 1; i + stampHeight - 1 <= m; i++) {\n            for (int j = 1; j + stampWidth - 1 <= n; j++) {\n                int x = i + stampHeight - 1;\n                int y = j + stampWidth - 1;\n                if (sum[x][y] - sum[x][j - 1] - sum[i - 1][y] + sum[i - 1][j - 1] == 0) {\n                    diff[i][j]++;\n                    diff[i][y + 1]--;\n                    diff[x + 1][j]--;\n                    diff[x + 1][y + 1]++;\n                }\n            }\n        }\n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                diff[i][j] += diff[i - 1][j] + diff[i][j - 1] - diff[i - 1][j - 1];\n                if (diff[i][j] == 0 && grid[i - 1][j - 1] == 0) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }", "target_Lan": "cpp###possibleToStamp.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    \n    vector<vector<int>> grid1 = {{0}};\n    cout << boolalpha << possibleToStamp(grid1, 1, 1) << endl; \n\n    \n    vector<vector<int>> grid2 = {{1, 1}, {1, 1}};\n    cout << boolalpha << possibleToStamp(grid2, 2, 2) << endl; \n\n    \n    vector<vector<int>> grid3 = {{0, 0, 0}, {0, 1, 0}, {0, 0, 0}};\n    cout << boolalpha << possibleToStamp(grid3, 2, 2) << endl; \n\n    \n    vector<vector<int>> grid4 = {{0, 1, 1}, {1, 1, 0}, {1, 0, 0}};\n    cout << boolalpha << possibleToStamp(grid4, 2, 1) << endl; \n\n    \n    vector<vector<int>> grid5 = {{0, 0}, {0, 0}};\n    cout << boolalpha << possibleToStamp(grid5, 1, 1) << endl; \n\n    return 0;\n}"}, {"source_Lan": "python###makeSmallestPalindrome.py", "source_code": "def makeSmallestPalindrome( s: str) -> str:\n        s = list(s)\n        left, right = 0, len(s) - 1\n        while left < right:\n            if s[left] != s[right]:\n                s[left] = s[right] = min(s[left], s[right])\n            left += 1\n            right -= 1\n        return \"\".join(s)", "trans_code": "public : string makeSmallestPalindrome ( string s ) throw ( ) {\n  sort ( s . begin ( ) , s . end ( ) ) ;\n  int left = 0 , right = s . size ( ) - 1 ;\n  while ( left < right ) {\n    if ( s [ left ] != s [ right ] ) s [ left ] = s [ right ] = min ( s [ left ] , s [ right ] ) ;\n    left ++ ;\n    right -- ;\n  }\n  return string ( s . begin ( ) , s . end ( ) ) ;\n}\n", "reference_code": "string makeSmallestPalindrome(string s) {\n        int left = 0, right = s.size() - 1;\n        while (left < right) {\n            if (s[left] != s[right]) {\n                s[left] = s[right] = min(s[left], s[right]);\n            }\n            ++left;\n            --right;\n        }\n        return s;\n    }", "target_Lan": "cpp###makeSmallestPalindrome.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <string>\n// TOFILL\nint main() {\n    cout << makeSmallestPalindrome(\"\") << endl;\n    cout << makeSmallestPalindrome(\"abcba\") << endl;\n    cout << makeSmallestPalindrome(\"aaaa\") << endl;\n    cout << makeSmallestPalindrome(\"abac\") << endl;\n    cout << makeSmallestPalindrome(\"AaBb\") << endl;\n}"}, {"source_Lan": "python###secondGreaterElement.py", "source_code": "def secondGreaterElement( nums: List[int]) -> List[int]:\n    res = [-1] * len(nums)\n    stack = []\n    q = []\n    for i in range(len(nums)):\n        while len(q) and q[0][0] < nums[i]:\n            res[q[0][1]] = nums[i]\n            heappop(q)\n        while len(stack) and nums[stack[-1]] < nums[i]:\n            heappush(q, (nums[stack[-1]], stack[-1]))\n            stack.pop()\n        stack.append(i)\n    return res", "trans_code": "public : vector < int > secondGreaterElement ( vector < int > & nums ) throw ( ) {\n  vector < int > res ( nums . size ( ) , - 1 ) ;\n  vector < int > stack ;\n  vector < int > q ;\n  for ( int i = 0 ;\n  i < nums . size ( ) ;\n  i ++ ) {\n    while ( q . size ( ) > 0 && q [ 0 ] . first < nums [ i ] ) {\n      res [ q [ 0 ] . second ] = nums [ i ] ;\n      heappop ( q ) ;\n    }\n    while ( stack . size ( ) > 0 && nums [ stack . back ( ) ] < nums [ i ] ) {\n      heappush ( q , ( int ) nums [ stack . back ( ) ] ) ;\n      stack . pop_back ( ) ;\n    }\n    stack . push_back ( i ) ;\n  }\n  return res ;\n}\n", "reference_code": "vector<int> secondGreaterElement(vector<int>& nums) {\n        vector<int> res(nums.size(), -1);\n        stack<int> st;\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> q;\n        for (int i = 0; i < nums.size(); ++i) {\n            while (!q.empty() && q.top().first < nums[i]) {\n                res[q.top().second] = nums[i];\n                q.pop();\n            }\n            while (!st.empty() && nums[st.top()] < nums[i]) {\n                q.push({nums[st.top()], st.top()});\n                st.pop();\n            }\n            st.push(i);\n        }\n        return res;\n    }", "target_Lan": "cpp###secondGreaterElement.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <stack>\n#include <queue>\n// TOFILL\nint main() {\n    vector<int> input1 = {};\n    vector<int> input2 = {5};\n    vector<int> input3 = {1, 2};\n    vector<int> input4 = {1, 2, 3, 4};\n    vector<int> input5 = {4, 3, 2, 1};\n    vector<int> input6 = {5, 1, 2, 6, 3, 4};\n    vector<int> input7 = {3, 1, 2, 3, 4, 1, 2};\n\n    vector<int> output1 = secondGreaterElement(input1);\n    vector<int> output2 = secondGreaterElement(input2);\n    vector<int> output3 = secondGreaterElement(input3);\n    vector<int> output4 = secondGreaterElement(input4);\n    vector<int> output5 = secondGreaterElement(input5);\n    vector<int> output6 = secondGreaterElement(input6);\n    vector<int> output7 = secondGreaterElement(input7);\n\n    for(int val : output1) cout << val << \" \";\n    cout << endl;\n    for(int val : output2) cout << val << \" \";\n    cout << endl;\n    for(int val : output3) cout << val << \" \";\n    cout << endl;\n    for(int val : output4) cout << val << \" \";\n    cout << endl;\n    for(int val : output5) cout << val << \" \";\n    cout << endl;\n    for(int val : output6) cout << val << \" \";\n    cout << endl;\n    for(int val : output7) cout << val << \" \";\n    cout << endl;\n\n    return 0;\n}"}, {"source_Lan": "python###maxTaxiEarnings.py", "source_code": "def maxTaxiEarnings( n: int, rides: List[List[int]]) -> int:\n        dp = [0] * (n + 1)\n        rideMap = {}\n        for ride in rides:\n            if ride[1] not in rideMap:\n                rideMap[ride[1]] = []\n            rideMap[ride[1]].append(ride)\n        for i in range(1, n + 1):\n            dp[i] = dp[i - 1]\n            if i not in rideMap:\n                continue\n            for ride in rideMap[i]:\n                dp[i] = max(dp[i], dp[ride[0]] + ride[1] - ride[0] + ride[2])\n        return dp[n]", "trans_code": "public : int maxTaxiEarnings ( int n , vector < vector < int >> rides ) throw ( ) {\n  vector < int > dp ( n + 1 , 0 ) ;\n  map < int , vector < int >> rideMap ;\n  for ( auto it = rides . begin ( ) ;\n  it != rides . end ( ) ;\n  ++ it ) {\n    if ( it -> second != 0 ) rideMap [ it -> first ] . push_back ( it -> second ) ;\n    rideMap [ it -> first ] . push_back ( it -> second ) ;\n  }\n  for ( int i = 1 ;\n  i <= n ;\n  ++ i ) {\n    dp [ i ] = dp [ i - 1 ] ;\n    if ( i != 0 ) continue ;\n    for ( auto it = rideMap . begin ( ) ;\n    it != rideMap . end ( ) ;\n    ++ it ) dp [ i ] = max ( dp [ i ] , dp [ it -> first ] + it -> second - it -> first + it -> second ) ;\n  }\n  return dp [ n ] ;\n}\n", "reference_code": "long long maxTaxiEarnings(int n, vector<vector<int>> &rides) {\n        vector<long long> dp(n + 1);\n        unordered_map<int, vector<vector<int>>> rideMap;\n        for (const auto &ride : rides) {\n            rideMap[ride[1]].push_back(ride);\n        }\n        for (int i = 1; i <= n; i++) {\n            dp[i] = dp[i - 1];\n            for (const auto &ride : rideMap[i]) {\n                dp[i] = max(dp[i], dp[ride[0]] + ride[1] - ride[0] + ride[2]);\n            }\n        }\n        return dp[n];\n    }", "target_Lan": "cpp###maxTaxiEarnings.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <algorithm>\n// TOFILL\nint main() {\n    \n    vector<vector<int>> rides1 = {};\n    cout << maxTaxiEarnings(0, rides1) << endl;\n    \n    vector<vector<int>> rides2 = {{0, 5, 10}, {1, 3, 5}, {2, 5, 7}};\n    cout << maxTaxiEarnings(5, rides2) << endl;\n    \n    vector<vector<int>> rides3 = {{1, 2, 1}, {2, 3, 1}, {3, 4, 3}, {4, 10, 10}};\n    cout << maxTaxiEarnings(10, rides3) << endl;\n\n    vector<vector<int>> rides4 = {{0, 2, 1}, {1, 4, 2}, {2, 7, 8}};\n    cout << maxTaxiEarnings(7, rides4) << endl;\n\n    vector<vector<int>> rides5 = {{0, 6, 12}, {1, 3, 5}, {1, 4, 7}};\n    cout << maxTaxiEarnings(6, rides5) << endl;\n\n    return 0;\n}"}, {"source_Lan": "python###carPooling.py", "source_code": "def carPooling( trips: List[List[int]], capacity: int) -> bool:\n        to_max = max(trip[2] for trip in trips)\n        diff = [0] * (to_max + 1)\n        for num_i, from_i, to_i in trips:\n            diff[from_i] += num_i\n            diff[to_i] -= num_i\n        count = 0\n        for i in range(to_max + 1):\n            count += diff[i]\n            if count > capacity:\n                return False\n        return True", "trans_code": "bool carPooling ( std :: vector < std :: vector < int >> & trips , int capacity ) throw ( ) {\n  int toMax = std :: max ( trip [ 2 ] . size ( ) , trips . size ( ) ) ;\n  std :: vector < int > diff ( toMax + 1 , 0 ) ;\n  for ( int numI = 0 , fromI = 0 , toI = 0 ;\n  numI < trips . size ( ) ;\n  numI ++ , fromI ++ , toI ++ ) {\n    diff [ fromI ] += numI ;\n    diff [ toI ] -= numI ;\n  }\n  int count = 0 ;\n  for ( int i = 0 ;\n  i < toMax + 1 ;\n  i ++ ) {\n    count += diff [ i ] ;\n    if ( count > capacity ) return false ;\n  }\n  return true ;\n}\n", "reference_code": "bool carPooling(vector<vector<int>>& trips, int capacity) {\n        int to_max = 0;\n        for (const auto& trip: trips) {\n            to_max = max(to_max, trip[2]);\n        }\n        vector<int> diff(to_max + 1);\n        for (const auto& trip: trips) {\n            diff[trip[1]] += trip[0];\n            diff[trip[2]] -= trip[0];\n        }\n        int count = 0;\n        for (int i = 0; i <= to_max; ++i) {\n            count += diff[i];\n            if (count > capacity) {\n                return false;\n            }\n        }\n        return true;\n    }", "target_Lan": "cpp###carPooling.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    vector<vector<int>> trips1 = {{2, 1, 3}, {3, 2, 5}, {1, 3, 4}};\n    int capacity1 = 5;\n    cout << carPooling(trips1, capacity1) << endl; \n\n    vector<vector<int>> trips2 = {{2, 1, 3}, {3, 2, 5}, {1, 3, 4}};\n    int capacity2 = 4;\n    cout << carPooling(trips2, capacity2) << endl; \n\n    vector<vector<int>> trips3 = {{2, 1, 5}, {2, 2, 5}, {1, 3, 5}};\n    int capacity3 = 5;\n    cout << carPooling(trips3, capacity3) << endl; \n\n    vector<vector<int>> trips4 = {{2, 1, 3}, {3, 3, 5}};\n    int capacity4 = 5;\n    cout << carPooling(trips4, capacity4) << endl; \n\n    return 0;\n}"}, {"source_Lan": "python###firstCompleteIndex.py", "source_code": "def firstCompleteIndex( arr: List[int], mat: List[List[int]]) -> int:\n        n, m = len(mat), len(mat[0])\n        mp = {}\n        for i in range(n):\n            for j in range(m):\n                mp[mat[i][j]] = [i, j]\n        rowCnt, colCnt = [0] * n, [0] * m\n        for i in range(len(arr)):\n            v = mp[arr[i]]\n            rowCnt[v[0]] += 1\n            if rowCnt[v[0]] == m:\n                return i\n            colCnt[v[1]] += 1\n            if colCnt[v[1]] == n:\n                return i\n        return -1", "trans_code": "int firstCompleteIndex ( vector < int > arr , vector < vector < int >> & mat ) throw ( ) {\n  int n = mat . size ( ) ;\n  int m = mat [ 0 ] . size ( ) ;\n  map < int , vector < int >> mp ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) for ( int j = 0 ;\n  j < m ;\n  j ++ ) mp [ mat [ i ] [ j ] ] . push_back ( i , j ) ;\n  vector < int > rowCnt ( n , 0 ) , colCnt ( m , 0 ) ;\n  for ( int i = 0 ;\n  i < arr . size ( ) ;\n  i ++ ) {\n    vector < int > v = mp [ arr [ i ] ] ;\n    rowCnt [ v [ 0 ] ] ++ ;\n    if ( rowCnt [ v [ 0 ] ] == m ) return i ;\n    colCnt [ v [ 1 ] ] ++ ;\n    if ( colCnt [ v [ 1 ] ] == n ) return i ;\n  }\n  return - 1 ;\n}\n", "reference_code": "int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\n        int n = mat.size();\n        int m = mat[0].size();\n        unordered_map<int, pair<int, int>> mp;\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                mp[mat[i][j]] = {i, j};\n            }\n        }\n        vector<int> rowCnt(n, 0);\n        vector<int> colCnt(m, 0);\n        for (int i = 0; i < arr.size(); ++i) {\n            auto& v = mp[arr[i]];\n            ++rowCnt[v.first];\n            if (rowCnt[v.first] == m) {\n                return i;\n            }\n            ++colCnt[v.second];\n            if (colCnt[v.second] == n) {\n                return i;\n            }\n        }\n        return -1;\n    }", "target_Lan": "cpp###firstCompleteIndex.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n// TOFILL\nint main() {\n    vector<int> arr1 = {1, 2, 3, 4, 5};\n    vector<vector<int>> mat1 = {{1, 2}, {3, 4}};\n    cout << firstCompleteIndex(arr1, mat1) << endl; \n\n    vector<int> arr2 = {1, 2, 3, 4, 5, 6};\n    vector<vector<int>> mat2 = {{1, 2, 3}, {4, 5, 6}};\n    cout << firstCompleteIndex(arr2, mat2) << endl; \n\n    vector<int> arr3 = {1, 1, 2, 3, 4};\n    vector<vector<int>> mat3 = {{1, 2}, {1, 3}};\n    cout << firstCompleteIndex(arr3, mat3) << endl; \n\n    vector<int> arr4 = {};\n    vector<vector<int>> mat4 = {{1, 2}, {3, 4}};\n    cout << firstCompleteIndex(arr4, mat4) << endl; \n}"}, {"source_Lan": "python###closeStrings.py", "source_code": "def closeStrings(word1: str, word2: str) -> bool:\n    return Counter(word1).keys() == Counter(word2).keys() and sorted(Counter(word1).values()) == sorted(Counter(word2).values())\n    ", "trans_code": "bool closeStrings ( const std :: string & word1 , const std :: string & word2 ) throw ( ) {\n  return std :: count ( word1 . begin ( ) , word1 . end ( ) , word2 . begin ( ) , word2 . end ( ) ) == std :: count ( word1 . begin ( ) , word1 . end ( ) , word2 . begin ( ) , word2 . end ( ) ) && std :: count ( word1 . begin ( ) , word1 . end ( ) , word2 . begin ( ) , word2 . end ( ) ) == std :: count ( word1 . begin ( ) , word1 . end ( ) , word2 . begin ( ) , word2 . end ( ) ) ;\n}\n", "reference_code": "bool closeStrings(string word1, string word2) {\n        vector<int> count1(26), count2(26);\n        for (char c : word1) {\n            count1[c - 'a']++;\n        }\n        for (char c : word2) {\n            count2[c - 'a']++;\n        }\n        for (int i = 0; i < 26; i++) {\n            if (count1[i] > 0 && count2[i] == 0 || count1[i] == 0 && count2[i] > 0) {\n                return false;\n            }\n        }\n        sort(count1.begin(), count1.end());\n        sort(count2.begin(), count2.end());\n        return count1 == count2;\n    }", "target_Lan": "cpp###closeStrings.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <algorithm>\n// TOFILL\nint main() {\n    cout << closeStrings(\"\", \"\") << endl; \n    cout << closeStrings(\"abc\", \"def\") << endl; \n    cout << closeStrings(\"aabbcc\", \"abcabc\") << endl; \n    cout << closeStrings(\"aabb\", \"bbaa\") << endl; \n    cout << closeStrings(\"ab\", \"ab\") << endl; \n}"}, {"source_Lan": "python###minDeletion.py", "source_code": "def minDeletion( nums: List[int]) -> int:\n        n = len(nums)\n        ans, check = 0, True\n        for i in range(n - 1):\n            if nums[i] == nums[i + 1] and check:\n                ans += 1\n            else:\n                check = not check\n        if (n - ans) % 2 != 0:\n            ans += 1\n        return ans", "trans_code": "public : int minDeletion ( vector < int > & nums ) throw ( ) {\n  int n = nums . size ( ) ;\n  int ans = 0 , check = true ;\n  for ( int i = 0 ;\n  i < n - 1 ;\n  i ++ ) {\n    if ( nums [ i ] == nums [ i + 1 ] && check ) ans ++ ;\n    else check = ! check ;\n  }\n  if ( ( n - ans ) % 2 != 0 ) ans ++ ;\n  return ans ;\n}\n", "reference_code": "int minDeletion(vector<int>& nums) {\n        int n = nums.size();\n        int ans = 0;\n        bool check = true;\n        for (int i = 0; i + 1 < n; ++i) {\n            if (nums[i] == nums[i + 1] && check) {\n                ++ans;\n            }\n            else {\n                check = !check;\n            }\n        }\n        if ((n - ans) % 2 != 0) {\n            ++ans;\n        }\n        return ans;\n    }", "target_Lan": "cpp###minDeletion.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    vector<int> input1 = {};\n    vector<int> input2 = {1, 2, 3, 4};\n    vector<int> input3 = {1, 1, 1, 1};\n    vector<int> input4 = {1, 1, 2, 2, 1};\n    vector<int> input5 = {1, 2, 2, 3, 3, 3};\n\n    cout << minDeletion(input1) << endl;\n    cout << minDeletion(input2) << endl;\n    cout << minDeletion(input3) << endl;\n    cout << minDeletion(input4) << endl;\n    cout << minDeletion(input5) << endl;\n\n    return 0;\n}"}, {"source_Lan": "python###maximumSum.py", "source_code": "def maximumSum( nums: List[int]) -> int:\n        d = defaultdict(int)\n        res = -1\n        for i in nums:\n            digitsSum = sum(int(c) for c in str(i))\n            if digitsSum in d:\n                res = max(res, d[digitsSum] + i)\n                d[digitsSum] = max(d[digitsSum], i)\n            else:\n                d[digitsSum] = i\n        return res", "trans_code": "public : int maximumSum ( vector < int > & nums ) throw ( ) {\n  map < int , int > map ;\n  int res = - 1 ;\n  for ( int i : nums ) {\n    int digitsSum = sum ( int ( i ) ) ;\n    if ( digitsSum < map . size ( ) ) {\n      res = max ( res , map [ digitsSum ] + i ) ;\n      map [ digitsSum ] = max ( map [ digitsSum ] , i ) ;\n    }\n    else {\n      map [ digitsSum ] = i ;\n    }\n  }\n  return res ;\n}\n", "reference_code": "int maximumSum(vector<int>& nums) {\n        unordered_map<int, int> dict;\n        int res = -1;\n        for (int i : nums) {\n            int digitsSum = 0;\n            int temp = i;\n            while (temp > 0) {\n                digitsSum += temp % 10;\n                temp /= 10;\n            }\n            if (dict.count(digitsSum)) {\n                res = max(res, dict[digitsSum] + i);\n                dict[digitsSum] = max(dict[digitsSum], i);\n            } else {\n                dict[digitsSum] = i;\n            }\n        }\n        return res;\n    }", "target_Lan": "cpp###maximumSum.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <algorithm>\n// TOFILL\nint main() {\n    vector<int> input1 = {};\n    vector<int> input2 = {1, 2, 3, 4, 5};\n    vector<int> input3 = {12, 21, 30, 3, 39};\n    vector<int> input4 = {1000000000, 1000000000, 999999999, 999999998};\n    \n    cout << maximumSum(input1) << endl; \n    cout << maximumSum(input2) << endl; \n    cout << maximumSum(input3) << endl; \n    cout << maximumSum(input4) << endl; \n}"}, {"source_Lan": "python###minPathCost.py", "source_code": "def minPathCost(grid: List[List[int]], moveCost: List[List[int]]) -> int:\n    m, n = len(grid), len(grid[0])\n    dp = grid[0]\n    for i in range(1, len(grid)):\n        dp = [grid[i][j] + min(dp[k] + moveCost[grid[i - 1][k]][j] for k in range(n)) for j in range(n)]\n    return min(dp)\n", "trans_code": "public : int minPathCost ( vector < vector < int >> & grid , vector < vector < int >> & moveCost ) throw ( ) {\n  int m = grid . size ( ) , n = grid [ 0 ] . size ( ) ;\n  vector < int > dp = grid [ 0 ] ;\n  for ( int i = 1 ;\n  i < grid . size ( ) ;\n  i ++ ) dp . push_back ( grid [ i ] [ j ] + min ( dp [ k ] + moveCost [ grid [ i - 1 ] [ k ] ] [ j ] for k in range ( n ) ) ) ;\n  return min ( dp ) ;\n}\n", "reference_code": "int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\n        int m = grid.size(), n = grid[0].size();\n        vector<vector<int>> dp(2, vector<int>(n));\n        dp[0] = grid[0];\n        int cur = 0;\n        for (int i = 1; i < m; i++) {\n            int next = 1 - cur;\n            for (int j = 0; j < n; j++) {\n                dp[next][j] = INT_MAX;\n                for (int k = 0; k < n; k++) {\n                    dp[next][j] = min(dp[next][j], dp[cur][k] + moveCost[grid[i - 1][k]][j] + grid[i][j]);\n                }\n            }\n            cur = next;\n        }\n        return *min_element(dp[cur].begin(), dp[cur].end());\n    }", "target_Lan": "cpp###minPathCost.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n// TOFILL\nint main() {\n    vector<vector<int>> grid = {{0, 0, 0}, {1, 2, 3}};\n    vector<vector<int>> moveCost = {{1, 2, 1}, {3, 2, 1}};\n    \n    cout << minPathCost(grid, moveCost) << endl;\n}"}, {"source_Lan": "python###maximizeSum.py", "source_code": "def maximizeSum( nums: List[int], k: int) -> int:\n        return (2 * max(nums) + k - 1) * k // 2", "trans_code": "public : int maximizeSum ( vector < int > & nums , int k ) throw ( ) {\n  return ( 2 * max ( nums ) + k - 1 ) * k / 2 ;\n}\n", "reference_code": "int maximizeSum(vector<int>& nums, int k) {\n        int m = *max_element(nums.begin(), nums.end());\n        return (2 * m + k - 1) * k / 2;\n    }", "target_Lan": "cpp###maximizeSum.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n// TOFILL\nint main() {\n    \n    vector<int> nums1 = {-2, 5, -1, 3};\n    int k1 = 3;\n    vector<int> nums2 = {1, 2, 3, 4};\n    int k2 = 1;\n    vector<int> nums3 = {-10, -5, -3, -7};\n    int k3 = 5;\n    vector<int> nums4 = {0};\n    int k4 = 10;\n    vector<int> nums5 = {-100, 100};\n    int k5 = 2;\n\n    \n    vector<pair<vector<int>, int>> testInputs = {\n        {nums1, k1},\n        {nums2, k2},\n        {nums3, k3},\n        {nums4, k4},\n        {nums5, k5}\n    };\n\n    \n    for(size_t i = 0; i < testInputs.size(); ++i) {\n        vector<int> nums = testInputs[i].first;\n        int k = testInputs[i].second;\n        cout << maximizeSum(nums, k) << endl;\n    }\n\n    return 0;\n}"}, {"source_Lan": "python###longestAlternatingSubarray.py", "source_code": "def longestAlternatingSubarray( nums: List[int], threshold: int) -> int:\n        res, dp = 0, 0\n        for l in range(len(nums) - 1, -1, -1):\n            if nums[l] > threshold:\n                dp = 0\n            elif l == len(nums) - 1 or nums[l] % 2 != nums[l + 1] % 2:\n                dp = dp + 1\n            else:\n                dp = 1\n            res = dp if nums[l] % 2 == 0 and dp > res else res\n        return res", "trans_code": "public : int longestAlternatingSubarray ( vector < int > & nums , int threshold ) throw ( ) {\n  int res = 0 , dp = 0 ;\n  for ( int l = nums . size ( ) - 1 ;\n  l >= 0 ;\n  l -- ) {\n    if ( nums [ l ] > threshold ) dp = 0 ;\n    else if ( l == nums . size ( ) - 1 || nums [ l ] % 2 != nums [ l + 1 ] % 2 ) dp = dp + 1 ;\n    else dp = 1 ;\n    res = dp == nums [ l ] % 2 && dp > res ? dp : res ;\n  }\n  return res ;\n}\n", "reference_code": "int longestAlternatingSubarray(vector<int>& nums, int threshold) {\n        int res = 0, dp = 0, n = nums.size();\n        for (int l = n - 1; l >= 0; l--) {\n            if (nums[l] > threshold) {\n                dp = 0;\n            } else if (l == n - 1 || nums[l] % 2 != nums[l + 1] % 2) {\n                dp++;\n            } else {\n                dp = 1;\n            }\n            if (nums[l] % 2 == 0) {\n                res = max(res, dp);\n            }\n        }\n        return res;\n    }", "target_Lan": "cpp###longestAlternatingSubarray.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    vector<int> input1 = {};\n    vector<int> input2 = {7};\n    vector<int> input3 = {5, 5, 5};\n    vector<int> input4 = {1, 2, 1, 2, 1};\n    vector<int> input5 = {2, 7, 4, 3, 6, 1};\n    int threshold1 = 5;\n    int threshold2 = 10;\n    int threshold3 = 10;\n    int threshold4 = 5;\n    int threshold5 = 6;\n\n    cout << longestAlternatingSubarray(input1, threshold1) << endl;\n    cout << longestAlternatingSubarray(input2, threshold2) << endl;\n    cout << longestAlternatingSubarray(input3, threshold3) << endl;\n    cout << longestAlternatingSubarray(input4, threshold4) << endl;\n    cout << longestAlternatingSubarray(input5, threshold5) << endl;\n\n    return 0;\n}"}, {"source_Lan": "python###findTheLongestBalancedSubstring.py", "source_code": "def findTheLongestBalancedSubstring( s: str) -> int:\n        res = 0\n        n = len(s)\n        count = [0, 0]\n        for i in range(n):\n            if s[i] == '1':\n                count[1] += 1\n                res = max(res, 2 * min(count))\n            elif i == 0 or s[i-1] == '1':\n                count[0] = 1\n                count[1] = 0\n            else:\n                count[0] += 1\n        return res", "trans_code": "public : int findTheLongestBalancedSubstring ( string s ) throw ( ) {\n  int res = 0 ;\n  int n = s . size ( ) ;\n  int count [ 2 ] = {\n    0 , 0 }\n    ;\n    for ( int i = 0 ;\n    i < n ;\n    i ++ ) {\n      if ( s [ i ] == '1' ) {\n        count [ 1 ] ++ ;\n        res = max ( res , 2 * min ( count ) ) ;\n      }\n      else if ( i == 0 || s [ i - 1 ] == '1' ) {\n        count [ 0 ] = 1 ;\n        count [ 1 ] = 0 ;\n      }\n      else {\n        count [ 0 ] ++ ;\n      }\n    }\n    return res ;\n  }\n  ", "reference_code": "int findTheLongestBalancedSubstring(string s) {\n        int res = 0, n = s.size();\n        vector<int> count(2);\n        for (int i = 0; i < n; i++) {\n            if (s[i] == '1') {\n                count[1]++;\n                res = max(res, 2 * min(count[0], count[1]));\n            } else if (i == 0 || s[i - 1] == '1') {\n                count[0] = 1;\n                count[1] = 0;\n            } else {\n                count[0]++;\n            }\n        }\n        return res;            \n    }", "target_Lan": "cpp###findTheLongestBalancedSubstring.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <string>\n// TOFILL\nint main() {\n    cout << findTheLongestBalancedSubstring(\"\") << endl;\n    cout << findTheLongestBalancedSubstring(\"0000\") << endl;\n    cout << findTheLongestBalancedSubstring(\"1111\") << endl;\n    cout << findTheLongestBalancedSubstring(\"00110011\") << endl;\n    cout << findTheLongestBalancedSubstring(\"00110000\") << endl;\n}"}, {"source_Lan": "python###vowelStrings.py", "source_code": "def vowelStrings( words: List[str], left: int, right: int) -> int:\n        vowels = set(\"aeiou\")\n        ans = 0\n        for i in range(left, right + 1):\n            word = words[i]\n            if word[0] in vowels and word[-1] in vowels:\n                ans += 1\n        return ans", "trans_code": "int vowelStrings ( vector < string > & words , int left , int right ) throw ( ) {\n  set < string > vowels ( \"aeiou\" ) ;\n  int ans = 0 ;\n  for ( int i = left ;\n  i <= right ;\n  i ++ ) {\n    string word = words [ i ] ;\n    if ( word [ 0 ] == vowels [ i ] && word [ word . length ( ) - 1 ] == vowels [ i ] ) ans ++ ;\n  }\n  return ans ;\n}\n", "reference_code": "int vowelStrings(vector<string>& words, int left, int right) {\n        unordered_set<char> vowels = {'a', 'e', 'i', 'o', 'u'};\n        int ans = 0;\n        for (int i = left; i <= right; ++i) {\n            const string& word = words[i];\n            if (vowels.count(word[0]) && vowels.count(word.back())) {\n                ++ans;\n            }\n        }\n        return ans;\n    }", "target_Lan": "cpp###vowelStrings.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <unordered_set>\n// TOFILL\nint main() {\n    vector<string> words1 = {\"apple\", \"banana\", \"orange\", \"grape\"};\n    cout << vowelStrings(words1, 0, 3) << endl;\n    \n    vector<string> words2 = {\"kiwi\", \"apple\", \" \", \"banana\"};\n    cout << vowelStrings(words2, 0, 2) << endl;\n    \n    vector<string> words3 = {\"apple\", \"banana\", \"umbrella\"};\n    cout << vowelStrings(words3, 1, 1) << endl;\n    \n    vector<string> words4 = {\"\", \"eagle\", \"sky\", \"ice\"};\n    cout << vowelStrings(words4, 1, 3) << endl;\n    \n    vector<string> words5 = {\"elephant\", \"ant\", \"ufo\"};\n    cout << vowelStrings(words5, 0, 2) << endl;\n\n    return 0;\n}"}, {"source_Lan": "python###categorizeBox.py", "source_code": "def categorizeBox( length, width, height, mass):\n        maxd = max(length, width, height)\n        vol = length * width * height\n        isBulky = maxd >= 10000 or vol >= 10**9\n        isHeavy = mass >= 100\n        if isBulky and isHeavy:\n            return 'Both'\n        if isBulky:\n            return 'Bulky'\n        if isHeavy:\n            return 'Heavy'\n        return 'Neither'", "trans_code": "string categorizeBox ( int length , int width , int height , int mass ) {\n  int maxd = max ( length , width , height ) ;\n  int vol = length * width * height ;\n  bool isBulky = maxd >= 10000 || vol >= 10 * 9 ;\n  bool isHeavy = mass >= 100 ;\n  if ( isBulky && isHeavy ) return \"Both\" ;\n  if ( isBulky ) return \"Bulky\" ;\n  if ( isHeavy ) return \"Heavy\" ;\n  return \"Neither\" ;\n}\n", "reference_code": "string categorizeBox(int length, int width, int height, int mass) {\n        long long maxd = max(length, max(width, height)), vol = 1L * length * width * height;\n        bool isBulky = maxd >= 10000 || vol >= 1000000000, isHeavy = mass >= 100;\n        if (isBulky && isHeavy) {\n             return \"Both\";\n        } else if (isBulky) {\n            return \"Bulky\";\n        } else if (isHeavy) {\n            return \"Heavy\";\n        } else {\n            return \"Neither\";\n        }\n    }", "target_Lan": "cpp###categorizeBox.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <string>\n// TOFILL\nint main() {\n    cout << categorizeBox(1, 1, 1, 50) << endl;\n    cout << categorizeBox(100, 1, 1, 150) << endl;\n    cout << categorizeBox(10000, 100, 1, 50) << endl;\n    cout << categorizeBox(10000, 100, 1000, 200) << endl;\n    cout << categorizeBox(100000, 100000, 100000, 100) << endl;\n}"}, {"source_Lan": "python###maxKelements.py", "source_code": "def maxKelements(nums: List[int], k: int) -> int:\n    q = [-x for x in nums]\n    heapify(q)\n    ans = 0\n    for _ in range(k):\n        x = heappop(q)\n        ans += -x\n        heappush(q, -((-x + 2) // 3))\n    return ans\n", "trans_code": "public : int maxKelements ( vector < int > & nums , int k ) throw ( ) {\n  vector < int > q ;\n  q . push_back ( - nums [ 0 ] ) ;\n  q . push_back ( nums [ 1 ] ) ;\n  q . push_back ( nums [ 2 ] ) ;\n  q . push_back ( nums [ 3 ] ) ;\n  q . push_back ( nums [ 4 ] ) ;\n  q . push_back ( nums [ 5 ] ) ;\n  q . push_back ( nums [ 6 ] ) ;\n  q . push_back ( nums [ 7 ] ) ;\n  q . push_back ( nums [ 8 ] ) ;\n  q . push_back ( nums [ 9 ] ) ;\n  q . push_back ( nums [ 10 ] ) ;\n  q . push_back ( nums [ 11 ] ) ;\n  q . push_back ( nums [ 12 ] ) ;\n  q . push_back ( nums [ 13 ] ) ;\n  q . push_back ( nums [ 14 ] ) ;\n  q . push_back ( nums [ 15 ] ) ;\n  q . push_back ( nums [ 16 ] ) ;\n  q . push_back ( nums [ 17 ] ) ;\n  q . push_back ( nums [ 18 ] ) ;\n  q . push_back ( nums [ 19 ] ) ;\n  q . push_back ( nums [ 20 ] ) ;\n  q . push_back ( nums [ 21 ] ) ;\n  q . push_back ( nums [ 22 ] ) ;\n  q . push_back ( nums [ 23 ] ) ;\n  q . push_back ( nums [ 24 ] ) ;\n  ", "reference_code": "long long maxKelements(vector<int>& nums, int k) {\n        priority_queue<int> q(nums.begin(), nums.end());\n        long long ans = 0;\n        for (int _ = 0; _ < k; ++_) {\n            int x = q.top();\n            q.pop();\n            ans += x;\n            q.push((x + 2) / 3);\n        }\n        return ans;\n    }", "target_Lan": "cpp###maxKelements.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <queue>\n// TOFILL\nint main() {\n    vector<int> nums1 = {10, 20, 30};\n    int k1 = 2;\n    cout << maxKelements(nums1, k1) << endl;\n\n    vector<int> nums2 = {1, 2, 3, 4, 5};\n    int k2 = 3;\n    cout << maxKelements(nums2, k2) << endl;\n\n    vector<int> nums3 = {100000, 200000, 300000};\n    int k3 = 3;\n    cout << maxKelements(nums3, k3) << endl;\n\n    vector<int> nums4 = {-1, -2, -3};\n    int k4 = 2;\n    cout << maxKelements(nums4, k4) << endl;\n\n    return 0;\n}"}, {"source_Lan": "python###pickGifts.py", "source_code": "def pickGifts(gifts: List[int], k: int) -> int:\n    q = [-gift for gift in gifts]\n    heapify(q)\n    while k:\n        x = heappop(q)\n        heappush(q, -int(sqrt(-x)))\n        k -= 1\n    return -sum(q)\n", "trans_code": "int pickGifts ( vector < int > & gifts , int k ) throw ( ) {\n  vector < int > q ;\n  q . push_back ( - gifts [ k ] ) ;\n  heapify ( q ) ;\n  while ( k ) {\n    int x = heappop ( q ) ;\n    heappush ( q , - int ( sqrt ( - x ) ) ) ;\n    k -- ;\n  }\n  return - sum ( q ) ;\n}\n", "reference_code": "    long long pickGifts(vector<int>& gifts, int k) {\n        priority_queue<int> q(gifts.begin(), gifts.end());\n        while (k--) {\n            int x = q.top(); \n            q.pop();\n            q.push(int(sqrt(x)));\n        }\n        long long res = 0;\n        while (q.size()) {\n            res += q.top(); \n            q.pop();\n        }\n        return res;\n    }", "target_Lan": "cpp###pickGifts.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <cmath>\n// TOFILL\nint main() {\n    vector<int> gifts1 = {};\n    cout << pickGifts(gifts1, 0) << endl;\n    \n    vector<int> gifts2 = {16, 25, 36};\n    cout << pickGifts(gifts2, 1) << endl;\n    \n    vector<int> gifts3 = {1, 4, 9, 16, 64};\n    cout << pickGifts(gifts3, 2) << endl;\n    \n    vector<int> gifts4 = {1000000000, 1000000000, 1000000000};\n    cout << pickGifts(gifts4, 3) << endl;\n    \n    vector<int> gifts5 = {2, 3, 5, 7};\n    cout << pickGifts(gifts5, 4) << endl;\n\n    return 0;\n}"}, {"source_Lan": "python###minimumOneBitOperations.py", "source_code": "def minimumOneBitOperations( n: int) -> int:\n        ans = 0\n        sign = 1\n        for i in range(29, -1, -1):\n            if n & (1 << i):\n                ans += sign * ((1 << (i + 1)) - 1)\n                sign = -sign\n        return ans", "trans_code": "public : int minimumOneBitOperations ( int n ) throw ( ) {\n  int ans = 0 ;\n  int sign = 1 ;\n  for ( int i = 29 ;\n  i >= 0 ;\n  i -- ) {\n    if ( n & ( 1 << i ) ) {\n      ans += sign * ( ( 1 << ( i + 1 ) ) - 1 ) ;\n      sign = - sign ;\n    }\n  }\n  return ans ;\n}\n", "reference_code": "int minimumOneBitOperations(int n) {\n        int ans = 0;\n        int sign = 1;\n        for (int i = 29; i >= 0; --i) {\n            if (n & (1 << i)) {\n                ans += sign * ((1 << (i + 1)) - 1);\n                sign = -sign;\n            }\n        }\n        return ans;\n    }", "target_Lan": "cpp###minimumOneBitOperations.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n// TOFILL\nint main() {\n    cout << minimumOneBitOperations(0) << endl;           \n    cout << minimumOneBitOperations(1) << endl;           \n    cout << minimumOneBitOperations(15) << endl;          \n    cout << minimumOneBitOperations(1073741823) << endl;  \n    cout << minimumOneBitOperations(-1) << endl;          \n}"}, {"source_Lan": "python###successfulPairs.py", "source_code": "def successfulPairs( spells: List[int], potions: List[int], success: int) -> List[int]:\n        res = [0] * len(spells)\n        idx = [i for i in range(len(spells))]\n        idx.sort(key = lambda x: spells[x])\n        potions.sort(key = lambda x : -x)\n        j = 0\n        for p in idx:\n            v = spells[p]\n            while j < len(potions) and potions[j] * v >= success:\n                j += 1\n            res[p] = j\n        return res", "trans_code": "public : vector < int > successfulPairs ( vector < int > & spells , vector < int > & potions , int success ) throw ( ) {\n  vector < int > res ( spells . size ( ) ) ;\n  vector < int > idx ( spells . size ( ) ) ;\n  for ( int i = 0 ;\n  i < spells . size ( ) ;\n  i ++ ) idx [ i ] = i ;\n  sort ( idx . begin ( ) , idx . end ( ) ) ;\n  sort ( potions . begin ( ) , potions . end ( ) ) ;\n  int j = 0 ;\n  for ( int p = 0 ;\n  p < idx . size ( ) ;\n  p ++ ) {\n    int v = idx [ p ] ;\n    while ( j < potions . size ( ) && potions [ j ] * v >= success ) j ++ ;\n    res [ p ] = j ;\n  }\n  return res ;\n}\n", "reference_code": "vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\n        vector<int> res(spells.size());\n        vector<int> idx(spells.size());\n        iota(idx.begin(), idx.end(), 0);\n        sort(idx.begin(), idx.end(), [&](int a, int b) {\n            return spells[a] < spells[b];\n        });\n        sort(potions.begin(), potions.end(), [](int a, int b) {\n            return a > b;\n        });\n        for (int i = 0, j = 0; i < spells.size(); ++i) {\n            int p = idx[i];\n            int v = spells[p];\n            while (j < potions.size() && (long long) potions[j] * v >= success) {\n                ++j;\n            }\n            res[p] = j;\n        }\n        return res;\n    }", "target_Lan": "cpp###successfulPairs.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <numeric>\n#include <algorithm>\n// TOFILL\nint main() {\n    vector<int> spells1 = {};\n    vector<int> potions1 = {};\n    long long success1 = 0;\n    vector<int> result1 = successfulPairs(spells1, potions1, success1);\n    for(int r : result1) {\n        cout << r << \" \";\n    }\n    cout << endl;\n\n    vector<int> spells2 = {3};\n    vector<int> potions2 = {2};\n    long long success2 = 6;\n    vector<int> result2 = successfulPairs(spells2, potions2, success2);\n    for(int r : result2) {\n        cout << r << \" \";\n    }\n    cout << endl;\n\n    vector<int> spells3 = {-1, -2, 3};\n    vector<int> potions3 = {1, 2};\n    long long success3 = 2;\n    vector<int> result3 = successfulPairs(spells3, potions3, success3);\n    for(int r : result3) {\n        cout << r << \" \";\n    }\n    cout << endl;\n\n    vector<int> spells4 = {100000, 200000};\n    vector<int> potions4 = {100000, 200000};\n    long long success4 = 10000000000;\n    vector<int> result4 = successfulPairs(spells4, potions4, success4);\n    for(int r : result4) {\n        cout << r << \" \";\n    }\n    cout << endl;\n\n    vector<int> spells5 = {2, 4, 8};\n    vector<int> potions5 = {1, 3, 5};\n    long long success5 = 10;\n    vector<int> result5 = successfulPairs(spells5, potions5, success5);\n    for(int r : result5) {\n        cout << r << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}"}, {"source_Lan": "python###countPairs2.py", "source_code": "def countPairs2(nums: List[int], target: int) -> int:\n    return sum(x + y < target for x, y in combinations(nums, 2))\n", "trans_code": "public : int countPairs2 ( vector < int > & nums , int target ) throw ( ) {\n  return std :: accumulate ( nums . begin ( ) , nums . end ( ) , 0 ) ;\n}\n", "reference_code": "int countPairs2(vector<int>& nums, int target) {\n        int res = 0;\n        for (int i = 0; i < nums.size(); i++) {\n            for (int j = i + 1; j < nums.size(); j++) {\n                if (nums[i] + nums[j] < target) {\n                    res++;\n                }\n            }\n        }\n        return res;\n    }", "target_Lan": "cpp###countPairs2.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    vector<int> input1 = {};\n    cout << countPairs2(input1, 5) << endl;\n\n    vector<int> input2 = {1};\n    cout << countPairs2(input2, 5) << endl;\n\n    vector<int> input3 = {1, 1, 1, 1};\n    cout << countPairs2(input3, 5) << endl;\n\n    vector<int> input4 = {1, 2, 3, 4};\n    cout << countPairs2(input4, 10) << endl;\n\n    vector<int> input5 = {6, 7, 8, 9};\n    cout << countPairs2(input5, 10) << endl;\n\n    return 0;\n}"}, {"source_Lan": "python###tupleSameProduct.py", "source_code": "def tupleSameProduct( nums: List[int]) -> int:\n        n = len(nums)\n        cnt = Counter([nums[i] * nums[j] for i in range(n) for j in range(i + 1, n)])\n        ans = 0\n        for _, v in cnt.items():\n            ans += v * (v - 1) * 4\n        return ans", "trans_code": "public : int tupleSameProduct ( vector < int > & nums ) throw ( ) {\n  int n = nums . size ( ) ;\n  map < int , int > cnt ( n ) ;\n  for ( int i = 0 ;\n  i < n ;\n  ++ i ) {\n    cnt [ i ] = nums [ i ] * nums [ j ] ;\n  }\n  int ans = 0 ;\n  for ( map < int , int > :: iterator it = cnt . begin ( ) ;\n  it != cnt . end ( ) ;\n  ++ it ) {\n    ans += it -> second * ( it -> first - it -> first ) * 4 ;\n  }\n  return ans ;\n}\n", "reference_code": "int tupleSameProduct(vector<int>& nums) {\n        int n = nums.size();\n        int ans = 0;\n        unordered_map<int, int> cnt;\n        for (int i = 0; i < n; i++) {\n            for(int j = i + 1; j < n; j++) {\n                cnt[nums[i] * nums[j]]++;\n            }\n        }\n        for (auto &[k, v] : cnt) {\n            ans += v * (v - 1) * 4;\n        }\n        return ans;\n    }", "target_Lan": "cpp###tupleSameProduct.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n// TOFILL\nint main() {\n    vector<vector<int>> testInputs = {\n        {},\n        {1},\n        {1, 1, 1},\n        {1, 2, 3, 4, 6},\n        {10000, 10000, -10000, -10000}\n    };\n\n    for(const auto& input : testInputs) {\n        cout << tupleSameProduct(const_cast<vector<int>&>(input)) << endl;\n    }\n\n    return 0;\n}"}, {"source_Lan": "python###sumOfMultiples.py", "source_code": "def sumOfMultiples( n: int) -> int:\n        return sum(i for i in range(1, n + 1) if i % 3 == 0 or i % 5 == 0 or i % 7 == 0)", "trans_code": "int sumOfMultiples ( int n ) throw ( ) {\n  return sum ( n ) ;\n}\n", "reference_code": "int sumOfMultiples(int n) {\n        int res = 0;\n        for (int i = 1; i <= n; i++) {\n            if (i % 3 == 0 || i % 5 == 0 || i % 7 == 0) {\n                res += i;\n            }\n        }\n        return res;\n    }", "target_Lan": "cpp###sumOfMultiples.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n// TOFILL\nint main() {\n    cout << sumOfMultiples(0) << endl;\n    cout << sumOfMultiples(1) << endl;\n    cout << sumOfMultiples(8) << endl;\n    cout << sumOfMultiples(15) << endl;\n    cout << sumOfMultiples(100) << endl;\n}"}, {"source_Lan": "python###topStudents.py", "source_code": "def topStudents( positive_feedback, negative_feedback, report, student_id, k):\n        words = {}\n        for w in positive_feedback:\n            words[w] = 3\n        for w in negative_feedback:\n            words[w] = -1\n        A = []\n        for s, i in zip(report, student_id):\n            score = sum(words.get(w, 0)for w in s.split())\n            A.append([-score, i])\n        A.sort()\n        return [i for v,i in A[:k]]", "trans_code": "public : vector < int > topStudents ( vector < string > & positiveFeedback , vector < string > & negativeFeedback , vector < string > & report , string studentId , int k ) {\n  map < string , int > words ;\n  for ( string w : positiveFeedback ) words [ w ] = 3 ;\n  for ( string w : negativeFeedback ) words [ w ] = - 1 ;\n  vector < int > A ;\n  for ( string s : report ) {\n    int score = accumulate ( words . begin ( ) , words . end ( ) , 0 ) ;\n    A . push_back ( - score ) ;\n  }\n  sort ( A . begin ( ) , A . end ( ) ) ;\n  return A [ k ] ;\n}\n", "reference_code": "vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& student_id, int k) {\n        unordered_map<std::string, int> words;\n        for (const auto& word : positive_feedback) {\n            words[word] = 3;\n        }\n        for (const auto& word : negative_feedback) {\n            words[word] = -1;\n        }\n        vector<vector<int>> A;\n        for (int i = 0; i < report.size(); i++) {\n            stringstream ss; \n            string w;\n            int score = 0;\n            ss << report[i];\n            while (ss >> w) {\n                if (words.count(w)) {\n                    score += words[w];\n                }\n            }\n            A.push_back({-score, student_id[i]});\n        }\n        sort(A.begin(), A.end());\n        vector<int> top_k;\n        for (int i = 0; i < k; i++) {\n            top_k.push_back(A[i][1]);\n        }\n        return top_k;\n    }", "target_Lan": "cpp###topStudents.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <unordered_map>\n#include <algorithm>\n// TOFILL\nint main() {\n    \n    vector<string> positive_feedback1 = {};\n    vector<string> negative_feedback1 = {};\n    vector<string> report1 = {\"good job\", \"bad work\"};\n    vector<int> student_id1 = {1, 2};\n    int k1 = 1;\n    vector<int> result1 = topStudents(positive_feedback1, negative_feedback1, report1, student_id1, k1);\n    for(int id : result1) {\n        cout << id << \" \";\n    }\n    cout << endl;\n\n    \n    vector<string> positive_feedback2 = {\"excellent\", \"great\"};\n    vector<string> negative_feedback2 = {\"poor\"};\n    vector<string> report2 = {\"excellent work\", \"poor performance\"};\n    vector<int> student_id2 = {1, 2};\n    int k2 = 2;\n    vector<int> result2 = topStudents(positive_feedback2, negative_feedback2, report2, student_id2, k2);\n    for(int id : result2) {\n        cout << id << \" \";\n    }\n    cout << endl;\n\n    \n    vector<string> positive_feedback3 = {\"awesome\"};\n    vector<string> negative_feedback3 = {\"bad\"};\n    vector<string> report3 = {\"awesome job\", \"bad job\", \"bad day\"};\n    vector<int> student_id3 = {1, 2, 3};\n    int k3 = 2;\n    vector<int> result3 = topStudents(positive_feedback3, negative_feedback3, report3, student_id3, k3);\n    for(int id : result3) {\n        cout << id << \" \";\n    }\n    cout << endl;\n\n    \n    vector<string> positive_feedback4 = {\"good\"};\n    vector<string> negative_feedback4 = {\"terrible\"};\n    vector<string> report4 = {\"good effort\", \"\", \"just okay\"};\n    vector<int> student_id4 = {1, 2, 3};\n    int k4 = 1;\n    vector<int> result4 = topStudents(positive_feedback4, negative_feedback4, report4, student_id4, k4);\n    for(int id : result4) {\n        cout << id << \" \";\n    }\n    cout << endl;\n\n    \n    vector<string> positive_feedback5 = {\"fantastic\"};\n    vector<string> negative_feedback5 = {\"mediocre\"};\n    vector<string> report5 = {\"fantastic performance\", \"mediocre execution\", \"wonderful effort\"};\n    vector<int> student_id5 = {1, 2, 3};\n    int k5 = 3;\n    vector<int> result5 = topStudents(positive_feedback5, negative_feedback5, report5, student_id5, k5);\n    for(int id : result5) {\n        cout << id << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}"}, {"source_Lan": "python###filterRestaurants.py", "source_code": "def filterRestaurants( restaurants: List[List[int]], veganFriendly: int, maxPrice: int, maxDistance: int) -> List[int]:\n        filtered = [r for r in restaurants if r[3] <= maxPrice and r[4] <= maxDistance and not (veganFriendly and not r[2])]\n        filtered.sort(key=lambda r: (-r[1], -r[0]))\n        return [r[0] for r in filtered]", "trans_code": "vector < int > filterRestaurants ( vector < vector < int >> restaurants , int veganFriendly , int maxPrice , int maxDistance ) throw ( ) {\n  vector < int > filtered ;\n  filtered . push_back ( restaurants [ 3 ] ) ;\n  filtered . push_back ( restaurants [ 4 ] ) ;\n  filtered . push_back ( restaurants [ 5 ] ) ;\n  filtered . push_back ( restaurants [ 6 ] ) ;\n  filtered . push_back ( restaurants [ 7 ] ) ;\n  filtered . push_back ( restaurants [ 8 ] ) ;\n  filtered . push_back ( restaurants [ 9 ] ) ;\n  filtered . push_back ( restaurants [ 10 ] ) ;\n  filtered . push_back ( restaurants [ 11 ] ) ;\n  filtered . push_back ( restaurants [ 12 ] ) ;\n  filtered . push_back ( restaurants [ 13 ] ) ;\n  filtered . push_back ( restaurants [ 14 ] ) ;\n  filtered . push_back ( restaurants [ 15 ] ) ;\n  filtered . push_back ( restaurants [ 16 ] ) ;\n  filtered . push_back ( restaurants [ 17 ] ) ;\n  filtered . push_back ( restaurants [ 18 ] ) ;\n  filtered . push_back ( restaurants [ 19 ] ) ;\n  filtered . push_back ( restaurants [ 20 ] ) ;\n  filtered . push_back ( restaurants [ 21 ] ) ;\n  filtered . push_back ( restaurants [ 22 ] ) ;\n  filtered . push_back ( restaurants [ 23 ] ) ;\n  filtered . push_back ( restaurants [ 24 ] ) ;\n  filtered . push_back ( restaurants [ 25 ] ) ;\n  filtered . push_back ( restaurants [ 26 ] ) ;\n  filtered . push_back ( restaurants [ 27 ] ) ;\n  filtered . push_back ( restaurants [ 28 ] ) ;\n  filtered . push_back ( restaurants [ 29 ] ) ;\n  filtered . push_back ( restaurants [ 30 ] ) ;\n  filtered", "reference_code": "vector<int> filterRestaurants(vector<vector<int>>& restaurants, int veganFriendly, int maxPrice, int maxDistance) {\n        int n = restaurants.size();\n        vector<vector<int>> filtered;\n        for (int i = 0; i < n; i++) {\n            if (restaurants[i][3] <= maxPrice && restaurants[i][4] <= maxDistance && !(veganFriendly && !restaurants[i][2])) {\n                filtered.push_back(restaurants[i]);\n            }\n        }\n        sort(filtered.begin(), filtered.end(), [](vector<int> &v1, vector<int> &v2) -> bool {\n            return v1[1] > v2[1] || (v1[1] == v2[1] && v1[0] > v2[0]);\n        });\n        vector<int> res;\n        for (auto &v : filtered) {\n            res.push_back(v[0]);\n        }\n        return res;\n    }", "target_Lan": "cpp###filterRestaurants.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <algorithm>\n// TOFILL\nint main() {\n    vector<vector<int>> restaurants1 = {{1, 5, 1, 40, 10}, {2, 3, 0, 30, 15}, {3, 4, 1, 50, 5}, {4, 2, 0, 20, 3}};\n    vector<int> result1 = filterRestaurants(restaurants1, 1, 45, 12);\n    for(int id : result1) {\n        cout << id << \" \";\n    }\n    cout << endl;\n\n    vector<vector<int>> restaurants2 = {{1, 5, 1, 50, 10}, {2, 3, 0, 30, 15}, {3, 4, 0, 20, 5}, {4, 2, 1, 20, 3}};\n    vector<int> result2 = filterRestaurants(restaurants2, 0, 100, 20);\n    for(int id : result2) {\n        cout << id << \" \";\n    }\n    cout << endl;\n\n    vector<vector<int>> restaurants3 = {{1, 5, 1, 40, 10}, {2, 3, 1, 50, 15}, {3, 4, 0, 70, 5}, {4, 2, 0, 20, 5}};\n    vector<int> result3 = filterRestaurants(restaurants3, 1, 65, 10);\n    for(int id : result3) {\n        cout << id << \" \";\n    }\n    cout << endl;\n\n    vector<vector<int>> restaurants4 = {{1, 5, 1, 40, 10}, {2, 3, 0, 30, 20}, {3, 4, 1, 10, 2}, {4, 2, 1, 15, 1}};\n    vector<int> result4 = filterRestaurants(restaurants4, 1, 12, 2);\n    for(int id : result4) {\n        cout << id << \" \";\n    }\n    cout << endl;\n\n    vector<vector<int>> restaurants5 = {{1, 5, 1, 100, 30}, {2, 3, 0, 50, 15}, {3, 4, 1, 50, 5}};\n    vector<int> result5 = filterRestaurants(restaurants5, 0, 50, 10);\n    for(int id : result5) {\n        cout << id << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}"}, {"source_Lan": "python###passThePillow.py", "source_code": "def passThePillow( n: int, time: int) -> int:\n        time %= (n - 1) * 2\n        return time + 1 if time < n else n * 2 - time - 1", "trans_code": "int passThePillow ( int n , int time ) throw ( ) {\n  time %= ( n - 1 ) * 2 ;\n  return time + 1 == n ? n * 2 - time - 1 : n * 2 - time - 1 ;\n}\n", "reference_code": "    int passThePillow(int n, int time) {\n        time %= (n - 1) * 2;\n        return time < n ? time + 1 : n * 2 - time - 1;\n    }", "target_Lan": "cpp###passThePillow.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n// TOFILL\nint main() {\n    cout << passThePillow(3, 2) << endl;\n    cout << passThePillow(5, 1) << endl;\n    cout << passThePillow(4, 8) << endl;\n    cout << passThePillow(6, 10) << endl;\n    cout << passThePillow(2, 9) << endl;\n}"}, {"source_Lan": "python###collectTheCoins.py", "source_code": "def collectTheCoins( coins: List[int], edges: List[List[int]]) -> int:\n        n = len(coins)\n        g = defaultdict(list)\n        degree = [0] * n\n        for x, y in edges:\n            g[x].append(y)\n            g[y].append(x)\n            degree[x] += 1\n            degree[y] += 1\n        rest = n\n        \n        q = deque(i for i in range(n) if degree[i] == 1 and coins[i] == 0)\n        while q:\n            u = q.popleft()\n            degree[u] -= 1\n            rest -= 1\n            for v in g[u]:\n                degree[v] -= 1\n                if degree[v] == 1 and coins[v] == 0:\n                    q.append(v)\n        \n        for _ in range(2):\n            q = deque(i for i in range(n) if degree[i] == 1)\n            while q:\n                u = q.popleft()\n                degree[u] -= 1\n                rest -= 1\n                for v in g[u]:\n                    degree[v] -= 1\n        return 0 if rest == 0 else (rest - 1) * 2", "trans_code": "public : int collectTheCoins ( vector < int > coins , vector < vector < int >> edges ) throw ( ) {\n  int n = coins . size ( ) ;\n  map < int , vector < int >> g ;\n  vector < int > degree ( n ) ;\n  for ( int x = 0 , y = 0 ;\n  x < n ;\n  ++ x , ++ y ) {\n    g [ x ] . push_back ( y ) ;\n    g [ y ] . push_back ( x ) ;\n    degree [ x ] ++ ;\n    degree [ y ] ++ ;\n  }\n  int rest = n ;\n  deque < int > q ( i ) ;\n  if ( degree [ i ] == 1 && coins [ i ] == 0 ) {\n    while ( q . size ( ) > 0 ) {\n      int u = q . front ( ) ;\n      degree [ u ] -- ;\n      rest -- ;\n      for ( int v : g [ u ] ) {\n        degree [ v ] -- ;\n        if ( degree [ v ] == 1 && coins [ v ] == 0 ) q . pop_front ( ) ;\n      }\n    }\n  }\n  for ( ;\n  ;\n  ) {\n    deque < int > q ( i ) ;\n    while ( q . size ( ) > 0 ) {\n      int u = q . front ( ) ;\n      degree [ u ] -- ;\n      rest -- ;\n      for ( int v : g [ u ] ) {\n        degree [ v ] -- ;\n      }\n    }\n  }\n  return 0 == rest ? 0 : ( rest - 1 ) * 2 ;\n}\n", "reference_code": "int collectTheCoins(vector<int>& coins, vector<vector<int>>& edges) {\n        int n = coins.size();\n        vector<vector<int>> g(n);\n        vector<int> degree(n);\n        for (const auto& edge: edges) {\n            int x = edge[0], y = edge[1];\n            g[x].push_back(y);\n            g[y].push_back(x);\n            ++degree[x];\n            ++degree[y];\n        }\n        int rest = n;\n        {\n            \n            queue<int> q;\n            for (int i = 0; i < n; ++i) {\n                if (degree[i] == 1 && !coins[i]) {\n                    q.push(i);\n                }\n            }\n            while (!q.empty()) {\n                int u = q.front();\n                --degree[u];\n                q.pop();\n                --rest;\n                for (int v: g[u]) {\n                    --degree[v];\n                    if (degree[v] == 1 && !coins[v]) {\n                        q.push(v);\n                    }\n                }\n            }\n        }\n        {\n            \n            for (int _ = 0; _ < 2; ++_) {\n                queue<int> q;\n                for (int i = 0; i < n; ++i) {\n                    if (degree[i] == 1) {\n                        q.push(i);\n                    }\n                }\n                while (!q.empty()) {\n                    int u = q.front();\n                    --degree[u];\n                    q.pop();\n                    --rest;\n                    for (int v: g[u]) {\n                        --degree[v];\n                    }\n                }\n            }\n        }\n        return rest == 0 ? 0 : (rest - 1) * 2;\n    }", "target_Lan": "cpp###collectTheCoins.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <queue>\n// TOFILL\nint main() {\n    vector<int> coins1 = {1, 0, 0, 0};\n    vector<vector<int>> edges1 = {{0, 1}, {0, 2}};\n    cout << collectTheCoins(coins1, edges1) << endl;\n\n    vector<int> coins2 = {0, 0, 0, 0};\n    vector<vector<int>> edges2 = {{0, 1}, {1, 2}, {1, 3}};\n    cout << collectTheCoins(coins2, edges2) << endl;\n\n    vector<int> coins3 = {1, 1, 1, 0, 0};\n    vector<vector<int>> edges3 = {{0, 1}, {1, 2}, {1, 3}, {3, 4}};\n    cout << collectTheCoins(coins3, edges3) << endl;\n\n    vector<int> coins4 = {1, 0, 1};\n    vector<vector<int>> edges4 = {{0, 1}, {1, 2}};\n    cout << collectTheCoins(coins4, edges4) << endl;\n\n    vector<int> coins5 = {0, 1, 0, 1};\n    vector<vector<int>> edges5 = {{0, 1}, {1, 2}, {1, 3}};\n    cout << collectTheCoins(coins5, edges5) << endl;\n\n    return 0;\n}"}, {"source_Lan": "python###distMoney.py", "source_code": "def distMoney( money: int, children: int) -> int:\n        if money < children:\n            return -1\n        money -= children\n        cnt = min(money // 7, children)\n        money -= cnt * 7\n        children -= cnt\n        if (children == 0 and money > 0) or (children == 1 and money == 3):\n            cnt -= 1\n        return cnt", "trans_code": "int distMoney ( int money , int children ) throw ( ) {\n  if ( money < children ) return - 1 ;\n  money -= children ;\n  int cnt = min ( money / 7 , children ) ;\n  money -= cnt * 7 ;\n  children -= cnt ;\n  if ( ( children == 0 && money > 0 ) || ( children == 1 && money == 3 ) ) cnt -- ;\n  return cnt ;\n}\n", "reference_code": "int distMoney(int money, int children) {\n        if (money < children) {\n            return -1;\n        }\n        money -= children;\n        int cnt = min(money / 7, children);\n        money -= cnt * 7;\n        children -= cnt;\n        if ((children == 0 && money > 0) || (children == 1 && money == 3)) {\n            cnt--;\n        }\n        return cnt;\n    }", "target_Lan": "cpp###distMoney.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <algorithm>\n// TOFILL\nint main() {\n    cout << distMoney(10, 5) << endl;\n    cout << distMoney(14, 3) << endl;\n    cout << distMoney(7, 2) << endl;\n    cout << distMoney(21, 4) << endl;\n    cout << distMoney(3, 1) << endl;\n}"}, {"source_Lan": "python###queensAttacktheKing.py", "source_code": "def queensAttacktheKing( queens: List[List[int]], king: List[int]) -> List[List[int]]:\n        queen_pos = set((x, y) for x, y in queens)\n        ans = list()\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == dy == 0:\n                    continue\n                kx, ky = king[0] + dx, king[1] + dy\n                while 0 <= kx < 8 and 0 <= ky < 8:\n                    if (kx, ky) in queen_pos:\n                        ans.append([kx, ky])\n                        break\n                    kx += dx\n                    ky += dy\n        return ans", "trans_code": "public : vector < vector < int >> queensAttacktheKing ( vector < vector < int >> & queens , vector < int > & king ) -> vector < vector < int >> {\n  set < int > queenPos ( queens . begin ( ) , queens . end ( ) ) ;\n  vector < vector < int >> ans ;\n  for ( int dx = - 1 ;\n  dx < queens . size ( ) ;\n  dx ++ ) {\n    for ( int dy = - 1 ;\n    dy < queens . size ( ) ;\n    dy ++ ) {\n      if ( dx == dy == 0 ) continue ;\n      int kx = king [ 0 ] + dx , ky = king [ 1 ] + dy ;\n      while ( 0 <= kx && 0 <= ky ) {\n        if ( ( kx < 8 ) || ( ky < 8 ) ) {\n          ans . push_back ( {\n            kx , ky }\n            ) ;\n            break ;\n          }\n          kx += dx ;\n          ky += dy ;\n        }\n      }\n    }\n    return ans ;\n  }\n  ", "reference_code": "vector<vector<int>> queensAttacktheKing(vector<vector<int>>& queens, vector<int>& king) {\n        unordered_set<int> queen_pos;\n        for (const auto& queen: queens) {\n            int x = queen[0], y = queen[1];\n            queen_pos.insert(x * 8 + y);\n        }\n        vector<vector<int>> ans;\n        for (int dx = -1; dx <= 1; ++dx) {\n            for (int dy = -1; dy <= 1; ++dy) {\n                if (dx == 0 && dy == 0) {\n                    continue;\n                }\n                int kx = king[0] + dx, ky = king[1] + dy;\n                while (kx >= 0 && kx < 8 && ky >= 0 && ky < 8) {\n                    int pos = kx * 8 + ky;\n                    if (queen_pos.count(pos)) {\n                        ans.push_back({kx, ky});\n                        break;\n                    }\n                    kx += dx;\n                    ky += dy;\n                }\n            }\n        }\n        return ans;\n    }", "target_Lan": "cpp###queensAttacktheKing.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <unordered_set>\n// TOFILL\nint main() {\n    vector<vector<int>> queens1 = {};\n    vector<int> king1 = {4, 4};\n    vector<vector<int>> result1 = queensAttacktheKing(queens1, king1);\n    \n    vector<vector<int>> queens2 = {{0, 0}};\n    vector<int> king2 = {0, 0};\n    vector<vector<int>> result2 = queensAttacktheKing(queens2, king2);\n    \n    vector<vector<int>> queens3 = {{0, 1}, {1, 0}};\n    vector<int> king3 = {0, 0};\n    vector<vector<int>> result3 = queensAttacktheKing(queens3, king3);\n    \n    vector<vector<int>> queens4 = {{2, 0}, {0, 2}, {1, 1}};\n    vector<int> king4 = {1, 1};\n    vector<vector<int>> result4 = queensAttacktheKing(queens4, king4);\n    \n    vector<vector<int>> queens5 = {{3, 3}, {4, 5}, {5, 4}};\n    vector<int> king5 = {4, 4};\n    vector<vector<int>> result5 = queensAttacktheKing(queens5, king5);\n    \n    for(const auto& res : result1) {\n        cout << \"[\" << res[0] << \",\" << res[1] << \"] \";\n    }\n    cout << endl;\n\n    for(const auto& res : result2) {\n        cout << \"[\" << res[0] << \",\" << res[1] << \"] \";\n    }\n    cout << endl;\n\n    for(const auto& res : result3) {\n        cout << \"[\" << res[0] << \",\" << res[1] << \"] \";\n    }\n    cout << endl;\n\n    for(const auto& res : result4) {\n        cout << \"[\" << res[0] << \",\" << res[1] << \"] \";\n    }\n    cout << endl;\n\n    for(const auto& res : result5) {\n        cout << \"[\" << res[0] << \",\" << res[1] << \"] \";\n    }\n    cout << endl;\n\n    return 0;\n}"}, {"source_Lan": "python###giveGem.py", "source_code": "def giveGem( gem: List[int], operations: List[List[int]]) -> int:\n        for x, y in operations:\n            number = gem[x] // 2\n            gem[x] -= number\n            gem[y] += number\n        mn, mx = gem[0], gem[0]\n        for number in gem:\n            mn = min(number, mn)\n            mx = max(number, mx)\n        return mx - mn", "trans_code": "int giveGem ( vector < int > gem , vector < vector < int >> operations ) throw ( ) {\n  for ( int x = 0 , y = 0 ;\n  x < operations . size ( ) ;\n  x ++ , y ++ ) {\n    int number = gem [ x ] / 2 ;\n    gem [ x ] -= number ;\n    gem [ y ] += number ;\n  }\n  int mn = gem [ 0 ] , mx = gem [ 0 ] ;\n  for ( int number : gem ) {\n    mn = min ( number , mn ) ;\n    mx = max ( number , mx ) ;\n  }\n  return mx - mn ;\n}\n", "reference_code": "int giveGem(vector<int>& gem, vector<vector<int>>& operations) {\n        for (auto &operation : operations) {\n            int x = operation[0], y = operation[1];\n            int number = gem[x] / 2;\n            gem[x] -= number;\n            gem[y] += number;\n        }\n        int mn = *min_element(gem.begin(), gem.end());\n        int mx = *max_element(gem.begin(), gem.end());\n        return mx - mn;\n    }", "target_Lan": "cpp###giveGem.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <tuple> // Include for std::tuple\n#include <algorithm>\nusing namespace std;\n// TOFILL\nint main() {\n    \n    vector<int> gem1 = {3, 2, 5, 1};\n    vector<vector<int>> operations1 = {{0, 2}, {1, 3}};\n    \n    vector<int> gem2 = {1000, 2000, 3000, 4000};\n    vector<vector<int>> operations2 = {{1, 3}, {0, 2}};\n    \n    vector<int> gem3 = {-5, -3, -1, 2};\n    vector<vector<int>> operations3 = {{2, 1}, {3, 0}};\n    \n    vector<int> gem4 = {7, 8, 9, 10};\n    vector<vector<int>> operations4 = {{0, 1}, {2, 3}};\n    \n    vector<int> gem5 = {1, 2, 3, 4};\n    vector<vector<int>> operations5 = {{2, 0}, {3, 1}};\n    \n    \n    vector<tuple<vector<int>, vector<vector<int>>>> testInputs = {\n        {gem1, operations1},\n        {gem2, operations2},\n        {gem3, operations3},\n        {gem4, operations4},\n        {gem5, operations5}\n    };\n    \n    \n    for(const auto& testInput : testInputs) {\n        vector<int> gem;\n        vector<vector<int>> operations;\n        tie(gem, operations) = testInput; \n        \n        cout << giveGem(gem, operations) << endl;\n    }\n\n    return 0;\n}"}, {"source_Lan": "python###checkValidGrid.py", "source_code": "def checkValidGrid( grid: List[List[int]]) -> bool:\n        if grid[0][0] != 0:\n            return False\n        n = len(grid)\n        indices = [[] for _ in range(n * n)]\n        for i in range(n):\n            for j in range(n):\n                indices[grid[i][j]] = [i, j]\n        for i in range(1, n * n, 1):\n            dx = abs(indices[i][0] - indices[i - 1][0])\n            dy = abs(indices[i][1] - indices[i - 1][1])\n            if dx * dy != 2:\n                return False\n        return True", "trans_code": "bool checkValidGrid ( vector < vector < int >> & grid ) throw ( ) {\n  if ( grid [ 0 ] [ 0 ] != 0 ) return false ;\n  int n = grid . size ( ) ;\n  vector < vector < int >> indices ( n * n ) ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) for ( int j = 0 ;\n  j < n ;\n  j ++ ) indices [ grid [ i ] [ j ] ] . push_back ( i ) ;\n  for ( int i = 1 ;\n  i < n * n ;\n  i += 1 ) {\n    int dx = abs ( indices [ i ] [ 0 ] - indices [ i - 1 ] [ 0 ] ) ;\n    int dy = abs ( indices [ i ] [ 1 ] - indices [ i - 1 ] [ 1 ] ) ;\n    if ( dx * dy != 2 ) return false ;\n  }\n  return true ;\n}\n", "reference_code": "bool checkValidGrid(vector<vector<int>>& grid) {\n        if (grid[0][0] != 0) {\n            return false;\n        }\n        int n = grid.size();\n        vector<array<int, 2>> indices(n * n);\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                indices[grid[i][j]] = {i, j};\n            }\n        }\n        for (int i = 1; i < indices.size(); i++) {\n            int dx = abs(indices[i][0] - indices[i - 1][0]);\n            int dy = abs(indices[i][1] - indices[i - 1][1]);\n            if (dx * dy != 2) {\n                return false;\n            }\n        }\n        return true;\n    }", "target_Lan": "cpp###checkValidGrid.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <array>\n// TOFILL\nint main() {\n    vector<vector<int>> grid1 = {{0}};\n    vector<vector<int>> grid2 = {{1, 0}, {2, 3}};\n    vector<vector<int>> grid3 = {{0, 1}, {3, 2}};\n    vector<vector<int>> grid4 = {{0, 2, 3}, {1, 4, 5}, {6, 7, 8}};\n    vector<vector<int>> grid5 = {{0, 2, 3}, {1, 5, 4}, {6, 7, 8}};\n\n    cout << checkValidGrid(grid1) << endl; \n    cout << checkValidGrid(grid2) << endl; \n    cout << checkValidGrid(grid3) << endl; \n    cout << checkValidGrid(grid4) << endl; \n    cout << checkValidGrid(grid5) << endl; \n\n    return 0;\n}"}, {"source_Lan": "python###findDelayedArrivalTime.py", "source_code": "def findDelayedArrivalTime( arrivalTime: int, delayedTime: int) -> int:\n        return (arrivalTime + delayedTime) % 24", "trans_code": "int findDelayedArrivalTime ( int arrivalTime , int delayedTime ) throw ( ) {\n  return ( arrivalTime + delayedTime ) % 24 ;\n}\n", "reference_code": "    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\n        return (arrivalTime + delayedTime) % 24;\n    }", "target_Lan": "cpp###findDelayedArrivalTime.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n// TOFILL\nint main() {\n    cout << findDelayedArrivalTime(0, 0) << endl; \n    cout << findDelayedArrivalTime(22, 5) << endl; \n    cout << findDelayedArrivalTime(20, 7) << endl; \n    cout << findDelayedArrivalTime(23, 1) << endl; \n    cout << findDelayedArrivalTime(10, 15) << endl; \n}"}, {"source_Lan": "python###checkIfPrerequisite.py", "source_code": "def checkIfPrerequisite( numCourses: int, prerequisites: List[List[int]], queries: List[List[int]]) -> List[bool]:\n        g = [[] for _ in range(numCourses)]\n        indgree = [0] * numCourses\n        isPre = [[False] * numCourses for _ in range(numCourses)]\n        for p in prerequisites:\n            indgree[p[1]] += 1\n            g[p[0]].append(p[1])\n        q = []\n        for i in range(numCourses):\n            if indgree[i] == 0:\n                q.append(i)\n        while len(q) > 0:\n            cur = q[0]\n            q.pop(0)\n            for ne in g[cur]:\n                isPre[cur][ne] = True\n                for i in range(numCourses):\n                    isPre[i][ne] = isPre[i][ne] or isPre[i][cur]\n                indgree[ne] -= 1\n                if indgree[ne] == 0:\n                    q.append(ne)\n        res = []\n        for query in queries:\n            res.append(isPre[query[0]][query[1]])\n        return res", "trans_code": "public : vector < vector < bool >> checkIfPrerequisite ( int numCourses , vector < vector < int >> & prerequisites , vector < vector < int >> & queries ) throw ( ) {\n  vector < vector < int >> g ( numCourses ) ;\n  vector < int > indgree ( numCourses , 0 ) ;\n  vector < vector < bool >> isPre ( numCourses , vector < bool > ( numCourses , false ) ) ;\n  for ( auto p : prerequisites ) {\n    indgree [ p . second ] ++ ;\n    g [ p . first ] . push_back ( p . second ) ;\n  }\n  vector < int > q ;\n  for ( int i = 0 ;\n  i < numCourses ;\n  i ++ ) if ( indgree [ i ] == 0 ) q . push_back ( i ) ;\n  while ( q . size ( ) > 0 ) {\n    int cur = q . front ( ) ;\n    q . pop ( ) ;\n    for ( int ne = 0 ;\n    ne < g [ cur ] . size ( ) ;\n    ne ++ ) {\n      isPre [ cur ] [ ne ] = true ;\n      for ( int i = 0 ;\n      i < numCourses ;\n      i ++ ) isPre [ i ] [ ne ] = isPre [ i ] [ ne ] || isPre [ i ] [ cur ] ;\n      indgree [ ne ] -- ;\n      if ( indgree [ ne ] == 0 ) q . push_back ( ne ) ;\n    }\n  }\n  vector < vector < bool >> res ;\n  for ( auto query : queries ) res . push_back ( isPre [ query . first ] [ query . second ] ) ;\n  return res ;\n}\n", "reference_code": "vector<bool> checkIfPrerequisite(int numCourses, vector<vector<int>>& prerequisites, vector<vector<int>>& queries) {\n        vector<vector<int>> g(numCourses);\n        vector<int> indgree(numCourses, 0);\n        vector<vector<bool>> isPre(numCourses, vector<bool>(numCourses, false));\n        for (auto& p : prerequisites) {\n            ++indgree[p[1]];\n            g[p[0]].push_back(p[1]);\n        }\n        queue<int> q;\n        for (int i = 0; i < numCourses; ++i) {\n            if (indgree[i] == 0) {\n                q.push(i);\n            }\n        }\n        while (!q.empty()) {\n            auto cur = q.front();\n            q.pop();\n            for (auto& ne : g[cur]) {\n                isPre[cur][ne] = true;\n                for (int i = 0; i < numCourses; ++i) {\n                    isPre[i][ne] = isPre[i][ne] | isPre[i][cur];\n                }\n                --indgree[ne];\n                if (indgree[ne] == 0) {\n                    q.push(ne);\n                }\n            }\n        }\n        vector<bool> res;\n        for (auto& query : queries) {\n            res.push_back(isPre[query[0]][query[1]]);\n        }\n        return res;\n    }", "target_Lan": "cpp###checkIfPrerequisite.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <queue>\n// TOFILL\nint main() {\n    \n    int numCourses1 = 1;\n    vector<vector<int>> prerequisites1 = {};\n    vector<vector<int>> queries1 = {{0, 0}};\n    vector<bool> result1 = checkIfPrerequisite(numCourses1, prerequisites1, queries1);\n    for(bool r : result1) cout << r << \" \";\n    cout << endl;\n\n    \n    int numCourses2 = 3;\n    vector<vector<int>> prerequisites2 = {{0, 1}, {1, 2}};\n    vector<vector<int>> queries2 = {{0, 1}, {1, 2}, {0, 2}};\n    vector<bool> result2 = checkIfPrerequisite(numCourses2, prerequisites2, queries2);\n    for(bool r : result2) cout << r << \" \";\n    cout << endl;\n\n    \n    int numCourses3 = 3;\n    vector<vector<int>> prerequisites3 = {{0, 1}, {0, 2}};\n    vector<vector<int>> queries3 = {{1, 0}, {2, 0}, {0, 1}, {0, 2}};\n    vector<bool> result3 = checkIfPrerequisite(numCourses3, prerequisites3, queries3);\n    for(bool r : result3) cout << r << \" \";\n    cout << endl;\n\n    \n    int numCourses4 = 4;\n    vector<vector<int>> prerequisites4 = {{0, 1}, {1, 2}, {2, 3}};\n    vector<vector<int>> queries4 = {{0, 3}, {3, 0}, {0, 2}, {1, 3}, {2, 1}};\n    vector<bool> result4 = checkIfPrerequisite(numCourses4, prerequisites4, queries4);\n    for(bool r : result4) cout << r << \" \";\n    cout << endl;\n\n    return 0;\n}"}, {"source_Lan": "python###minTrioDegree.py", "source_code": "def minTrioDegree( n: int, edges: List[List[int]]) -> int:\n        \n        g = defaultdict(set)\n        \n        h = defaultdict(list)\n        degree = [0] * n\n        for x, y in edges:\n            x, y = x - 1, y - 1\n            g[x].add(y)\n            g[y].add(x)\n            degree[x] += 1\n            degree[y] += 1\n        for x, y in edges:\n            x, y = x - 1, y - 1\n            if degree[x] < degree[y] or (degree[x] == degree[y] and x < y):\n                h[x].append(y)\n            else:\n                h[y].append(x)\n        ans = inf\n        for i in range(n):\n            for j in h[i]:\n                for k in h[j]:\n                    if k in g[i]:\n                        ans = min(ans, degree[i] + degree[j] + degree[k] - 6)\n        return -1 if ans == inf else ans", "trans_code": "public : int minTrioDegree ( int n , vector < vector < int >> & edges ) throw ( ) {\n  unordered_set < int > g ;\n  unordered_set < int > h ;\n  vector < int > degree ( n ) ;\n  for ( int x = 0 , y = 0 ;\n  x < n ;\n  x ++ , y ++ ) {\n    int x = x - 1 , y = y - 1 ;\n    g [ x ] . insert ( y ) ;\n    g [ y ] . insert ( x ) ;\n    degree [ x ] ++ ;\n    degree [ y ] ++ ;\n  }\n  for ( int x = 0 , y = 0 ;\n  x < n ;\n  x ++ , y ++ ) {\n    int x = x - 1 , y = y - 1 ;\n    if ( degree [ x ] < degree [ y ] || ( degree [ x ] == degree [ y ] && x < y ) ) h [ x ] . insert ( y ) ;\n    else h [ y ] . insert ( x ) ;\n  }\n  int ans = inf ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < h [ i ] . size ( ) ;\n    j ++ ) {\n      for ( int k = 0 ;\n      k < h [ j ] . size ( ) ;\n      k ++ ) {\n        if ( h [ j ] [ k ] == g [ i ] [ j ] ) ans = min ( ans , degree [ i ] + degree [ j ] + degree [ k ] - 6 ) ;\n      }\n    }\n  }\n  return - 1 == ans ? inf : ans ;\n}\n", "reference_code": "int minTrioDegree(int n, vector<vector<int>>& edges) {\n        \n        vector<unordered_set<int>> g(n);\n        \n        vector<vector<int>> h(n);\n        vector<int> degree(n);\n        for (auto&& edge: edges) {\n            int x = edge[0] - 1, y = edge[1] - 1;\n            g[x].insert(y);\n            g[y].insert(x);\n            ++degree[x];\n            ++degree[y];\n        }\n        for (auto&& edge: edges) {\n            int x = edge[0] - 1, y = edge[1] - 1;\n            if (degree[x] < degree[y] || (degree[x] == degree[y] && x < y)) {\n                h[x].push_back(y);\n            }\n            else {\n                h[y].push_back(x);\n            }\n        }\n        int ans = INT_MAX;\n        for (int i = 0; i < n; ++i) {\n            for (int j: h[i]) {\n                for (int k: h[j]) {\n                    if (g[i].count(k)) {\n                        ans = min(ans, degree[i] + degree[j] + degree[k] - 6);\n                    }\n                }\n            }\n        }\n        return ans == INT_MAX ? -1 : ans;\n    }", "target_Lan": "cpp###minTrioDegree.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <unordered_set>\n#include <climits>\n// TOFILL\nint main() {\n    vector<vector<int>> edges1 = {{1, 2}, {2, 3}, {1, 3}};\n    cout << minTrioDegree(3, edges1) << endl;\n\n    vector<vector<int>> edges2 = {{1, 2}, {2, 3}, {3, 4}, {4, 5}};\n    cout << minTrioDegree(5, edges2) << endl;\n\n    vector<vector<int>> edges3 = {{1, 2}, {2, 3}, {3, 4}, {1, 3}, {1, 4}};\n    cout << minTrioDegree(4, edges3) << endl;\n\n    vector<vector<int>> edges4 = {{1, 2}, {2, 3}, {3, 4}, {1, 4}, {3, 5}, {5, 6}};\n    cout << minTrioDegree(6, edges4) << endl;\n\n    vector<vector<int>> edges5 = {{1, 2}, {2, 3}, {3, 4}, {1, 5}, {5, 6}, {6, 7}, {3, 6}};\n    cout << minTrioDegree(7, edges5) << endl;\n\n    return 0;\n}"}, {"source_Lan": "python###minimumJumps.py", "source_code": "def minimumJumps( forbidden: List[int], a: int, b: int, x: int) -> int:\n        q, visited = deque([[0, 1, 0]]), set([0])\n        lower, upper = 0, max(max(forbidden) + a, x) + b\n        forbiddenSet = set(forbidden)\n        while q:\n            position, direction, step = q.popleft()\n            if position == x:\n                return step\n            nextPosition = position + a\n            nextDirection = 1\n            if lower <= nextPosition <= upper and nextPosition * nextDirection not in visited and nextPosition not in forbiddenSet:\n                visited.add(nextPosition * nextDirection)\n                q.append([nextPosition, nextDirection, step + 1])\n            if direction == 1:\n                nextPosition = position - b\n                nextDirection = -1\n                if lower <= nextPosition <= upper and nextPosition * nextDirection not in visited and nextPosition not in forbiddenSet:\n                    visited.add(nextPosition * nextDirection)\n                    q.append([nextPosition, nextDirection, step + 1])\n        return -1", "trans_code": "int minimumJumps ( std :: vector < int > forbidden , int a , int b , int x ) throw ( ) {\n  std :: deque < int > q , visited ;\n  q . push_back ( 0 ) ;\n  q . push_back ( 1 ) ;\n  q . push_back ( 0 ) ;\n  q . push_back ( 0 ) ;\n  q . push_back ( 0 ) ;\n  q . push_back ( 0 ) ;\n  q . push_back ( 0 ) ;\n  q . push_back ( 0 ) ;\n  q . push_back ( 0 ) ;\n  q . push_back ( 0 ) ;\n  q . push_back ( 0 ) ;\n  q . push_back ( 0 ) ;\n  q . push_back ( 0 ) ;\n  q . push_back ( 0 ) ;\n  q . push_back ( 0 ) ;\n  q . push_back ( 0 ) ;\n  q . push_back ( 0 ) ;\n  q . push_back ( 0 ) ;\n  q . push_back ( 0 ) ;\n  q . push_back ( 0 ) ;\n  q . push_back ( 0 ) ;\n  q . push_back ( 0 ) ;\n  q . push_back ( 0 ) ;\n  q . push_back ( 0 ) ;\n  q . push_back ( 0 ) ;\n  q . push_back ( 0 ) ;\n  q . push_back ( 0 ) ;\n  q . push_back ( 0 ) ;\n  q . push_back ( 0 ) ;\n  q . push_back ( 0 ) ;\n  q . push_back ( 0 ) ;\n  q . push_back ( 0 ) ;\n  q . push_back ( 0 ) ;\n  q . push_back ( 0 ) ;\n  q . push_back ( 0 ) ;\n  q . push_back ( 0 ) ;\n  q . push_back ( 0 ) ;\n  q . push_back ( 0 ) ;\n  q . push_back ( 0 ) ;\n  q . push_back ( 0 ) ;\n  q . push_back ( 0 ) ;\n  q . push_back ( 0 ) ;\n  q . push_back ( 0 ) ;\n  q . push_back ( 0 ) ;\n  q . push_back ( 0 ) ;\n  q . push_back ( 0 ) ;\n  q . push_back ( 0 ) ;\n  q . push_back ( 0 ) ;\n  q . push_back ( 0 ) ;\n  q . push_back ( 0 ) ;\n  q . push_back ( 0 ) ;\n  q . push_back ( 0 ) ;\n  q . push_back ( 0 ) ;\n  q . push_back ( 0 ) ;\n  q . push_back ( 0 ) ;\n  q . push_back ( 0 ) ;\n  q . push_back ( 0 ) ;\n  q . push_back ( 0 ) ;\n  q . push_back ( 0 ) ;\n  q . push_back ( 0 ) ;\n  q . push_back ( 0 ) ;\n  q . push_back ( 0 ) ;\n  q . push_back ( 0 ) ;\n  q . push_back ( 0 ) ;\n  q . push_back ( 0 ) ;\n  q . push_back ( 0 ) ;\n  q . push_back ( 0 ) ;\n  q . push_back ( 0", "reference_code": "int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\n        queue<tuple<int, int, int>> q;\n        unordered_set<int> visited;\n        q.emplace(0, 1, 0);\n        visited.emplace(0);\n        int lower = 0, upper = max(*max_element(forbidden.begin(), forbidden.end()) + a, x) + b;\n        unordered_set<int> forbiddenSet(forbidden.begin(), forbidden.end());\n        while (!q.empty()) {\n            auto [position, direction, step] = q.front();\n            q.pop();\n            if (position == x) {\n                return step;\n            }\n            int nextPosition = position + a;\n            int nextDirection = 1;\n            if (lower <= nextPosition && nextPosition <= upper && !visited.count(nextPosition * nextDirection) && !forbiddenSet.count(nextPosition)) {\n                visited.emplace(nextPosition * nextDirection);\n                q.emplace(nextPosition, nextDirection, step + 1);\n            }\n            if (direction == 1) {\n                nextPosition = position - b;\n                nextDirection = -1;\n                if (lower <= nextPosition && nextPosition <= upper && !visited.count(nextPosition * nextDirection) && !forbiddenSet.count(nextPosition)) {\n                    visited.emplace(nextPosition * nextDirection);\n                    q.emplace(nextPosition, nextDirection, step + 1);\n                }\n            }\n        }\n        return -1;\n    }", "target_Lan": "cpp###minimumJumps.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <unordered_set>\n#include <queue>\n#include <tuple>\n#include <algorithm>\n// TOFILL\nint main() {\n    vector<int> forbidden1 = {3};\n    cout << minimumJumps(forbidden1, 2, 1, 5) << endl; \n\n    vector<int> forbidden2 = {7, 8};\n    cout << minimumJumps(forbidden2, 3, 2, 10) << endl; \n\n    vector<int> forbidden3 = {200};\n    cout << minimumJumps(forbidden3, 100, 50, 250) << endl; \n}"}, {"source_Lan": "python###numFactoredBinaryTrees.py", "source_code": "def numFactoredBinaryTrees( arr: List[int]) -> int:\n        n = len(arr)\n        arr = sorted(arr)\n        dp = [1] * n\n        res, mod = 0, 10**9 + 7\n        for i in range(n):\n            left, right = 0, i - 1\n            while left <= right:\n                while right >= left and arr[left] * arr[right] > arr[i]:\n                    right -= 1\n                if right >= left and arr[left] * arr[right] == arr[i]:\n                    if right != left:\n                        dp[i] = (dp[i] + dp[left] * dp[right] * 2) % mod\n                    else:\n                        dp[i] = (dp[i] + dp[left] * dp[right]) % mod\n                left += 1\n            res = (res + dp[i]) % mod\n        return res", "trans_code": "public : int numFactoredBinaryTrees ( vector < int > arr ) throw ( ) {\n  int n = arr . size ( ) ;\n  sort ( arr . begin ( ) , arr . end ( ) ) ;\n  vector < int > dp ( n , 1 ) ;\n  int res = 0 , mod = 10 * 9 + 7 ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    int left = 0 , right = i - 1 ;\n    while ( left <= right ) {\n      while ( right >= left && arr [ left ] * arr [ right ] > arr [ i ] ) right -- ;\n      if ( right >= left && arr [ left ] * arr [ right ] == arr [ i ] ) {\n        if ( right != left ) dp [ i ] = ( dp [ i ] + dp [ left ] * dp [ right ] * 2 ) % mod ;\n        else dp [ i ] = ( dp [ i ] + dp [ left ] * dp [ right ] ) % mod ;\n      }\n      left ++ ;\n    }\n    res = ( res + dp [ i ] ) % mod ;\n  }\n  return res ;\n}\n", "reference_code": "int numFactoredBinaryTrees(vector<int>& arr) {\n        sort(arr.begin(), arr.end());\n        int n = arr.size();\n        vector<long long> dp(n);\n        long long res = 0, mod = 1e9 + 7;\n        for (int i = 0; i < n; i++) {\n            dp[i] = 1;\n            for (int left = 0, right = i - 1; left <= right; left++) {\n                while (right >= left && (long long)arr[left] * arr[right] > arr[i]) {\n                    right--;\n                }\n                if (right >= left && (long long)arr[left] * arr[right] == arr[i]) {\n                    if (right != left) {\n                        dp[i] = (dp[i] + dp[left] * dp[right] * 2) % mod;\n                    } else {\n                        dp[i] = (dp[i] + dp[left] * dp[right]) % mod;\n                    }\n                }\n            }\n            res = (res + dp[i]) % mod;\n        }\n        return res;\n    }", "target_Lan": "cpp###numFactoredBinaryTrees.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <algorithm>\n// TOFILL\nint main() {\n    vector<int> input1 = {1, 2, 4};\n    vector<int> input2 = {2, 2, 4};\n    vector<int> input3 = {2, 3, 6, 12};\n    vector<int> input4 = {1000000000, 1000000000, 1000000000};\n\n    cout << numFactoredBinaryTrees(input1) << endl;\n    cout << numFactoredBinaryTrees(input2) << endl;\n    cout << numFactoredBinaryTrees(input3) << endl;\n    cout << numFactoredBinaryTrees(input4) << endl;\n\n    return 0;\n}"}, {"source_Lan": "python###captureForts.py", "source_code": "def captureForts( forts: List[int]) -> int:\n        ans, pre = 0, -1\n        for i, fort in enumerate(forts):\n            if fort == -1 or fort == 1:\n                if pre >= 0 and fort != forts[pre]:\n                    ans = max(ans, i - pre - 1)\n                pre = i\n        return ans", "trans_code": "int captureForts ( vector < int > & forts ) throw ( ) {\n  int ans = 0 , pre = - 1 ;\n  for ( int i = 0 , fort = 0 ;\n  i < forts . size ( ) ;\n  i ++ ) {\n    if ( forts [ i ] == - 1 || forts [ i ] == 1 ) {\n      if ( pre >= 0 && forts [ pre ] != forts [ i ] ) ans = max ( ans , i - pre - 1 ) ;\n      pre = i ;\n    }\n  }\n  return ans ;\n}\n", "reference_code": "int captureForts(vector<int>& forts) {\n        int ans = 0, pre = -1;\n        for (int i = 0; i < forts.size(); i++) {\n            if (forts[i] == 1 || forts[i] == -1) {\n                if (pre >= 0 && forts[i] != forts[pre]) {\n                    ans = max(ans, i - pre - 1);\n                }\n                pre = i;\n            }\n        }\n        return ans;\n    }", "target_Lan": "cpp###captureForts.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    vector<int> input1 = {};\n    vector<int> input2 = {1, 1, 1};\n    vector<int> input3 = {-1, -1, -1};\n    vector<int> input4 = {1, 0, -1, 0, 1};\n    vector<int> input5 = {0, 0, 1, 0, -1, 0, 0};\n\n    cout << captureForts(input1) << endl; \n    cout << captureForts(input2) << endl; \n    cout << captureForts(input3) << endl; \n    cout << captureForts(input4) << endl; \n    cout << captureForts(input5) << endl; \n\n    return 0;\n}"}, {"source_Lan": "python###maxDistToClosest.py", "source_code": "def maxDistToClosest( seats: List[int]) -> int:\n        res, l = 0, 0\n        while l < len(seats) and seats[l] == 0:\n            l += 1\n        res = max(res, l)\n        while l < len(seats):\n            r = l + 1\n            while r < len(seats) and seats[r] == 0:\n                r += 1\n            if r == len(seats):\n                res = max(res, r - l - 1)\n            else:\n                res = max(res, (r - l) // 2)\n            l = r\n        return res", "trans_code": "public : int maxDistToClosest ( vector < int > & seats ) throw ( ) {\n  int res = 0 , l = 0 ;\n  while ( l < seats . size ( ) && seats [ l ] == 0 ) l ++ ;\n  res = max ( res , l ) ;\n  while ( l < seats . size ( ) ) {\n    int r = l + 1 ;\n    while ( r < seats . size ( ) && seats [ r ] == 0 ) r ++ ;\n    if ( r == seats . size ( ) ) res = max ( res , r - l - 1 ) ;\n    else res = max ( res , ( r - l ) / 2 ) ;\n    l = r ;\n  }\n  return res ;\n}\n", "reference_code": "int maxDistToClosest(vector<int>& seats) {\n        int res = 0;\n        int l = 0;\n        while (l < seats.size() && seats[l] == 0) {\n            ++l;\n        }\n        res = max(res, l);\n        while (l < seats.size()) {\n            int r = l + 1;\n            while (r < seats.size() && seats[r] == 0) {\n                ++r;\n            }\n            if (r == seats.size()) {\n                res = max(res, r - l - 1);\n            } else {\n                res = max(res, (r - l) / 2);\n            }\n            l = r;\n        }\n        return res;\n    }", "target_Lan": "cpp###maxDistToClosest.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <algorithm>\n// TOFILL\nint main() {\n    vector<int> input1 = {0, 0, 0, 0, 1};\n    vector<int> input2 = {1, 0, 0, 0, 1};\n    vector<int> input3 = {1, 0, 0, 0, 0};\n    vector<int> input4 = {0, 0, 0, 1, 0, 1, 0, 0};\n    vector<int> input5 = {1, 1, 1, 1};\n\n    cout << maxDistToClosest(input1) << endl;\n    cout << maxDistToClosest(input2) << endl;\n    cout << maxDistToClosest(input3) << endl;\n    cout << maxDistToClosest(input4) << endl;\n    cout << maxDistToClosest(input5) << endl;\n\n    return 0;\n}"}, {"source_Lan": "python###findReplaceString.py", "source_code": "def findReplaceString( s: str, indices: List[int], sources: List[str], targets: List[str]) -> str:\n        n, m = len(s), len(indices)\n        ops = list(range(m))\n        ops.sort(key=lambda x: indices[x])\n        ans = list()\n        i = pt = 0\n        while i < n:\n            while pt < m and indices[ops[pt]] < i:\n                pt += 1\n            succeed = False\n            while pt < m and indices[ops[pt]] == i:\n                if s[i:i + len(sources[ops[pt]])] == sources[ops[pt]]:\n                    succeed = True\n                    break\n                pt += 1\n            if succeed:\n                ans.append(targets[ops[pt]])\n                i += len(sources[ops[pt]])\n            else:\n                ans.append(s[i])\n                i += 1\n        return \"\".join(ans)", "trans_code": "public : string findReplaceString ( string s , vector < int > indices , vector < string > sources , vector < string > targets ) throw ( ) {\n  int n = s . size ( ) ;\n  int m = indices . size ( ) ;\n  vector < int > ops ( m ) ;\n  sort ( ops . begin ( ) , ops . end ( ) ) ;\n  vector < string > ans ;\n  int i = pt = 0 ;\n  while ( i < n ) {\n    while ( pt < m && indices [ ops [ pt ] ] < i ) pt ++ ;\n    bool succeed = false ;\n    while ( pt < m && indices [ ops [ pt ] ] == i ) {\n      if ( s . substr ( i , sources [ ops [ ops [ pt ] ] ] . size ( ) ) == sources [ ops [ ops [ pt ] ] ] ) {\n        succeed = true ;\n        break ;\n      }\n      pt ++ ;\n    }\n    if ( succeed ) {\n      ans . push_back ( targets [ ops [ ops [ pt ] ] ] ) ;\n      i += sources [ ops [ ops [ pt ] ] ] . size ( ) ;\n    }\n    else {\n      ans . push_back ( s [ i ] ) ;\n      i ++ ;\n    }\n  }\n  return ans ;\n}\n", "reference_code": "string findReplaceString(string s, vector<int>& indices, vector<string>& sources, vector<string>& targets) {\n        int n = s.size(), m = indices.size();\n        vector<int> ops(m);\n        iota(ops.begin(), ops.end(), 0);\n        sort(ops.begin(), ops.end(), [&](int i, int j) { return indices[i] < indices[j]; });\n        string ans;\n        int pt = 0;\n        for (int i = 0; i < n;) {\n            while (pt < m && indices[ops[pt]] < i) {\n                ++pt;\n            }\n            bool succeed = false;\n            while (pt < m && indices[ops[pt]] == i) {\n                if (s.substr(i, sources[ops[pt]].size()) == sources[ops[pt]]) {\n                    succeed = true;\n                    break;\n                }\n                ++pt;\n            }\n            if (succeed) {\n                ans += targets[ops[pt]];\n                i += sources[ops[pt]].size();\n            }\n            else {\n                ans += s[i];\n                ++i;\n            }\n        }\n        return ans;\n    }", "target_Lan": "cpp###findReplaceString.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n// TOFILL\nint main() {\n    vector<int> indices1 = {0, 2};\n    vector<string> sources1 = {\"ab\", \"cd\"};\n    vector<string> targets1 = {\"12\", \"34\"};\n    cout << findReplaceString(\"abcde\", indices1, sources1, targets1) << endl;\n\n    vector<int> indices2 = {0, 1, 2};\n    vector<string> sources2 = {\"a\", \"b\", \"c\"};\n    vector<string> targets2 = {\"x\", \"y\", \"z\"};\n    cout << findReplaceString(\"abcde\", indices2, sources2, targets2) << endl;\n\n    vector<int> indices3 = {0, 0, 0};\n    vector<string> sources3 = {\"abc\", \"a\", \"abcd\"};\n    vector<string> targets3 = {\"1\", \"2\", \"3\"};\n    cout << findReplaceString(\"abcde\", indices3, sources3, targets3) << endl;\n\n    vector<int> indices4 = {5};\n    vector<string> sources4 = {\"\"};\n    vector<string> targets4 = {\"xyz\"};\n    cout << findReplaceString(\"abcde\", indices4, sources4, targets4) << endl;\n\n    vector<int> indices5 = {};\n    vector<string> sources5 = {};\n    vector<string> targets5 = {};\n    cout << findReplaceString(\"\", indices5, sources5, targets5) << endl;\n\n    return 0;\n}"}, {"source_Lan": "python###circularGameLosers.py", "source_code": "def circularGameLosers( n: int, k: int) -> List[int]:\n        visit = [False] * n\n        i = k\n        j = 0\n        while not visit[j]:\n            visit[j] = True\n            j = (j + i) % n\n            i += k\n        ans = []\n        for i in range(n):\n            if not visit[i]:\n                ans.append(i + 1)\n        return ans", "trans_code": "public : vector < int > circularGameLosers ( int n , int k ) throw ( ) {\n  vector < bool > visit ( n , false ) ;\n  int i = k ;\n  int j = 0 ;\n  while ( ! visit [ j ] ) {\n    visit [ j ] = true ;\n    j = ( j + i ) % n ;\n    i += k ;\n  }\n  vector < int > ans ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    if ( ! visit [ i ] ) ans . push_back ( i + 1 ) ;\n  }\n  return ans ;\n}\n", "reference_code": "vector<int> circularGameLosers(int n, int k) {\n        vector<bool> visit(n, false);\n        for (int i = k, j = 0; !visit[j]; i += k) {\n            visit[j] = true;\n            j = (j + i) % n;\n        }\n        vector<int> ans;\n        for (int i = 0; i < n; i++) {\n            if (!visit[i]) {\n                ans.emplace_back(i + 1);\n            }\n        }\n        return ans;\n    }", "target_Lan": "cpp###circularGameLosers.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    vector<int> result;\n\n    result = circularGameLosers(1, 1);\n    for(int i : result) cout << i << \" \";\n    cout << endl;\n\n    result = circularGameLosers(5, 2);\n    for(int i : result) cout << i << \" \";\n    cout << endl;\n\n    result = circularGameLosers(10, 1);\n    for(int i : result) cout << i << \" \";\n    cout << endl;\n\n    result = circularGameLosers(10, 5);\n    for(int i : result) cout << i << \" \";\n    cout << endl;\n\n    result = circularGameLosers(7, 8);\n    for(int i : result) cout << i << \" \";\n    cout << endl;\n\n    result = circularGameLosers(100, 25);\n    for(int i : result) cout << i << \" \";\n    cout << endl;\n\n    return 0;\n}"}, {"source_Lan": "python###countSeniors.py", "source_code": "def countSeniors( details: List[str]) -> int:\n        return sum(1 for info in details if int(info[11:13]) > 60)", "trans_code": "int countSeniors ( const std :: vector < std :: string > & details ) throw ( ) {\n  return std :: distance ( details . begin ( ) , details . end ( ) ) ;\n}\n", "reference_code": "int countSeniors(vector<string>& details) {\n        int count = 0;\n        for (string & info : details) {\n            if (stoi(info.substr(11, 2)) > 60) {\n                count++;\n            }\n        }\n        return count;\n    }", "target_Lan": "cpp###countSeniors.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <string>\n// TOFILL\nint main() {\n    vector<string> test1 = {};\n    vector<string> test2 = {\"John Doe 01-01-1960\"};\n    vector<string> test3 = {\"Jane Smith 01-01-1962\"};\n    \n    cout << countSeniors(test1) << endl;\n    cout << countSeniors(test2) << endl;\n    cout << countSeniors(test3) << endl;\n\n    return 0;\n}"}, {"source_Lan": "python###maxAbsoluteSum.py", "source_code": "def maxAbsoluteSum( nums: List[int]) -> int:\n        positiveMax, negativeMin = 0, 0\n        positiveSum, negativeSum = 0, 0\n        for n in nums:\n            positiveSum += n\n            positiveMax = max(positiveMax, positiveSum)\n            positiveSum = max(0, positiveSum)\n            negativeSum += n\n            negativeMin = min(negativeMin, negativeSum)\n            negativeSum = min(0, negativeSum)\n        return max(positiveMax, -negativeMin)", "trans_code": "public : int maxAbsoluteSum ( vector < int > & nums ) throw ( ) {\n  int positiveMax = 0 , negativeMin = 0 ;\n  int positiveSum = 0 , negativeSum = 0 ;\n  for ( int n : nums ) {\n    positiveSum += n ;\n    positiveMax = max ( positiveMax , positiveSum ) ;\n    positiveSum = max ( 0 , positiveSum ) ;\n    negativeSum += n ;\n    negativeMin = min ( negativeMin , negativeSum ) ;\n    negativeSum = min ( 0 , negativeSum ) ;\n  }\n  return max ( positiveMax , - negativeMin ) ;\n}\n", "reference_code": "int maxAbsoluteSum(vector<int>& nums) {\n        int positiveMax = 0, negativeMin = 0;\n        int positiveSum = 0, negativeSum = 0;\n        for (int num : nums) {\n            positiveSum += num;\n            positiveMax = max(positiveMax, positiveSum);\n            positiveSum = max(0, positiveSum);\n            negativeSum += num;\n            negativeMin = min(negativeMin, negativeSum);\n            negativeSum = min(0, negativeSum);\n        }\n        return max(positiveMax, -negativeMin);\n    }", "target_Lan": "cpp###maxAbsoluteSum.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n// TOFILL\nint main() {\n    \n    vector<int> nums1 = {};\n    cout << maxAbsoluteSum(nums1) << endl;\n\n    \n    vector<int> nums2 = {1, 2, 3, 4, 5};\n    cout << maxAbsoluteSum(nums2) << endl;\n\n    \n    vector<int> nums3 = {-1, -2, -3, -4, -5};\n    cout << maxAbsoluteSum(nums3) << endl;\n\n    \n    vector<int> nums4 = {1, -2, 3, -4, 5, -6};\n    cout << maxAbsoluteSum(nums4) << endl;\n\n    \n    vector<int> nums5 = {10};\n    cout << maxAbsoluteSum(nums5) << endl;\n\n    return 0;\n}"}, {"source_Lan": "python###minimumOperationsToMakeKPeriodic.py", "source_code": "def minimumOperationsToMakeKPeriodic( word: str, k: int) -> int:\n        n = len(word)\n        count = Counter(word[i: i + k] for i in range(0, n, k))\n        return n // k - max(count.values())", "trans_code": "int minimumOperationsToMakeKPeriodic ( string word , int k ) throw ( ) {\n  int n = word . size ( ) ;\n  std :: map < int , int > count ( word . begin ( ) , word . end ( ) ) ;\n  return n / k - std :: max ( count . begin ( ) , count . end ( ) ) ;\n}\n", "reference_code": "int minimumOperationsToMakeKPeriodic(string word, int k) {\n        int n = word.size(), res = INT_MAX;\n        unordered_map<string, int> count;\n        for (int i = 0; i < n; i += k) {\n            string &&part = word.substr(i, k);\n            count[part]++;\n            res = min(res, n / k - count[part]);\n        }\n        return res;\n    }", "target_Lan": "cpp###minimumOperationsToMakeKPeriodic.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <unordered_map>\n#include <string>\n#include <climits>\n// TOFILL\nint main() {\n    cout << minimumOperationsToMakeKPeriodic(\"abc\", 5) << endl;\n    cout << minimumOperationsToMakeKPeriodic(\"aaaa\", 2) << endl;\n    cout << minimumOperationsToMakeKPeriodic(\"ababab\", 3) << endl;\n}"}, {"source_Lan": "python###maxScore.py", "source_code": "def maxScore( grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        prerow = [[0] * n for _ in range(m)]\n        precol = [[0] * n for _ in range(m)]\n        f = [[-inf] * n for _ in range(m)]\n        ans = -inf\n        for i in range(m):\n            for j in range(n):\n                if i > 0:\n                    f[i][j] = max(f[i][j], grid[i][j] + precol[i - 1][j])\n                if j > 0:\n                    f[i][j] = max(f[i][j], grid[i][j] + prerow[i][j - 1])\n                ans = max(ans, f[i][j])\n                prerow[i][j] = precol[i][j] = max(f[i][j], 0) - grid[i][j]\n                if i > 0:\n                    precol[i][j] = max(precol[i][j], precol[i - 1][j])\n                if j > 0:\n                    prerow[i][j] = max(prerow[i][j], prerow[i][j - 1])\n        return ans", "trans_code": "public : int maxScore ( vector < vector < int >> & grid ) throw ( ) {\n  int m = grid . size ( ) ;\n  int n = grid [ 0 ] . size ( ) ;\n  vector < vector < int >> prerow ( m ) ;\n  vector < vector < int >> precol ( m ) ;\n  vector < vector < int >> f ( m ) ;\n  int ans = - inf ;\n  for ( int i = 0 ;\n  i < m ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < n ;\n    j ++ ) {\n      if ( i > 0 ) f [ i ] [ j ] = max ( f [ i ] [ j ] , grid [ i ] [ j ] + precol [ i - 1 ] [ j ] ) ;\n      if ( j > 0 ) f [ i ] [ j ] = max ( f [ i ] [ j ] , grid [ i ] [ j ] + prerow [ i ] [ j - 1 ] ) ;\n      ans = max ( ans , f [ i ] [ j ] ) ;\n      prerow [ i ] [ j ] = precol [ i ] [ j ] = max ( f [ i ] [ j ] , 0 ) - grid [ i ] [ j ] ;\n      if ( i > 0 ) precol [ i ] [ j ] = max ( precol [ i ] [ j ] , precol [ i - 1 ] [ j ] ) ;\n      if ( j > 0 ) prerow [ i ] [ j ] = max ( prerow [ i ] [ j ] , prerow [ i ] [ j - 1 ] ) ;\n    }\n  }\n  return ans ;\n}\n", "reference_code": "int maxScore(vector<vector<int>>& grid) {\n        int m = grid.size(), n = grid[0].size();\n        vector<vector<int>> prerow(m, vector<int>(n));\n        vector<vector<int>> precol(m, vector<int>(n));\n        vector<vector<int>> f(m, vector<int>(n, INT_MIN));\n        int ans = INT_MIN;\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (i > 0) {\n                    f[i][j] = max(f[i][j], grid[i][j] + precol[i - 1][j]);\n                }\n                if (j > 0) {\n                    f[i][j] = max(f[i][j], grid[i][j] + prerow[i][j - 1]);\n                }\n                ans = max(ans, f[i][j]);\n                prerow[i][j] = precol[i][j] = max(f[i][j], 0) - grid[i][j];\n                if (i > 0) {\n                    precol[i][j] = max(precol[i][j], precol[i - 1][j]);\n                }\n                if (j > 0) {\n                    prerow[i][j] = max(prerow[i][j], prerow[i][j - 1]);\n                }\n            }\n        }\n        return ans;\n    }", "target_Lan": "cpp###maxScore.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits> // For INT_MIN\nusing namespace std;\n// TOFILL\nint main() {\n    \n    vector<vector<int>> grid1 = {{1,2}};\n    cout << maxScore(grid1) << endl;\n\n    \n    vector<vector<int>> grid2 = {{1, 2}, {3, 4}};\n    cout << maxScore(grid2) << endl;\n\n    \n    vector<vector<int>> grid3 = {{100, -1}, {-1, 100}};\n    cout << maxScore(grid3) << endl;\n\n    \n    vector<vector<int>> grid4 = {{0, 0, 0}, {0, 0, 0}, {0, 0, 0}};\n    cout << maxScore(grid4) << endl;\n\n    \n    vector<vector<int>> grid5 = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};\n    cout << maxScore(grid5) << endl;\n\n    return 0;\n}"}, {"source_Lan": "python###isArraySpecial.py", "source_code": "def isArraySpecial( nums: List[int], queries: List[List[int]]) -> List[bool]:\n       n = len(nums)\n       dp = [1] * n\n       for i in range(1, n):\n           if (nums[i] ^ nums[i - 1]) & 1 == 1:\n               dp[i] = dp[i - 1] + 1\n       return [dp[y] >= y - x + 1 for x, y in queries]", "trans_code": "public : bool isArraySpecial ( vector < int > & nums , vector < vector < int >> & queries ) throw ( ) {\n  int n = nums . size ( ) ;\n  vector < int > dp ( n , 1 ) ;\n  for ( int i = 1 ;\n  i < n ;\n  i ++ ) {\n    if ( ( nums [ i ] ^ nums [ i - 1 ] ) & 1 == 1 ) {\n      dp [ i ] = dp [ i - 1 ] + 1 ;\n    }\n  }\n  return dp [ y ] >= y - x + 1 ;\n}\n", "reference_code": "vector<bool> isArraySpecial(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        vector<int> dp(n, 1);\n        for (int i = 1; i < n; i++) {\n            if ((nums[i] ^ nums[i - 1]) & 1) {\n                dp[i] = dp[i - 1] + 1;\n            }\n        }\n        vector<bool> res;\n        for (auto &q : queries) {\n            int x = q[0], y = q[1];\n            res.emplace_back(dp[y] >= y - x + 1);\n        }\n        return res;\n    }", "target_Lan": "cpp###isArraySpecial.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    vector<int> nums1 = {2, 4, 6, 8};\n    vector<vector<int>> queries1 = {{0, 3}};\n    vector<bool> result1 = isArraySpecial(nums1, queries1);\n    \n    vector<int> nums2 = {1, 3, 5, 7};\n    vector<vector<int>> queries2 = {{0, 3}};\n    vector<bool> result2 = isArraySpecial(nums2, queries2);\n    \n    vector<int> nums3 = {1, 2, 3, 4};\n    vector<vector<int>> queries3 = {{0, 3}};\n    vector<bool> result3 = isArraySpecial(nums3, queries3);\n    \n    vector<int> nums4 = {1, 1, 2, 2, 3, 3};\n    vector<vector<int>> queries4 = {{0, 5}};\n    vector<bool> result4 = isArraySpecial(nums4, queries4);\n    \n    vector<int> nums5 = {1, 2, 3, 4};\n    vector<vector<int>> queries5 = {{1, 3}, {0, 2}};\n    vector<bool> result5 = isArraySpecial(nums5, queries5);\n\n    \n    for(bool res : result1) cout << std::boolalpha << res << endl;\n    for(bool res : result2) cout << std::boolalpha << res << endl;\n    for(bool res : result3) cout << std::boolalpha << res << endl;\n    for(bool res : result4) cout << std::boolalpha << res << endl;\n    for(bool res : result5) cout << std::boolalpha << res << endl;\n\n    return 0;\n}"}, {"source_Lan": "python###leftmostBuildingQueries.py", "source_code": "def leftmostBuildingQueries(heights: List[int], queries: List[List[int]]) -> List[int]:\n    n = len(heights)\n    m = len(queries)\n    query = [[] for _ in range(n)]\n    ans = [-1] * m\n    st = []\n    for i in range(m):\n        a, b = queries[i]\n        if a > b:\n            a, b = b, a\n        if a == b or heights[a] < heights[b]:\n            ans[i] = b\n            continue\n        query[b].append((i, heights[a]))\n    top = -1\n    for i in range(n - 1, -1, -1):\n        for q, val in query[i]:\n            if top == -1 or heights[st[0]] <= val:\n                ans[q] = -1\n                continue\n            l, r = 0, top\n            while l <= r:\n                mid = (l + r) // 2\n                if heights[st[mid]] > val:\n                    l = mid + 1\n                else:\n                    r = mid - 1\n            ans[q] = st[r]\n        while top >= 0 and heights[st[top]] <= heights[i]:\n            st.pop()\n            top -= 1\n        st.append(i)\n        top += 1\n    return ans\n    ", "trans_code": "public : vector < int > leftmostBuildingQueries ( vector < int > heights , vector < vector < int >> queries ) throw ( ) {\n  int n = heights . size ( ) ;\n  int m = queries . size ( ) ;\n  vector < vector < int >> query ( n , vector < int > ( m ) ) ;\n  vector < int > ans ( m , - 1 ) ;\n  vector < int > st ;\n  for ( int i = 0 ;\n  i < m ;\n  i ++ ) {\n    int a = queries [ i ] [ 0 ] , b = queries [ i ] [ 1 ] ;\n    if ( a > b ) a = b ;\n    if ( a == b || heights [ a ] < heights [ b ] ) {\n      ans [ i ] = b ;\n      continue ;\n    }\n    query [ b ] . push_back ( make_pair ( i , heights [ a ] ) ) ;\n  }\n  int top = - 1 ;\n  for ( int i = n - 1 ;\n  i >= 0 ;\n  i -- ) {\n    for ( int q = 0 , r = top ;\n    q <= r ;\n    q ++ ) {\n      if ( top == - 1 || heights [ st [ 0 ] ] <= val ) {\n        ans [ q ] = - 1 ;\n        continue ;\n      }\n      int l = 0 , r = top ;\n      while ( l <= r ) {\n        int mid = ( l + r ) / 2 ;\n        if ( heights [ st [ mid ] ] > val ) l = mid + 1 ;\n        else r = mid - 1 ;\n      }\n      ans [ q ] = st [ r ] ;\n    }\n    while ( top >= 0 && heights [ st [ top ] ] <= heights [ i ] ) {\n      st . pop_back ( ) ;\n      top -- ;\n    }\n    st . push_back ( i ) ;\n    top ++ ;\n  }\n  return ans ;\n}\n", "reference_code": "vector<int> leftmostBuildingQueries(vector<int>& heights, vector<vector<int>>& queries) {\n        int n = heights.size();\n        int m = queries.size();\n        vector<vector<pair<int, int>>> query(n);\n        vector<int> ans(m);\n        vector<int> st;\n        for (int i = 0; i < m; i++) {\n            int a = queries[i][0];\n            int b = queries[i][1];\n            if (a > b) swap(a, b);\n            if (a == b || heights[a] < heights[b]) {\n                ans[i] = b;\n                continue;\n            }\n            query[b].push_back(make_pair(i, heights[a]));\n        }\n        int top = -1;\n        for (int i = n - 1; i >= 0; i--) {\n            for (int j = 0; j < query[i].size(); j++) {\n                int q = query[i][j].first;\n                int val = query[i][j].second;\n                if (top == -1 || heights[st[0]] <= val) {\n                    ans[q] = -1;\n                    continue;\n                }\n                int l = 0, r = top;\n                while (l <= r) {\n                    int mid = (l + r) >> 1;\n                    if (heights[st[mid]] > val) {\n                        l = mid + 1;\n                    } else {\n                        r = mid - 1;\n                    }\n                }\n                ans[q] = st[r];\n            }\n            while (top >= 0 && heights[st[top]] <= heights[i]) {\n                st.pop_back();\n                top--;\n            }\n            st.push_back(i);\n            top++;\n        }\n        return ans;\n    }", "target_Lan": "cpp###leftmostBuildingQueries.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    vector<int> heights1 = {5, 3, 6, 7, 4};\n    vector<vector<int>> queries1 = {{0, 3}, {1, 4}, {3, 2}, {2, 2}, {0, 0}};\n    vector<int> result1 = leftmostBuildingQueries(heights1, queries1);\n    for(int r : result1) cout << r << \" \"; \n    cout << endl;\n\n    vector<int> heights2 = {1, 2, 3};\n    vector<vector<int>> queries2 = {{0, 2}, {1, 1}, {2, 0}};\n    vector<int> result2 = leftmostBuildingQueries(heights2, queries2);\n    for(int r : result2) cout << r << \" \";\n    cout << endl;\n\n    vector<int> heights3 = {10, 20, 30, 40};\n    vector<vector<int>> queries3 = {{1, 3}, {0, 3}, {2, 2}};\n    vector<int> result3 = leftmostBuildingQueries(heights3, queries3);\n    for(int r : result3) cout << r << \" \";\n    cout << endl;\n\n    vector<int> heights4 = {5, 5, 5, 5, 5};\n    vector<vector<int>> queries4 = {{0, 1}, {1, 4}, {0, 3}};\n    vector<int> result4 = leftmostBuildingQueries(heights4, queries4);\n    for(int r : result4) cout << r << \" \";\n    cout << endl;\n\n    vector<int> heights5 = {0, 10, 5, 15};\n    vector<vector<int>> queries5 = {{0, 1}, {3, 0}, {2, 3}, {1, 1}};\n    vector<int> result5 = leftmostBuildingQueries(heights5, queries5);\n    for(int r : result5) cout << r << \" \";\n    cout << endl;\n\n    return 0;\n}"}, {"source_Lan": "python###isArraySpecial.py", "source_code": "def isArraySpecial( nums: List[int]) -> bool:\n        n = len(nums)\n        for i in range(1, n):\n            if nums[i - 1] % 2 == nums[i] % 2:\n                return False\n        return True", "trans_code": "public : bool isArraySpecial ( vector < int > & nums ) throw ( ) {\n  int n = nums . size ( ) ;\n  for ( int i = 1 ;\n  i < n ;\n  i ++ ) {\n    if ( nums [ i - 1 ] % 2 == nums [ i ] % 2 ) return false ;\n  }\n  return true ;\n}\n", "reference_code": "bool isArraySpecial(vector<int>& nums) {\n        int n = nums.size();\n        for (int i = 1; i < n; ++i) {\n            if (nums[i - 1] % 2 == nums[i] % 2) {\n                return false;\n            }\n        }\n        return true;\n    }", "target_Lan": "cpp###isArraySpecial.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    vector<int> input1 = {};\n    vector<int> input2 = {1};\n    vector<int> input3 = {2, 1, 4, 3};\n    vector<int> input4 = {2, 4, 6, 8};\n    vector<int> input5 = {3, 5, 7, 2, 4, 6};\n\n    cout << isArraySpecial(input1) << endl; \n    cout << isArraySpecial(input2) << endl; \n    cout << isArraySpecial(input3) << endl; \n    cout << isArraySpecial(input4) << endl; \n    cout << isArraySpecial(input5) << endl; \n}"}, {"source_Lan": "python###finalPositionOfSnake.py", "source_code": "def finalPositionOfSnake( n: int, commands: List[str]) -> int:\n        i = j = 0\n        for s in commands:\n            if s[0] == 'U': i -= 1\n            elif s[0] == 'D': i += 1\n            elif s[0] == 'L': j -= 1\n            else: j += 1\n        return i * n + j", "trans_code": "int finalPositionOfSnake ( int n , vector < string > commands ) throw ( ) {\n  int i = j = 0 ;\n  for ( string s : commands ) {\n    if ( s [ 0 ] == 'U' ) {\n      i -- ;\n    }\n    else if ( s [ 0 ] == 'D' ) {\n      i ++ ;\n    }\n    else if ( s [ 0 ] == 'L' ) {\n      j -- ;\n    }\n    else {\n      j ++ ;\n    }\n  }\n  return i * n + j ;\n}\n", "reference_code": "int finalPositionOfSnake(int n, vector<string>& commands) {\n        int i = 0, j = 0;\n        for (auto& s : commands) {\n            switch (s[0]) {\n                case 'U': i--; break;\n                case 'D': i++; break;\n                case 'L': j--; break;\n                default:  j++;\n            }\n        }\n        return i * n + j;\n    }", "target_Lan": "cpp###finalPositionOfSnake.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <string>\n// TOFILL\nint main() {\n    vector<string> commands1 = {\"U\", \"D\", \"L\", \"R\"};\n    cout << finalPositionOfSnake(1, commands1) << endl;\n\n    vector<string> commands2 = {\"U\", \"U\", \"D\"};\n    cout << finalPositionOfSnake(1000, commands2) << endl;\n\n    vector<string> commands3 = {\"L\", \"L\", \"R\"};\n    cout << finalPositionOfSnake(1, commands3) << endl;\n\n    vector<string> commands4 = {\"D\", \"D\", \"U\", \"L\"};\n    cout << finalPositionOfSnake(0, commands4) << endl;\n\n    vector<string> commands5 = {\"U\", \"D\", \"R\", \"L\", \"D\", \"U\", \"R\", \"R\"};\n    cout << finalPositionOfSnake(1000000, commands5) << endl;\n\n    return 0;\n}"}, {"source_Lan": "python###countOfPairs.py", "source_code": "def countOfPairs( nums):\n        MOD = 1_000_000_007\n        m = len(nums)\n        n = max(nums)\n        f = [0] * (n + 1)\n        \n        for v in range(nums[0] + 1):\n            f[v] = 1\n        preSums = []\n        \n        for i in range(1, m + 1):\n            \n            preSums.clear()\n            preSum = 0\n            for v in f:\n                preSum += v\n                preSum %= MOD\n                preSums.append(preSum)\n            \n            if i == m:\n                return preSums[-1]\n            \n            for j in range(nums[i] + 1):\n                ceil = min(j, nums[i-1] - nums[i] + j)\n                if ceil >= 0:\n                    f[j] = preSums[ceil]\n                else:  \n                    f[j] = 0\n            for j in range(nums[i] + 1, len(f)):\n                f[j] = 0\n        \n        return 0", "trans_code": "public : int countOfPairs ( vector < int > & nums ) {\n  const int MOD = 1 _000_000_007 ;\n  int m = nums . size ( ) ;\n  int n = max ( nums . size ( ) ) ;\n  vector < int > f ( n + 1 , 0 ) ;\n  for ( int v = 0 ;\n  v < nums [ 0 ] + 1 ;\n  v ++ ) f [ v ] = 1 ;\n  vector < int > preSums ;\n  for ( int i = 1 ;\n  i <= m ;\n  i ++ ) {\n    preSums . clear ( ) ;\n    int preSum = 0 ;\n    for ( int v = 0 ;\n    v < f . size ( ) ;\n    v ++ ) {\n      preSum += f [ v ] ;\n      preSum %= MOD ;\n      preSums . push_back ( preSum ) ;\n    }\n    if ( i == m ) return preSums . back ( ) ;\n    for ( int j = 0 ;\n    j < nums [ i ] + 1 ;\n    j ++ ) {\n      int ceil = min ( j , nums [ i - 1 ] - nums [ i ] + j ) ;\n      if ( ceil >= 0 ) f [ j ] = preSums [ ceil ] ;\n      else f [ j ] = 0 ;\n    }\n    for ( int j = nums [ i ] + 1 ;\n    j < f . size ( ) ;\n    j ++ ) f [ j ] = 0 ;\n  }\n  return 0 ;\n}\n", "reference_code": "int countOfPairs(vector<int>& nums) {\n        const int MOD = 1e9 + 7;\n        int m = nums.size();\n        int n = *max_element(nums.begin(), nums.end());\n        vector<int> f(n + 1);\n        \n        for (int v = 0; v <= nums[0]; ++v)\n            f[v] = 1;\n        vector<int> preSums;\n        \n        for (int i = 1; i <= m; ++i) {\n            \n            preSums.clear();\n            int preSum = 0;\n            for(int v : f){\n                preSum += v;\n                preSum %= MOD; \n                preSums.push_back(preSum);\n            }\n            \n            if (i == m) return preSums.back();\n            \n            for (int j = 0; j <= nums[i]; ++j) {\n                int ceil = min(j, nums[i-1] - nums[i] + j);\n                if (ceil >= 0)\n                    f[j] = preSums[ceil];\n                else \n                    f[j] = 0;\n            }\n            for (int j = nums[i] + 1; j < f.size(); ++j) {\n                f[j] = 0;\n            }\n        }\n        \n        return 0;\n    }", "target_Lan": "cpp###countOfPairs.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n// TOFILL\nint main() {\n    \n    vector<int> nums1 = {1, 2, 3};\n    cout << countOfPairs(nums1) << endl;\n\n    \n    vector<int> nums2 = {5, 5, 5, 5};\n    cout << countOfPairs(nums2) << endl;\n\n    \n    vector<int> nums3 = {0};\n    cout << countOfPairs(nums3) << endl;\n\n    \n    vector<int> nums4 = {10, 20, 30, 40, 50};\n    cout << countOfPairs(nums4) << endl;\n\n    \n    vector<int> nums5 = {3, 1, 4};\n    cout << countOfPairs(nums5) << endl;\n\n    return 0;\n}"}, {"source_Lan": "python###shortestDistanceAfterQueries.py", "source_code": "def shortestDistanceAfterQueries(n: int, queries: List[List[int]]) -> List[int]:\n    frm = [[] for _ in range(n)]\n    f = list(range(n))\n    ans = []\n    for l, r in queries:\n        frm[r].append(l)\n        if f[l] + 1 < f[r]:\n            f[r] = f[l] + 1\n            for i in range(r + 1, n):\n                f[i] = min(f[i], f[i - 1] + 1, min((f[j] for j in frm[i]), default=inf) + 1)\n        ans.append(f[-1])\n    return ans\n", "trans_code": "public : vector < int > shortestDistanceAfterQueries ( int n , vector < vector < int >> & queries ) throw ( ) {\n  vector < vector < int >> frm ( n ) ;\n  vector < int > f ( n ) ;\n  vector < int > ans ;\n  for ( int l = 0 , r = 0 ;\n  l < n ;\n  l ++ , r ++ ) {\n    frm [ r ] . push_back ( l ) ;\n    if ( f [ l ] + 1 < f [ r ] ) {\n      f [ r ] = f [ l ] + 1 ;\n      for ( int i = r + 1 ;\n      i < n ;\n      i ++ ) f [ i ] = min ( f [ i ] , f [ i - 1 ] + 1 , min ( ( f [ j ] ) , f [ i ] ) + 1 ) ;\n    }\n    ans [ f [ f . size ( ) - 1 ] ] = f [ f . size ( ) - 1 ] ;\n  }\n  return ans ;\n}\n", "reference_code": "vector<int> shortestDistanceAfterQueries(int n, vector<vector<int>>& queries) {\n        vector<vector<int>> from(n);\n        vector<int> f(n);\n        iota(f.begin(), f.end(), 0);\n        vector<int> ans(queries.size());\n        for (int qi = 0; qi < queries.size(); qi++) {\n            int l = queries[qi][0], r = queries[qi][1];\n            from[r].push_back(l);\n            if (f[l] + 1 < f[r]) {\n                f[r] = f[l] + 1;\n                for (int i = r + 1; i < n; i++) {\n                    f[i] = min(f[i], f[i - 1] + 1);\n                    for (int j : from[i]) {\n                        f[i] = min(f[i], f[j] + 1);\n                    }\n                }\n            }\n            ans[qi] = f[n - 1];\n        }\n        return ans;\n    }", "target_Lan": "cpp###shortestDistanceAfterQueries.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <numeric>\n// TOFILL\nint main() {\n    vector<vector<int>> queries1 = {{0, 2}, {1, 2}};\n    vector<int> result1 = shortestDistanceAfterQueries(3, queries1);\n    for(int res : result1) {\n        cout << res << endl;\n    }\n\n    vector<vector<int>> queries2 = {{0, 0}};\n    vector<int> result2 = shortestDistanceAfterQueries(1, queries2);\n    for(int res : result2) {\n        cout << res << endl;\n    }\n\n    return 0;\n}"}, {"source_Lan": "python###shortestDistanceAfterQueries2.py", "source_code": "def shortestDistanceAfterQueries2(n: int, queries: List[List[int]]) -> List[int]:\n    ans = []\n    nxt = list(range(1, n))\n    cnt = n - 1\n    for l, r in queries:\n        if 0 < nxt[l] < r:\n            i = nxt[l]\n            while i < r:\n                cnt -= 1\n                nxt[i], i = 0, nxt[i]\n            nxt[l] = r\n        ans.append(cnt)\n    return ans\n    ", "trans_code": "public : vector < int > shortestDistanceAfterQueries2 ( int n , vector < vector < int >> & queries ) throw ( ) {\n  vector < int > ans ;\n  vector < int > nxt ( 1 , n ) ;\n  int cnt = n - 1 ;\n  for ( auto l : queries ) {\n    if ( 0 < nxt [ l ] && nxt [ l ] < r ) {\n      int i = nxt [ l ] ;\n      while ( i < r ) {\n        cnt -- ;\n        nxt [ i ] = 0 , i = nxt [ i ] ;\n      }\n      nxt [ l ] = r ;\n    }\n    ans . push_back ( cnt ) ;\n  }\n  return ans ;\n}\n", "reference_code": "vector<int> shortestDistanceAfterQueries2(int n, vector<vector<int>>& queries) {\n        vector<int> nxt(n - 1);\n        iota(nxt.begin(), nxt.end(), 1);\n        vector<int> ans(queries.size());\n        int cnt = n - 1;\n        for (int qi = 0; qi < queries.size(); qi++) {\n            int l = queries[qi][0], r = queries[qi][1];\n            if (nxt[l] && nxt[l] < r) {\n                for (int i = nxt[l]; i < r;) {\n                    cnt--;\n                    int tmp = nxt[i];\n                    nxt[i] = 0;\n                    i = tmp;\n                }\n                nxt[l] = r;\n            }\n            ans[qi] = cnt;\n        }\n        return ans;\n    }", "target_Lan": "cpp###shortestDistanceAfterQueries2.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <numeric> // For iota\n// TOFILL\nint main() {\n    vector<vector<int>> queries1 = {{0, 2}};\n    vector<vector<int>> queries2 = {{0, 2}, {1, 3}, {0, 4}};\n    vector<vector<int>> queries3 = {{0, 3}, {1, 4}, {0, 2}, {2, 4}};\n\n    vector<int> result1 = shortestDistanceAfterQueries2(5, queries1);\n    vector<int> result2 = shortestDistanceAfterQueries2(5, queries2);\n    vector<int> result3 = shortestDistanceAfterQueries2(5, queries3);\n\n    for(int dist : result1) {\n        cout << dist << \" \";\n    }\n    cout << endl;\n\n    for(int dist : result2) {\n        cout << dist << \" \";\n    }\n    cout << endl;\n\n    for(int dist : result3) {\n        cout << dist << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}"}, {"source_Lan": "python###winningPlayerCount.py", "source_code": "def winningPlayerCount( n: int, pick: List[List[int]]) -> int:\n        cnts = [[0] * 11 for _ in range(n)]\n        for x, y in pick:\n            cnts[x][y] += 1\n        ans = 0\n        for i, cnt in enumerate(cnts):\n            if any(c > i for c in cnt):\n                ans += 1\n        return ans", "trans_code": "int winningPlayerCount ( int n , std :: vector < std :: vector < int >> pick ) throw ( ) {\n  std :: vector < std :: vector < int >> cnts ( n , std :: vector < int > ( 11 ) ) ;\n  for ( int x = 0 ;\n  x < n ;\n  ++ x ) {\n    cnts [ x ] [ y ] ++ ;\n  }\n  int ans = 0 ;\n  for ( int i = 0 , cnt = cnts . size ( ) ;\n  i < cnt ;\n  ++ i ) {\n    if ( std :: find ( cnts . begin ( ) + i , cnts . end ( ) , i ) != cnts . end ( ) ) {\n      ++ ans ;\n    }\n  }\n  return ans ;\n}\n", "reference_code": "int winningPlayerCount(int n, vector<vector<int>>& pick) {\n        vector<array<int, 11>> cnts(n);\n        for (auto& p : pick) {\n            cnts[p[0]][p[1]]++;\n        }\n        int ans = 0;\n        for (int i = 0; i < n; i++) {\n            for (int c : cnts[i]) {\n                if (c > i) {\n                    ans++;\n                    break;\n                }\n            }\n        }\n        return ans;\n    }", "target_Lan": "cpp###winningPlayerCount.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <array>\n// TOFILL\nint main() {\n    vector<vector<int>> pick1 = {};\n    cout << winningPlayerCount(0, pick1) << endl;\n\n    vector<vector<int>> pick2 = {{0, 0}};\n    cout << winningPlayerCount(1, pick2) << endl;\n\n    vector<vector<int>> pick3 = {{0, 1}, {1, 0}, {1, 0}};\n    cout << winningPlayerCount(3, pick3) << endl;\n\n    vector<vector<int>> pick4 = {{0, 1}, {0, 2}, {1, 1}, {2, 1}, {2, 2}};\n    cout << winningPlayerCount(3, pick4) << endl;\n\n    vector<vector<int>> pick5 = {{4, 3}, {4, 3}, {3, 2}, {3, 0}, {2, 1}, {1, 0}};\n    cout << winningPlayerCount(5, pick5) << endl;\n\n    return 0;\n}"}, {"source_Lan": "python###minFlips.py", "source_code": "def minFlips( grid: List[List[int]]) -> int:\n        diff_row = 0\n        for row in grid:\n            for j in range(len(row) // 2):\n                if row[j] != row[-1 - j]:\n                    diff_row += 1\n        diff_col = 0\n        for col in zip(*grid):\n            for i in range(len(grid) // 2):\n                if col[i] != col[-1 - i]:\n                    diff_col += 1\n        return min(diff_row, diff_col)", "trans_code": "public : int minFlips ( vector < vector < int >> & grid ) throw ( ) {\n  int diffRow = 0 ;\n  for ( vector < int > & row : grid ) {\n    for ( int j = 0 ;\n    j < row . size ( ) / 2 ;\n    ++ j ) {\n      if ( row [ j ] != row [ grid . size ( ) - 1 - j ] ) {\n        ++ diffRow ;\n      }\n    }\n  }\n  int diffCol = 0 ;\n  for ( vector < int > & col : * grid ) {\n    for ( int i = 0 ;\n    i < grid . size ( ) / 2 ;\n    ++ i ) {\n      if ( col [ i ] != col [ grid . size ( ) - 1 - i ] ) {\n        ++ diffCol ;\n      }\n    }\n  }\n  return min ( diffRow , diffCol ) ;\n}\n", "reference_code": "int minFlips(vector<vector<int>>& grid) {\n        int m = grid.size(), n = grid[0].size();\n        int diff_row = 0;\n        for (auto& row : grid) {\n            for (int j = 0; j < n / 2; j++) {\n                diff_row += row[j] != row[n - 1 - j];\n            }\n        }\n        int diff_col = 0;\n        for (int j = 0; j < n; j++) {\n            for (int i = 0; i < m / 2; i++) {\n                diff_col += grid[i][j] != grid[m - 1 - i][j];\n            }\n        }\n        return min(diff_row, diff_col);\n    }", "target_Lan": "cpp###minFlips.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    vector<vector<int>> input1 = {{0, 0}, {0, 0}};\n    vector<vector<int>> input2 = {{1, 0}, {0, 1}};\n    vector<vector<int>> input3 = {{1, 1}, {1, 1}};\n    vector<vector<int>> input4 = {{0}, {1}, {0}};\n    vector<vector<int>> input5 = {{1, 0, 1}, {0, 1, 0}};\n\n    cout << minFlips(input1) << endl; \n    cout << minFlips(input2) << endl; \n    cout << minFlips(input3) << endl; \n    cout << minFlips(input4) << endl; \n    cout << minFlips(input5) << endl; \n\n    return 0;\n}"}, {"source_Lan": "python###minFlips.py", "source_code": "def minFlips( a: List[List[int]]) -> int:\n        ans = 0\n        m, n = len(a), len(a[0])\n        for i in range(m // 2):\n            row, row2 = a[i], a[-1 - i]\n            for j in range(n // 2):\n                cnt1 = row[j] + row[-1 - j] + row2[j] + row2[-1 - j]\n                ans += min(cnt1, 4 - cnt1)  \n        if m % 2 and n % 2:\n            \n            ans += a[m // 2][n // 2]\n        diff = cnt1 = 0\n        if m % 2:\n            \n            row = a[m // 2]\n            for j in range(n // 2):\n                if row[j] != row[-1 - j]:\n                    diff += 1\n                else:\n                    cnt1 += row[j] * 2\n        if n % 2:\n            \n            for i in range(m // 2):\n                if a[i][n // 2] != a[- 1 - i][n // 2]:\n                    diff += 1\n                else:\n                    cnt1 += a[i][n // 2] * 2\n        return ans + (diff if diff else cnt1 % 4)", "trans_code": "public : int minFlips ( vector < vector < int >> & a ) throw ( ) {\n  int ans = 0 ;\n  int m = a . size ( ) , n = a [ 0 ] . size ( ) ;\n  for ( int i = 0 ;\n  i < m / 2 ;\n  i ++ ) {\n    vector < int > row = a [ i ] , row2 = a [ - 1 - i ] ;\n    for ( int j = 0 ;\n    j < n / 2 ;\n    j ++ ) {\n      int cnt1 = row [ j ] + row [ - 1 - j ] + row2 [ j ] + row2 [ - 1 - j ] ;\n      ans += min ( cnt1 , 4 - cnt1 ) ;\n    }\n  }\n  if ( m % 2 && n % 2 ) ans += a [ m / 2 ] [ n / 2 ] ;\n  int diff = cnt1 = 0 ;\n  if ( m % 2 ) {\n    vector < int > row = a [ m / 2 ] ;\n    for ( int j = 0 ;\n    j < n / 2 ;\n    j ++ ) {\n      if ( row [ j ] != row [ - 1 - j ] ) diff ++ ;\n      else cnt1 += row [ j ] * 2 ;\n    }\n  }\n  if ( n % 2 ) {\n    for ( int i = 0 ;\n    i < m / 2 ;\n    i ++ ) {\n      if ( a [ i ] [ n / 2 ] != a [ - 1 - i ] [ n / 2 ] ) diff ++ ;\n      else cnt1 += a [ i ] [ n / 2 ] * 2 ;\n    }\n  }\n  return ans + ( diff == 0 ? cnt1 % 4 : cnt1 % 4 ) ;\n}\n", "reference_code": "int minFlips(vector<vector<int>>& a) {\n        int m = a.size(), n = a[0].size(), ans = 0;\n        for (int i = 0; i < m / 2; i++) {\n            for (int j = 0; j < n / 2; j++) {\n                int cnt1 = a[i][j] + a[i][n - 1 - j] + a[m - 1 - i][j] + a[m - 1 - i][n - 1 - j];\n                ans += min(cnt1, 4 - cnt1);  \n            }\n        }\n        if (m % 2 && n % 2) {\n            \n            ans += a[m / 2][n / 2];\n        }\n        int diff = 0, cnt1 = 0;\n        if (m % 2) {\n            \n            for (int j = 0; j < n / 2; j++) {\n                if (a[m / 2][j] != a[m / 2][n - 1 - j]) {\n                    diff++;\n                } else {\n                    cnt1 += a[m / 2][j] * 2;\n                }\n            }\n        }\n        if (n % 2) {\n            \n            for (int i = 0; i < m / 2; i++) {\n                if (a[i][n / 2] != a[m - 1 - i][n / 2]) {\n                    diff++;\n                } else {\n                    cnt1 += a[i][n / 2] * 2;\n                }\n            }\n        }\n        return ans + (diff ? diff : cnt1 % 4);\n    }", "target_Lan": "cpp###minFlips.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    vector<vector<int>> input1 = {{0, 0}, {0, 0}};\n    vector<vector<int>> input2 = {{1, 1}, {1, 1}};\n    vector<vector<int>> input3 = {{0, 1}, {1, 0}};\n    vector<vector<int>> input4 = {{1, 0, 1}, {1, 0, 1}};\n    vector<vector<int>> input5 = {{1, 0, 1, 0}, {0, 1, 0, 1}, {1, 0, 1, 0}};\n    \n    cout << minFlips(input1) << endl; \n    cout << minFlips(input2) << endl; \n    cout << minFlips(input3) << endl; \n    cout << minFlips(input4) << endl; \n    cout << minFlips(input5) << endl; \n\n    return 0;\n}"}, {"source_Lan": "python###canAliceWin.py", "source_code": "def canAliceWin( nums: List[int]) -> bool:\n        return sum(x if x < 10 else -x for x in nums) != 0", "trans_code": "bool canAliceWin ( vector < int > & nums ) throw ( ) {\n  return sum ( nums . begin ( ) , nums . end ( ) ) != 0 ;\n}\n", "reference_code": "bool canAliceWin(vector<int>& nums) {\n        int s = 0;\n        for (int x : nums) {\n            s += x < 10 ? x : -x;\n        }\n        return s; \n    }", "target_Lan": "cpp###canAliceWin.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    vector<int> input1 = {1, 2, 3};\n    vector<int> input2 = {10, 20, 30};\n    vector<int> input3 = {5, 15, 2};\n    vector<int> input4 = {0, 9, 11, 12};\n    vector<int> input5 = {2147483647, -2147483648};\n\n    cout << canAliceWin(input1) << endl; \n    cout << canAliceWin(input2) << endl; \n    cout << canAliceWin(input3) << endl; \n    cout << canAliceWin(input4) << endl; \n    cout << canAliceWin(input5) << endl; \n}"}, {"source_Lan": "python###numberOfSubstrings.py", "source_code": "def numberOfSubstrings( s: str) -> int:\n        n = len(s)\n        a = [i for i, b in enumerate(s) if b == '0']\n        tot1 = n - len(a)\n        a.append(n)  \n        ans = i = 0  \n        for left, b in enumerate(s):\n            if b == '1':\n                ans += a[i] - left  \n            for k in range(i, len(a) - 1):\n                cnt0 = k - i + 1\n                if cnt0 * cnt0 > tot1:\n                    break\n                cnt1 = a[k] - left - (k - i)\n                \n                ans += max(a[k + 1] - a[k] - max(cnt0 * cnt0 - cnt1, 0), 0)\n            if b == '0':\n                i += 1  \n        return ans", "trans_code": "public : int numberOfSubstrings ( string s ) throw ( ) {\n  int n = s . size ( ) ;\n  vector < int > a ( n ) ;\n  int tot1 = n - a . size ( ) ;\n  a . resize ( n ) ;\n  int ans = i = 0 ;\n  for ( int left = 0 ;\n  left < n ;\n  left ++ ) {\n    if ( s [ left ] == '1' ) ans += a [ i ] - left ;\n    for ( int k = i ;\n    k < a . size ( ) - 1 ;\n    k ++ ) {\n      int cnt0 = k - i + 1 ;\n      if ( cnt0 * cnt0 > tot1 ) break ;\n      int cnt1 = a [ k ] - left - ( k - i ) ;\n      ans += max ( a [ k + 1 ] - a [ k ] - max ( cnt0 * cnt0 - cnt1 , 0 ) , 0 ) ;\n    }\n    if ( s [ left ] == '0' ) i ++ ;\n  }\n  return ans ;\n}\n", "reference_code": "int numberOfSubstrings(string s) {\n        int n = s.length();\n        vector<int> a;\n        for (int i = 0; i < n; i++) {\n            if (s[i] == '0') {\n                a.push_back(i);\n            }\n        }\n        int tot1 = n - a.size();\n        a.push_back(n); \n        int ans = 0, i = 0; \n        for (int left = 0; left < n; left++) {\n            if (s[left] == '1') {\n                ans += a[i] - left; \n            }\n            for (int k = i; k < a.size() - 1; k++) {\n                int cnt0 = k - i + 1;\n                if (cnt0 * cnt0 > tot1) {\n                    break;\n                }\n                int cnt1 = a[k] - left - (k - i);\n                ans += max(a[k + 1] - a[k] - max(cnt0 * cnt0 - cnt1, 0), 0);\n            }\n            if (s[left] == '0') {\n                i++; \n            }\n        }\n        return ans;\n    }", "target_Lan": "cpp###numberOfSubstrings.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <string>\n// TOFILL\nint main() {\n    cout << numberOfSubstrings(\"110011\") << endl;\n    cout << numberOfSubstrings(\"00000\") << endl;\n    cout << numberOfSubstrings(\"11111\") << endl;\n    cout << numberOfSubstrings(\"101010\") << endl;\n    cout << numberOfSubstrings(\"1\") << endl;\n    cout << numberOfSubstrings(\"0\") << endl;\n    cout << numberOfSubstrings(\"1101001\") << endl;\n    cout << numberOfSubstrings(\"10\") << endl;\n    cout << numberOfSubstrings(\"10001\") << endl;\n    cout << numberOfSubstrings(\"111000111\") << endl;\n}"}, {"source_Lan": "python###getMax.py", "source_code": "def getMax( x: int) -> int:\n        \n        flag = False\n        prev = -1\n        cnt = 0\n        for i in range(30, -1, -1):\n            if cnt >= 2:\n                break\n            if not flag and (x & (1 << i)) > 0:\n                flag = True\n                continue\n            if flag:\n                if (x & (1 << i)) == 0 and prev == -1:\n                    prev = i\n                    x |= (1 << i)\n                    cnt += 1\n                if (x & (1 << i)) == 0 and prev - i > 1:\n                    x |= (1 << i)\n                    cnt += 1\n        return x", "trans_code": "int getMax ( int x ) throw ( ) {\n  bool flag = false ;\n  int prev = - 1 ;\n  int cnt = 0 ;\n  for ( int i = 30 ;\n  i >= 0 ;\n  i -- ) {\n    if ( cnt >= 2 ) break ;\n    if ( ! flag && ( x & ( 1 << i ) ) > 0 ) {\n      flag = true ;\n      continue ;\n    }\n    if ( flag ) {\n      if ( ( x & ( 1 << i ) ) == 0 && prev == - 1 ) {\n        prev = i ;\n        x |= ( 1 << i ) ;\n        cnt ++ ;\n      }\n      if ( ( x & ( 1 << i ) ) == 0 && prev - i > 1 ) {\n        x |= ( 1 << i ) ;\n        cnt ++ ;\n      }\n    }\n  }\n  return x ;\n}\n", "reference_code": "    int getMax(int x) {\n        \n        bool flag = false;\n        int prev = -1;\n        int cnt = 0;\n        for (int i = 30; i >= 0; i--) {\n            if (cnt >= 2)\n                break;\n            if (flag == false and (x & (1 << i)) > 0) {\n                flag = true;\n                continue;\n            }\n            if (flag) {\n                if ((x & (1 << i)) == 0 and prev == -1) {\n                    prev = i;\n                    x |= (1 << i);\n                    cnt++;\n                }\n                if ((x & (1 << i)) == 0 and prev - i > 1) {\n                    x |= (1 << i);\n                    cnt++;\n                }\n            }\n        }\n        return x;\n    }", "target_Lan": "cpp###getMax.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n// TOFILL\nint main() {\n    cout << getMax(0) << endl;\n    cout << getMax(1) << endl;\n    cout << getMax(2147483647) << endl;\n    cout << getMax(34) << endl;\n    cout << getMax(1073741824) << endl;\n}"}, {"source_Lan": "python###getCount.py", "source_code": "def getCount( n : int, arr : List[int], a : int, b : int) -> int:\n        \n        ans = 0\n        for i in range(n):\n            for j in range(i, n):\n                flag = False\n                for k in range(i, j + 1):\n                    for l in range(k + 1, j + 1):\n                        if arr[k] + arr[l] < a or arr[k] + arr[l] > b:\n                            flag = True\n                if not flag:\n                    ans += 1\n        return ans", "trans_code": "public : int getCount ( int n , int arr [ ] , int a , int b ) throw ( ) {\n  int ans = 0 ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    for ( int j = i ;\n    j < n ;\n    j ++ ) {\n      bool flag = false ;\n      for ( int k = i ;\n      k <= j ;\n      k ++ ) {\n        for ( int l = k + 1 ;\n        l <= j ;\n        l ++ ) {\n          if ( arr [ k ] + arr [ l ] < a || arr [ k ] + arr [ l ] > b ) {\n            flag = true ;\n          }\n        }\n      }\n      if ( ! flag ) {\n        ans ++ ;\n      }\n    }\n  }\n  return ans ;\n}\n", "reference_code": "long long getCount(int n, vector<int> &arr, int a, int b) {\n        \n        int ans=0;\n        for(int i=0;i<n;i++){\n            for(int j=i;j<n;j++){\n                bool flag=false;\n                for(int k=i;k<=j;k++){\n                    for(int l=k+1;l<=j;l++){\n                        if(arr[k]+arr[l]<a || arr[k]+arr[l]>b)\n                        flag=true;\n                    }\n                }\n                if(flag==false)  ans++;\n            }\n        }\n        return ans;\n    }", "target_Lan": "cpp###getCount.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    vector<int> arr1 = {};\n    cout << getCount(0, arr1, 1, 10) << endl;\n\n    vector<int> arr2 = {1, 2, 3, 4, 5};\n    cout << getCount(5, arr2, 3, 8) << endl;\n\n    vector<int> arr3 = {-1, -2, -3, -4, -5};\n    cout << getCount(5, arr3, -10, -3) << endl;\n\n    vector<int> arr4 = {10, 20, 30, 40, 50};\n    cout << getCount(5, arr4, 15, 60) << endl;\n\n    vector<int> arr5 = {1, 2, 3, 4, 5};\n    cout << getCount(5, arr5, 10, 20) << endl;\n\n    return 0;\n}"}, {"source_Lan": "python###minSwaps.py", "source_code": "def minSwaps( S):\n        even_sum, odd_sum = 0, 0\n        n = len(S)\n        \n        for i in range(n):\n            if i % 2 == 1:\n                odd_sum += (S[i] == '1')\n            else:\n                even_sum += (S[i] == '1')\n        \n        difference = abs(odd_sum - even_sum)\n        \n        if difference % 2 == 1:\n            return -1\n        \n        return difference // 2", "trans_code": "int minSwaps ( string S ) {\n  int even_sum = 0 , odd_sum = 0 ;\n  int n = S . size ( ) ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    if ( i % 2 == 1 ) odd_sum += ( S [ i ] == '1' ) ;\n    else even_sum += ( S [ i ] == '1' ) ;\n  }\n  int difference = abs ( odd_sum - even_sum ) ;\n  if ( difference % 2 == 1 ) return - 1 ;\n  return difference / 2 ;\n}\n", "reference_code": "int minSwaps(string S) {\n        int evenSum = 0, oddSum = 0;\n        int n = S.size();\n        \n        for (int i = 0; i < n; i++) {\n            if (i & 1)\n                oddSum += (S[i] == '1');\n            else\n                evenSum += (S[i] == '1');\n        }\n        \n        int difference = abs(oddSum - evenSum);\n        \n        if (difference & 1)\n            return -1;\n        \n        return difference / 2;\n    }", "target_Lan": "cpp###minSwaps.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <string>\n#include <cstdlib> // For abs function\n// TOFILL\nint main() {\n    cout << minSwaps(\"\") << endl; \n    cout << minSwaps(\"01010100\") << endl; \n    cout << minSwaps(\"111000\") << endl; \n    cout << minSwaps(\"1100\") << endl; \n    cout << minSwaps(\"1010101\") << endl; \n}"}, {"source_Lan": "python###countUniques.py", "source_code": "def countUniques( a, k, l, r):\n        \n        set_ = set()\n        dup = 0\n        for i in a:\n            if i in set_:\n                dup += 1\n            else:\n                set_.add(i)\n        unique = len(set_)\n        for i in range(l, r + 1):\n            if k > 0 and dup > 0 and i not in set_:\n                unique += 1\n                k -= 1\n                dup -= 1\n        return unique", "trans_code": "public : int countUniques ( vector < int > a , int k , int l , int r ) {\n  set < int > set_ ;\n  int dup = 0 ;\n  for ( int i = 0 ;\n  i < a . size ( ) ;\n  i ++ ) {\n    if ( a [ i ] == 0 ) dup ++ ;\n    else set_ . insert ( a [ i ] ) ;\n  }\n  int unique = set_ . size ( ) ;\n  for ( int i = l ;\n  i <= r ;\n  i ++ ) {\n    if ( k > 0 && dup > 0 && a [ i ] != 0 ) {\n      unique ++ ;\n      k -- ;\n      dup -- ;\n    }\n  }\n  return unique ;\n}\n", "reference_code": "int countUniques(vector<int> a, int k, int l, int r) {\n        \n        unordered_set<int> set;\n        int dup = 0;\n        for (int i : a) {\n            if (!set.insert(i).second) {\n                dup++;\n            }\n        }\n        int unique = set.size();\n        for (int i = l; i <= r; i++) {\n            if (k > 0 && dup > 0 && set.find(i) == set.end()) {\n                unique++;\n                k--;\n                dup--;\n            }\n        }\n        return unique;\n    }", "target_Lan": "cpp###countUniques.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <unordered_set>\n// TOFILL\nint main() {\n    cout << countUniques({1, 2, 3, 4, 5}, 3, 1, 5) << endl;\n    cout << countUniques({1, 2, 2, 3, 4}, 2, 1, 5) << endl;\n    cout << countUniques({}, 3, 1, 5) << endl;\n    cout << countUniques({6, 7, 8}, 3, 1, 10) << endl;\n    cout << countUniques({1, 1, 1}, 0, 2, 4) << endl;\n}"}, {"source_Lan": "python###maxLength.py", "source_code": "def maxLength( arr):\n        \n        N = len(arr)\n        ans = 0\n        for i in range(N):\n            or_val = 0\n            for j in range(i, n):\n                or_val |= arr[j]\n                x = bin(or_val).count('1')\n                if x == len(bin(or_val)) - 2:  \n                    ans = max(ans, j - i + 1)\n        return ans", "trans_code": "public : int maxLength ( vector < int > arr ) {\n  int N = arr . size ( ) ;\n  int ans = 0 ;\n  for ( int i = 0 ;\n  i < N ;\n  i ++ ) {\n    int or_val = 0 ;\n    for ( int j = i ;\n    j < n ;\n    j ++ ) {\n      or_val |= arr [ j ] ;\n      int x = bin ( or_val ) . count ( '1' ) ;\n      if ( x == bin ( or_val ) . size ( ) - 2 ) ans = max ( ans , j - i + 1 ) ;\n    }\n  }\n  return ans ;\n}\n", "reference_code": "int maxLength(vector<int> arr) {\n        \n        int ans = 0;\n        int N = arr.size();\n        for (int i = 0; i < N; i++) {\n            int or_val = 0;\n            for (int j = i; j < N; j++) {\n                or_val = or_val | arr[j];\n                int x = __builtin_popcount(or_val);\n                if (x == (int)log2(or_val) + 1) {\n                    ans = max(ans, j - i + 1);\n                }\n            }\n        }\n        return ans;\n    }", "target_Lan": "cpp###maxLength.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n// TOFILL\nint main() {\n    vector<int> arr = {};\n    cout << maxLength(arr) << endl;\n}"}, {"source_Lan": "python###firstWord.py", "source_code": "def firstWord( n: int, dictionary: List[str]) -> str:\n        dictionary.sort()\n        seen_words = set()\n        for word in dictionary:\n            if word in seen_words:\n                return \"Invalid\"\n            seen_words.add(word)\n        return dictionary[0]", "trans_code": "string firstWord ( int n , vector < string > & dictionary ) throw ( ) {\n  sort ( dictionary . begin ( ) , dictionary . end ( ) ) ;\n  set < string > seenWords ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    if ( dictionary [ i ] . empty ( ) ) return \"Invalid\" ;\n    seenWords . insert ( dictionary [ i ] ) ;\n  }\n  return dictionary [ 0 ] ;\n}\n", "reference_code": "string firstWord(int n, vector<string> &dictionary) {\n        \n        sort(dictionary.begin(), dictionary.end());\n        for(int i=0;i<n;i++) {\n            for(int j=i+1;j<n;j++) {\n                if(dictionary[i]==dictionary[j]){\n                    return \"Invalid\";\n                }\n            }\n        }\n        return dictionary[0];\n    }", "target_Lan": "cpp###firstWord.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n// TOFILL\nint main() {\n    vector<string> dictionary1 = {\"apple\"};\n    cout << firstWord(1, dictionary1) << endl;\n\n    vector<string> dictionary2 = {\"banana\", \"apple\", \"cherry\"};\n    cout << firstWord(3, dictionary2) << endl;\n\n    vector<string> dictionary3 = {\"banana\", \"apple\", \"banana\", \"cherry\"};\n    cout << firstWord(4, dictionary3) << endl;\n\n    vector<string> dictionary4 = {\"apple\", \"Apple\", \"banana\"};\n    cout << firstWord(3, dictionary4) << endl;\n\n    return 0;\n}"}, {"source_Lan": "python###longestSubarray.py", "source_code": "def longestSubarray( n: int, arr: List[int]) -> int:\n        ans = -1\n        for i in range(n):\n            count = 0\n            total_sum = 0\n            for j in range(i, n):\n                count += 1\n                total_sum += arr[j]\n                if count == total_sum:\n                    ans = max(ans, count)\n        return ans", "trans_code": "int longestSubarray ( int n , int * arr ) throw ( ) {\n  int ans = - 1 ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    int count = 0 ;\n    int totalSum = 0 ;\n    for ( int j = i ;\n    j < n ;\n    j ++ ) {\n      count ++ ;\n      totalSum += arr [ j ] ;\n      if ( count == totalSum ) ans = max ( ans , count ) ;\n    }\n  }\n  return ans ;\n}\n", "reference_code": "int longestSubarray(int n, vector<int> &arr) {\n        \n        int ans=-1;\n        for(int i=0;i<n;i++){\n            int count=0;\n            int sum=0;\n            for(int j=i;j<n;j++) {\n                count++;\n                sum += arr[j];\n                if(count == sum){\n                    ans = max(ans, count);\n                }\n            }\n        }\n        return ans;\n    }", "target_Lan": "cpp###longestSubarray.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    vector<int> arr1 = {};\n    cout << longestSubarray(0, arr1) << endl; \n\n    vector<int> arr2 = {1};\n    cout << longestSubarray(1, arr2) << endl; \n\n    vector<int> arr3 = {1, 1, 2, 3, 4};\n    cout << longestSubarray(5, arr3) << endl; \n\n    vector<int> arr4 = {1, 2, 3, 4, 5, 6};\n    cout << longestSubarray(6, arr4) << endl; \n\n    vector<int> arr5 = {0, 0, 0, 0};\n    cout << longestSubarray(4, arr5) << endl; \n}"}, {"source_Lan": "python###minDifference.py", "source_code": "def minDifference( n: int, arr: List[int], x: int) -> int:\n        ans = n + 1\n        for i in range(n - 1):\n            for j in range(i + 1, n):\n                if (arr[i] ^ arr[j]) <= x:\n                    ans = min(ans, j - i)\n        return -1 if ans == n + 1 else ans", "trans_code": "int minDifference ( int n , int arr [ ] , int x ) throw ( ) {\n  int ans = n + 1 ;\n  for ( int i = 0 ;\n  i < n - 1 ;\n  i ++ ) {\n    for ( int j = i + 1 ;\n    j < n ;\n    j ++ ) {\n      if ( ( arr [ i ] ^ arr [ j ] ) <= x ) {\n        ans = min ( ans , j - i ) ;\n      }\n    }\n  }\n  return - 1 == ans + 1 ? ans : ans ;\n}\n", "reference_code": "int minDifference(int n, vector<int> &arr, int x) {\n        \n        int ans=n+1;\n        for(int i=0;i<n-1;i++){\n            for(int j=i+1;j<n;j++){\n                if((arr[i]^arr[j]) <= x){\n                    ans = min(ans, j-i);\n                }\n            }\n        }\n        return (ans == n+1 ? -1 : ans);\n    }", "target_Lan": "cpp###minDifference.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <algorithm>\n// TOFILL\nint main() {\n    vector<int> arr1 = {1, 0, 0, 0, 0};\n    vector<int> arr2 = {5, 5, 5, 5, 5};\n    vector<int> arr3 = {3, 7, 8, 9, 10};\n    vector<int> arr4 = {1, 2, 3, 4, 10};\n\n    cout << minDifference(5, arr1, 1) << endl; \n    cout << minDifference(5, arr2, 0) << endl; \n    cout << minDifference(5, arr3, 1) << endl; \n    cout << minDifference(5, arr4, 5) << endl; \n}"}, {"source_Lan": "python###reachAlice.py", "source_code": "def reachAlice(d: int, x: int, y: int, k: int) -> str:\n    p = d // x\n    q = d // y\n    q += k\n    return \"Walk\" if p <= q else \"Bike\"\n    ", "trans_code": "string reachAlice ( int d , int x , int y , int k ) throw ( ) {\n  int p = d / x ;\n  int q = d / y ;\n  q += k ;\n  return \"Walk\" == p ? \"Bike\" : \"Walk\" ;\n}\n", "reference_code": "string reachAlice(int d, int x, int y, int k) {\n        int t1 = d / x;\n        int t2 = d / y + k;\n        if (t1 <= t2)\n            return \"Walk\";\n        return \"Bike\";\n    }", "target_Lan": "cpp###reachAlice.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <string>\n// TOFILL\nint main() {\n    cout << reachAlice(0, 1, 1, 0) << endl;\n    cout << reachAlice(100, 10, 20, 1) << endl;\n    cout << reachAlice(100, 20, 10, 1) << endl;\n}"}, {"source_Lan": "python###splitNum.py", "source_code": "def splitNum( num: int) -> int:\n    stnum = \"\".join(sorted(str(num)))\n    num1, num2 = int(stnum[::2]), int(stnum[1::2])\n    return num1 + num2", "trans_code": "int splitNum ( int num ) throw ( ) {\n  string stnum = \"\" ;\n  sort ( stnum . begin ( ) , stnum . end ( ) ) ;\n  int num1 = atoi ( stnum . c_str ( ) ) , num2 = atoi ( stnum . c_str ( ) ) ;\n  return num1 + num2 ;\n}\n", "reference_code": "int splitNum(int num) {\n        string stnum = to_string(num);\n        sort(stnum.begin(), stnum.end());\n        int num1 = 0, num2 = 0;\n        for (int i = 0; i < stnum.size(); ++i) {\n            if (i % 2 == 0) {\n                num1 = num1 * 10 + (stnum[i] - '0');\n            }\n            else {\n                num2 = num2 * 10 + (stnum[i] - '0');\n            }\n        }\n        return num1 + num2;\n    }", "target_Lan": "cpp###splitNum.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <string>\n#include <algorithm>\n// TOFILL\nint main() {\n    cout << splitNum(42) << endl;\n    cout << splitNum(321) << endl;\n    cout << splitNum(112233) << endl;\n    cout << splitNum(987654321) << endl;\n}"}, {"source_Lan": "python###countKConstraintSubstrings.py", "source_code": "def countKConstraintSubstrings(s: str, k: int) -> int:\n        ans = left = 0\n        cnt = [0, 0]\n        for i, c in enumerate(s):\n            cnt[ord(c) & 1] += 1\n            while cnt[0] > k and cnt[1] > k:\n                cnt[ord(s[left]) & 1] -= 1\n                left += 1\n            ans += i - left + 1\n        return ans\n\n", "trans_code": "public : int countKConstraintSubstrings ( string s , int k ) throw ( ) {\n  int ans = left = 0 ;\n  int cnt [ ] = {\n    0 , 0 }\n    ;\n    for ( int i = 0 , n = s . size ( ) ;\n    i < n ;\n    i ++ ) {\n      cnt [ ( unsigned char ) s [ left ] & 1 ] ++ ;\n      while ( cnt [ 0 ] > k && cnt [ 1 ] > k ) {\n        cnt [ ( unsigned char ) s [ left ] & 1 ] -- ;\n        left ++ ;\n      }\n      ans += i - left + 1 ;\n    }\n    return ans ;\n  }\n  ", "reference_code": "int countKConstraintSubstrings(string s, int k) {\n        int ans = 0, left = 0, cnt[2]{};\n        for (int i = 0; i < s.length(); i++) {\n            cnt[s[i] & 1]++;\n            while (cnt[0] > k && cnt[1] > k) {\n                cnt[s[left++] & 1]--;\n            }\n            ans += i - left + 1;\n        }\n        return ans;\n    }\n\n", "target_Lan": "cpp###countKConstraintSubstrings.cpp", "target_code_shell": "#include <iostream>\n#include <string>\nusing namespace std;\n\n\n// TOFILL\nint main() {\n    std::cout << countKConstraintSubstrings(\"1101\", 1) << std::endl;\n    std::cout << countKConstraintSubstrings(\"0000\", 2) << std::endl;\n    std::cout << countKConstraintSubstrings(\"101010\", 3) << std::endl;\n    std::cout << countKConstraintSubstrings(\"111000\", 0) << std::endl;\n    std::cout << countKConstraintSubstrings(\"10101\", 2) << std::endl;\n    return 0;\n}"}, {"source_Lan": "python###countKConstraintSubstrings.py", "source_code": "def countKConstraintSubstrings(s: str, k: int, queries: List[List[int]]) -> List[int]:\n        n = len(s)\n        left = [0] * n\n        pre = [0] * (n + 1)\n        cnt = [0, 0]\n        l = 0\n        for i, c in enumerate(s):\n            cnt[ord(c) & 1] += 1\n            while cnt[0] > k and cnt[1] > k:\n                cnt[ord(s[l]) & 1] -= 1\n                l += 1\n            left[i] = l\n            # \u8ba1\u7b97 i-left[i]+1 \u7684\u524d\u7f00\u548c\n            pre[i + 1] = pre[i] + i - l + 1\n\n        ans = []\n        for l, r in queries:\n            j = bisect_left(left, l, l, r + 1)\n            ans.append(pre[r + 1] - pre[j] + (j - l + 1) * (j - l) // 2)\n        return ans\n\n", "trans_code": "public : vector < int > countKConstraintSubstrings ( string s , int k , vector < vector < int >> & queries ) throw ( ) {\n  int n = s . size ( ) ;\n  vector < int > left ( n , 0 ) ;\n  vector < int > pre ( n , 0 ) ;\n  vector < int > cnt ( n + 1 , 0 ) ;\n  int l = 0 ;\n  for ( int i = 0 , c = s . size ( ) ;\n  i < c ;\n  ++ i ) {\n    cnt [ ( unsigned char ) s [ l ] & 1 ] ++ ;\n    while ( cnt [ 0 ] > k && cnt [ 1 ] > k ) {\n      cnt [ ( unsigned char ) s [ l ] & 1 ] -- ;\n      ++ l ;\n    }\n    left [ i ] = l ;\n    pre [ i + 1 ] = pre [ i ] + i - l + 1 ;\n  }\n  vector < int > ans ;\n  for ( int l = 0 , r = queries . size ( ) ;\n  l < r ;\n  ++ l ) {\n    int j = bisect_left ( left . begin ( ) , left . end ( ) , l , l , r + 1 ) ;\n    ans . push_back ( pre [ r + 1 ] - pre [ j ] + ( j - l + 1 ) * ( j - l ) / 2 ) ;\n  }\n  return ans ;\n}\n", "reference_code": "vector<long long> countKConstraintSubstrings(string s, int k, vector<vector<int>>& queries) {\n        int n = s.length();\n        vector<int> left(n);\n        vector<long long> sum(n + 1);\n        int cnt[2]{}, l = 0;\n        for (int i = 0; i < n; i++) {\n            cnt[s[i] & 1]++;\n            while (cnt[0] > k && cnt[1] > k) {\n                cnt[s[l++] & 1]--;\n            }\n            left[i] = l;\n            // \u8ba1\u7b97 i-left[i]+1 \u7684\u524d\u7f00\u548c\n            sum[i + 1] = sum[i] + i - l + 1;\n        }\n\n        vector<long long> ans(queries.size());\n        for (int i = 0; i < queries.size(); i++) {\n            int l = queries[i][0], r = queries[i][1];\n            int j = lower_bound(left.begin() + l, left.begin() + r + 1, l) - left.begin();\n            ans[i] = sum[r + 1] - sum[j] + (long long) (j - l + 1) * (j - l) / 2;\n        }\n        return ans;\n    }\n\n", "target_Lan": "cpp###countKConstraintSubstrings.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n\n// TOFILL\nint main() {\n    std::string s1 = \"1101\";\n    std::vector<std::vector<int>> queries1 = {{0, 2}, {1, 3}};\n    std::vector<long long> result1 = countKConstraintSubstrings(s1, 1, queries1);\n    for(auto res : result1) std::cout << res << \" \";\n    std::cout << std::endl;\n\n    std::string s2 = \"0000\";\n    std::vector<std::vector<int>> queries2 = {{0, 1}, {1, 2}, {2, 3}};\n    std::vector<long long> result2 = countKConstraintSubstrings(s2, 2, queries2);\n    for(auto res : result2) std::cout << res << \" \";\n    std::cout << std::endl;\n\n    std::string s3 = \"101010\";\n    std::vector<std::vector<int>> queries3 = {{0, 5}, {2, 4}};\n    std::vector<long long> result3 = countKConstraintSubstrings(s3, 3, queries3);\n    for(auto res : result3) std::cout << res << \" \";\n    std::cout << std::endl;\n\n    std::string s4 = \"111000\";\n    std::vector<std::vector<int>> queries4 = {{0, 2}, {3, 5}};\n    std::vector<long long> result4 = countKConstraintSubstrings(s4, 0, queries4);\n    for(auto res : result4) std::cout << res << \" \";\n    std::cout << std::endl;\n\n    std::string s5 = \"10101\";\n    std::vector<std::vector<int>> queries5 = {{0, 3}, {1, 4}};\n    std::vector<long long> result5 = countKConstraintSubstrings(s5, 2, queries5);\n    for(auto res : result5) std::cout << res << \" \";\n    std::cout << std::endl;\n\n    return 0;\n}"}, {"source_Lan": "python###resultsArray.py", "source_code": "def resultsArray(nums: List[int], k: int) -> List[int]:\n        ans = [-1] * (len(nums) - k + 1)\n        cnt = 0\n        for i, x in enumerate(nums):\n            cnt = cnt + 1 if i == 0 or x == nums[i - 1] + 1 else 1\n            if cnt >= k:\n                ans[i - k + 1] = x\n        return ans\n\n", "trans_code": "public : vector < int > resultsArray ( vector < int > & nums , int k ) throw ( ) {\n  vector < int > ans ( nums . size ( ) - k + 1 , - 1 ) ;\n  int cnt = 0 ;\n  for ( int i = 0 , x = nums . size ( ) ;\n  i < k ;\n  i ++ ) {\n    cnt = cnt + 1 == i || x == nums [ i - 1 ] + 1 ? 1 : 0 ;\n    if ( cnt >= k ) ans [ i - k + 1 ] = x ;\n  }\n  return ans ;\n}\n", "reference_code": "vector<int> resultsArray(vector<int>& nums, int k) {\n        vector<int> ans(nums.size() - k + 1, -1);\n        int cnt = 0;\n        for (int i = 0; i < nums.size(); i++) {\n            cnt = i == 0 || nums[i] == nums[i - 1] + 1 ? cnt + 1 : 1;\n            if (cnt >= k) {\n                ans[i - k + 1] = nums[i];\n            }\n        }\n        return ans;\n    }\n\n", "target_Lan": "cpp###resultsArray.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n\n// TOFILL\nint main() {\n    std::vector<int> nums1 = {1, 2, 3, 4, 5};\n    std::vector<int> result1 = resultsArray(nums1, 3);\n    for(int res : result1) std::cout << res << \" \";\n    std::cout << std::endl;\n\n    std::vector<int> nums2 = {1, 3, 5, 7, 9};\n    std::vector<int> result2 = resultsArray(nums2, 2);\n    for(int res : result2) std::cout << res << \" \";\n    std::cout << std::endl;\n\n    std::vector<int> nums3 = {5, 6, 7, 8, 9, 10};\n    std::vector<int> result3 = resultsArray(nums3, 4);\n    for(int res : result3) std::cout << res << \" \";\n    std::cout << std::endl;\n\n    std::vector<int> nums4 = {2, 4, 6, 8, 10};\n    std::vector<int> result4 = resultsArray(nums4, 1);\n    for(int res : result4) std::cout << res << \" \";\n    std::cout << std::endl;\n\n    std::vector<int> nums5 = {1, 2, 2, 3, 4, 5};\n    std::vector<int> result5 = resultsArray(nums5, 2);\n    for(int res : result5) std::cout << res << \" \";\n    std::cout << std::endl;\n\n    return 0;\n}"}, {"source_Lan": "python###finalPositionOfSnake.py", "source_code": "def finalPositionOfSnake(n: int, commands: List[str]) -> int:\n        i = j = 0\n        for s in commands:\n            if s[0] == 'U': i -= 1\n            elif s[0] == 'D': i += 1\n            elif s[0] == 'L': j -= 1\n            else: j += 1\n        return i * n + j\n\n", "trans_code": "int finalPositionOfSnake ( int n , vector < string > commands ) throw ( ) {\n  int i = j = 0 ;\n  for ( string s : commands ) {\n    if ( s [ 0 ] == 'U' ) {\n      i -- ;\n    }\n    else if ( s [ 0 ] == 'D' ) {\n      i ++ ;\n    }\n    else if ( s [ 0 ] == 'L' ) {\n      j -- ;\n    }\n    else {\n      j ++ ;\n    }\n  }\n  return i * n + j ;\n}\n", "reference_code": "int finalPositionOfSnake(int n, vector<string>& commands) {\n        int i = 0, j = 0;\n        for (auto& s : commands) {\n            switch (s[0]) {\n                case 'U': i--; break;\n                case 'D': i++; break;\n                case 'L': j--; break;\n                default:  j++;\n            }\n        }\n        return i * n + j;\n    }\n\n", "target_Lan": "cpp###finalPositionOfSnake.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n\n// TOFILL\nint main() {\n    std::vector<std::string> commands1 = {\"U\", \"R\", \"R\", \"D\", \"L\"};\n    std::cout << finalPositionOfSnake(5, commands1) << std::endl;\n\n    std::vector<std::string> commands2 = {\"U\", \"U\", \"D\", \"R\", \"R\", \"L\", \"D\"};\n    std::cout << finalPositionOfSnake(10, commands2) << std::endl;\n\n    std::vector<std::string> commands3 = {\"U\", \"L\", \"L\", \"D\", \"R\", \"U\"};\n    std::cout << finalPositionOfSnake(7, commands3) << std::endl;\n\n    std::vector<std::string> commands4 = {\"D\", \"D\", \"R\", \"U\", \"U\", \"L\"};\n    std::cout << finalPositionOfSnake(4, commands4) << std::endl;\n\n    std::vector<std::string> commands5 = {\"U\", \"U\", \"R\", \"R\", \"D\", \"D\", \"L\", \"L\"};\n    std::cout << finalPositionOfSnake(8, commands5) << std::endl;\n\n    return 0;\n}"}, {"source_Lan": "python###satisfiesConditions.py", "source_code": "def satisfiesConditions(grid: List[List[int]]) -> bool:\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if i + 1 < len(grid) and grid[i][j] != grid[i + 1][j]:\n                    return False\n                if j + 1 < len(grid[0]) and grid[i][j] == grid[i][j + 1]:\n                    return False\n        return True\n\n", "trans_code": "bool satisfiesConditions ( vector < vector < int >> & grid ) throw ( ) {\n  for ( int i = 0 ;\n  i < grid . size ( ) ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < grid [ 0 ] . size ( ) ;\n    j ++ ) {\n      if ( i + 1 < grid . size ( ) && grid [ i ] [ j ] != grid [ i + 1 ] [ j ] ) return false ;\n      if ( j + 1 < grid [ 0 ] . size ( ) && grid [ i ] [ j ] == grid [ i ] [ j + 1 ] ) return false ;\n    }\n  }\n  return true ;\n}\n", "reference_code": "bool satisfiesConditions(vector<vector<int>>& grid) {\n        for (int i = 0; i < grid.size(); ++i) {\n            for (int j = 0; j < grid[0].size(); ++j) {\n                if (i + 1 < grid.size() && grid[i][j] != grid[i + 1][j]) {\n                    return false;\n                }\n                if (j + 1 < grid[0].size() && grid[i][j] == grid[i][j + 1]) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n", "target_Lan": "cpp###satisfiesConditions.cpp", "target_code_shell": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// TOFILL\nint main() {\n    vector<vector<int>> grid1 = {{1, 2, 3}, {1, 2, 3}, {1, 2, 3}};\n    cout <<(satisfiesConditions(grid1) ? \"true\" : \"false\") << endl;\n\n    vector<vector<int>> grid2 = {{1, 2, 2}, {3, 4, 5}, {6, 7, 8}};\n    cout <<(satisfiesConditions(grid2) ? \"true\" : \"false\") << endl;\n\n    vector<vector<int>> grid3 = {{5, 6, 7}, {5, 6, 7}, {5, 6, 7}};\n    cout <<(satisfiesConditions(grid3) ? \"true\" : \"false\") << endl;\n\n    vector<vector<int>> grid4 = {{1, 2, 1}, {1, 2, 1}, {1, 2, 1}};\n    cout <<(satisfiesConditions(grid4) ? \"true\" : \"false\") << endl;\n\n    vector<vector<int>> grid5 = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};\n    cout <<(satisfiesConditions(grid5) ? \"true\" : \"false\") << endl;\n\n    return 0;\n}"}, {"source_Lan": "python###pow_mod.py", "source_code": "def pow_mod(x, y, mod):\n    res = 1\n    while y:\n        if y & 1:\n            res = res * x % mod\n        x = x * x % mod\n        y >>= 1\n    return res\n\n", "trans_code": "int pow_mod ( int x , int y , int mod ) {\n  int res = 1 ;\n  while ( y ) {\n    if ( y & 1 ) res = res * x % mod ;\n    x = x * x % mod ;\n    y >>= 1 ;\n  }\n  return res ;\n}\n", "reference_code": "int pow_mod(long long x, long long y, int mod) {\n        int res = 1;\n        while (y) {\n            if (y & 1) {\n                res = res * x % mod;\n            }\n            x = x * x % mod;\n            y >>= 1;\n        }\n        return res;\n    }\n\n", "target_Lan": "cpp###pow_mod.cpp", "target_code_shell": "#include <iostream>\nusing namespace std;\n\n// TOFILL\nint main() {\n    cout << pow_mod(2, 10, 1000) << endl;\n    cout << pow_mod(3, 7, 50) << endl;\n    cout << pow_mod(5, 20, 100) << endl;\n    cout << pow_mod(7, 3, 13) << endl;\n    cout << pow_mod(10, 5, 17) << endl;\n    return 0;\n}"}, {"source_Lan": "python###countPow.py", "source_code": "def countPow(x):\n    res = 0\n    sum = 0\n\n    for i in range(60, -1, -1):\n        if (1 << i) & x:\n            res += sum * (1 << i)\n            sum += i\n\n            if i > 0:\n                res += i * (i - 1) // 2 * (1 << (i - 1))\n    \n    res += sum\n    return res\n\n", "trans_code": "int countPow ( int x ) {\n  int res = 0 ;\n  int sum = 0 ;\n  for ( int i = 60 ;\n  i >= 0 ;\n  i -- ) {\n    if ( ( 1 << i ) & x ) {\n      res += sum * ( 1 << i ) ;\n      sum += i ;\n      if ( i > 0 ) res += i * ( i - 1 ) / 2 * ( 1 << ( i - 1 ) ) ;\n    }\n  }\n  res += sum ;\n  return res ;\n}\n", "reference_code": "long long countPow(long long x) {\n        long long res = 0;\n        int sum = 0;\n\n        for (int i = 60; i >= 0; i--) {\n            if (1LL << i & x) {\n                res += 1LL * sum * (1LL << i);\n                sum += i;\n                \n                if (i > 0) {\n                    res += 1LL * i * (i - 1) / 2 * (1LL << (i - 1));\n                }\n            }\n        }\n        res += sum;\n        return res;\n    }\n\n", "target_Lan": "cpp###countPow.cpp", "target_code_shell": "#include <iostream>\nusing namespace std;\n\n// TOFILL\nint main() {\n    cout << countPow(0) << endl;\n    cout << countPow(16) << endl;\n    cout << countPow(1023) << endl;\n    cout << countPow(255) << endl;\n    cout << countPow(4096) << endl;\n    return 0;\n}"}]