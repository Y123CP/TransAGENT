[{"source_Lan": "cpp###timeTravel.cpp", "source_code": "    int timeTravel(int n, vector<int> &arr) {\n        int ans = 0;\n        for(int i = 1; i < n; i++)\n            ans += (arr[i] > arr[i - 1] ? 1 : (arr[i] < arr[i - 1] ? 2 : 0));\n        return ans;\n    }", "trans_code": "def timeTravel ( n , arr ) :\n    ans = 0\n    for i in range ( 1 , n ) :\n        ans += ( arr [ i ] > arr [ i - 1 ] )\n    return ans\n", "reference_code": "def timeTravel( n, arr):\n    ans=0\n    for i in range(1,n):\n        if (arr[i]>arr[i-1]):\n            ans+=1\n        elif (arr[i]<arr[i-1]):\n            ans+=2\n    return ans", "target_Lan": "python###timeTravel.py", "target_code_shell": "# TOFILL\nif __name__ == \"__main__\":\n    print(timeTravel(0, []))\n    print(timeTravel(1, [1]))\n    print(timeTravel(2, [1,2]))\n    print(timeTravel(3, [2,1,2]))\n    print(timeTravel(5, [1,2,3,4,5]))"}, {"source_Lan": "cpp###lastFairyStanding.cpp", "source_code": "    int lastFairyStanding(int n, int k) {\n        \n        int i = 1, ans = 0;\n        while (i <= n)\n            ans = (ans + k) % i++;\n        return ans + 1;\n    }", "trans_code": "def lastFairyStanding ( n , k ) :\n    i , ans = 1 , 0\n    while i <= n :\n        ans = ( ans + k ) % i\n    return ans + 1\n", "reference_code": "def lastFairyStanding( n : int, k : int) -> int:\n    ans = 0\n    for x in range(2, n+1): \n        ans = (ans + k) % x\n    return ans + 1", "target_Lan": "python###lastFairyStanding.py", "target_code_shell": "# TOFILL\nif __name__ == \"__main__\":\n    print(lastFairyStanding(0, 0))\n    print(lastFairyStanding(1, 1))\n    print(lastFairyStanding(-1, -1))\n    print(lastFairyStanding(10, 5))\n    print(lastFairyStanding(5, 2))"}, {"source_Lan": "cpp###findEnemies.cpp", "source_code": "    vector<vector<int>> findEnemies(int n, int m, int k, vector<int> &col, vector<int> &count) {\n        vector<vector<int>> answer(n, vector<int>(m, -1));\n        int curr = 0;\n        int ind = 0;\n        while(curr < k && ind < n){\n            int total = count[ind];\n            while(total--){\n                answer[ind][col[curr]] = curr;\n                curr += 1;\n            }\n            ind += 1;\n        }\n        return answer;\n    }", "trans_code": "def find_enemies ( n , m , k , col , count ) :\n    answer = np.zeros ( ( n , m , -1 ) )\n    curr = 0\n    ind = 0\n    while curr < k and ind < n :\n        total = count [ ind ]\n        while total :\n            answer [ ind ] [ col [ curr ] ] = curr\n            curr += 1\n        ind += 1\n    return answer\n", "reference_code": "def findEnemies( n : int, m : int, k : int, col : List[int], count : List[int]) -> List[List[int]]:\n    arr=[[-1]*(m) for _ in range(n)]\n    ind=0\n    for i in range(n):\n        while count[i]>0:\n            arr[i][col[ind]]=ind\n            ind+=1\n            count[i]-=1\n    return arr", "target_Lan": "python###findEnemies.py", "target_code_shell": "from typing import List\nfrom typing import List\nfrom typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(findEnemies(0, 0, 0, [], []))\n    print(findEnemies(1, 1, 1, [0], [1]))\n    print(findEnemies(2, 2, 2, [0, 1], [1, 1]))\n    print(findEnemies(3, 3, 3, [0, 1, 2], [1, 1, 1]))\n    print(findEnemies(4, 4, 4, [0, 1, 2, 3], [1, 1, 1, 1]))"}, {"source_Lan": "cpp###validStrings.cpp", "source_code": "    int validStrings(int n, int k, vector<string> &arr) {\n        int tot=0;\n        for (auto j:arr){\n            int c=0;\n            for (auto q:j){\n                if (q=='a'||q=='e'||q=='i'||q=='o'||q=='u') c+=1;\n            }\n            if (c==k) tot+=1;\n        }\n        return tot;\n    }", "trans_code": "def validStrings ( n , k , arr ) :\n    tot = 0\n    for j in arr :\n        c = 0\n        for q in j :\n            if q in [ 'a' , 'e' , 'i' , 'o' , 'u' ] :\n                c += 1\n        if c == k :\n            tot += 1\n    return tot\n", "reference_code": "def validStrings( n : int, k : int, arr : List[str]) -> int:\n    ans=0\n    for el in arr:\n        C=0\n        for e in el:\n            if e in \"aeiou\":\n                C+=1\n        if C==k:\n            ans+=1\n    return ans", "target_Lan": "python###validStrings.py", "target_code_shell": "from typing import List\nfrom typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(validStrings(0, 0, []))\n    print(validStrings(1, 1, [\"a\"]))\n    print(validStrings(2, 2, [\"ae\", \"iou\"]))\n    print(validStrings(3, 3, [\"aei\", \"ou\", \"a\"]))\n    print(validStrings(5, 5, [\"aeiou\", \"a\", \"e\", \"i\", \"o\"]))"}, {"source_Lan": "cpp###isMagicArray.cpp", "source_code": "    bool isMagicArray(int n, vector<int> &arr) {\n        for (int i=1;i<n;i++){\n            if ((arr[i]%2==0 && arr[i-1]%2==0) || (arr[i]%2!=0 && arr[i-1]%2!=0)) return 0;\n        }\n        return 1;\n    }", "trans_code": "def isMagicArray ( n , arr ) :\n    for i in range ( 1 , n ) :\n        if ( arr [ i ] % 2 == 0 and arr [ i - 1 ] % 2 == 0 ) :\n            return 0\n    return 1\n", "reference_code": "def isMagicArray( n : int, arr : List[int]) -> bool:\n    for i in range(n-1):\n        if (arr[i]&1)==(arr[i+1]&1):\n            return 0\n    return 1", "target_Lan": "python###isMagicArray.py", "target_code_shell": "from typing import List\nfrom typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(isMagicArray(0, []))  # Output: True\n    print(isMagicArray(1, [1]))  # Output: True\n    print(isMagicArray(2, [1, 2]))  # Output: False\n    print(isMagicArray(2, [2, 1]))  # Output: False\n    print(isMagicArray(5, [1, 2, 3, 4, 5]))  # Output: True"}, {"source_Lan": "cpp###smallestString.cpp", "source_code": "    string smallestString(int n, string s) {\n        string answer = s;\n        int odd = n%2;\n        if(n == 1){\n            return \"-1\";\n        }\n        for(int i = 0; i < (n/2); i ++){\n            if(s[i] != 'a'){\n                answer[i] = 'a';\n                return answer;\n            }\n        }\n        answer[answer.size() - 1] = 'b';\n        return answer;\n    }", "trans_code": "def smallest_string ( n , s ) :\n    answer = s\n    odd = n % 2\n    if n == 1 :\n        return '-1'\n    for i in range ( ( n // 2 ) ) :\n        if s [ i ] != 'a' :\n            answer [ i ] = 'a'\n            return answer\n    answer [ - 1 ] = 'b'\n    return answer\n", "reference_code": "def smallestString( n : int, s : str) -> str:\n    #return -1 if n is 1\n    if n == 1:\n        return \"-1\"\n    answer = list(s)\n    #iterate only till half of the string\n    for i in range(n // 2):\n        #if character is not 'a', replace it with 'a' and return\n        if s[i] != 'a':\n            answer[i] = 'a'\n            return ''.join(answer)\n    #if all characters are 'a', change the last character to 'b'\n    answer[-1] = 'b'\n    return ''.join(answer)", "target_Lan": "python###smallestString.py", "target_code_shell": "# TOFILL\nif __name__ == \"__main__\":\n    print(smallestString(2, \"ab\"))\n    print(smallestString(1, \"a\"))\n    print(smallestString(3, \"aaa\"))\n    print(smallestString(4, \"aaaa\"))\n    print(smallestString(5, \"baaaa\"))"}, {"source_Lan": "cpp###matrixConundrum.cpp", "source_code": "    bool matrixConundrum(int n, int m, vector<string> &mat) {\n        string play = \"play\";\n        int fnd = 0;\n        for (int i = 0; i < m; ++i) {\n            bool check = false;\n            for (int j = 0; j < n; ++j) {\n                if (mat[j][i] == play[fnd]) {\n                    check = true;\n                }\n            }\n            if (check) {\n                ++fnd;\n                if (fnd == 4) {\n                    break;\n                }\n            }\n        }\n        if (fnd == 4)\n            return true;\n        return false;\n    }", "trans_code": "def matrixConundrum ( n , m , mat ) :\n    play = \"play\"\n    fnd = 0\n    for i in range ( m ) :\n        check = False\n        for j in range ( n ) :\n            if mat [ j ] [ i ] == play [ fnd ] :\n                check = True\n        if check :\n            fnd += 1\n            if fnd == 4 :\n                break\n    if fnd == 4 :\n        return True\n    return False\n", "reference_code": "def matrixConundrum( n: int, m: int, mat: List[str]) -> bool:\n    check = ['p', 'l', 'a', 'y']\n    idx = 0\n    for j in range(m):\n        for i in range(n):\n            if mat[i][j] == check[idx]:\n                idx += 1\n                if idx == 4:\n                    return True\n                break\n    return False", "target_Lan": "python###matrixConundrum.py", "target_code_shell": "from typing import List\nfrom typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(matrixConundrum(4, 4, [\"play\", \"game\", \"love\", \"hate\"]))\n    print(matrixConundrum(1, 1, [\"play\"]))\n    print(matrixConundrum(2, 2, [\"pla\", \"lay\"]))\n    print(matrixConundrum(3, 3, [\"pla\", \"ypl\", \"ayp\"]))\n    print(matrixConundrum(4, 4, [\"play\", \"ypal\", \"alpy\", \"paly\"]))"}, {"source_Lan": "cpp###isPossible.cpp", "source_code": "    string isPossible(int a, int b, int c) {\n        \n        if ((a + b) > c && (a + c) > b && (b + c) > a)\n            return \"YES\";\n        else\n            return \"NO\";\n    }", "trans_code": "def isPossible ( a , b , c ) :\n    if ( a + b ) > c and ( a + c ) > b and ( b + c ) > a :\n        return \"YES\"\n    else :\n        return \"NO\"\n", "reference_code": "def isPossible( a: int, b: int, c: int) -> str:\n    # sum of any two sides should be strictly greater than third side\n    if (a + b) > c and (a + c) > b and (b + c) > a:\n        return \"YES\"\n    else:\n        return \"NO\"", "target_Lan": "python###isPossible.py", "target_code_shell": "# TOFILL\nif __name__ == \"__main__\":\n    print(isPossible(0, 0, 0))\n    print(isPossible(1, 2, 3))\n    print(isPossible(10, 10, 30))\n    print(isPossible(5, 5, 15))\n    print(isPossible(10, 20, 25))"}, {"source_Lan": "cpp###geeklandElections.cpp", "source_code": "    bool geeklandElections(int n, int k, string &s) {\n        int votes = 0;\n        for (int i = 0; i < n; i++)\n            votes += (s[i] == '1');\n        return (votes + k) > (n - (votes + k));\n    }", "trans_code": "def geekland_elections ( n , k , s ) :\n    votes = 0\n    for i in range ( n ) :\n        votes += ( s [ i ] == '1' )\n    return ( votes + k ) > ( n - ( votes + k ) )\n", "reference_code": "def geeklandElections( n: int, k: int, s: str) -> bool:\n    ans = s.count(\"1\") + min(k, s.count(\"0\"))\n    return ans > n - ans", "target_Lan": "python###geeklandElections.py", "target_code_shell": "# TOFILL\nif __name__ == \"__main__\":\n    print(geeklandElections(0, 0, \"\"))\n    print(geeklandElections(5, 2, \"11111\"))\n    print(geeklandElections(10, 5, \"1111100000\"))\n    print(geeklandElections(5, 5, \"11111\"))\n    print(geeklandElections(10, 2, \"1111100000\"))"}, {"source_Lan": "cpp###totalCount.cpp", "source_code": "    int totalCount(int n, string s) {\n        int answer = 0;\n        int mod = 1e9 + 7;\n        char now = s[0];\n        for(int i = 0; i < n; i ++){\n            if(s[i] == now){\n                answer += n - i;\n                answer %= mod;\n            }\n        }\n        return answer;\n    }", "trans_code": "def totalCount ( n , s ) :\n    answer = 0\n    mod = 1e9 + 7\n    now = s [ 0 ]\n    for i in range ( n ) :\n        if s [ i ] == now :\n            answer += n - i\n            answer %= mod\n    return answer\n", "reference_code": "def totalCount( n : int, s : str) -> int:\n    mod=10**9+7\n    ans=0\n    for i in range(n):\n        if s[i]==s[0]:\n            ans+=(n-i)\n            ans%=mod\n    return ans", "target_Lan": "python###totalCount.py", "target_code_shell": "# TOFILL\nif __name__ == \"__main__\":\n    print(totalCount(0, \"\"))\n    print(totalCount(1, \"a\"))\n    print(totalCount(5, \"aaaaa\"))\n    print(totalCount(3, \"abc\"))\n    print(totalCount(7, \"aabbcdd\"))"}, {"source_Lan": "cpp###geekTasks.cpp", "source_code": "    long long geekTasks(int n, int m, int q, vector<vector<int>> &tasks) {\n        long long int total = 0;\n        long long int a,b, minA, minB;\n        for(long long int i=0; i<q; i++)\n        {\n            a = tasks[i][0];\n            b = tasks[i][1];\n            a += 1;\n            b += 1;\n            if(i==0){\n                minA=a;\n                minB=b;\n            }\n            if(a<minA){\n                minA=a;\n            }\n            if(b<minB){\n                minB=b;\n            }\n        }\n        vector<int> col(n, 0);\n        for(auto i : tasks){\n            long long int x = i[1] + 1;\n            col[i[0]] = max((long long int)col[i[0]], x);\n        }\n        long long int maxi = 0;\n        for(int i = n - 1; i >= 0; i--){\n            maxi = max(maxi, (long long int)col[i]);\n            total += maxi;\n        }\n        long long int cellsWithMaxValue = minA*minB;\n        total -= cellsWithMaxValue;\n        return total;\n    }", "trans_code": "def geekTasks ( n , m , q , tasks ) :\n    total = 0\n    a , b , min_a , min_b = tasks\n    for i in range ( q ) :\n        a , b = tasks [ i ] [ 0 ] , tasks [ i ] [ 1 ]\n        a += 1\n        b += 1\n        if i == 0 :\n            min_a = a\n            min_b = b\n        if a < min_a : min_a = a\n        if b < min_b : min_b = b\n    col = [ 0 ] * n\n    for i in tasks :\n        x = i [ 1 ] + 1\n        col [ i [ 0 ] ] = max ( int ( col [ i [ 0 ] ] ) , x )\n    maxi = 0\n    for i in range ( n - 1 , - 1 , - 1 ) :\n        maxi = max ( maxi , int ( col [ i ] ) )\n        total += maxi\n    cellsWithMaxValue = min_a * min_b\n    total -= cellsWithMaxValue\n    return total\n", "reference_code": "def geekTasks( n : int, m : int, q : int, tasks : List[List[int]]) -> int:\n    minA=0\n    minB=0\n    for i in range(q):\n        a,b=tasks[i][0],tasks[i][1]\n        a+=1\n        b+=1\n        if i==0:\n            minA=a\n            minB=b\n        else:\n            if minA>a:\n                minA=a\n            if minB>b:\n                minB=b\n    total=0\n    maxi=0\n    col=[0]*(n)\n    for i in range(q):\n        col[tasks[i][0]]=max(col[tasks[i][0]],tasks[i][1]+1)\n    for i in range(n-1,-1,-1):\n        maxi=max(maxi,col[i])\n        total+=maxi\n    total-=minA*minB\n    return total", "target_Lan": "python###geekTasks.py", "target_code_shell": "from typing import List\nfrom typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(geekTasks(2, 2, 2, [[0, 0], [1, 1]]))\n    print(geekTasks(3, 3, 3, [[0, 0], [1, 1], [2, 2]]))\n    print(geekTasks(4, 4, 4, [[0, 0], [1, 1], [2, 2], [3, 3]]))\n    print(geekTasks(5, 5, 5, [[0, 0], [1, 1], [2, 2], [3, 3], [4, 4]]))\n    print(geekTasks(6, 6, 6, [[0, 0], [1, 1], [2, 2], [3, 3], [4, 4], [5, 5]]))"}, {"source_Lan": "cpp###majorityWins.cpp", "source_code": "    int majorityWins(int arr[], int n, int x, int y) {\n        int count_x = 0;\n        int count_y = 0;\n        \n        \n        for (int i = 0; i < n; i++) {\n            if (arr[i] == x) count_x++;\n            if (arr[i] == y) count_y++;\n        }\n        \n        if (count_x > count_y)\n            \n            return x;\n        else if (count_y > count_x)\n            \n            return y;\n        \n        else\n            return x < y ? x : y;\n    }", "trans_code": "def majorityWins ( arr , n , x , y ) :\n    count_x = 0\n    count_y = 0\n    for i in range ( n ) :\n        if arr [ i ] == x :\n            count_x += 1\n        if arr [ i ] == y :\n            count_y += 1\n    if count_x > count_y :\n        return x\n    elif count_y > count_x :\n        return y\n    else :\n        return x if y else y\n", "reference_code": "def majorityWins( arr, n, x, y):\n    count_x=0;\n    count_y=0;\n    for i in range(0,n):\n        #Iterating through the array elements.\n        #Incrementing the counter variables accordingly.\n        if(arr[i]==x):\n            count_x+=1\n        if(arr[i]==y):\n            count_y+=1\n    #Comparing the two counters.\n    #If both appear same number of times, returning the smaller number.\n    if(count_x>count_y or (count_x==count_y and x<y)):\n        #Returning the number with more appearances in the array.\n        return x\n    else:\n        #Returning the number with more appearances in the array.\n        return y", "target_Lan": "python###majorityWins.py", "target_code_shell": "# TOFILL\nif __name__ == \"__main__\":\n    print(majorityWins([1,2,3,4,5,6], 6, 1, 2))\n    print(majorityWins([1,1,2,2,3,3], 6, 1, 2))\n    print(majorityWins([1,1,1,2,2,3], 6, 1, 3))\n    print(majorityWins([1,2,3,4,5,6], 6, 1, 1))\n    print(majorityWins([1,1,2,2,3,3,4,4,4,5,5], 11, 4, 5))"}, {"source_Lan": "cpp###areaOfMaxDiagonal.cpp", "source_code": "    int areaOfMaxDiagonal(vector<vector<int>> &dimensions) {\n        int ans = 0, max_l = 0;\n        for (auto &d: dimensions) {\n            int x = d[0], y = d[1];\n            int l = x * x + y * y;\n            if (l > max_l || (l == max_l && x * y > ans)) {\n                max_l = l;\n                ans = x * y;\n            }\n        }\n        return ans;\n    }", "trans_code": "def areaOfMaxDiagonal ( dimensions ) :\n    ans , max_l = 0 , 0\n    for d in dimensions :\n        x , y = d\n        l = x * x + y * y\n        if l > max_l or ( l == max_l and x * y > ans ) :\n            max_l = l\n            ans = x * y\n    return ans\n", "reference_code": "def areaOfMaxDiagonal( dimensions: List[List[int]]) -> int:\n    return max((x * x + y * y, x * y) for x, y in dimensions)[1]", "target_Lan": "python###areaOfMaxDiagonal.py", "target_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(areaOfMaxDiagonal([[1,1],[1,1],[1,1]]))\n    print(areaOfMaxDiagonal([[2,3],[5,7],[12,15],[15,12]]))\n    print(areaOfMaxDiagonal([[0,0],[0,0],[0,0]]))\n    print(areaOfMaxDiagonal([[10,20],[30,40],[50,60],[70,80]]))\n    print(areaOfMaxDiagonal([[100,200],[300,400],[500,600],[700,800]]))"}, {"source_Lan": "cpp###countSubmatrices.cpp", "source_code": "    int countSubmatrices(vector<vector<int>> &grid, int k) {\n        int ans = 0, m = grid.size(), n = grid[0].size();\n        vector<vector<int>> sum(m + 1, vector<int>(n + 1));\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                sum[i + 1][j + 1] = sum[i + 1][j] + sum[i][j + 1] - sum[i][j] + grid[i][j];\n                ans += sum[i + 1][j + 1] <= k;\n            }\n        }\n        return ans;\n    }", "trans_code": "def countSubmatrices ( grid , k ) :\n    ans , m , n = 0 , len ( grid ) , len ( grid [ 0 ] )\n    sum = np.zeros ( ( m + 1 , n + 1 ) )\n    for i in range ( m ) :\n        for j in range ( n ) :\n            sum [ i + 1 ] [ j + 1 ] = sum [ i + 1 ] [ j ] + sum [ i ] [ j + 1 ] - sum [ i ] [ j ] + grid [ i ] [ j ]\n            ans += sum [ i + 1 ] [ j + 1 ] <= k\n    return ans\n", "reference_code": "def countSubmatrices( grid: List[List[int]], k: int) -> int:\n    ans = 0\n    m, n = len(grid), len(grid[0])\n    s = [[0] * (n + 1) for _ in range(m + 1)]\n    for i, row in enumerate(grid):\n        for j, x in enumerate(row):\n            s[i + 1][j + 1] = s[i + 1][j] + s[i][j + 1] - s[i][j] + x\n            if s[i + 1][j + 1] <= k:\n                ans += 1\n    return ans", "target_Lan": "python###countSubmatrices.py", "target_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(countSubmatrices([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 5))\n    print(countSubmatrices([[10, 20, 30], [40, 50, 60], [70, 80, 90]], 40))\n    print(countSubmatrices([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 1))\n    print(countSubmatrices([[0, 0, 0], [0, 0, 0], [0, 0, 0]], 1))\n    print(countSubmatrices([[10, 20, 30], [40, 50, 60], [70, 80, 90]], 100))"}, {"source_Lan": "cpp###minimumOperationsToWriteY.cpp", "source_code": "    int minimumOperationsToWriteY(vector<vector<int>> &grid) {\n        int cnt1[3]{}, cnt2[3]{};\n        int n = grid.size();\n        int m = n / 2;\n        for (int i = 0; i < m; i++) {\n            cnt1[grid[i][i]]++;\n            cnt1[grid[i][n - 1 - i]]++;\n            for (int j = 0; j < n; j++) {\n                if (j != i && j != n - 1 - i) {\n                    cnt2[grid[i][j]]++;\n                }\n            }\n        }\n        for (int i = m; i < n; i++) {\n            cnt1[grid[i][m]]++;\n            for (int j = 0; j < n; j++) {\n                if (j != m) {\n                    cnt2[grid[i][j]]++;\n                }\n            }\n        }\n        int max_not_change = 0;\n        for (int i = 0; i < 3; i++) {\n            for (int j = 0; j < 3; j++) {\n                if (i != j) {\n                    max_not_change = max(max_not_change, cnt1[i] + cnt2[j]);\n                }\n            }\n        }\n        return n * n - max_not_change;\n    }", "trans_code": "def minimumOperationsToWriteY ( grid ) :\n    cnt1 , cnt2 = [ ] , [ ]\n    n = len ( grid )\n    m = n // 2\n    for i in range ( m ) :\n        cnt1.append ( grid [ i ] [ i ] )\n        cnt1.append ( grid [ i ] [ n - 1 - i ] )\n        for j in range ( n ) :\n            if j != i and j != n - 1 - i :\n                cnt2.append ( grid [ i ] [ j ] )\n    for i in range ( m , n ) :\n        cnt1.append ( grid [ i ] [ m ] )\n        for j in range ( n ) :\n            if j != m :\n                cnt2.append ( grid [ i ] [ j ] )\n    max_not_change = 0\n    for i in range ( 3 ) :\n        for j in range ( 3 ) :\n            if i != j :\n                max_not_change = max ( max_not_change , cnt1 [ i ] + cnt2 [ j ] )\n    return n * n - max_not_change\n", "reference_code": "def minimumOperationsToWriteY( grid: List[List[int]]) -> int:\n    cnt1 = [0] * 3\n    cnt2 = [0] * 3\n    n = len(grid)\n    m = n // 2\n    for i, row in enumerate(grid[:m]):\n        cnt1[row[i]] += 1\n        cnt1[row[-1 - i]] += 1\n        for j, x in enumerate(row):\n            if j != i and j != n - 1 - i:\n                cnt2[x] += 1\n    for row in grid[m:]:\n        cnt1[row[m]] += 1\n        for j, x in enumerate(row):\n            if j != m:\n                cnt2[x] += 1\n    max_not_change = 0\n    for i, c1 in enumerate(cnt1):\n        for j, c2 in enumerate(cnt2):\n            if i != j:\n                max_not_change = max(max_not_change, c1 + c2)\n    return n * n - max_not_change", "target_Lan": "python###minimumOperationsToWriteY.py", "target_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(minimumOperationsToWriteY([[1,1,1],[1,1,1],[1,1,1]]))\n    print(minimumOperationsToWriteY([[2,2,2],[2,2,2],[2,2,2]]))\n    print(minimumOperationsToWriteY([[0,0,0],[0,0,0],[0,0,0]]))"}, {"source_Lan": "cpp###maxBottlesDrunk.cpp", "source_code": "    int maxBottlesDrunk(int numBottles, int numExchange) {\n        int ans = numBottles; \n        while (numBottles >= numExchange) { \n            ans++; \n            numBottles += 1 - numExchange++;\n        }\n        return ans;\n    }", "trans_code": "def maxBottlesDrunk ( numBottles , numExchange ) :\n    ans = numBottles\n    while numBottles >= numExchange :\n        ans += 1\n        numBottles += 1 - numExchange\n    return ans\n", "reference_code": "def maxBottlesDrunk( numBottles: int, numExchange: int) -> int:\n    ans = numBottles  # \u4e00\u5f00\u59cb\u5c31\u5168\u90e8\u559d\u5b8c\n    while numBottles >= numExchange:  # \u6709\u8db3\u591f\u7684\u7a7a\u74f6\n        ans += 1  # \u7528 numExchange \u4e2a\u7a7a\u74f6\u4ea4\u6362\uff0c\u7136\u540e\u559d\u6389\uff0c\u4ea7\u751f\u4e00\u4e2a\u65b0\u7684\u7a7a\u74f6\n        numBottles += 1 - numExchange\n        numExchange += 1\n    return ans", "target_Lan": "python###maxBottlesDrunk.py", "target_code_shell": "# TOFILL\nif __name__ == \"__main__\":\n    print(maxBottlesDrunk(1, 1))\n    print(maxBottlesDrunk(5, 3))\n    print(maxBottlesDrunk(10, 5))\n    print(maxBottlesDrunk(0, 1))\n    print(maxBottlesDrunk(10, 10))"}, {"source_Lan": "cpp###getSmallestString.cpp", "source_code": "    string getSmallestString(string s, int k) {\n        for (int i = 0; i < s.length(); i++) {\n            int dis = min(s[i] - 'a', 'z' - s[i] + 1);\n            if (dis > k) {\n                s[i] -= k;\n                break;\n            }\n            s[i] = 'a';\n            k -= dis;\n        }\n        return s;\n    }", "trans_code": "def getSmallestString ( s , k ) :\n    for i in range ( len ( s ) ) :\n        dis = min ( s [ i ] - 'a' , 'z' - s [ i ] + 1 )\n        if dis > k :\n            s [ i ] -= k\n            break\n        s [ i ] = 'a'\n        k -= dis\n    return s\n", "reference_code": "def getSmallestString( s: str, k: int) -> str:\n    s = list(s)\n    for i, c in enumerate(map(ord, s)):\n        dis = min(c - ord('a'), ord('z') - c + 1)\n        if dis > k:\n            s[i] = chr(c - k)\n            break\n        s[i] = 'a'\n        k -= dis\n    return ''.join(s)", "target_Lan": "python###getSmallestString.py", "target_code_shell": "# TOFILL\nif __name__ == \"__main__\":\n    print(getSmallestString(\"abc\", 3))\n    print(getSmallestString(\"aaa\", 1))\n    print(getSmallestString(\"xyz\", 2))\n    print(getSmallestString(\"zzz\", 3))\n    print(getSmallestString(\"aaz\", 2))"}, {"source_Lan": "cpp###countCompleteDayPairs.cpp", "source_code": "    long long countCompleteDayPairs(vector<int> &hours) {\n        long long ans = 0;\n        int cnt[24]{};\n        for (int t : hours) {\n            \n            \n            ans += cnt[(24 - t % 24) % 24];\n            cnt[t % 24]++;\n        }\n        return ans;\n    }", "trans_code": "def countCompleteDayPairs ( hours ) :\n    ans = 0\n    cnt = { }\n    for t in hours :\n        ans += cnt [ ( 24 - t % 24 ) % 24 ]\n        cnt [ t % 24 ] += 1\n    return ans\n", "reference_code": "def countCompleteDayPairs( hours: List[int]) -> int:\n    ans = 0\n    cnt = [0] * 24\n    for t in hours:\n        # \u5148\u67e5\u8be2 cnt\uff0c\u518d\u66f4\u65b0 cnt\uff0c\u56e0\u4e3a\u9898\u76ee\u8981\u6c42 i<j\n        # \u5982\u679c\u5148\u66f4\u65b0\uff0c\u518d\u67e5\u8be2\uff0c\u5c31\u628a i=j \u7684\u60c5\u51b5\u4e5f\u8003\u8651\u8fdb\u53bb\u4e86\n        ans += cnt[(24 - t % 24) % 24]\n        cnt[t % 24] += 1\n    return ans", "target_Lan": "python###countCompleteDayPairs.py", "target_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(countCompleteDayPairs([0, 23, 23, 23, 23]))\n    print(countCompleteDayPairs([0, 0, 0, 0, 0]))\n    print(countCompleteDayPairs([23, 23, 23, 23, 23]))\n    print(countCompleteDayPairs([12, 12, 12, 12, 12]))\n    print(countCompleteDayPairs([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23]))"}, {"source_Lan": "cpp###maximumLength.cpp", "source_code": "    int maximumLength(vector<int>& nums, int k) {\n        int ans = 0;\n        vector<vector<int>> f(k, vector<int>(k));\n        for (int x : nums) {\n            x %= k;\n            for (int y = 0; y < k; y++) {\n                f[y][x] = f[x][y] + 1;\n                ans = max(ans, f[y][x]);\n            }\n        }\n        return ans;\n    }", "trans_code": "def maximum_length ( nums , k ) :\n    ans = 0\n    f = np.zeros ( ( k , k ) )\n    for x in nums :\n        x %= k\n        for y in range ( k ) :\n            f [ y ] [ x ] = f [ x ] [ y ] + 1\n            ans = max ( ans , f [ y ] [ x ] )\n    return ans\n", "reference_code": "def maximumLength( nums: List[int], k: int) -> int:\n    f = [[0] * k for _ in range(k)]\n    for x in nums:\n        x %= k\n        for y, fxy in enumerate(f[x]):\n            f[y][x] = fxy + 1\n    return max(map(max, f))", "target_Lan": "python###maximumLength.py", "target_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(maximumLength([1, 2, 3, 4, 5], 7))\n    print(maximumLength([2, 4, 6, 8, 10], 2))\n    print(maximumLength([1, 3, 5, 7, 9], 10))\n    print(maximumLength([10, 20, 30, 40, 50], 10))\n    print(maximumLength([1, 1, 1, 1, 1], 1))"}, {"source_Lan": "cpp###triangleType.cpp", "source_code": "    string triangleType(vector<int> &nums) {\n        sort(nums.begin(), nums.end());\n        int x = nums[0], y = nums[1], z = nums[2];\n        if (x + y <= z) { \n            return \"none\";\n        }\n        if (x == z) { \n            return \"equilateral\";\n        }\n        if (x == y || y == z) {\n            return \"isosceles\";\n        }\n        return \"scalene\";\n    }", "trans_code": "def triangleType ( nums ) :\n    nums = sorted ( nums )\n    x , y , z = nums\n    if x + y <= z :\n        return \"none\"\n    if x == z :\n        return \"equilateral\"\n    if x == y or y == z :\n        return \"isosceles\"\n    return \"scalene\"\n", "reference_code": "def triangleType( nums: List[int]) -> str:\n    nums.sort()\n    x, y, z = nums\n    if x + y <= z:  # \u6392\u5e8f\u540e\uff0c\u53ea\u9700\u6bd4\u8f83 x+y \u548c z\n        return \"none\"\n    if x == z:  # \u6392\u5e8f\u4e86\uff0c\u8bf4\u660e y \u4e5f\u548c x z \u76f8\u7b49\n        return \"equilateral\"\n    if x == y or y == z:\n        return \"isosceles\"\n    return \"scalene\"", "target_Lan": "python###triangleType.py", "target_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(triangleType([1,1,1]))\n    print(triangleType([2,2,3]))\n    print(triangleType([3,4,5]))\n    print(triangleType([2,2,1]))\n    print(triangleType([3,4,3]))"}, {"source_Lan": "cpp###satisfiesConditions.cpp", "source_code": "    bool satisfiesConditions(vector<vector<int>>& grid) {\n        for (int i = 0; i < grid.size(); i++) {\n            for (int j = 0; j < grid[i].size(); j++) {\n                if (j && grid[i][j] == grid[i][j - 1] || i && grid[i][j] != grid[i - 1][j]) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }", "trans_code": "def satisfies_conditions ( grid ) :\n    for i in range ( len ( grid ) ) :\n        for j in range ( len ( grid [ i ] ) ) :\n            if j and grid [ i ] [ j ] == grid [ i ] [ j - 1 ] or i and grid [ i ] [ j ] != grid [ i - 1 ] [ j ] :\n                return False\n    return True\n", "reference_code": "def satisfiesConditions( grid: List[List[int]]) -> bool:\n    for i, row in enumerate(grid):\n        for j, x in enumerate(row):\n            if j and x == row[j - 1] or i and x != grid[i - 1][j]:\n                return False\n    return True", "target_Lan": "python###satisfiesConditions.py", "target_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(satisfiesConditions([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]]))\n    print(satisfiesConditions([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]))\n    print(satisfiesConditions([[1, 1, 1, 2], [1, 1, 1, 2], [1, 1, 1, 2]]))\n    print(satisfiesConditions([[1, 1, 1, 1], [2, 2, 2, 2], [3, 3, 3, 3]]))\n    print(satisfiesConditions([[1, 2, 3, 4], [1, 2, 3, 4], [1, 2, 3, 4]]))"}, {"source_Lan": "cpp###minOperations.cpp", "source_code": "    int minOperations(vector<int>& nums) {\n        int n = nums.size();\n        int ans = 0;\n        for (int i = 0; i < n - 2; i++) {\n            if (nums[i] == 0) {\n                nums[i + 1] ^= 1;\n                nums[i + 2] ^= 1;\n                ans++;\n            }\n        }\n        return nums[n - 2] && nums[n - 1] ? ans : -1;\n    }", "trans_code": "def minOperations ( nums ) :\n    n = len ( nums )\n    ans = 0\n    for i in range ( n - 2 ) :\n        if nums [ i ] == 0 :\n            nums [ i + 1 ] ^= 1\n            nums [ i + 2 ] ^= 1\n            ans += 1\n    return nums [ n - 2 ] and nums [ n - 1 ] if ans else -1\n", "reference_code": "def minOperations( nums: List[int]) -> int:\n    ans = 0\n    for i in range(len(nums) - 2):\n        if nums[i] == 0:\n            nums[i + 1] ^= 1\n            nums[i + 2] ^= 1\n            ans += 1\n    return ans if nums[-2] and nums[-1] else -1", "target_Lan": "python###minOperations.py", "target_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(minOperations([0, 0, 0, 0, 0]))  # Output: 2\n    print(minOperations([1, 1, 1, 1, 1]))  # Output: -1\n    print(minOperations([0, 0, 1, 1, 0]))  # Output: 1\n    print(minOperations([1, 0, 1, 0, 1]))  # Output: -1\n    print(minOperations([1, 1, 0, 0, 1]))  # Output: 1"}, {"source_Lan": "cpp###countAlternatingSubarrays.cpp", "source_code": "    long long countAlternatingSubarrays(vector<int>& nums) {\n        long long res = 0, cur = 0;\n        int pre = -1;\n        for (int a : nums) {\n            cur = (pre != a) ? cur + 1 : 1;\n            pre = a;\n            res += cur;\n        }\n        return res;\n    }", "trans_code": "def countAlternatingSubarrays ( nums ) :\n    res , cur = 0 , 0\n    pre = -1\n    for a in nums :\n        cur = ( pre != a ) and cur + 1 or 1\n        pre = a\n        res += cur\n    return res\n", "reference_code": "def countAlternatingSubarrays( nums: List[int]) -> int:\n    res = cur = 0\n    pre = -1\n    for a in nums:\n        if pre != a:\n            cur += 1\n        else:\n            cur = 1\n        pre = a\n        res += cur\n    return res", "target_Lan": "python###countAlternatingSubarrays.py", "target_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(countAlternatingSubarrays([1, 2, 3, 4, 5]))  # output: 5\n    print(countAlternatingSubarrays([5, 4, 3, 2, 1]))  # output: 5\n    print(countAlternatingSubarrays([1, 1, 1, 1, 1]))  # output: 1\n    print(countAlternatingSubarrays([-1, -2, -3, -4, -5]))  # output: 5\n    print(countAlternatingSubarrays([1, 2, 2, 1, 3, 4, 4, 3]))  # output: 8"}, {"source_Lan": "cpp###modifiedMatrix.cpp", "source_code": "    vector<vector<int>> modifiedMatrix(vector<vector<int>>& matrix) {\n        int n = matrix.size();\n        int m = matrix[0].size();\n        for (int j = 0; j < m; j++) {\n            int zd = -1;\n            for (int i = 0; i < n; i++) {\n                zd = max(zd, matrix[i][j]);\n            }\n            for (int i = 0; i < n; i++) {\n                if (matrix[i][j] == -1) {\n                    matrix[i][j] = zd;\n                }\n            }\n        }\n        return matrix;\n    }", "trans_code": "def modified_matrix ( matrix ) :\n    n = len ( matrix )\n    m = len ( matrix [ 0 ] )\n    for j in range ( m ) :\n        zd = -1\n        for i in range ( n ) :\n            zd = max ( zd , matrix [ i ] [ j ] )\n        for i in range ( n ) :\n            if matrix [ i ] [ j ] == -1 :\n                matrix [ i ] [ j ] = zd\n    return matrix\n", "reference_code": "def modifiedMatrix( matrix: List[List[int]]) -> List[List[int]]:\n    n, m = len(matrix), len(matrix[0])\n    for j in range(m):\n        zd = -1\n        for i in range(n):\n            zd = max(zd, matrix[i][j])\n        for i in range(n):\n            if matrix[i][j] == -1:\n                matrix[i][j] = zd\n    return matrix", "target_Lan": "python###modifiedMatrix.py", "target_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    from typing import List\n    print(modifiedMatrix([[-1, 2, 3], [4, 5, -1], [7, -1, 9]]))\n    print(modifiedMatrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]))\n    print(modifiedMatrix([[1, -1, 3], [-1, 5, -1], [7, 8, 9]]))\n    print(modifiedMatrix([[10, 20, 30], [40, -1, 60], [-1, 80, -1]]))\n    print(modifiedMatrix([[1, 1, 1], [1, 1, 1], [1, 1, 1]]))"}, {"source_Lan": "cpp###accountBalanceAfterPurchase.cpp", "source_code": "    int accountBalanceAfterPurchase(int purchaseAmount) {\n        int r = purchaseAmount % 10;\n        if (r < 5) {\n            purchaseAmount -= r;\n        } else {\n            purchaseAmount += 10 - r;\n        }\n        return 100 - purchaseAmount;\n    }", "trans_code": "def accountBalanceAfterPurchase ( purchaseAmount ) :\n    r = purchaseAmount % 10\n    if r < 5 :\n        purchaseAmount -= r\n    else :\n        purchaseAmount += 10 - r\n    return 100 - purchaseAmount\n", "reference_code": "def accountBalanceAfterPurchase( purchaseAmount: int) -> int:\n    r = purchaseAmount % 10\n    purchaseAmount = purchaseAmount - r if r < 5 else purchaseAmount + 10 - r\n    return 100 - purchaseAmount", "target_Lan": "python###accountBalanceAfterPurchase.py", "target_code_shell": "# TOFILL\nif __name__ == \"__main__\":\n    print(accountBalanceAfterPurchase(0))\n    print(accountBalanceAfterPurchase(10))\n    print(accountBalanceAfterPurchase(11))\n    print(accountBalanceAfterPurchase(15))\n    print(accountBalanceAfterPurchase(100))"}, {"source_Lan": "cpp###maxOperations.cpp", "source_code": "    int maxOperations(vector<int>& nums) {\n        int n = nums.size(), t = 0;\n        for (int i = 1; i < n; i += 2) {\n            if (nums[i] + nums[i - 1] != nums[1] + nums[0]) {\n                break;\n            }\n            t++;\n        }\n        return t;\n    }", "trans_code": "def maxOperations ( nums ) :\n    n , t = len ( nums ) , 0\n    for i in range ( 1 , n , 2 ) :\n        if nums [ i ] + nums [ i - 1 ] != nums [ 1 ] + nums [ 0 ] :\n            break\n        t += 1\n    return t\n", "reference_code": "def maxOperations( nums: List[int]) -> int:\n    n, t = len(nums), 0\n    for i in range(1, n, 2):\n        if nums[i] + nums[i - 1] != nums[1] + nums[0]:\n            break\n        t += 1\n    return t", "target_Lan": "python###maxOperations.py", "target_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(maxOperations([1, 2, 3, 4, 5, 6]))\n    print(maxOperations([1, 1, 1, 1, 1, 1]))\n    print(maxOperations([-1, -1, 2, 2, 3, 3]))\n    print(maxOperations([0, 0, 0, 0, 0, 0]))\n    print(maxOperations([10, 20, 30, 40, 50, 60]))"}, {"source_Lan": "cpp###minimumSteps.cpp", "source_code": "    long long minimumSteps(string s) {\n        long long ans = 0;\n        int sum = 0;\n        for (int i = 0; i < s.size(); i++) {\n            if (s[i] == '1') {\n                sum++;\n            } else {\n                ans += sum;\n            }\n        }\n        return ans;\n    }", "trans_code": "def minimumSteps ( s ) :\n    ans = 0\n    sum = 0\n    for c in s :\n        if c == '1' :\n            sum += 1\n        else :\n            ans += sum\n    return ans\n", "reference_code": "def minimumSteps( s):\n    ans, sum = 0, 0\n    for i in range(len(s)):\n        if s[i] == '1':\n            sum += 1\n        else:\n            ans += sum\n    return ans", "target_Lan": "python###minimumSteps.py", "target_code_shell": "# TOFILL\nif __name__ == \"__main__\":\n    print(minimumSteps(\"0\"))\n    print(minimumSteps(\"11111\"))\n    print(minimumSteps(\"101010101010\"))"}, {"source_Lan": "cpp###findMissingAndRepeatedValues.cpp", "source_code": "    vector<int> findMissingAndRepeatedValues(vector<vector<int>>& grid) {\n        int n = grid.size();\n        vector<int> count(n * n + 1);\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                count[grid[i][j]]++;\n            }\n        }\n        vector<int> res(2);\n        for (int i = 1; i <= n * n; i++) {\n            if (count[i] == 2) {\n                res[0] = i;\n            }\n            if (count[i] == 0) {\n                res[1] = i;\n            }\n        }\n        return res;\n    }", "trans_code": "def findMissingAndRepeatedValues ( grid ) :\n    n = len ( grid )\n    count = [ 0 ] * ( n * n + 1 )\n    for i in range ( n ) :\n        for j in range ( n ) :\n            count [ grid [ i ] [ j ] ] += 1\n    res = [ 0 ] * ( 2 )\n    for i in range ( 1 , n * n ) :\n        if count [ i ] == 2 :\n            res [ 0 ] = i\n        if count [ i ] == 0 :\n            res [ 1 ] = i\n    return res\n", "reference_code": "def findMissingAndRepeatedValues( grid: List[List[int]]) -> List[int]:\n    n = len(grid)\n    count = [0] * (n * n + 1)\n    count[0] = -1\n    for i in range(n):\n        for j in range(n):\n            count[grid[i][j]] += 1\n    return [count.index(2), count.index(0)]", "target_Lan": "python###findMissingAndRepeatedValues.py", "target_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(findMissingAndRepeatedValues([[1, 2, 3], [1, 5, 6], [7, 8, 9]]))\n    print(findMissingAndRepeatedValues([[1, 2, 3], [4, 5, 6], [4, 8, 9]]))\n    print(findMissingAndRepeatedValues([[1, 2, 3], [4, 5, 6], [7, 8, 1]]))"}, {"source_Lan": "cpp###distributeCandies2.cpp", "source_code": "    long long distributeCandies2(int n, int limit) {\n        long long ans = 0;\n        for (int i = 0; i <= min(limit, n); i++) {\n            if (n - i > 2 * limit) {\n                continue;\n            }\n            ans += min(n - i, limit) - max(0, n - i - limit) + 1;\n        }\n        return ans;\n    }", "trans_code": "def distributeCandies2 ( n , limit ) :\n    ans = 0\n    for i in range ( 0 , min ( limit , n ) ) :\n        if n - i > 2 * limit :\n            continue\n        ans += min ( n - i , limit ) - max ( 0 , n - i - limit ) + 1\n    return ans\n", "reference_code": "def distributeCandies2( n: int, limit: int) -> int:\n    ans = 0\n    for i in range(min(limit, n) + 1):\n        if n - i > 2 * limit:\n            continue\n        ans += min(n - i, limit) - max(0, n - i - limit) + 1\n    return ans", "target_Lan": "python###distributeCandies2.py", "target_code_shell": "# TOFILL\nif __name__ == \"__main__\":\n    print(distributeCandies2(0, 0))\n    print(distributeCandies2(1, 1))\n    print(distributeCandies2(2, 2))\n    print(distributeCandies2(3, 3))\n    print(distributeCandies2(10, 5))"}, {"source_Lan": "cpp###distributeCandies.cpp", "source_code": "    int distributeCandies(int n, int limit) {\n        int ans = 0;\n        for (int i = 0; i <= limit; i++) {\n            for (int j = 0; j <= limit; j++) {\n                if (i + j > n) {\n                    break;\n                }\n                if (n - i - j <= limit) {\n                    ans++;\n                }\n            }\n        }\n        return ans;\n    }", "trans_code": "def distributeCandies ( n , limit ) :\n    ans = 0\n    for i in range ( 0 , limit ) :\n        for j in range ( 0 , limit ) :\n            if i + j > n :\n                break\n            if n - i - j <= limit :\n                ans += 1\n    return ans\n", "reference_code": "def distributeCandies( n: int, limit: int) -> int:\n    ans = 0\n    for i in range(limit + 1):\n        for j in range(limit + 1):\n            if i + j > n:\n                break\n            if n - i - j <= limit:\n                ans += 1\n    return ans", "target_Lan": "python###distributeCandies.py", "target_code_shell": "# TOFILL\nif __name__ == \"__main__\":\n    print(distributeCandies(10, 5))\n    print(distributeCandies(20, 10))\n    print(distributeCandies(100, 50))\n    print(distributeCandies(1, 1))\n    print(distributeCandies(0, 0))"}, {"source_Lan": "cpp###theMaximumAchievableX.cpp", "source_code": "    int theMaximumAchievableX(int num, int t) {\n        return num + 2 * t;\n    }", "trans_code": "def theMaximumAchievableX ( num , t ) :\n    return num + 2 * t\n", "reference_code": "def theMaximumAchievableX( num: int, t: int) -> int:\n    return num + 2 * t", "target_Lan": "python###theMaximumAchievableX.py", "target_code_shell": "# TOFILL\nif __name__ == \"__main__\":\n    print(theMaximumAchievableX(0, 0))\n    print(theMaximumAchievableX(100, 20))\n    print(theMaximumAchievableX(-10, 30))\n    print(theMaximumAchievableX(50, -10))\n    print(theMaximumAchievableX(-100, -20))"}, {"source_Lan": "cpp###garbageCollection.cpp", "source_code": "    int garbageCollection(vector<string>& garbage, vector<int>& travel) {\n        unordered_map<char, int> distance;\n        int res = 0, cur_dis = 0;\n        for (int i = 0; i < garbage.size(); i++) {\n            res += garbage[i].size();\n            if (i > 0) {\n                cur_dis += travel[i - 1];\n            }\n            for (auto c : garbage[i]) {\n                distance[c] = cur_dis;\n            }\n        }\n        for (auto &[k, v] : distance) {\n            res += v;\n        }\n        return res;\n    }", "trans_code": "def garbageCollection ( garbage , travel ) :\n    distance = { }\n    res , cur_dis = 0 , 0\n    for i in range ( len ( garbage ) ) :\n        res += len ( garbage [ i ] )\n        if i > 0 : cur_dis += travel [ i - 1 ]\n        for c in garbage [ i ] :\n            distance [ c ] = cur_dis\n    for [ k , v ] in distance.items ( ) :\n        res += v\n    return res\n", "reference_code": "def garbageCollection( garbage: List[str], travel: List[int]) -> int:\n    distance = {}\n    res = 0\n    cur_dis = 0\n    for i in range(len(garbage)):\n        res += len(garbage[i])\n        if i > 0:\n            cur_dis += travel[i - 1]\n        for c in garbage[i]:\n            distance[c] = cur_dis\n    return res + sum(distance.values())", "target_Lan": "python###garbageCollection.py", "target_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(garbageCollection([\"MMMMMMMMMM\", \"PGG\", \"GP\"], [5, 10]))\n    print(garbageCollection([\"GGGG\", \"PPPPPP\", \"GGGG\", \"PPPPPP\"], [1, 1, 1]))\n    print(garbageCollection([\"MMM\", \"PG\", \"GP\", \"MMM\"], [3, 10, 2]))\n    print(garbageCollection([\"G\", \"P\", \"GP\", \"GG\"], [1, 2, 3]))"}, {"source_Lan": "cpp###numberOfEmployeesWhoMetTarget.cpp", "source_code": "    int numberOfEmployeesWhoMetTarget(vector<int>& hours, int target) {\n        int ans = 0;\n        for (int i = 0; i < hours.size(); i++) {\n            if (hours[i] >= target) {\n                ans++;\n            }\n        }\n        return ans;\n    }", "trans_code": "def numberOfEmployeesWhoMetTarget ( hours , target ) :\n    ans = 0\n    for hour in hours :\n        if hour >= target :\n            ans += 1\n    return ans\n", "reference_code": "def numberOfEmployeesWhoMetTarget( hours, target):\n    ans = 0\n    for i in range(0, len(hours)):\n        if hours[i] >= target:\n            ans += 1\n    return ans", "target_Lan": "python###numberOfEmployeesWhoMetTarget.py", "target_code_shell": "# TOFILL\nif __name__ == \"__main__\":\n    print(numberOfEmployeesWhoMetTarget([0, 20, 40, 60, 80, 100], 40))\n    print(numberOfEmployeesWhoMetTarget([10, 10, 10, 10, 10, 10], 10))\n    print(numberOfEmployeesWhoMetTarget([50, 50, 50, 50, 50, 50], 0))\n    print(numberOfEmployeesWhoMetTarget([100, 90, 80, 70, 60, 50], 100))\n    print(numberOfEmployeesWhoMetTarget([10, 20, 30, 40, 50, 60], 70))"}, {"source_Lan": "cpp###countTestedDevices.cpp", "source_code": "    int countTestedDevices(vector<int>& batteryPercentages) {\n        int n = batteryPercentages.size();\n        int need = 0;\n        for (int i = 0; i < n; i++) {\n            if (batteryPercentages[i] > 0) {\n                need++;\n                for (int j = i + 1; j < n; j++) {\n                    batteryPercentages[j] = max(batteryPercentages[j] - 1, 0);\n                }\n            }\n        }\n        return need;\n    }", "trans_code": "def countTestedDevices ( batteryPercentages ) :\n    n = len ( batteryPercentages )\n    need = 0\n    for i in range ( n ) :\n        if batteryPercentages [ i ] > 0 :\n            need += 1\n            for j in range ( i + 1 , n ) :\n                batteryPercentages [ j ] = max ( batteryPercentages [ j ] - 1 , 0 )\n    return need\n", "reference_code": "def countTestedDevices( batteryPercentages: List[int]) -> int:\n    n = len(batteryPercentages)\n    need = 0\n    for i in range(n):\n        if batteryPercentages[i] > 0:\n            need += 1\n            for j in range(i + 1, n):\n                batteryPercentages[j] = max(batteryPercentages[j] - 1, 0)\n    return need", "target_Lan": "python###countTestedDevices.py", "target_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(countTestedDevices([100, 100, 100, 100, 100]))  # Output: 5\n    print(countTestedDevices([0, 0, 0, 0, 0]))  # Output: 0\n    print(countTestedDevices([100, 50, 25, 10, 0]))  # Output: 4\n    print(countTestedDevices([100, 100, 0, 100, 100]))  # Output: 3\n    print(countTestedDevices([100, 50, 50, 50, 100]))  # Output: 4"}, {"source_Lan": "cpp###maximumBinaryString.cpp", "source_code": "    string maximumBinaryString(string binary) {\n        int n = binary.size();\n        int j = 0;\n        for (int i = 0; i < n; i++) {\n            if (binary[i] == '0') {\n                while (j <= i || (j < n && binary[j] == '1')) {\n                    j++;\n                }\n                if (j < n) {\n                    binary[j] = '1';\n                    binary[i] = '1';\n                    binary[i + 1] = '0';\n                }\n            }\n        }\n        return binary;\n    }", "trans_code": "def maximumBinaryString ( binary ) :\n    n = len ( binary )\n    j = 0\n    for i in range ( n ) :\n        if binary [ i ] == '0' :\n            while j <= i or ( j < n and binary [ j ] == '1' ) :\n                j += 1\n            if j < n :\n                binary [ j ] = '1'\n                binary [ i ] = '1'\n                binary [ i + 1 ] = '0'\n    return binary\n", "reference_code": "def maximumBinaryString( binary: str) -> str:\n    n = len(binary)\n    s = list(binary)\n    j = 0\n    for i in range(n):\n        if s[i] == '0':\n            while j <= i or (j < n and s[j] == '1'):\n                j += 1\n            if j < n:\n                s[j] = '1'\n                s[i] = '1'\n                s[i + 1] = '0'\n    return ''.join(s)", "target_Lan": "python###maximumBinaryString.py", "target_code_shell": "# TOFILL\nif __name__ == \"__main__\":\n    print(maximumBinaryString(\"000000\"))\n    print(maximumBinaryString(\"111111\"))\n    print(maximumBinaryString(\"001000\"))\n    print(maximumBinaryString(\"110110\"))\n    print(maximumBinaryString(\"010101\"))"}, {"source_Lan": "cpp###minOperations2.cpp", "source_code": "    int minOperations2(vector<int>& nums) {\n        int n = nums.size();\n        unordered_set<int> cnt(nums.begin(), nums.end());\n        vector<int> sortedUniqueNums(cnt.begin(), cnt.end());\n        sort(sortedUniqueNums.begin(), sortedUniqueNums.end());\n        int res = n, j = 0;\n        for (int i = 0; i < sortedUniqueNums.size(); i++) {\n            int right = sortedUniqueNums[i] + n - 1;\n            while (j < sortedUniqueNums.size() && sortedUniqueNums[j] <= right) {\n                res = min(res, n - (j - i + 1));\n                j++;\n            }\n        }            \n        return res;\n    }", "trans_code": "def min_operations2 ( nums ) :\n    n = len ( nums )\n    cnt = set ( nums )\n    sorted_unique_nums = sorted ( cnt )\n    res , j = n , 0\n    for i in range ( len ( sorted_unique_nums ) ) :\n        right = sorted_unique_nums [ i ] + n - 1\n        while j < len ( sorted_unique_nums ) and sorted_unique_nums [ j ] <= right :\n            res = min ( res , n - ( j - i + 1 ) )\n            j += 1\n    return res\n", "reference_code": "def minOperations2( nums: List[int]) -> int:\n    n = len(nums)\n    sortedUniqueNums = sorted((set(nums)))\n    res = n\n    j = 0\n    for i, left in enumerate(sortedUniqueNums):\n        right = left + n - 1\n        while j < len(sortedUniqueNums) and sortedUniqueNums[j] <= right:\n            res = min(res, n - (j - i + 1))\n            j += 1\n    return res", "target_Lan": "python###minOperations2.py", "target_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(minOperations2([1, 2, 3, 4, 5]))\n    print(minOperations2([1, 1, 1, 1, 1]))\n    print(minOperations2([5, 5, 5, 5, 5]))\n    print(minOperations2([1, 3, 5, 7, 9]))\n    print(minOperations2([-1, -2, -3, -4, -5]))"}, {"source_Lan": "cpp###findChampion.cpp", "source_code": "    int findChampion(int n, vector<vector<int>>& edges) {\n        vector<int> degree(n);\n        for (auto e : edges) {\n            degree[e[1]]++;\n        }\n        int champion = -1;\n        for (int i = 0; i < n; i++) {\n            if (degree[i] == 0) {\n                if (champion == -1) {\n                    champion = i;\n                } else {\n                    return -1;\n                }\n            }\n        }\n        return champion;\n    }", "trans_code": "def findChampion ( n , edges ) :\n    degree = [ 0 ] * n\n    for e in edges :\n        degree [ e [ 1 ] ] += 1\n    champion = -1\n    for i in range ( n ) :\n        if degree [ i ] == 0 :\n            if champion == -1 :\n                champion = i\n            else :\n                return -1\n    return champion\n", "reference_code": "def findChampion( n: int, edges: List[List[int]]) -> int:\n    degree = [0] * n\n    for x, y in edges:\n        degree[y] += 1\n    champion = -1\n    for i, d in enumerate(degree):\n        if d == 0:\n            if champion == -1:\n                champion = i\n            else:\n                return -1\n    return champion", "target_Lan": "python###findChampion.py", "target_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(findChampion(4, [[0, 1], [0, 2], [1, 3], [2, 3]]))\n    print(findChampion(4, [[0, 1], [0, 2], [1, 2], [1, 3]]))\n    print(findChampion(5, [[0, 1], [0, 2], [1, 3], [2, 3], [3, 4]]))\n    print(findChampion(5, [[0, 1], [0, 2], [1, 2], [1, 3], [2, 4]]))\n    print(findChampion(3, [[0, 1], [1, 2], [2, 0]]))"}, {"source_Lan": "cpp###findKOr.cpp", "source_code": "    int findKOr(vector<int>& nums, int k) {\n        int ans = 0;\n        for (int i = 0; i < 31; ++i) {\n            int cnt = 0;\n            for (int num: nums) {\n                if ((num >> i) & 1) {\n                    ++cnt;\n                }\n            }\n            if (cnt >= k) {\n                ans |= 1 << i;\n            }\n        }\n        return ans;\n    }", "trans_code": "def findKOr ( nums , k ) :\n    ans = 0\n    for i in range ( 31 ) :\n        cnt = 0\n        for num in nums :\n            if ( num >> i ) & 1 :\n                cnt += 1\n        if cnt >= k :\n            ans |= 1 << i\n    return ans\n", "reference_code": "def findKOr( nums: List[int], k: int) -> int:\n    ans = 0\n    for i in range(31):\n        cnt = sum(1 for num in nums if ((num >> i) & 1) > 0)\n        if cnt >= k:\n            ans |= 1 << i\n    return ans", "target_Lan": "python###findKOr.py", "target_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(findKOr([2,3,4,5], 3))\n    print(findKOr([6,7,8,9], 2))\n    print(findKOr([10,11,12,13], 1))\n    print(findKOr([14,15,16,17], 4))\n    print(findKOr([18,19,20,21], 5))"}, {"source_Lan": "cpp###minIncrements.cpp", "source_code": "    int minIncrements(int n, vector<int>& cost) {\n        int ans = 0;\n        for (int i = n - 2; i > 0; i -= 2) {\n            ans += abs(cost[i] - cost[i + 1]);\n            \n            cost[i / 2] += max(cost[i], cost[i + 1]);\n        }\n        return ans;\n    }", "trans_code": "def minIncrements ( n , cost ) :\n    ans = 0\n    for i in range ( n - 2 , 0 , - 2 ) :\n        ans += abs ( cost [ i ] - cost [ i + 1 ] )\n        cost [ i / 2 ] += max ( cost [ i ] , cost [ i + 1 ] )\n    return ans\n", "reference_code": "def minIncrements( n: int, cost: List[int]) -> int:\n    ans = 0\n    for i in range(n - 2, 0, -2):\n        ans += abs(cost[i] - cost[i + 1])\n        # \u53f6\u8282\u70b9 i \u548c i+1 \u7684\u53cc\u4eb2\u8282\u70b9\u4e0b\u6807\u4e3a i/2\uff08\u6574\u6570\u9664\u6cd5\uff09\n        cost[i // 2] += max(cost[i], cost[i + 1])\n    return ans", "target_Lan": "python###minIncrements.py", "target_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(minIncrements(0, []))\n    print(minIncrements(1, [1]))\n    print(minIncrements(2, [2,1]))\n    print(minIncrements(3, [1,2,1]))\n    print(minIncrements(4, [1,1,2,1]))"}, {"source_Lan": "cpp###maxResult.cpp", "source_code": "    int maxResult(vector<int>& nums, int k) {\n        int n = nums.size();\n        vector<int> dp(n);\n        dp[0] = nums[0];\n        deque<int> queue;\n        queue.push_back(0);\n        for (int i = 1; i < n; i++) {\n            while (!queue.empty() && queue.front() < i - k) {\n                queue.pop_front();\n            }\n            dp[i] = dp[queue.front()] + nums[i];\n            while (!queue.empty() && dp[queue.back()] <= dp[i]) {\n                queue.pop_back();\n            }\n            queue.push_back(i);\n        }\n        return dp[n - 1];\n    }", "trans_code": "def maxResult ( nums , k ) :\n    n = len ( nums )\n    dp = [ 0 ] * n\n    dp [ 0 ] = nums [ 0 ]\n    queue = deque ( [ 0 ] )\n    for i in range ( 1 , n ) :\n        while not queue and queue [ 0 ] < i - k : queue.popleft ( )\n        dp [ i ] = dp [ queue [ 0 ] ] + nums [ i ]\n        while not queue and dp [ queue [ - 1 ] ] <= dp [ i ] : queue.popleft ( )\n        queue.append ( i )\n    return dp [ n - 1 ]\n", "reference_code": "def maxResult( nums: List[int], k: int) -> int:\n    n = len(nums)\n    dp = [0] * n\n    dp[0] = nums[0]\n    queue = deque([0])\n    for i in range(1, n):\n        while queue and queue[0] < i - k:\n            queue.popleft()\n        dp[i] = dp[queue[0]] + nums[i]\n        while queue and dp[queue[-1]] <= dp[i]:\n            queue.pop()\n        queue.append(i)\n    return dp[n - 1]", "target_Lan": "python###maxResult.py", "target_code_shell": "from typing import List\nfrom collections import deque\n# TOFILL\nif __name__ == \"__main__\":\n    print(maxResult([10, -20, -5], 1))\n    print(maxResult([100, 200, 300, 400, 500], 2))\n    print(maxResult([-10, -20, -30, -40, -50], 3))\n    print(maxResult([1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 10))\n    print(maxResult([1000, 2000, 3000, 4000, 5000, 6000, 7000, 8000, 9000, 10000], 5))"}, {"source_Lan": "cpp###maximumSumOfHeights.cpp", "source_code": "    long long maximumSumOfHeights(vector<int>& maxHeights) {\n        int n = maxHeights.size();\n        long long res = 0;\n        for (int i = 0; i < n; i++) {\n            int pre = maxHeights[i];\n            long long sum = pre;\n            for (int j = i - 1; j >= 0; j--) {\n                pre = min(pre, maxHeights[j]);\n                sum += pre;\n            }\n            int suf = maxHeights[i];\n            for (int j = i + 1; j < n; j++) {\n                suf = min(suf, maxHeights[j]);\n                sum += suf;\n            }\n            res = max(res, sum);\n        }\n        return res;\n    }", "trans_code": "def maximumSumOfHeights ( maxHeights ) :\n    n = len ( maxHeights )\n    res = 0\n    for i in range ( n ) :\n        pre = maxHeights [ i ]\n        sum = pre\n        for j in range ( i - 1 , - 1 , - 1 ) :\n            pre = min ( pre , maxHeights [ j ] )\n            sum += pre\n        suf = maxHeights [ i ]\n        for j in range ( i + 1 , n ) :\n            suf = min ( suf , maxHeights [ j ] )\n            sum += suf\n        res = max ( res , sum )\n    return res\n", "reference_code": "def maximumSumOfHeights( maxHeights: List[int]) -> int:\n    n = len(maxHeights)\n    res = 0\n    for i in range(n):\n        pre, psum = maxHeights[i], maxHeights[i]\n        for j in range(i - 1, -1, -1):\n            pre = min(pre, maxHeights[j])\n            psum += pre\n        suf = maxHeights[i]\n        for j in range(i + 1, n):\n            suf = min(suf, maxHeights[j])\n            psum += suf\n        res = max(res, psum)\n    return res", "target_Lan": "python###maximumSumOfHeights.py", "target_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(maximumSumOfHeights([1, 2, 3, 4, 5]))\n    print(maximumSumOfHeights([5, 4, 3, 2, 1]))\n    print(maximumSumOfHeights([1, 1, 1, 1, 1]))\n    print(maximumSumOfHeights([1000000000, 1000000000, 1000000000, 1000000000, 1000000000]))\n    print(maximumSumOfHeights([1, 10, 20, 30, 40]))"}, {"source_Lan": "cpp###alternatingSubarray.cpp", "source_code": "    int alternatingSubarray(vector<int>& nums) {\n        int res = -1;\n        int n = nums.size();\n        for (int firstIndex = 0; firstIndex < n; firstIndex++) {\n            for (int i = firstIndex + 1; i < n; i++) {\n                int length = i - firstIndex + 1;\n                if (nums[i] - nums[firstIndex] == (length - 1) % 2) {\n                    res = max(res, length);\n                } else {\n                    break;\n                }\n            }\n        }\n        return res;\n    }", "trans_code": "def alternating_subarray ( nums ) :\n    res = -1\n    n = len ( nums )\n    for first_index in range ( n ) :\n        for i in range ( first_index + 1 , n ) :\n            length = i - first_index + 1\n            if nums [ i ] - nums [ first_index ] == ( length - 1 ) % 2 :\n                res = max ( res , length )\n            else :\n                break\n    return res\n", "reference_code": "def alternatingSubarray( nums: List[int]) -> int:\n    res = -1\n    n = len(nums)\n    for firstIndex in range(n):\n        for i in range(firstIndex + 1, n):\n            length = i - firstIndex + 1\n            if nums[i] - nums[firstIndex] == (length - 1) % 2:\n                res = max(res, length)\n            else:\n                break\n    return res", "target_Lan": "python###alternatingSubarray.py", "target_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(alternatingSubarray([1,2,3,4,5]))\n    print(alternatingSubarray([1,1,1,1,1]))\n    print(alternatingSubarray([-1,-2,-3,-4,-5]))\n    print(alternatingSubarray([5,4,3,2,1]))\n    print(alternatingSubarray([1,2,3,4,5,6,7,8,9,10]))"}, {"source_Lan": "cpp###ANDequalOR.cpp", "source_code": "    long long ANDequalOR(int n, vector<int> arr) {\n        long long ans = 0;\n        for (int i = 0; i < n; i++) {\n            int pt = i;\n            long long ct = 0;\n            while (pt < n) {\n                if (arr[pt] == arr[i]) {\n                    pt++;\n                    ct++;\n                } else\n                    break;\n            }\n            ct *= (ct + 1);\n            ct /= 2;\n            ans += ct;\n            i = pt - 1;\n        }\n        return ans;\n    }", "trans_code": "def ANDequalOR ( n , arr ) :\n    ans = 0\n    for i in range ( n ) :\n        pt = i\n        ct = 0\n        while pt < n :\n            if arr [ pt ] == arr [ i ] :\n                pt += 1\n                ct += 1\n            else :\n                break\n        ct *= ( ct + 1 )\n        ct /= 2\n        ans += ct\n        i = pt - 1\n    return ans\n", "reference_code": "def ANDequalOR( n: int, arr: List[int]) -> int:\n    ans = 0\n    pre = 0\n    count = 0\n    for i in range(n):\n        if arr[i] == arr[pre]:\n            count += 1\n        else:\n            ans += (count * (count + 1)) // 2\n            pre = i\n            count = 1\n    ans += (count * (count + 1)) // 2\n    return ans", "target_Lan": "python###ANDequalOR.py", "target_code_shell": "from typing import List\nfrom typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(ANDequalOR(0, []))\n    print(ANDequalOR(1, [1]))\n    print(ANDequalOR(2, [1, 1]))\n    print(ANDequalOR(3, [1, 2, 1]))\n    print(ANDequalOR(5, [1, 1, 2, 2, 1]))"}, {"source_Lan": "cpp###equality.cpp", "source_code": "    int equality(int A, int B) {\n        if (B<A) return 0;\n        if (A==B) return 1;\n        if (B%2==0) return 1;\n        return 0;\n    }", "trans_code": "def equality ( A , B ) :\n    if B < A :\n        return 0\n    if A == B :\n        return 1\n    if B % 2 == 0 :\n        return 1\n    return 0\n", "reference_code": "def equality( A, B):\n    if A > B:\n        return 0\n    if A == B:\n        return 1\n    if B % 2 == 0:\n        return 1\n    return 0", "target_Lan": "python###equality.py", "target_code_shell": "# TOFILL\nif __name__ == \"__main__\":\n    print(equality(0,0))\n    print(equality(1,1))\n    print(equality(-1,-1))\n    print(equality(10,10))\n    print(equality(5,5))"}, {"source_Lan": "cpp###AreEqual.cpp", "source_code": "    bool AreEqual(string a, string b) {\n        int n = a.length();\n        bool flag = false;\n        for (int i = 0; i < n - 1; i++) {\n            if (a[i] == '0' && b[i + 1] == '1') {\n                if (a[i] == b[i] && a[i + 1] == b[i + 1]) {\n                    flag = true;\n                }\n            }\n        }\n        return flag;\n    }", "trans_code": "def are_equal ( a , b ) :\n    n = len ( a )\n    flag = False\n    for i in range ( n - 1 ) :\n        if a [ i ] == '0' and b [ i + 1 ] == '1' :\n            if a [ i ] == b [ i ] and a [ i + 1 ] == b [ i + 1 ] :\n                flag = True\n    return flag\n", "reference_code": "def AreEqual( a: str, b: str) -> bool:\n    for i in range(len(a) - 1):\n        if (a[i] == b[i] and a[i] == '0' and a[i + 1] == b[i + 1]\n                and a[i + 1] == '1'):\n            return True\n    return False", "target_Lan": "python###AreEqual.py", "target_code_shell": "# TOFILL\nif __name__ == \"__main__\":\n    print(AreEqual(\"01\", \"10\"))\n    print(AreEqual(\"101\", \"010\"))\n    print(AreEqual(\"000\", \"111\"))\n    print(AreEqual(\"111\", \"000\"))\n    print(AreEqual(\"010\", \"101\"))"}, {"source_Lan": "cpp###maxPoints.cpp", "source_code": "    long long maxPoints(int n, vector<vector<int>> &arr) {\n        long long dp[200001] = {};\n        for (int i = n - 1; i >= 0; --i)\n            dp[i] = max(arr[i][0] + dp[arr[i][1] + i + 1], dp[i + 1]);\n        return dp[0];\n    }", "trans_code": "def maxPoints ( n , arr ) :\n    dp = [ ]\n    for i in range ( n - 1 , - 1 , - 1 ) :\n        dp.append ( max ( arr [ i ] [ 0 ] + dp [ arr [ i ] [ 1 ] + i + 1 ] , dp [ i + 1 ] ) )\n    return dp [ 0 ]\n", "reference_code": "def maxPoints( n: int, arr: List[List[int]]) -> int:\n    dp = [0] * (200000)\n    for i in range(n - 1, -1, -1):\n        dp[i] = max(arr[i][0] + dp[arr[i][1] + i + 1], dp[i + 1])\n    return dp[0]", "target_Lan": "python###maxPoints.py", "target_code_shell": "from typing import List\nfrom typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(maxPoints(3, [[1,2],[2,3],[3,4]]))\n    print(maxPoints(2, [[1,1],[2,2]]))\n    print(maxPoints(1, [[1,0]]))\n    print(maxPoints(4, [[1,1],[2,2],[3,3],[4,4]]))\n    print(maxPoints(5, [[1,2],[2,3],[3,4],[4,5],[5,6]]))"}, {"source_Lan": "cpp###countOperations.cpp", "source_code": "    int countOperations(string s) {\n        const int mod = 1000000007;\n        int ans = 0;\n        int count_b = 0;\n        for (int i = s.length() - 1; i >= 0; --i) {\n            if (s[i] == 'b')\n                count_b = (count_b + 1) % mod;\n            else {\n                ans = (ans + count_b) % mod;\n                count_b = (count_b + count_b) % mod;\n            }\n        }\n        return ans;\n    }", "trans_code": "def countOperations ( s ) :\n    mod = 1000000007\n    ans = 0\n    count_b = 0\n    for i in range ( len ( s ) - 1 , - 1 , - 1 ) :\n        if s [ i ] == 'b' :\n            count_b = ( count_b + 1 ) % mod\n        else :\n            ans = ( ans + count_b ) % mod\n            count_b = ( count_b + count_b ) % mod\n    return ans\n", "reference_code": "def countOperations( s: str) -> int:\n    mod = 10**9 + 7\n    ans = 0\n    count_b = 0\n    for i in range(len(s) - 1, -1, -1):\n        if s[i] == 'b':\n            count_b = (count_b + 1) % mod\n        else:\n            ans = (ans + count_b) % mod\n            count_b = (count_b + count_b) % mod\n    return ans", "target_Lan": "python###countOperations.py", "target_code_shell": "# TOFILL\nif __name__ == \"__main__\":\n    print(countOperations(\"ab\"))\n    print(countOperations(\"bbbb\"))\n    print(countOperations(\"baab\"))\n    print(countOperations(\"babb\"))\n    print(countOperations(\"aaabbb\"))"}, {"source_Lan": "cpp###isFriend.cpp", "source_code": "    string isFriend(int n, int x, int y, vector<int> &arr) {\n        for (auto j:arr){\n            if (x+j==y) return \"yes\";\n        }\n        return \"no\";\n    }", "trans_code": "def isFriend ( n , x , y , arr ) :\n    for j in arr :\n        if x + j == y :\n            return \"yes\"\n    return \"no\"\n", "reference_code": "def isFriend( n : int, x : int, y : int, arr : List[int]) -> str:\n    if y-x in arr:\n        return \"yes\"\n    else:\n        return \"no\"", "target_Lan": "python###isFriend.py", "target_code_shell": "from typing import List\nfrom typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(isFriend(0, 0, 0, []))\n    print(isFriend(1, 1, 2, [1]))\n    print(isFriend(2, 2, 4, [1, 2]))\n    print(isFriend(3, 3, 6, [1, 2, 3]))\n    print(isFriend(4, 4, 8, [1, 2, 3, 4]))"}, {"source_Lan": "cpp###minimumPushes.cpp", "source_code": "    int minimumPushes(string &word) {\n        int n = word.length();\n        int k = n / 8;\n        return (k * 4 + n % 8) * (k + 1);\n    }", "trans_code": "def minimumPushes ( word ) :\n    n = len ( word )\n    k = n / 8\n    return ( k * 4 + n % 8 ) * ( k + 1 )\n", "reference_code": "def minimumPushes( word: str) -> int:\n    k, rem = divmod(len(word), 8)\n    return (k * 4 + rem) * (k + 1)", "target_Lan": "python###minimumPushes.py", "target_code_shell": "# TOFILL\nif __name__ == \"__main__\":\n    print(minimumPushes(\"a\"))\n    print(minimumPushes(\"abcdefgh\"))\n    print(minimumPushes(\"abcdefghijklmnop\"))\n    print(minimumPushes(\"abcdefghijklmnopqrstuvwxyz\"))\n    print(minimumPushes(\"abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz\"))"}, {"source_Lan": "cpp###minOrAfterOperations.cpp", "source_code": "    int minOrAfterOperations(vector<int> &nums, int k) {\n        int ans = 0, mask = 0;\n        for (int b = 29; b >= 0; b--) {\n            mask |= 1 << b;\n            int cnt = 0, and_res = -1; \n            for (int x : nums) {\n                and_res &= x & mask;\n                if (and_res) {\n                    cnt++; \n                } else {\n                    and_res = -1; \n                }\n            }\n            if (cnt > k) {\n                ans |= 1 << b; \n                mask ^= 1 << b; \n            }\n        }\n        return ans;\n    }", "trans_code": "def minOrAfterOperations ( nums , k ) :\n    ans , mask = 0 , 0\n    for b in range ( 29 , - 1 , - 1 ) :\n        mask |= 1 << b\n        cnt , and_res = 0 , -1\n        for x in nums :\n            and_res &= x & mask\n            if and_res : cnt += 1\n            else : and_res = -1\n        if cnt > k :\n            ans |= 1 << b\n            mask ^= 1 << b\n    return ans\n", "reference_code": "def minOrAfterOperations( nums: List[int], k: int) -> int:\n    ans = mask = 0\n    for b in range(max(nums).bit_length() - 1, -1, -1):\n        mask |= 1 << b\n        cnt = 0  # \u64cd\u4f5c\u6b21\u6570\n        and_res = -1  # -1 \u7684\u4e8c\u8fdb\u5236\u5168\u4e3a 1\n        for x in nums:\n            and_res &= x & mask\n            if and_res:\n                cnt += 1  # \u5408\u5e76 x\uff0c\u64cd\u4f5c\u6b21\u6570\u52a0\u4e00\n            else:\n                and_res = -1  # \u51c6\u5907\u5408\u5e76\u4e0b\u4e00\u6bb5\n        if cnt > k:\n            ans |= 1 << b  # \u7b54\u6848\u7684\u8fd9\u4e2a\u6bd4\u7279\u4f4d\u5fc5\u987b\u662f 1\n            mask ^= 1 << b  # \u540e\u9762\u4e0d\u8003\u8651\u8fd9\u4e2a\u6bd4\u7279\u4f4d\n    return ans", "target_Lan": "python###minOrAfterOperations.py", "target_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(minOrAfterOperations([1,2,3,4,5], 2))\n    print(minOrAfterOperations([10,20,30,40,50], 3))\n    print(minOrAfterOperations([100,200,300,400,500], 4))\n    print(minOrAfterOperations([1000,2000,3000,4000,5000], 5))\n    print(minOrAfterOperations([10000,20000,30000,40000,50000], 6))"}, {"source_Lan": "cpp###resultArray.cpp", "source_code": "    vector<int> resultArray(vector<int> &nums) {\n        vector<int> a{nums[0]}, b{nums[1]};\n        for (int i = 2; i < nums.size(); i++) {\n            (a.back() > b.back() ? a : b).push_back(nums[i]);\n        }\n        a.insert(a.end(), b.begin(), b.end());\n        return a;\n    }", "trans_code": "def resultArray ( nums ) :\n    a , b = [ nums [ 0 ] ] , [ nums [ 1 ] ]\n    for i in range ( 2 , len ( nums ) ) :\n        ( a [ - 1 ] , b [ - 1 ] ) = ( a [ - 1 ] , b [ - 1 ] )\n    a.extend ( b )\n    return a\n", "reference_code": "def resultArray( nums: List[int]) -> List[int]:\n    a = nums[:1]\n    b = nums[1:2]\n    for x in nums[2:]:\n        if a[-1] > b[-1]:\n            a.append(x)\n        else:\n            b.append(x)\n    return a + b", "target_Lan": "python###resultArray.py", "target_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(resultArray([1, 2, 3, 4, 5]))\n    print(resultArray([5, 4, 3, 2, 1]))\n    print(resultArray([1, 1, 1, 1, 1]))\n    print(resultArray([1, 2, 1, 2, 1]))\n    print(resultArray([10, 20, 30, 40, 50]))"}, {"source_Lan": "cpp###maximumLengthSubstring.cpp", "source_code": "    int maximumLengthSubstring(string s) {\n        int ans = 0, left = 0, cnt[26]{};\n        for (int i = 0; i < s.length(); i++) {\n            int b = s[i] - 'a';\n            cnt[b]++;\n            while (cnt[b] > 2) {\n                cnt[s[left++] - 'a']--;\n            }\n            ans = max(ans, i - left + 1);\n        }\n        return ans;\n    }", "trans_code": "def maximumLengthSubstring ( s ) :\n    ans , left , cnt = 0 , 0 , { }\n    for i in range ( len ( s ) ) :\n        b = s [ i ] - 'a'\n        cnt [ b ] += 1\n        while cnt [ b ] > 2 : cnt [ s [ left ++ ] - 'a' ] -= 1\n        ans = max ( ans , i - left + 1 )\n    return ans\n", "reference_code": "def maximumLengthSubstring( s: str) -> int:\n    ans = left = 0\n    cnt = Counter()\n    for i, c in enumerate(s):\n        cnt[c] += 1\n        while cnt[c] > 2:\n            cnt[s[left]] -= 1\n            left += 1\n        ans = max(ans, i - left + 1)\n    return ans", "target_Lan": "python###maximumLengthSubstring.py", "target_code_shell": "from collections import Counter\n# TOFILL\nif __name__ == \"__main__\":\n    print(maximumLengthSubstring(\"abcabcbb\"))\n    print(maximumLengthSubstring(\"bbbbb\"))\n    print(maximumLengthSubstring(\"pwwkew\"))\n    print(maximumLengthSubstring(\"abcdefghijklmnopqrstuvwxyz\"))\n    print(maximumLengthSubstring(\"aabbccdd\"))"}, {"source_Lan": "cpp###compressedString.cpp", "source_code": "    string compressedString(string word) {\n        string t;\n        int i0 = -1;\n        for (int i = 0; i < word.length(); i++) {\n            char c = word[i];\n            if (i + 1 == word.length() || c != word[i + 1]) {\n                int k = i - i0;\n                for (int j = 0; j < k / 9; j++) {\n                    t += '9';\n                    t += c;\n                }\n                if (k % 9) {\n                    t += '0' + (k % 9);\n                    t += c;\n                }\n                i0 = i;\n            }\n        }\n        return t;\n    }", "trans_code": "def compressedString ( word ) :\n    t = ''\n    i0 = -1\n    for c in word :\n        if i + 1 == len ( word ) or c != word [ i + 1 ] :\n            k = i - i0\n            for j in range ( k / 9 ) :\n                t += '9'\n                t += c\n            if k % 9 :\n                t += '0' + ( k % 9 )\n                t += c\n            i0 = i\n    return t\n", "reference_code": "def compressedString( word: str) -> str:\n    t = []\n    i0 = -1\n    for i, c in enumerate(word):\n        if i + 1 == len(word) or c != word[i + 1]:\n            k, rem = divmod(i - i0, 9)\n            t.append((\"9\" + c) * k)\n            if rem:\n                t.append(str(rem))\n                t.append(c)\n            i0 = i\n    return ''.join(t)", "target_Lan": "python###compressedString.py", "target_code_shell": "# TOFILL\nif __name__ == \"__main__\":\n    print(compressedString(\"\"))\n    print(compressedString(\"a\"))\n    print(compressedString(\"aaa\"))\n    print(compressedString(\"abc\"))\n    print(compressedString(\"aabbcc\"))"}, {"source_Lan": "cpp###numberOfChild.cpp", "source_code": "   int numberOfChild(int n, int k) {\n       int a = k / (n - 1), b = k % (n - 1);\n       return (a & 1) == 0 ? b : n - 1 - b;\n   }", "trans_code": "def number_of_child ( n , k ) :\n    a , b = k // ( n - 1 ) , k % ( n - 1 )\n    return ( a & 1 ) == 0\n", "reference_code": "def numberOfChild( n: int, k: int) -> int:\n    k, t = divmod(k, n - 1)\n    return n - t - 1 if k % 2 else t", "target_Lan": "python###numberOfChild.py", "target_code_shell": "# TOFILL\nif __name__ == \"__main__\":\n    print(numberOfChild(2, 1))\n    print(numberOfChild(10, 5))\n    print(numberOfChild(100, 99))\n    print(numberOfChild(1000, 999))\n    print(numberOfChild(10000, 9999))"}, {"source_Lan": "cpp###sumOfPower.cpp", "source_code": "    int sumOfPower(vector<int> &nums, int k) {\n        const int MOD = 1'000'000'007;\n        int n = nums.size();\n        vector<vector<int>> f(k + 1, vector<int>(n + 1));\n        f[0][0] = 1;\n        for (int i = 0; i < n; i++) {\n            for (int j = k; j >= nums[i]; j--) {\n                for (int c = i + 1; c > 0; c--) {\n                    f[j][c] = (f[j][c] + f[j - nums[i]][c - 1]) % MOD;\n                }\n            }\n        }\n        int ans = 0;\n        int pow2 = 1;\n        for (int i = n; i > 0; i--) {\n            ans = (ans + (long long) f[k][i] * pow2) % MOD;\n            pow2 = pow2 * 2 % MOD;\n        }\n        return ans;\n    }", "trans_code": "def sumOfPower ( nums , k ) :\n    MOD = 1'000'000'007\n    n = len ( nums )\n    f = [ [ 0 ] * ( k + 1 ) for i in range ( n + 1 ) ]\n    f [ 0 ] [ 0 ] = 1\n    for i in range ( n ) :\n        for j in range ( k , i >= nums [ i ] , - 1 ) :\n            for c in range ( i + 1 , 0 , - 1 ) :\n                f [ j ] [ c ] = ( f [ j ] [ c ] + f [ j - nums [ i ] ] [ c - 1 ] ) % MOD\n    ans = 0\n    pow2 = 1\n    for i in range ( n , 0 , - 1 ) :\n        ans = ( ans + long ( f [ k ] [ i ] * pow2 ) ) % MOD\n        pow2 = pow2 * 2 % MOD\n    return ans\n", "reference_code": "def sumOfPower( nums: List[int], k: int) -> int:\n    MOD = 1_000_000_007\n    n = len(nums)\n    f = [[0] * (n + 1) for _ in range(k + 1)]\n    f[0][0] = 1\n    for i, x in enumerate(nums):\n        for j in range(k, x - 1, -1):\n            for c in range(i + 1, 0, -1):\n                f[j][c] = (f[j][c] + f[j - x][c - 1]) % MOD\n    ans = 0\n    pow2 = 1\n    for i in range(n, 0, -1):\n        ans = (ans + f[k][i] * pow2) % MOD\n        pow2 = pow2 * 2 % MOD\n    return ans", "target_Lan": "python###sumOfPower.py", "target_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(sumOfPower([1,2,3,4,5], 10))\n    print(sumOfPower([1,1,1,1,1], 5))\n    print(sumOfPower([1,2,3,4,5,6,7,8,9,10], 55))\n    print(sumOfPower([10,20,30,40,50], 150))\n    print(sumOfPower([100,200,300,400,500], 1500))"}, {"source_Lan": "cpp###findIndices.cpp", "source_code": "    vector<int> findIndices(vector<int>& nums, int indexDifference, int valueDifference) {\n        for (int i = 0; i < nums.size(); i++) {\n            for (int j = i; j < nums.size(); j++) {\n                if (j - i >= indexDifference && abs(nums[j] - nums[i]) >= valueDifference) {\n                    return {i, j};\n                }\n            }\n        }\n        return {-1, -1};\n    }", "trans_code": "def findIndices ( nums , indexDifference , valueDifference ) :\n    for i in range ( len ( nums ) ) :\n        for j in range ( i , len ( nums ) ) :\n            if j - i >= indexDifference and abs ( nums [ j ] - nums [ i ] ) >= valueDifference :\n                return [ i , j ]\n    return [ -1 , -1 ]\n", "reference_code": "def findIndices( nums: List[int], indexDifference: int, valueDifference: int) -> List[int]:\n    for i in range(len(nums)):\n        for j in range(i, len(nums)):\n            if j - i >= indexDifference and abs(nums[j] - nums[i]) >= valueDifference:\n                return [i, j]\n    return [-1, -1]", "target_Lan": "python###findIndices.py", "target_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(findIndices([1,2,3,4,5], 2, 1))\n    print(findIndices([1,2,3,4,5], 1, 2))\n    print(findIndices([1,2,3,4,5], 0, 0))\n    print(findIndices([1,2,3,4,5], 10, 10))\n    print(findIndices([1,2,3,4,5], -1, -1))"}, {"source_Lan": "cpp###maxArrayValue.cpp", "source_code": "    long long maxArrayValue(vector<int>& nums) {\n        long long sum = nums.back();\n        for (int i = nums.size() - 2; i >= 0; i--) {\n            sum = nums[i] <= sum ? nums[i] + sum : nums[i];\n        }\n        return sum;\n    }", "trans_code": "def maxArrayValue ( nums ) :\n    sum = nums [ - 1 ]\n    for i in range ( len ( nums ) - 2 , - 1 , - 1 ) :\n        sum = nums [ i ] if i <= sum else nums [ i ] + sum\n    return sum\n", "reference_code": "def maxArrayValue( nums: List[int]) -> int:\n    for i in range(len(nums) - 2, -1, -1):\n        if nums[i] <= nums[i + 1]:\n            nums[i] += nums[i + 1]\n    return nums[0]", "target_Lan": "python###maxArrayValue.py", "target_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(maxArrayValue([1, 2, 3, 4, 5]))\n    print(maxArrayValue([5, 4, 3, 2, 1]))\n    print(maxArrayValue([1, 1, 1, 1, 1]))\n    print(maxArrayValue([-1, -2, -3, -4, -5]))\n    print(maxArrayValue([1000000000, 1000000000, 1000000000, 1000000000, 1000000000]))"}, {"source_Lan": "cpp###maxNumberOfAlloys.cpp", "source_code": "    int maxNumberOfAlloys(int n, int k, int budget, vector<vector<int>>& composition, vector<int>& stock, vector<int>& cost) {\n        int left = 1, right = 2e8, ans = 0;\n        while (left <= right) {\n            int mid = (left + right) / 2;\n            bool valid = false;\n            for (int i = 0; i < k; ++i) {\n                long long spend = 0;\n                for (int j = 0; j < n; ++j) {\n                    spend += max(static_cast<long long>(composition[i][j]) * mid - stock[j], 0LL) * cost[j];\n                }\n                if (spend <= budget) {\n                    valid = true;\n                    break;\n                }\n            }\n            if (valid) {\n                ans = mid;\n                left = mid + 1;\n            }\n            else {\n                right = mid - 1;\n            }\n        }\n        return ans;\n    }", "trans_code": "def maxNumberOfAlloys ( n , k , budget , composition , stock , cost ) :\n    left , right = 1 , 2e8 , 0\n    while left <= right :\n        mid = ( left + right ) / 2\n        valid = False\n        for i in range ( k ) :\n            spend = 0\n            for j in range ( n ) :\n                spend += max ( int ( composition [ i ] [ j ] ) * mid - stock [ j ] , 0LL ) * cost [ j ]\n            if spend <= budget :\n                valid = True\n                break\n        if valid :\n            ans = mid\n            left = mid + 1\n        else :\n            right = mid - 1\n    return ans\n", "reference_code": "def maxNumberOfAlloys( n: int, k: int, budget: int, composition: List[List[int]], stock: List[int], cost: List[int]) -> int:\n    left, right, ans = 1, 2 * 10**8, 0\n    while left <= right:\n        mid = (left + right) // 2\n        valid = False\n        for i in range(k):\n            spend = 0\n            for j, (composition_j, stock_j, cost_j) in enumerate(zip(composition[i], stock, cost)):\n                spend += max(composition_j * mid - stock_j, 0) * cost_j\n            if spend <= budget:\n                valid = True\n                break\n        if valid:\n            ans = mid\n            left = mid + 1\n        else:\n            right = mid - 1\n    return ans", "target_Lan": "python###maxNumberOfAlloys.py", "target_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(maxNumberOfAlloys(3, 2, 1000, [[10, 20, 30], [20, 30, 40]], [50, 60, 70], [10, 20, 30]))\n    print(maxNumberOfAlloys(2, 1, 500, [[10, 20]], [30, 40], [10, 20]))\n    print(maxNumberOfAlloys(4, 3, 2000, [[10, 20, 30, 40], [20, 30, 40, 50], [30, 40, 50, 60]], [40, 50, 60, 70], [10, 20, 30, 40]))\n    print(maxNumberOfAlloys(1, 1, 1000, [[10]], [50], [10]))\n    print(maxNumberOfAlloys(3, 3, 3000, [[10, 20, 30], [20, 30, 40], [30, 40, 50]], [40, 50, 60], [10, 20, 30]))"}, {"source_Lan": "cpp###MaxDiff.cpp", "source_code": "    int MaxDiff(vector<int> &A, int n) {\n        vector<int> mx(1001, -1), mn(1001, n + 1);\n        for (int i = 0; i < n; i++) {\n            mx[A[i]] = max(mx[A[i]], i);\n            mn[A[i]] = min(mn[A[i]], i);\n        }\n        int ans = -1;\n        for (int i = 1; i <= 1000; i++) {\n            for (int j = i; j <= 1000; j++) {\n                int era = __gcd(i, j);\n                if (era != 1)\n                    continue;\n                if (mx[i] != -1 && mx[j] != -1) {\n                    ans = max(ans, abs(mx[i] - mn[j]));\n                    ans = max(ans, abs(mx[j] - mn[i]));\n                }\n            }\n        }\n        return ans;\n    }", "trans_code": "def MaxDiff ( A , n ) :\n    mx , mn = range ( 1001 , n + 1 )\n    for i in range ( n ) :\n        mx [ A [ i ] ] = max ( mx [ A [ i ] ] , i )\n        mn [ A [ i ] ] = min ( mn [ A [ i ] ] , i )\n    ans = -1\n    for i in range ( 1 , 1000 ) :\n        for j in range ( i , 1000 ) :\n            era = __gcd ( i , j )\n            if era != 1 :\n                continue\n            if mx [ i ] != -1 and mx [ j ] != -1 :\n                ans = max ( ans , abs ( mx [ i ] - mn [ j ] ) )\n                ans = max ( ans , abs ( mx [ j ] - mn [ i ] ) )\n    return ans\n", "reference_code": "def MaxDiff(A: List[int],n: int) -> int:\n    # Initialize the mx and mn lists with default values\n    mx = [-1] * 1001\n    mn = [n + 1] * 1001\n    # Populate mx and mn based on the indices in A\n    for i in range(n):\n        mx[A[i]] = max(mx[A[i]], i)\n        mn[A[i]] = min(mn[A[i]], i)\n    ans = -1\n    # Calculate the maximum difference where the GCD is 1\n    for i in range(1, 1001):\n        for j in range(i, 1001):\n            era = gcd(i, j)\n            if era != 1:\n                continue\n            if mx[i] != -1 and mx[j] != -1:\n                ans = max(ans, abs(mx[i] - mn[j]))\n                ans = max(ans, abs(mx[j] - mn[i]))\n    return ans", "target_Lan": "python###MaxDiff.py", "target_code_shell": "from typing import List\nfrom math import gcd\nfrom typing import List\nfrom math import gcd\n# TOFILL\nif __name__ == \"__main__\":\n    print(MaxDiff([1, 2, 3, 4, 5], 5))\n    print(MaxDiff([1000, 2, 3, 4, 5], 5))\n    print(MaxDiff([1, 2, 3, 4, 1000], 5))\n    print(MaxDiff([1, 2, 3, 1000, 5], 5))\n    print(MaxDiff([1, 2, 1000, 4, 5], 5))"}, {"source_Lan": "cpp###findFun.cpp", "source_code": "    int findFun(int n){\n        int mod=1000000007;\n        vector<long long>dp={2,5,9,7};\n        if (n<=3) return dp[n];\n        long long p1=2;\n        long long p2=5;\n        long long p3=9;\n        long long p4=7;\n        for (int i=4;i<=n;i++){\n            if (i%2==0){\n                int a=(p3*(i-2))%mod;\n                int b=(p1*(i-4))%mod;\n                int ele=(a+b)%mod;\n                p1=p2;\n                p2=p3;\n                p3=p4;\n                p4=ele;\n            }\n            else{\n                int a=(p4*(i-1))%mod;\n                int b=(p2*(i-3))%mod;\n                int ele=(a+b)%mod;\n                p1=p2;\n                p2=p3;\n                p3=p4;\n                p4=ele;\n            }\n        }\n        return p4;\n    }", "trans_code": "def findFun ( n ) :\n    mod = 1000000007\n    dp = [ 2 , 5 , 9 , 7 ]\n    if n <= 3 :\n        return dp [ n ]\n    p1 = 2\n    p2 = 5\n    p3 = 9\n    p4 = 7\n    for i in range ( 4 , n + 1 ) :\n        if i % 2 == 0 :\n            a = ( p3 * ( i - 2 ) ) % mod\n            b = ( p1 * ( i - 4 ) ) % mod\n            ele = ( a + b ) % mod\n            p1 = p2\n            p2 = p3\n            p3 = p4\n            p4 = ele\n        else :\n            a = ( p4 * ( i - 1 ) ) % mod\n            b = ( p2 * ( i - 3 ) ) % mod\n            ele = ( a + b ) % mod\n            p1 = p2\n            p2 = p3\n            p3 = p4\n            p4 = ele\n    return p4\n", "reference_code": "def findFun( n : int) -> int:\n    dp = [2,5,9,7]\n    if n<=3:\n        return dp[n]\n    mod = 10**9+7\n    for i in range(4,n+1):\n        if i&1==0:\n            z = dp[2]*(i-2) + dp[0]*(i-4)\n        else:\n            z = dp[3]*(i-1) + dp[1]*(i-3)\n        z = z%mod  \n        dp[0] = dp[1]\n        dp[1] = dp[2]\n        dp[2] = dp[3]\n        dp[3] = z\n    return dp[-1]", "target_Lan": "python###findFun.py", "target_code_shell": "# TOFILL\nif __name__ == \"__main__\":\n    print(findFun(0))\n    print(findFun(1))\n    print(findFun(2))\n    print(findFun(3))\n    print(findFun(4))"}, {"source_Lan": "cpp###CompatibleStrings.cpp", "source_code": "    vector<int> CompatibleStrings(int N, vector<string> &A1, vector<string> &A2) {\n        \n        \n        \n        vector<int> ans(N);\n        for(int j=0;j<N;j++){\n            vector<int> v1(26),v2(26);\n            for(auto i:A1[j]){\n                v1[i-'a']++;\n            }\n            for(auto i:A2[j]){\n                v2[i-'a']++;\n            }\n            vector<int> temp;\n            int p = 0;\n            int l = 0;\n            while(l<25){\n                p+=v1[l];\n                if(p<v2[l]){\n                    break;\n                }\n                else{\n                    p-=v2[l];\n                }\n                if(p!=0)\n                temp.push_back(p);\n                l++;\n            }\n            if(l!=25) ans[j]=0;\n            else if(p+v1[l]!=v2[l]) ans[j]=0;\n            else{\n                if(temp.size()==0){\n                    ans[j] = 1;\n                    continue;\n                }\n                int x = temp[0];\n                for(auto i:temp){\n                    x = __gcd(i,x);\n                }\n                if(x==1){\n                    ans[j] = 0;\n                }\n                else{\n                    ans[j] = 1;\n                }\n            }\n        }\n        return ans;\n    }", "trans_code": "def CompatibleStrings ( N , A1 , A2 ) :\n    ans = [ ]\n    for j in range ( N ) :\n        v1 , v2 = [ ] , [ ]\n        for i in A1 [ j ] :\n            v1.append ( i - 'a' )\n        for i in A2 [ j ] :\n            v2.append ( i - 'a' )\n        temp = [ ]\n        p = 0\n        l = 0\n        while l < 25 :\n            p += v1 [ l ]\n            if p < v2 [ l ] :\n                break\n            else :\n                p -= v2 [ l ]\n            if p != 0 :\n                temp.append ( p )\n            l += 1\n        if l != 25 :\n            ans.append ( 0 )\n        elif p + v1 [ l ] != v2 [ l ] :\n            ans.append ( 0 )\n        else :\n            if len ( temp ) == 0 :\n                ans.append ( 1 )\n                continue\n            x = temp [ 0 ]\n            for i in temp :\n                x = __gcd ( i , x )\n            if x == 1 :\n                ans.append ( 0 )\n            else :\n                ans.append ( 1 )\n    return ans\n", "reference_code": "def CompatibleStrings( N : int, A1 : List[str], A2 : List[str]) -> List[int]:\n    ans = [0]*N\n    for i in range(N):\n        s1 = A1[i]\n        s2 = A2[i]\n        if len(s1)!=len(s2):\n            continue\n        mp1 = Counter(s1)\n        mp2 = Counter(s2)\n        f = True\n        c2 = 0\n        c3 = 0\n        g = 0\n        r = 0\n        for c in range(97,123):\n            c = chr(c)\n            if mp1[c]==mp2[c]:\n                continue\n            d = abs(mp1[c]-mp2[c])\n            if mp2[c]>mp1[c]:\n                if r<d:\n                    f = False\n                    break\n                else:\n                    r-=d\n            else:\n                r += d\n            g = gcd(g,d)\n            if g==1:\n                f = False\n                break\n        if f:\n            ans[i] = 1\n    return ans", "target_Lan": "python###CompatibleStrings.py", "target_code_shell": "from typing import List\nfrom typing import List\nfrom collections import Counter\nfrom math import gcd\nfrom typing import List\nfrom collections import Counter\nfrom math import gcd\n# TOFILL\nif __name__ == \"__main__\":\n    print(CompatibleStrings(3, [\"abc\", \"def\", \"ghi\"], [\"abc\", \"def\", \"ghi\"]))\n    print(CompatibleStrings(3, [\"abc\", \"def\", \"ghi\"], [\"abc\", \"def\", \"ghi\"]))\n    print(CompatibleStrings(3, [\"abc\", \"def\", \"ghi\"], [\"abc\", \"def\", \"ghi\"]))\n    print(CompatibleStrings(3, [\"abc\", \"def\", \"ghi\"], [\"abc\", \"def\", \"ghi\"]))\n    print(CompatibleStrings(3, [\"abc\", \"def\", \"ghi\"], [\"abc\", \"def\", \"ghi\"]))"}, {"source_Lan": "cpp###collectingCoins.cpp", "source_code": "    int collectingCoins(int N, std::vector<std::vector<int>>& Coins)\n    {\n        \n        \n        unordered_map<int, int> hor,ver,diaa,diab;\n        int m = 0;\n        \n        for (auto& el : Coins)\n        {\n            \n            int a = el[0];\n            int b = el[1];\n            \n            \n            hor[a]++;\n            ver[b]++;\n            diaa[a + b]++;\n            diab[a - b]++;\n            \n            m = max(m, hor[a]);\n            m = max(m, ver[b]);\n            m = max(m, diaa[a + b]);\n            m = max(m, diab[a - b]);\n        }\n        \n        return m;\n    }", "trans_code": "def collectingCoins ( N , Coins ) :\n    hor , ver , diaa , diab = { } , { } , { } , { }\n    m = 0\n    for el in Coins :\n        a = el [ 0 ]\n        b = el [ 1 ]\n        hor [ a ] += 1\n        ver [ b ] += 1\n        diaa [ a + b ] += 1\n        diab [ a - b ] += 1\n        m = max ( m , hor [ a ] )\n        m = max ( m , ver [ b ] )\n        m = max ( m , diaa [ a + b ] )\n        m = max ( m , diab [ a - b ] )\n    return m\n", "reference_code": "def collectingCoins( N: int, Coins: List[List[int]]) -> int:\n    # Create defaultdicts to store the count of coins in each row, column, diagonal slope, and diagonal difference\n    hor = defaultdict(int)\n    ver = defaultdict(int)\n    diaa = defaultdict(int)\n    diab = defaultdict(int)\n    # Initialize a variable to store the maximum count of coins\n    m = 0\n    # Iterate through each coin\n    for el in Coins:\n        a, b = el[0], el[1]\n        # Update the count of coins in the corresponding row, column, diagonal slope, and diagonal difference\n        hor[a] += 1\n        ver[b] += 1\n        diaa[a + b] += 1\n        diab[a - b] += 1\n        # Update the maximum count of coins\n        m = max(m, hor[a], ver[b], diaa[a + b], diab[a - b])\n    # Return the maximum count of coins that can be collected\n    return m", "target_Lan": "python###collectingCoins.py", "target_code_shell": "from typing import List\nfrom collections import defaultdict\nfrom typing import List\nfrom collections import defaultdict\n# TOFILL\nif __name__ == \"__main__\":\n    print(collectingCoins(0, []))\n    print(collectingCoins(1, [[1,1]]))\n    print(collectingCoins(2, [[1,1], [2,2]]))\n    print(collectingCoins(3, [[1,1], [2,2], [3,3]]))\n    print(collectingCoins(4, [[1,1], [2,2], [3,3], [4,4]]))"}, {"source_Lan": "cpp###ForYou.cpp", "source_code": "    long long ForYou(int n, vector<int> &arr, int m, vector<vector<int> > &order)\n    {\n        vector<int> diff(n+1,0);\n        for(auto it:order)\n        {\n            diff[it[0]-1]++;\n            diff[it[1]]--;\n        }\n        for(int i=1;i<=n;i++)\n        {\n            diff[i] += diff[i-1];\n        }\n        diff.pop_back();\n        sort(diff.begin(),diff.end());\n        sort(arr.begin(),arr.end());\n        long long ans=0;\n        int mod = 1e9+7;\n        for(int i=0;i<n;i++)\n        {\n            ans += (1ll * diff[i]) * (1ll * arr[i]);\n            ans%=mod;\n        }\n        return ans;\n    }", "trans_code": "def ForYou ( n , arr , m , order ) :\n    diff = [ 0 ] * ( n + 1 )\n    for it in order :\n        diff [ it [ 0 ] - 1 ] += 1\n        diff [ it [ 1 ] ] -= 1\n    for i in range ( 1 , n + 1 ) :\n        diff [ i ] += diff [ i - 1 ]\n    diff.reverse ( )\n    diff = sorted ( diff )\n    arr = sorted ( arr )\n    ans = 0\n    mod = 1e9 + 7\n    for i in range ( n ) :\n        ans += ( 1ll * diff [ i ] ) * ( 1ll * arr [ i ] )\n        ans %= mod\n    return ans\n", "reference_code": "def ForYou( n : int, arr : List[int], m : int, order : List[List[int]]) -> int:\n    diff = [0] * (n + 1)\n    for it in order:\n        diff[it[0] - 1] += 1\n        diff[it[1]] -= 1\n    for i in range(1, n):\n        diff[i] += diff[i - 1]\n    diff.pop()\n    diff.sort()\n    arr.sort()\n    ans = 0\n    mod = int(1e9) + 7\n    for i in range(n):\n        ans += diff[i] * arr[i]\n        ans %= mod\n    return ans", "target_Lan": "python###ForYou.py", "target_code_shell": "from typing import List\nfrom typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(ForYou(5, [1, 2, 3, 4, 5], 3, [[1, 3], [2, 4], [1, 5]]))\n    print(ForYou(10, [10, 9, 8, 7, 6, 5, 4, 3, 2, 1], 5, [[1, 10], [2, 9], [3, 8], [4, 7], [5, 6]]))\n    print(ForYou(0, [], 0, []))\n    print(ForYou(1, [1], 0, []))\n    print(ForYou(2, [2, 1], 2, [[1, 2], [2, 1]]))"}, {"source_Lan": "cpp###createString.cpp", "source_code": "    string createString(int n, int k, string s) {\n        string answer = \"\";\n        unordered_map<char, int> m;\n        for(auto i : s){\n            m[i] += 1;\n        }\n        set<pair<char, int>> st;\n        for(auto i : m){\n            st.insert({i.first, i.second});\n        }\n        int curr = 0;\n        while(st.size()){\n            auto largest = st.end();\n            largest--;\n            if(curr == k){\n                if(st.size() == 1){\n                    break;\n                }else{\n                    largest--;\n                }\n                curr = -1;\n            }\n            char now = largest->first;\n            int count = largest->second;\n            st.erase({now, count});\n            count -= 1;\n            if(count){\n                st.insert({now, count});\n                curr += 1;\n            }else{\n                curr = 0;\n            }\n            answer += now;\n        }\n        return answer;\n    }", "trans_code": "def createString ( n , k , s ) :\n    answer = \"\"\n    m = { }\n    for i in s :\n        m [ i ] += 1\n    st = set ( )\n    for i in m :\n        st.add ( ( i [ 0 ] , i [ 1 ] ) )\n    curr = 0\n    while len ( st ) :\n        largest = st.pop ( )\n        largest.reverse ( )\n        if curr == k :\n            if len ( st ) == 1 :\n                break\n            else :\n                largest.reverse ( )\n            curr = -1\n        now = largest [ 0 ]\n        count = largest [ 1 ]\n        st.remove ( ( now , count ) )\n        count -= 1\n        if count :\n            st.add ( ( now , count ) )\n            curr += 1\n        else :\n            curr = 0\n        answer += now\n    return answer\n", "reference_code": "def createString( n : int, k : int, s : str) -> str:\n    c=Counter(s)\n    t=[(c[el],el) for el in c]\n    t.sort(key=lambda x:(x[1]))\n    ans=\"\"\n    while t:\n        ca,cb=t.pop()\n        if ca>k:\n            ca-=k\n            ans+=cb*k\n            if len(t)==0:\n                return ans\n            else:\n                da,db=t.pop()\n                if da>1:\n                    ans+=db\n                    t.append((da-1,db))\n                else:\n                    ans+=db\n            t.append((ca,cb))\n        else:\n            ans+=cb*ca\n    return ans", "target_Lan": "python###createString.py", "target_code_shell": "from collections import Counter\nfrom collections import Counter\n# TOFILL\nif __name__ == \"__main__\":\n    print(createString(5, 2, \"abcde\"))\n    print(createString(10, 3, \"abcabcabc\"))\n    print(createString(3, 1, \"aaa\"))\n    print(createString(4, 2, \"abcd\"))\n    print(createString(6, 3, \"aabbbc\"))"}, {"source_Lan": "cpp###maximumBattalions.cpp", "source_code": "    int maximumBattalions(int N, vector<string> &names) {\n        unordered_map<string, int> m;\n        for(int i = 0; i < N; i++){\n            m[names[i]] = i;\n        }\n        int answer = 0;\n        int maxi = 0;\n        int ind = 0;\n        for(auto i : names){\n            maxi = max(maxi, m[i]);\n            if(maxi == ind){\n                answer += 1;\n            }\n            ind += 1;\n        }\n        return answer;\n    }", "trans_code": "def maximumBattalions ( N , names ) :\n    m = { }\n    for i in range ( N ) :\n        m [ names [ i ] ] = i\n    answer = 0\n    maxi = 0\n    ind = 0\n    for i in names :\n        maxi = max ( maxi , m [ i ] )\n        if maxi == ind :\n            answer += 1\n        ind += 1\n    return answer\n", "reference_code": "def maximumBattalions( N : int, names : List[str]) -> int:\n    d={}\n    for i in range(N):\n        if names[i] not in d:\n            d[names[i]]=[]\n        d[names[i]].append(i)\n    seen=set()\n    ans=0\n    for i in range(N):\n        if names[i] not in seen:\n            seen.add(names[i])\n        if d[names[i]][-1]==i:\n            seen.remove(names[i])\n        if len(seen)==0:\n            ans+=1\n    return ans", "target_Lan": "python###maximumBattalions.py", "target_code_shell": "from typing import List\nfrom typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(maximumBattalions(0, []))\n    print(maximumBattalions(1, [\"John\"]))\n    print(maximumBattalions(2, [\"John\", \"John\"]))\n    print(maximumBattalions(3, [\"John\", \"John\", \"Doe\"]))\n    print(maximumBattalions(4, [\"John\", \"Doe\", \"John\", \"Doe\"]))"}, {"source_Lan": "cpp###minimumDis.cpp", "source_code": "    int minimumDis(int N, vector<int> X) {\n        sort(X.begin(), X.end());\n        return X[(N - 1) / 2];\n    }", "trans_code": "def minimumDis ( N , X ) :\n    X.sort ( )\n    return X [ ( N - 1 ) / 2 ]\n", "reference_code": "def minimumDis( N: int, X: List[int]) -> int:\n    X.sort()\n    return X[(N - 1) // 2]", "target_Lan": "python###minimumDis.py", "target_code_shell": "from typing import List\nfrom typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(minimumDis(1, [1]))\n    print(minimumDis(2, [1,2]))\n    print(minimumDis(3, [1,2,3]))\n    print(minimumDis(4, [1,2,3,4]))"}, {"source_Lan": "cpp###firstContact.cpp", "source_code": "    long long firstContact(int n, int m) {\n        long long ans = m / __gcd(n, m);\n        ans *= n;\n        return ans;\n    }", "trans_code": "def firstContact ( n , m ) :\n    ans = m / __gcd ( n , m )\n    ans *= n\n    return ans\n", "reference_code": "def firstContact( n: int, m: int) -> int:\n    #just return the LCM of n and m\n    return (n * m) // gcd(n, m)", "target_Lan": "python###firstContact.py", "target_code_shell": "from math import gcd\nfrom math import gcd\n# TOFILL\nif __name__ == \"__main__\":\n    print(firstContact(1, 1))\n    print(firstContact(10, 10))\n    print(firstContact(100, 100))\n    print(firstContact(1000, 1000))\n    print(firstContact(10000, 10000))"}, {"source_Lan": "cpp###maxAlternatingSubstring.cpp", "source_code": "    long long maxAlternatingSubstring(int N, string S) {\n        vector<long long> diff;\n        for (int i = 0; i < N;) {\n            int j = i + 1;\n            while (j < N && S[j] != S[j - 1])\n                j++;\n            diff.push_back(j - i);\n            i = j;\n        }\n        diff.push_back(0);\n        long long ans_before = 0;\n        for (long long x : diff) {\n            ans_before += ((x * (x + 1)) / 2);\n        }\n        long long ans = 0;\n        for (int i = 0; i < diff.size() - 1; ++i) {\n            long long a = diff[i];\n            long long b = diff[i + 1];\n            long long currAns = ans_before - ((a * (a + 1)) / 2) - ((b * (b + 1)) / 2) +\n                                ((a + b + 1) * (a + b + 2)) / 2;\n            ans = max(ans, currAns);\n        }\n        return ans;\n    }", "trans_code": "def maxAlternatingSubstring ( N , S ) :\n    diff = [ ]\n    for i in range ( N ) :\n        j = i + 1\n        while j < N and S [ j ] != S [ j - 1 ] :\n            j += 1\n        diff.append ( j - i )\n        i = j\n    diff.append ( 0 )\n    ans_before = 0\n    for x in diff :\n        ans_before += ( ( x * ( x + 1 ) ) / 2 )\n    ans = 0\n    for i in range ( len ( diff ) - 1 ) :\n        a = diff [ i ]\n        b = diff [ i + 1 ]\n        curr_ans = ans_before - ( ( a * ( a + 1 ) ) / 2 ) - ( ( b * ( b + 1 ) ) / 2 ) + ( ( a + b + 1 ) * ( a + b + 2 ) ) / 2\n        ans = max ( ans , curr_ans )\n    return ans\n", "reference_code": "def maxAlternatingSubstring( N: int, S: str) -> int:\n    diff = []\n    i = 0\n    while i < N:\n        j = i + 1\n        while j < N and S[j] != S[j - 1]:\n            j += 1\n        diff.append(j - i)\n        i = j\n    diff.append(0)\n    ans_before = 0\n    for x in diff:\n        ans_before += ((x * (x + 1)) // 2)\n    ans = 0\n    for i in range(len(diff) - 1):\n        a = diff[i]\n        b = diff[i + 1]\n        currAns = (ans_before - ((a * (a + 1)) // 2) -\n                   ((b * (b + 1)) // 2) + ((a + b + 1) * (a + b + 2)) // 2)\n        ans = max(ans, currAns)\n    return ans", "target_Lan": "python###maxAlternatingSubstring.py", "target_code_shell": "# TOFILL\nif __name__ == \"__main__\":\n    print(maxAlternatingSubstring(5, \"10101\"))\n    print(maxAlternatingSubstring(10, \"1100110011\"))"}, {"source_Lan": "cpp###countSuperPalindrome.cpp", "source_code": "    int countSuperPalindrome(int l, int r) {\n        int count = 0;\n        \n        int start = static_cast<int>(ceil(sqrt(l)));\n        \n        while (start * start <= r) {\n            \n            int square = start * start;\n            string s = to_string(square);\n            \n            if (s == string(s.rbegin(), s.rend())) {\n                count++;\n            }\n            start++;\n        }\n        return count;\n    }", "trans_code": "def countSuperPalindrome ( l , r ) :\n    count = 0\n    start = int ( math.ceil ( math.sqrt ( l ) ) )\n    while start * start <= r :\n        square = start * start\n        s = str ( square )\n        if s == str ( s.reverse ( ) ) :\n            count += 1\n        start += 1\n    return count\n", "reference_code": "def countSuperPalindrome( l: int, r: int) -> int:\n    count = 0\n    start = ceil(sqrt(l))\n    while start * start <= r:\n        s = str(start * start)\n        #Checking if the square of start is a palindrome.\n        if s == s[::-1]:\n            count += 1\n        start += 1\n    return count", "target_Lan": "python###countSuperPalindrome.py", "target_code_shell": "from math import sqrt, ceil\nfrom math import ceil, sqrt\n# TOFILL\nif __name__ == \"__main__\":\n    print(countSuperPalindrome(0, 10))\n    print(countSuperPalindrome(100, 1000))\n    print(countSuperPalindrome(1000, 10000))\n    print(countSuperPalindrome(10000, 100000))\n    print(countSuperPalindrome(100000, 1000000))"}, {"source_Lan": "cpp###maximumStrongIndices.cpp", "source_code": "    int maximumStrongIndices(int n, int x, int y, vector<int> &a, vector<int> &b) {\n        int j = 0, ans = 0;\n        for (int i = 0; i < n; i++) {\n            while (j < n && b[j] < a[i] - x)\n                j++;\n            if (j < n && b[j] <= a[i] + y) {\n                ans++;\n                j++;\n            }\n        }\n        return ans;\n    }", "trans_code": "def maximum_strong_indices ( n , x , y , a , b ) :\n    j , ans = 0 , 0\n    for i in range ( n ) :\n        while j < n and b [ j ] < a [ i ] - x :\n            j += 1\n        if j < n and b [ j ] <= a [ i ] + y :\n            ans += 1\n            j += 1\n    return ans\n", "reference_code": "def maximumStrongIndices( n: int, x: int, y: int, a: List[int],\n                         b: List[int]) -> int:\n    j = 0\n    ans = 0\n    for i in range(n):\n        while j < n and b[j] < a[i] - x:\n            j += 1\n        if j < n and b[j] <= a[i] + y:\n            ans += 1\n            j += 1\n    return ans", "target_Lan": "python###maximumStrongIndices.py", "target_code_shell": "from typing import List\nfrom typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(maximumStrongIndices(5, 2, 3, [1, 2, 3, 4, 5], [0, 1, 2, 3, 4]))\n    print(maximumStrongIndices(5, 1, 1, [1, 2, 3, 4, 5], [2, 3, 4, 5, 6]))\n    print(maximumStrongIndices(5, 0, 0, [1, 2, 3, 4, 5], [1, 2, 3, 4, 5]))\n    print(maximumStrongIndices(5, 1, 1, [1, 2, 3, 4, 5], [0, 0, 0, 0, 0]))\n    print(maximumStrongIndices(5, 1, 1, [1, 2, 3, 4, 5], [6, 6, 6, 6, 6]))"}, {"source_Lan": "cpp###candyShop.cpp", "source_code": "    int candyShop(int n, vector<int> &candies) {\n        int answer = INT_MAX;\n        unordered_map<int, int> m;\n        for(auto i : candies){\n            m[i] += 1;\n        }\n        int k = m.size();\n        m.clear();\n        int l = 0, r = 0;\n        int total = 0;\n        while(r < n){\n            m[candies[r]] += 1;\n            total += candies[r];\n            while(m[candies[l]] > 1){\n                m[candies[l]] -= 1;\n                total -= candies[l];\n                l += 1;\n            }\n            if(m.size() == k){\n                answer = min(answer, total);\n            }\n            r += 1;\n        }\n        return answer;\n    }", "trans_code": "def candyShop ( n , candies ) :\n    answer = sys.maxint\n    m = { }\n    for i in candies :\n        m [ i ] += 1\n    k = len ( m )\n    m = { }\n    l , r = 0 , 0\n    total = 0\n    while r < n :\n        m [ candies [ r ] ] += 1\n        total += candies [ r ]\n        while m [ candies [ l ] ] > 1 :\n            m [ candies [ l ] ] -= 1\n            total -= candies [ l ]\n            l += 1\n        if len ( m ) == k :\n            answer = min ( answer , total )\n        r += 1\n    return answer\n", "reference_code": "def candyShop( n : int, candies : List[int]) -> int:\n    s=set(el for el in candies)\n    t=Counter()\n    l=0\n    p=0\n    ans=float(\"inf\")\n    for el in candies:\n        p+=el\n        t[el]+=1\n        while len(t)==len(s):\n            ans=min(ans,p)\n            t[candies[l]]-=1\n            p-=candies[l]\n            if t[candies[l]]==0:\n                del t[candies[l]]\n            l+=1\n    return ans", "target_Lan": "python###candyShop.py", "target_code_shell": "from typing import List\nfrom collections import Counter\nfrom typing import List\nfrom collections import Counter\n# TOFILL\nif __name__ == \"__main__\":\n    print(candyShop(5, [1,2,3,4,5]))\n    print(candyShop(10, [1,1,1,1,1,1,1,1,1,1]))\n    print(candyShop(7, [1,2,3,4,5,6,7]))\n    print(candyShop(10, [1,2,3,4,5,6,7,8,9,10]))\n    print(candyShop(5, [1,1,1,2,2]))"}, {"source_Lan": "cpp###minimizeArr.cpp", "source_code": "    int minimizeArr(int n, vector<int>&arr){\n        int mi=INT_MAX;\n        for (auto j:arr) mi=min(mi,j);\n        int ct=0;\n        for (auto j:arr){\n            if (j==mi)ct+=1;\n        }\n        if (ct==1) return 1;\n        for (auto j:arr){\n            if (j%mi!=0) return 1;\n        }\n        return ceil((float)ct / 2);\n    }", "trans_code": "def minimize_arr ( n , arr ) :\n    mi = sys.maxint\n    for j in arr :\n        mi = min ( mi , j )\n    ct = 0\n    for j in arr :\n        if j == mi :\n            ct += 1\n    if ct == 1 :\n        return 1\n    for j in arr :\n        if j % mi != 0 :\n            return 1\n    return math.ceil ( float ( ct ) / 2 )\n", "reference_code": "def minimizeArr( n: int, arr: List[int]) -> int:\n    min_element = min(arr)\n    if arr.count(min_element) == 1:\n        return 1\n    else:\n        count = arr.count(min_element)\n        for el in arr:\n            if el % min_element != 0:\n                return 1\n        return (count + 1) // 2", "target_Lan": "python###minimizeArr.py", "target_code_shell": "from typing import List\nfrom typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(minimizeArr(1, [1]))\n    print(minimizeArr(2, [1, 1]))\n    print(minimizeArr(3, [1, 2, 3]))\n    print(minimizeArr(4, [2, 2, 2, 2]))"}, {"source_Lan": "cpp###chocolateDistribution.cpp", "source_code": "    int chocolateDistribution(int N, int M, vector<int> &arr, vector<int> &brr) {\n        sort(arr.begin(), arr.end());\n        sort(brr.begin(), brr.end());\n        int ans = 0;\n        int i = 0, j = 0;\n        while (i < N && j < M) {\n            if (arr[i] <= brr[j]) {\n                ans++;\n                i++;\n                j++;\n            } else {\n                j++;\n            }\n        }\n        return ans;\n    }", "trans_code": "def chocolate_distribution ( N , M , arr , brr ) :\n    arr = sorted ( arr )\n    brr = sorted ( brr )\n    ans = 0\n    i , j = 0 , 0\n    while i < N and j < M :\n        if arr [ i ] <= brr [ j ] :\n            ans += 1\n            i += 1\n            j += 1\n        else :\n            j += 1\n    return ans\n", "reference_code": "def chocolateDistribution( N, M, arr, brr):\n    arr.sort()\n    brr.sort()\n    ans = 0\n    i, j = 0, 0\n    while i < N and j < M:\n        if arr[i] <= brr[j]:\n            ans += 1\n            i += 1\n            j += 1\n        else:\n            j += 1\n    return ans", "target_Lan": "python###chocolateDistribution.py", "target_code_shell": "# TOFILL\nif __name__ == \"__main__\":\n    print(chocolateDistribution(0, 0, [], []))\n    print(chocolateDistribution(1, 1, [1], [1]))\n    print(chocolateDistribution(2, 2, [1,2], [1,2]))\n    print(chocolateDistribution(3, 3, [1,2,3], [1,2,3]))\n    print(chocolateDistribution(3, 3, [1,2,3], [2,3,4]))"}, {"source_Lan": "cpp###minElements.cpp", "source_code": "    int minElements(int n, int m, vector<int> &arr1, vector<int> &arr2) {\n        long long s=0;\n        for (auto j:arr1) s+=j;\n        sort(arr2.begin(),arr2.end());\n        long long cur=0;\n        int ans=0;\n        for (int i=m-1;i>=0;i--){\n            cur+=arr2[i];\n            ans+=1;\n            if (cur>=s)break;\n        }\n        if (cur>=s) return ans;\n        return -1;\n    }", "trans_code": "def minElements ( n , m , arr1 , arr2 ) :\n    s = 0\n    for j in arr1 :\n        s += j\n    arr2.sort ( )\n    cur = 0\n    ans = 0\n    for i in range ( m - 1 , - 1 , - 1 ) :\n        cur += arr2 [ i ]\n        ans += 1\n        if cur >= s :\n            break\n    if cur >= s :\n        return ans\n    return -1\n", "reference_code": "def minElements( n : int, m : int, arr1 : List[int], arr2 : List[int]) -> int:\n    s=sum(arr1)\n    arr2.sort(reverse=True)\n    ind=0\n    curr=0\n    for el in arr2:\n        curr+=el\n        if curr>=s:\n            return ind+1\n        ind+=1\n    return -1", "target_Lan": "python###minElements.py", "target_code_shell": "from typing import List\nfrom typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(minElements(5, 5, [1, 2, 3, 4, 5], [1, 2, 3, 4, 5]))\n    print(minElements(5, 5, [1, 2, 3, 4, 5], [5, 4, 3, 2, 1]))\n    print(minElements(5, 5, [1, 2, 3, 4, 5], [1, 1, 1, 1, 1]))\n    print(minElements(5, 5, [1, 2, 3, 4, 5], [5, 5, 5, 5, 5]))\n    print(minElements(5, 5, [1, 2, 3, 4, 5], [0, 0, 0, 0, 0]))"}, {"source_Lan": "cpp###maxScoreSubseq.cpp", "source_code": "    int maxScoreSubseq(int n, vector<int> &arr) {\n        unordered_map<int,int>mp;\n        int ma=INT_MIN;\n        for (int i=0;i<n;i++){\n            if (arr[i]>=0)mp[arr[i]-i]+=arr[i];\n            ma=max(ma,arr[i]);\n        }\n        int ele=INT_MIN;\n        for (auto j:mp) ele=max(ele,j.second);\n        return max(ele,ma);\n    }", "trans_code": "def maxScoreSubseq ( n , arr ) :\n    mp = { }\n    ma = sys.maxint\n    for i in range ( n ) :\n        if arr [ i ] >= 0 :\n            mp [ arr [ i ] - i ] += arr [ i ]\n        ma = max ( ma , arr [ i ] )\n    ele = sys.maxint\n    for j in mp :\n        ele = max ( ele , j [ 1 ] )\n    return max ( ele , ma )\n", "reference_code": "def maxScoreSubseq( n : int, arr : List[int]) -> int:\n    d=defaultdict(int)\n    v=max(arr)\n    for i in range(n):\n        d[arr[i]-i]+=max(0,arr[i])\n    c=(1 if 0 in arr else 0)\n    for el in d:\n        if d[el]>0:\n            v=max(v,d[el])\n        elif d[el]==0 and c:\n            v=max(0,v)\n    return v", "target_Lan": "python###maxScoreSubseq.py", "target_code_shell": "from typing import List\nfrom collections import defaultdict\nfrom typing import List\nfrom collections import defaultdict\n# TOFILL\nif __name__ == \"__main__\":\n    print(maxScoreSubseq(1, [1]))\n    print(maxScoreSubseq(2, [1, 2]))\n    print(maxScoreSubseq(3, [1, 2, 3]))\n    print(maxScoreSubseq(4, [1, 2, 3, 4]))"}, {"source_Lan": "cpp###canTrade.cpp", "source_code": "    vector<int> canTrade(int n, vector<int>& beautifulness, int q,\n                         vector<vector<int>>& queries) {\n        int prev = beautifulness[0];\n        beautifulness[0] = 0;\n        for (int i = 1; i < n; i++) {\n            int curr = beautifulness[i];\n            if (beautifulness[i] == prev)\n                beautifulness[i] = beautifulness[i - 1];\n            else\n                beautifulness[i] = i;\n            prev = curr;\n        }\n        vector<int> ans(q);\n        for (int i = 0; i < q; i++) {\n            int u = queries[i][0], v = queries[i][1];\n            u--;\n            v--;\n            if (beautifulness[v] <= u)\n                ans[i] = 1;\n        }\n        return ans;\n    }", "trans_code": "def canTrade ( n , beautifulness , q , queries ) :\n    prev = beautifulness [ 0 ]\n    beautifulness [ 0 ] = 0\n    for i in range ( 1 , n ) :\n        curr = beautifulness [ i ]\n        if beautifulness [ i ] == prev :\n            beautifulness [ i ] = beautifulness [ i - 1 ]\n        else :\n            beautifulness [ i ] = i\n        prev = curr\n    ans = [ 0 ] * q\n    for i in range ( q ) :\n        u , v = queries [ i ]\n        u -= 1\n        v -= 1\n        if beautifulness [ v ] <= u :\n            ans [ i ] = 1\n    return ans\n", "reference_code": "def canTrade( n: int, beautifulness: List[int], q: int,\n             queries: List[List[int]]) -> List[int]:\n    par = [i for i in range(n)]\n    for i in range(1, n):\n        if beautifulness[i] == beautifulness[i - 1]:\n            par[i] = par[i - 1]\n        else:\n            pass\n    ans = []\n    for el in queries:\n        a, b = el[0] - 1, el[1] - 1\n        if par[a] == par[b]:\n            ans.append(1)\n        else:\n            ans.append(0)\n    return ans", "target_Lan": "python###canTrade.py", "target_code_shell": "from typing import List\nfrom typing import List\nfrom typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(canTrade(5, [1, 2, 3, 4, 5], 3, [[1, 2], [2, 3], [3, 4]]))\n    print(canTrade(10, [10, 9, 8, 7, 6, 5, 4, 3, 2, 1], 5, [[1, 10], [2, 9], [3, 8], [4, 7], [5, 6]]))\n    print(canTrade(0, [], 0, []))\n    print(canTrade(1, [1], 1, [[1, 1]]))\n    print(canTrade(2, [1, 2], 2, [[1, 1], [2, 2]]))"}, {"source_Lan": "cpp###maxFrequencyElements.cpp", "source_code": "    int maxFrequencyElements(vector<int> &nums) {\n        int ans = 0, maxCnt = 0;\n        unordered_map<int, int> cnt;\n        for (int x : nums) {\n            int c = ++cnt[x];\n            if (c > maxCnt) {\n                maxCnt = ans = c;\n            } else if (c == maxCnt) {\n                ans += c;\n            }\n        }\n        return ans;\n    }", "trans_code": "def maxFrequencyElements ( nums ) :\n    ans , max_cnt = 0 , 0\n    cnt = { }\n    for x in nums :\n        c = yield cnt [ x ]\n        if c > max_cnt :\n            max_cnt = ans = c\n        elif c == max_cnt :\n            ans += c\n", "reference_code": "def maxFrequencyElements( nums: List[int]) -> int:\n    ans = max_cnt = 0\n    cnt = Counter()\n    for x in nums:\n        cnt[x] += 1\n        c = cnt[x]\n        if c > max_cnt:\n            max_cnt = ans = c\n        elif c == max_cnt:\n            ans += c\n    return ans", "target_Lan": "python###maxFrequencyElements.py", "target_code_shell": "from typing import List\nfrom collections import Counter\n# TOFILL\nif __name__ == \"__main__\":\n    print(maxFrequencyElements([1, 2, 2, 3, 3, 3]))\n    print(maxFrequencyElements([1, 1, 1, 1, 1, 1]))\n    print(maxFrequencyElements([1, 2, 3, 4, 5, 6]))\n    print(maxFrequencyElements([-1, -1, 0, 0, 1, 1]))\n    print(maxFrequencyElements([100, 200, 300, 400, 500, 600]))"}, {"source_Lan": "cpp###minimumOperationsToMakeKPeriodic.cpp", "source_code": "    int minimumOperationsToMakeKPeriodic(string word, int k) {\n        int n = word.size(), mx = 0;\n        unordered_map<string, int> cnt;\n        for (int i = k; i <= n; i += k) {\n            mx = max(mx, ++cnt[word.substr(i - k, k)]);\n        }\n        return n / k - mx;\n    }", "trans_code": "def minimumOperationsToMakeKPeriodic ( word , k ) :\n    n , mx = len ( word ) , 0\n    cnt = { }\n    for i in range ( k , n , k ) :\n        mx = max ( mx , yield cnt [ word [ i - k : i + k ] ] )\n    return n / k - mx\n", "reference_code": "def minimumOperationsToMakeKPeriodic( word: str, k: int) -> int:\n    n = len(word)\n    cnt = Counter(word[i - k: i] for i in range(k, n + 1, k))\n    mx = max(cnt.values())\n    return n // k - mx", "target_Lan": "python###minimumOperationsToMakeKPeriodic.py", "target_code_shell": "from collections import Counter\n# TOFILL\nif __name__ == \"__main__\":\n    print(minimumOperationsToMakeKPeriodic(\"abcabcabcabc\", 3))\n    print(minimumOperationsToMakeKPeriodic(\"aaaaa\", 1))\n    print(minimumOperationsToMakeKPeriodic(\"abcabcabcabc\", 4))\n    print(minimumOperationsToMakeKPeriodic(\"abcabcabcabc\", 6))\n    print(minimumOperationsToMakeKPeriodic(\"abcabcabcabc\", 12))"}, {"source_Lan": "cpp###maxScore.cpp", "source_code": "    int maxScore(vector<vector<int>>& grid) {\n        int ans = INT_MIN;\n        int m = grid.size(), n = grid[0].size();\n        vector<vector<int>> f(m + 1, vector<int>(n + 1, INT_MAX));\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                int mn = min(f[i + 1][j], f[i][j + 1]);\n                ans = max(ans, grid[i][j] - mn);\n                f[i + 1][j + 1] = min(mn, grid[i][j]);\n            }\n        }\n        return ans;\n    }", "trans_code": "def maxScore ( grid ) :\n    ans = int ( 0 )\n    m , n = len ( grid ) , len ( grid [ 0 ] )\n    f = np.zeros ( ( m + 1 , n + 1 ) )\n    for i in range ( m ) :\n        for j in range ( n ) :\n            mn = min ( f [ i + 1 ] [ j ] , f [ i ] [ j + 1 ] )\n            ans = max ( ans , grid [ i ] [ j ] - mn )\n            f [ i + 1 ] [ j + 1 ] = min ( mn , grid [ i ] [ j ] )\n    return ans\n", "reference_code": "def maxScore( grid: List[List[int]]) -> int:\n    ans = -inf\n    m, n = len(grid), len(grid[0])\n    f = [[inf] * (n + 1) for _ in range(m + 1)]\n    for i, row in enumerate(grid):\n        for j, x in enumerate(row):\n            mn = min(f[i + 1][j], f[i][j + 1])\n            ans = max(ans, x - mn)\n            f[i + 1][j + 1] = min(mn, x)\n    return ans", "target_Lan": "python###maxScore.py", "target_code_shell": "from typing import List\nfrom math import inf\n# TOFILL\nif __name__ == \"__main__\":\n    print(maxScore([[1, 2, 3], [4, 5, 6], [7, 8, 9]]))\n    print(maxScore([[10, 20, 30], [40, 50, 60], [70, 80, 90]]))\n    print(maxScore([[100, 200, 300], [400, 500, 600], [700, 800, 900]]))\n    print(maxScore([[1, 1, 1], [1, 1, 1], [1, 1, 1]]))\n    print(maxScore([[9, 9, 9], [9, 9, 9], [9, 9, 9]]))"}, {"source_Lan": "cpp###minimumArea.cpp", "source_code": "    int minimumArea(vector<vector<int>>& grid) {\n        int left = grid[0].size(), right = 0, top = grid.size(), bottom = 0;\n        for (int i = 0; i < grid.size(); i++) {\n            for (int j = 0; j < grid[i].size(); j++) {\n                if (grid[i][j]) {\n                    left = min(left, j);\n                    right = max(right, j);\n                    top = min(top, i);\n                    bottom = i;\n                }\n            }\n        }\n        return (right - left + 1) * (bottom - top + 1);\n    }", "trans_code": "def minimumArea ( grid ) :\n    left , right , top , bottom = 0 , 0 , len ( grid ) , 0 , 0\n    for i in range ( len ( grid ) ) :\n        for j in range ( len ( grid [ i ] ) ) :\n            if grid [ i ] [ j ] :\n                left = min ( left , j )\n                right = max ( right , j )\n                top = min ( top , i )\n                bottom = i\n    return ( right - left + 1 ) * ( bottom - top + 1 )\n", "reference_code": "def minimumArea( grid: List[List[int]]) -> int:\n    left, right = len(grid[0]), 0\n    top, bottom = len(grid), 0\n    for i, row in enumerate(grid):\n        for j, x in enumerate(row):\n            if x:\n                left = min(left, j)\n                right = max(right, j)\n                top = min(top, i)\n                bottom = i\n    return (right - left + 1) * (bottom - top + 1)", "target_Lan": "python###minimumArea.py", "target_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(minimumArea([[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]]))\n    print(minimumArea([[1,1,1,1,1],[1,1,1,1,1],[1,1,1,1,1],[1,1,1,1,1]]))\n    print(minimumArea([[1,0,0,0,0],[0,1,0,0,0],[0,0,1,0,0],[0,0,0,1,0]]))\n    print(minimumArea([[0,0,0,0,1],[0,0,0,1,0],[0,0,1,0,0],[0,1,0,0,0]]))\n    print(minimumArea([[1,1,1,1,1],[0,0,0,0,1],[0,0,0,1,0],[0,0,1,0,0]]))"}, {"source_Lan": "cpp###minimumCost.cpp", "source_code": "    int minimumCost(vector<int> &nums) {\n        sort(nums.begin() + 1, nums.end());\n        return accumulate(nums.begin(), nums.begin() + 3, 0);\n    }", "trans_code": "def minimum_cost ( nums ) :\n    nums = sorted ( nums )\n    return sum ( nums )\n", "reference_code": "def minimumCost( nums: List[int]) -> int:\n    return nums[0] + sum(sorted(nums[1:])[:2])", "target_Lan": "python###minimumCost.py", "target_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(minimumCost([1,2,3,4,5]))\n    print(minimumCost([5,4,3,2,1]))\n    print(minimumCost([1,1,1,1,1]))\n    print(minimumCost([-1,-2,-3,-4,-5]))\n    print(minimumCost([100,200,300,400,500]))"}, {"source_Lan": "cpp###maximumSubarraySum.cpp", "source_code": "    long long maximumSubarraySum(vector<int> &nums, int k) {\n        long long ans = LLONG_MIN, sum = 0;\n        unordered_map<int, long long> min_s;\n        for (int x: nums) {\n            auto it = min_s.find(x + k);\n            if (it != min_s.end()) {\n                ans = max(ans, sum + x - it->second);\n            }\n            it = min_s.find(x - k);\n            if (it != min_s.end()) {\n                ans = max(ans, sum + x - it->second);\n            }\n            it = min_s.find(x);\n            if (it == min_s.end() || sum < it->second) {\n                min_s[x] = sum;\n            }\n            sum += x;\n        }\n        return ans == LLONG_MIN ? 0 : ans;\n    }", "trans_code": "def maximumSubarraySum ( nums , k ) :\n    ans , sum = LLONG_MIN , 0\n    min_s = { }\n    for x in nums :\n        it = min_s.get ( x + k , None )\n        if it is not None :\n            ans = max ( ans , sum + x - it )\n        it = min_s.get ( x - k , None )\n        if it is not None :\n            ans = max ( ans , sum + x - it )\n        it = min_s.get ( x )\n        if it is None or sum < it :\n            min_s [ x ] = sum\n        sum += x\n    return ans if ans is LLONG_MIN else ans\n", "reference_code": "def maximumSubarraySum( nums: List[int], k: int) -> int:\n    ans = -inf\n    min_s = defaultdict(lambda: inf)\n    s = 0\n    for x in nums:\n        ans = max(ans, s + x - min(min_s[x - k], min_s[x + k]))\n        min_s[x] = min(min_s[x], s)\n        s += x\n    return ans if ans > -inf else 0", "target_Lan": "python###maximumSubarraySum.py", "target_code_shell": "from typing import List\nfrom collections import defaultdict\nfrom math import inf\n# TOFILL\nif __name__ == \"__main__\":\n    print(maximumSubarraySum([1, 2, 3, 4, 5], 1))\n    print(maximumSubarraySum([-1, -2, -3, -4, -5], 2))\n    print(maximumSubarraySum([0, 0, 0, 0, 0], 0))\n    print(maximumSubarraySum([1000000, -1000000, 1000000, -1000000], 1000000))\n    print(maximumSubarraySum([1, 3, 5, 7, 9], 2))"}, {"source_Lan": "cpp###minimumLevels.cpp", "source_code": "    int minimumLevels(vector<int> &possible) {\n        \n        int n = possible.size();\n        int s = accumulate(possible.begin(), possible.end(), 0) * 2 - n;\n        int pre = 0;\n        for (int i = 0; i < n - 1; i++) {\n            pre += possible[i] ? 2 : -2;\n            if (pre > s) {\n                return i + 1;\n            }\n        }\n        return -1;\n    }", "trans_code": "def minimumLevels ( possible ) :\n    n = len ( possible )\n    s = sum ( possible ) * 2 - n\n    pre = 0\n    for i in range ( n - 1 ) :\n        pre += possible [ i ] or 2\n        if pre > s :\n            return i + 1\n    return -1\n", "reference_code": "def minimumLevels( possible: List[int]) -> int:\n    # cnt1 - cnt0 = cnt1 - (n - cnt1) = cnt1 * 2 - n\n    s = sum(possible) * 2 - len(possible)\n    pre = 0\n    for i, x in enumerate(possible[:-1]):\n        pre += 2 if x else -2\n        if pre > s:\n            return i + 1\n    return -1", "target_Lan": "python###minimumLevels.py", "target_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(minimumLevels([0, 0, 0, 0, 0]))\n    print(minimumLevels([1, 1, 1, 1, 1]))\n    print(minimumLevels([0, 1, 0, 1, 0]))\n    print(minimumLevels([1, 0, 1, 0, 1]))\n    print(minimumLevels([1, 1, 1, 0, 0]))"}, {"source_Lan": "cpp###minimumDistance.cpp", "source_code": "    int minimumDistance(vector<vector<int>>& points) {\n        multiset<int> sx, sy;\n        for (auto & p : points) {\n            sx.emplace(p[0] - p[1]);\n            sy.emplace(p[0] + p[1]);\n        }\n        int res = INT_MAX;\n        for (auto &p : points) {\n            sx.erase(sx.find(p[0] - p[1]));\n            sy.erase(sy.find(p[0] + p[1]));\n            res = min(res, max(*sx.rbegin() - *sx.begin(), *sy.rbegin() - *sy.begin()));\n            sx.emplace(p[0] - p[1]);\n            sy.emplace(p[0] + p[1]);\n        }\n        return res;\n    }", "trans_code": "def minimumDistance ( points ) :\n    sx , sy = multiset ( ) , multiset ( )\n    for p in points :\n        sx.add ( p [ 0 ] - p [ 1 ] )\n        sy.add ( p [ 0 ] + p [ 1 ] )\n    res = sys.maxint\n    for p in points :\n        sx.remove ( p [ 0 ] - p [ 1 ] )\n        sy.remove ( p [ 0 ] + p [ 1 ] )\n        res = min ( res , max ( * sx ) - max ( * sy ) )\n        sx.add ( p [ 0 ] - p [ 1 ] )\n        sy.add ( p [ 0 ] + p [ 1 ] )\n    return res\n", "reference_code": "def minimumDistance( points: List[List[int]]) -> int:\n    sx = SortedList(p[0] - p[1] for p in points)\n    sy = SortedList(p[0] + p[1] for p in points)\n    res = float('inf')\n    for p in points:\n        sx.remove(p[0] - p[1])\n        sy.remove(p[0] + p[1])\n        res = min(res, max(sx[-1] - sx[0], sy[-1] - sy[0]))\n        sx.add(p[0] - p[1])\n        sy.add(p[0] + p[1])\n    return res", "target_Lan": "python###minimumDistance.py", "target_code_shell": "from sortedcontainers import SortedList\nfrom typing import List\nfrom sortedcontainers import SortedList\n# TOFILL\nif __name__ == \"__main__\":\n    print(minimumDistance([[0,0],[1,1],[2,2]]))\n    print(minimumDistance([[0,0],[1,0],[2,0]]))\n    print(minimumDistance([[0,0],[0,1],[0,2]]))\n    print(minimumDistance([[0,0],[1,2],[3,4]]))\n    print(minimumDistance([[0,0],[0,1],[1,0]]))"}, {"source_Lan": "cpp###maximumBeauty.cpp", "source_code": "    int maximumBeauty(vector<int>& nums, int k) {\n        int res = 0, n = nums.size();\n        sort(nums.begin(), nums.end());\n        for (int i = 0, j = 0; i < n; i++) {\n            while (nums[i] - 2 * k > nums[j]) {\n                j++;\n            }\n            res = max(res, i - j + 1);\n        }\n        return res;\n    }", "trans_code": "def maximum_beauty ( nums , k ) :\n    res , n = 0 , len ( nums )\n    nums = sorted ( nums )\n    for i , j in enumerate ( nums ) :\n        while nums [ i ] - 2 * k > nums [ j ] :\n            j += 1\n        res = max ( res , i - j + 1 )\n    return res\n", "reference_code": "def maximumBeauty( nums: List[int], k: int) -> int:\n    res, j, n = 0, 0, len(nums)\n    nums.sort()\n    for i in range(n):\n        while nums[i] - 2 * k > nums[j]:\n            j += 1\n        res = max(res, i - j + 1)\n    return res", "target_Lan": "python###maximumBeauty.py", "target_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(maximumBeauty([1, 2, 3, 4, 5], 1))\n    print(maximumBeauty([5, 4, 3, 2, 1], 2))\n    print(maximumBeauty([1, 1, 1, 1, 1], 0))\n    print(maximumBeauty([10, 20, 30, 40, 50], 5))\n    print(maximumBeauty([100, 200, 300, 400, 500], 100))"}, {"source_Lan": "cpp###totalCost.cpp", "source_code": "    long long totalCost(vector<int>& costs, int k, int candidates) {\n        int n = costs.size();\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> q;\n        int left = candidates - 1, right = n - candidates;\n        if (left + 1 < right) {\n            for (int i = 0; i <= left; ++i) {\n                q.emplace(costs[i], i);\n            }\n            for (int i = right; i < n; ++i) {\n                q.emplace(costs[i], i);\n            }\n        }\n        else {\n            for (int i = 0; i < n; ++i) {\n                q.emplace(costs[i], i);\n            }\n        }\n        long long ans = 0;\n        for (int _ = 0; _ < k; ++_) {\n            auto [cost, id] = q.top();\n            q.pop();\n            ans += cost;\n            if (left + 1 < right) {\n                if (id <= left) {\n                    ++left;\n                    q.emplace(costs[left], left);\n                }\n                else {\n                    --right;\n                    q.emplace(costs[right], right);\n                }\n            }\n        }\n        return ans;\n    }", "trans_code": "def total_cost ( costs , k , candidates ) :\n    n = len ( costs )\n    q = PriorityQueue ( )\n    left , right = candidates - 1 , n - candidates\n    if left + 1 < right :\n        for i in range ( 0 , left + 1 ) :\n            q.put ( costs [ i ] , i )\n        for i in range ( right , n ) :\n            q.put ( costs [ i ] , i )\n    else :\n        for i in range ( n ) :\n            q.put ( costs [ i ] , i )\n    ans = 0\n    for _ in range ( k ) :\n        [ cost , id ] = q.get ( )\n        q.put ( cost )\n        ans += cost\n        if left + 1 < right :\n            if id <= left :\n                left += 1\n                q.put ( costs [ left ] , left )\n            else :\n                right -= 1\n                q.put ( costs [ right ] , right )\n    return ans\n", "reference_code": "def totalCost( costs: List[int], k: int, candidates: int) -> int:\n    n = len(costs)\n    q = list()\n    left, right = candidates - 1, n - candidates\n    if left + 1 < right:\n        for i in range(left + 1):\n            heappush(q, (costs[i], i))\n        for i in range(right, n):\n            heappush(q, (costs[i], i))\n    else:\n        for i in range(n):\n            heappush(q, (costs[i], i))\n    ans = 0\n    for _ in range(k):\n        cost, idx = heappop(q)\n        ans += cost\n        if left + 1 < right:\n            if idx <= left:\n                left += 1\n                heappush(q, (costs[left], left))\n            else:\n                right -= 1\n                heappush(q, (costs[right], right))\n    return ans", "target_Lan": "python###totalCost.py", "target_code_shell": "from typing import List\nfrom heapq import heappush, heappop\n# TOFILL\nif __name__ == \"__main__\":\n    print(totalCost([1,2,3,4,5], 2, 2))\n    print(totalCost([5,4,3,2,1], 3, 1))\n    print(totalCost([10,20,30,40,50], 4, 3))\n    print(totalCost([100,200,300,400,500], 5, 4))\n    print(totalCost([1000,2000,3000,4000,5000], 1, 5))"}, {"source_Lan": "cpp###distinctIntegers.cpp", "source_code": "    int distinctIntegers(int n) {\n        vector<int> nums(n + 1);\n        nums[n] = 1;\n        for (int k = 0; k < n; k++) {\n            for (int x = 1; x <= n; x++) {\n                if (nums[x] == 0) {\n                    continue;\n                }\n                for (int i = 1; i <= n; i++) {\n                    if (x % i == 1) {\n                        nums[i] = 1;\n                    }\n                }\n            }\n        }\n        return accumulate(nums.begin(), nums.end(), 0);\n    }", "trans_code": "def distinctIntegers ( n ) :\n    nums = range ( n + 1 )\n    nums [ n ] = 1\n    for k in range ( n ) :\n        for x in range ( 1 , n + 1 ) :\n            if nums [ x ] == 0 :\n                continue\n            for i in range ( 1 , n + 1 ) :\n                if x % i == 1 :\n                    nums [ i ] = 1\n    return sum ( nums )\n", "reference_code": "def distinctIntegers( n: int) -> int:\n    nums = [0] * (n + 1)\n    nums[n] = 1\n    for _ in range(0, n):\n        for x in range(1, n + 1):\n            if nums[x] == 0:\n                continue\n            for i in range(1, n + 1):\n                if x % i == 1:\n                    nums[i] = 1\n    return sum(nums)", "target_Lan": "python###distinctIntegers.py", "target_code_shell": "# TOFILL\nif __name__ == \"__main__\":\n    print(distinctIntegers(0))\n    print(distinctIntegers(1))\n    print(distinctIntegers(5))\n    print(distinctIntegers(10))\n    print(distinctIntegers(100))"}, {"source_Lan": "cpp###divisibilityArray.cpp", "source_code": "    vector<int> divisibilityArray(string word, int m) {\n        vector<int> res;\n        long long cur = 0;\n        for (char& c : word) {\n            cur = (cur * 10 + (c - '0')) % m;\n            res.push_back(cur == 0 ? 1 : 0);\n        }\n        return res;\n    }", "trans_code": "def divisibilityArray ( word , m ) :\n    res = [ ]\n    cur = 0\n    for c in word :\n        cur = ( cur * 10 + ( c - '0' ) ) % m\n        res.append ( cur == 0 )\n    return res\n", "reference_code": "def divisibilityArray( word, m):\n    cur = 0\n    res = []\n    for c in word:\n        cur = (cur * 10 + int(c)) % m\n        res.append(1 if cur == 0 else 0)\n    return res", "target_Lan": "python###divisibilityArray.py", "target_code_shell": "# TOFILL\nif __name__ == \"__main__\":\n    print(divisibilityArray(\"123456789\", 2))\n    print(divisibilityArray(\"987654321\", 3))\n    print(divisibilityArray(\"111111111\", 1))\n    print(divisibilityArray(\"000000000\", 10))\n    print(divisibilityArray(\"123456789\", 10000))"}, {"source_Lan": "cpp###minimumTime.cpp", "source_code": "    int minimumTime(vector<int>& nums1, vector<int>& nums2, int x) {\n        int n = nums1.size();\n        vector<vector<int>> dp(n + 1, vector<int>(n + 1, 0));\n        vector<pair<int, int>> nums(n);\n        for (int i = 0; i < n; i++) {\n            nums[i] = {nums2[i], nums1[i]};\n        }\n        sort(nums.begin(), nums.end());\n        for (int j = 1; j <= n; j++) {\n            int b = nums[j - 1].first, a = nums[j - 1].second;\n            for (int i = j; i > 0; i--) {\n                dp[j][i] = max(dp[j - 1][i], dp[j - 1][i - 1] + i * b + a);\n            }\n        }\n        int s1 = accumulate(nums1.begin(), nums1.end(), 0);\n        int s2 = accumulate(nums2.begin(), nums2.end(), 0);\n        for (int i = 0; i <= n; i++) {\n            if (s2 * i + s1 - dp[n][i] <= x) {\n                return i;\n            }\n        }\n        return -1;\n    }", "trans_code": "def minimumTime ( nums1 , nums2 , x ) :\n    n = len ( nums1 )\n    dp = np.zeros ( ( n + 1 , n + 1 ) )\n    nums = [ [ nums2 [ i ] , nums1 [ i ] ] for i in range ( n ) ]\n    nums = sorted ( nums )\n    for j in range ( 1 , n + 1 ) :\n        b , a = nums [ j - 1 ] [ 0 ] , nums [ j - 1 ] [ 1 ]\n        for i in range ( j , i > 0 , - 1 ) :\n            dp [ j ] [ i ] = max ( dp [ j - 1 ] [ i ] , dp [ j - 1 ] [ i - 1 ] + i * b + a )\n    s1 = sum ( nums1 )\n    s2 = sum ( nums2 )\n    for i in range ( 0 , n + 1 ) :\n        if s2 * i + s1 - dp [ n ] [ i ] <= x :\n            return i\n    return -1\n", "reference_code": "def minimumTime( nums1: List[int], nums2: List[int], x: int) -> int:\n    n = len(nums1)\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    for j, (b, a) in enumerate(sorted(zip(nums2, nums1)), 1):\n        for i in range(j, 0, -1):\n            dp[j][i] = max(dp[j - 1][i], dp[j - 1][i - 1] + i * b + a)\n    sa, sb = sum(nums1), sum(nums2)\n    for i in range(0, n + 1):\n        if sb * i + sa - dp[n][i] <= x:\n            return i\n    return -1", "target_Lan": "python###minimumTime.py", "target_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(minimumTime([1,2,3,4,5], [1,2,3,4,5], 15))\n    print(minimumTime([1,1,1,1,1], [1,1,1,1,1], 5))\n    print(minimumTime([1,2,3,4,5], [5,4,3,2,1], 15))\n    print(minimumTime([10,20,30,40,50], [1,2,3,4,5], 100))\n    print(minimumTime([1,2,3,4,5], [5,5,5,5,5], 20))"}, {"source_Lan": "cpp###minLength.cpp", "source_code": "    int minLength(string s) {\n        vector<int> st;\n        for (char c : s) {\n            st.push_back(c);\n            int m = st.size();\n            if (m >= 2 &&\n                (st[m - 2] == 'A' && st[m - 1] == 'B' ||\n                st[m - 2] == 'C' && st[m - 1] == 'D')) {\n                st.pop_back();\n                st.pop_back();\n            }\n        }\n        return st.size();\n    }", "trans_code": "def minLength ( s ) :\n    st = [ ]\n    for c in s :\n        st.append ( c )\n        m = len ( st )\n        if m >= 2 and ( st [ m - 2 ] == 'A' and st [ m - 1 ] == 'B' or st [ m - 2 ] == 'C' and st [ m - 1 ] == 'D' ) :\n            st.pop ( )\n            st.pop ( )\n    return len ( st )\n", "reference_code": "def minLength( s: str) -> int:\n    stack = []\n    for c in s:\n        stack.append(c)\n        if len(stack) >= 2 and ((stack[-2] == 'A' and stack[-1] == 'B') or (stack[-2] == 'C' and stack[-1] == 'D')):\n            stack.pop()\n            stack.pop()\n    return len(stack)", "target_Lan": "python###minLength.py", "target_code_shell": "# TOFILL\nif __name__ == \"__main__\":\n    print(minLength(\"AB\"))\n    print(minLength(\"ABCD\"))\n    print(minLength(\"ABCDEF\"))\n    print(minLength(\"ABABAB\"))\n    print(minLength(\"CDCDCD\"))"}, {"source_Lan": "cpp###addMinimum.cpp", "source_code": "    int addMinimum(string word) {\n        int n = word.size();\n        vector<int> d(n + 1);\n        for (int i = 1; i <= n; i++) {\n            d[i] = d[i - 1] + 2;\n            if (i > 1 && word[i - 1] > word[i - 2]) {\n                d[i] = d[i - 1] - 1;\n            }\n        }\n        return d[n];\n    }", "trans_code": "def addMinimum ( word ) :\n    n = len ( word )\n    d = [ 0 ] * ( n + 1 )\n    for i in range ( 1 , n + 1 ) :\n        d [ i ] = d [ i - 1 ] + 2\n        if i > 1 and word [ i - 1 ] > word [ i - 2 ] :\n            d [ i ] = d [ i - 1 ] - 1\n    return d [ n ]\n", "reference_code": "def addMinimum( word: str) -> int:\n    n = len(word)\n    d = [0] * (n + 1)\n    for i in range(1, n + 1):\n        d[i] = d[i - 1] + 2\n        if i > 1 and word[i - 1] > word[i - 2]:\n            d[i] = d[i - 1] - 1\n    return d[n]", "target_Lan": "python###addMinimum.py", "target_code_shell": "# TOFILL\nif __name__ == \"__main__\":\n    print(addMinimum(\"a\"))\n    print(addMinimum(\"abc\"))\n    print(addMinimum(\"cba\"))\n    print(addMinimum(\"zzz\"))\n    print(addMinimum(\"aaa\"))"}, {"source_Lan": "cpp###frequency.cpp", "source_code": "    vector<int> frequency(int n, vector<int> &a){\n        vector<int>ans(n);\n        unordered_map<int,int>mp;\n        for(int i=n-1;i>-1;i--)\n        {\n            mp[a[i]]++;\n            ans[i]=mp[a[i]];\n        }\n        return ans;\n    }", "trans_code": "def frequency ( n , a ) :\n    ans = [ 0 ] * n\n    mp = { }\n    for i in range ( n - 1 , -1 , - 1 ) :\n        mp [ a [ i ] ] += 1\n        ans [ i ] = mp [ a [ i ] ]\n    return ans\n", "reference_code": "def frequency( n ,a):\n    mp=dict()\n    for i in range(n):\n        if a[i] in mp:\n            mp[a[i]]+=1\n        else:\n            mp[a[i]]=1\n    ans=[]\n    for i in range(n):\n        ans.append(mp[a[i]])\n        mp[a[i]]-=1\n    return ans", "target_Lan": "python###frequency.py", "target_code_shell": "# TOFILL\nif __name__ == \"__main__\":\n    print(frequency(0, []))\n    print(frequency(1, [1]))\n    print(frequency(2, [1, 2]))\n    print(frequency(3, [1, 2, 2]))\n    print(frequency(4, [1, 2, 2, 1]))"}, {"source_Lan": "cpp###findGoodPairs.cpp", "source_code": "    long long findGoodPairs(vector<int> a, int n, int k) {\n        map<int, int > ma;\n        long long ans = 0;\n        for (int i = k; i < n; i++) {\n            ma[a[i - k]]++;\n            ans += ma[a[i]];\n        }\n        return ans;\n    }", "trans_code": "def findGoodPairs ( a , n , k ) :\n    ma = { }\n    ans = 0\n    for i in range ( k , n ) :\n        ma [ a [ i - k ] ] += 1\n        ans += ma [ a [ i ] ]\n    return ans\n", "reference_code": "def findGoodPairs( a, n, k):\n    mp=dict()\n    for i in range(n):\n        if (a[i] in mp):\n            mp[a[i]].append(i)\n        else:\n            mp[a[i]]=[i]\n    c=0\n    for i in mp:\n        li=mp[i]\n        le=len(li)\n        i=0\n        j=0\n        while(j<le):\n            if (li[j]-li[i])>=k:\n                c+=(le-j)\n                i+=1\n            else:\n                j+=1\n    return c", "target_Lan": "python###findGoodPairs.py", "target_code_shell": "# TOFILL\nif __name__ == \"__main__\":\n    print(findGoodPairs([1,2,3,4,5], 5, 2))\n    print(findGoodPairs([1,1,1,1,1], 5, 1))\n    print(findGoodPairs([1,2,3,4,5,6,7,8,9,10], 10, 3))\n    print(findGoodPairs([10,20,30,40,50], 5, 1))\n    print(findGoodPairs([1,1,2,2,3,3], 6, 2))"}, {"source_Lan": "cpp###HeightTower.cpp", "source_code": "    int HeightTower(int n, int k, vector<int>& a) {\n        \n        stack<int> st;\n        int totalHeight = 0;\n        int i = 0;\n        \n        for (int j = 0; j < n; j++) {\n            totalHeight += a[j];\n            st.push(a[j]);\n            \n            if (totalHeight > k) {\n                \n                int removeBoxes = i + 1;\n                while (removeBoxes > 0 && !st.empty()) {\n                    totalHeight -= st.top();\n                    st.pop();\n                    removeBoxes--;\n                }\n                i++;\n            }\n        }\n        \n        return totalHeight;\n    }", "trans_code": "def HeightTower ( n , k , a ) :\n    st = stack ( )\n    total_height = 0\n    i = 0\n    for j in range ( n ) :\n        total_height += a [ j ]\n        st.push ( a [ j ] )\n        if total_height > k :\n            remove_boxes = i + 1\n            while remove_boxes > 0 and not st.empty ( ) :\n                total_height -= st.pop ( )\n                st.pop ( )\n                remove_boxes -= 1\n            i += 1\n    return total_height\n", "reference_code": "def Towerheight( n: int, k: int, arr: List[int]) -> int:\n    # Initializing variables and stack.\n    st = []\n    total_height = 0\n    i = 0\n    # Iterating over the boxes.\n    for j in range(n):\n        total_height += arr[j]\n        st.append(arr[j])\n        # Checking if total height exceeds the limit.\n        if total_height > k:\n            # Removing boxes to reduce height.\n            remove_boxes = i + 1\n            while remove_boxes > 0 and st:\n                total_height -= st.pop()\n                remove_boxes -= 1\n            i += 1\n    # Returning the final total height.\n    return total_height", "target_Lan": "python###Towerheight.py", "target_code_shell": "from typing import List\nfrom typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(Towerheight(5, 10, [1, 2, 3, 4, 5]))\n    print(Towerheight(3, 5, [2, 3, 4]))\n    print(Towerheight(2, 1, [1, 1]))\n    print(Towerheight(4, 10, [5, 5, 5, 5]))\n    print(Towerheight(1, 1, [1]))"}, {"source_Lan": "cpp###BeautifulBits.cpp", "source_code": "    vector<int> BeautifulBits(int n, vector<int> &arr, int q,\n                              vector<vector<int> > &queries) {\n        vector<vector<long long> > pref(n + 1, vector<long long>(32, 0));\n        for (int i = 1; i <= n; i++) {\n            for (int j = 0; j < 32; j++) {\n                pref[i][j] = pref[i - 1][j] + ((arr[i - 1] >> j) & 1);\n            }\n        }\n        vector<int> ans(q, 0);\n        for (int i = 0; i < q; i++) {\n            for (int j = 0; j < 32; j++) {\n                if (pref[queries[i][1]][j] - pref[queries[i][0] - 1][j] != 0) {\n                    ans[i] += 1 << j;\n                }\n            }\n        }\n        return ans;\n    }", "trans_code": "def BeautifulBits ( n , arr , q , queries ) :\n    pref = [ long ( 32 ) for i in range ( 1 , n + 1 ) ]\n    for i in range ( 1 , n + 1 ) :\n        for j in range ( 32 ) :\n            pref [ i ] [ j ] = pref [ i - 1 ] [ j ] + ( ( arr [ i - 1 ] >> j ) & 1 )\n    ans = [ 0 ] * q\n    for i in range ( q ) :\n        for j in range ( 32 ) :\n            if pref [ queries [ i ] [ 1 ] ] [ j ] - pref [ queries [ i ] [ 0 ] - 1 ] [ j ] != 0 :\n                ans [ i ] += 1 << j\n    return ans\n", "reference_code": "def BeautifulBits( n : int, arr : List[int], q : int, queries : List[List[int]]) -> List[int]:\n    pref = [[0] * 32 for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(32):\n            pref[i][j] = pref[i - 1][j] + ((arr[i - 1] >> j) & 1)\n    ans = [0] * q\n    for i in range(q):\n        for j in range(32):\n            if pref[queries[i][1]][j] - pref[queries[i][0] - 1][j] != 0:\n                ans[i] += 1 << j\n    return ans", "target_Lan": "python###BeautifulBits.py", "target_code_shell": "from typing import List\nfrom typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(BeautifulBits(5, [1, 2, 3, 4, 5], 2, [[1, 3], [2, 4]]))\n    print(BeautifulBits(10, [10, 20, 30, 40, 50, 60, 70, 80, 90, 100], 3, [[1, 5], [6, 10], [3, 8]]))\n    print(BeautifulBits(0, [], 0, []))\n    print(BeautifulBits(1, [1], 1, [[1, 1]]))\n    print(BeautifulBits(2, [1, 3], 1, [[1, 2]]))"}, {"source_Lan": "cpp###minOPs.cpp", "source_code": "    int minOPs(int n, vector<int> &A)\n    {\n        map<int,int> m;\n        for(auto it:A) m[it]++;\n        vector<int> v;\n        for(auto it:m) v.push_back(it.second);\n        sort(v.begin(),v.end());\n        int sum=0;\n        for(int i=v.size()-1;i>=0;i--)\n        {\n          sum+=v[i];\n          if(sum>(n/2)) return v.size()-1-i;\n        }\n    }", "trans_code": "def minOPs ( n , A ) :\n    m = { }\n    for key in A :\n        m [ key ] += 1\n    v = [ ]\n    for key in m :\n        v.append ( m [ key ] )\n    v = sorted ( v )\n    sum = 0\n    for i in range ( len ( v ) - 1 , - 1 , - 1 ) :\n        sum += v [ i ]\n        if sum > ( n / 2 ) :\n            return len ( v ) - 1 - i\n    return 0\n", "reference_code": "def minOPs( n : int, A : List[int]) -> int:\n    c=Counter(A)\n    t=[]\n    for el in c.values():\n        t.append(el)\n    t.sort()\n    s=0\n    ans=0\n    while s<=(n/2):\n        s+=t.pop()\n        ans+=1\n    return ans-1", "target_Lan": "python###minOPs.py", "target_code_shell": "from typing import List\nfrom collections import Counter\nfrom typing import List\nfrom collections import Counter\n# TOFILL\nif __name__ == \"__main__\":\n    print(minOPs(5, [1, 2, 3, 4, 5]))\n    print(minOPs(10, [1, 1, 1, 2, 2, 2, 3, 3, 3, 4]))\n    print(minOPs(1, [1]))\n    print(minOPs(2, [1, 2]))"}, {"source_Lan": "cpp###minJumps.cpp", "source_code": "    int minJumps(int n, vector<int> &arr) {\n        vector<int> right_greater(n, n);\n        vector<int> right_lesser(n, n);\n        stack<int> st;\n        for (int i = 0; i < n; i++) {\n            while (!st.empty() && arr[st.top()] < arr[i]) {\n                right_greater[st.top()] = i;\n                st.pop();\n            }\n            st.push(i);\n        }\n        stack<int> st1;\n        st = st1;\n        for (int i = 0; i < n; i++) {\n            while (!st.empty() && arr[st.top()] > arr[i]) {\n                right_lesser[st.top()] = i;\n                st.pop();\n            }\n            st.push(i);\n        }\n        deque<pair<int, int>> queue;\n        queue.push_back(make_pair(0, 0));\n        vector<int> visited(n, 0);\n        while (!queue.empty()) {\n            pair<int, int> p = queue.front();\n            queue.pop_front();\n            int idx = p.first;\n            int d = p.second;\n            if (visited[idx] == 1) {\n                continue;\n            }\n            visited[idx] = 1;\n            if (idx == n - 1) {\n                return d;\n            }\n            int temp = idx + 1;\n            if (arr[temp] > arr[idx]) {\n                while (temp != n && arr[temp] > arr[idx]) {\n                    queue.push_back(make_pair(temp, d + 1));\n                    temp = right_lesser[temp];\n                }\n                if (temp != n) {\n                    queue.push_back(make_pair(temp, d + 1));\n                }\n            } else {\n                while (temp != n && arr[temp] < arr[idx]) {\n                    queue.push_back(make_pair(temp, d + 1));\n                    temp = right_greater[temp];\n                }\n                if (temp != n) {\n                    queue.push_back(make_pair(temp, d + 1));\n                }\n            }\n        }\n        return -1;\n    }", "trans_code": "def minJumps ( n , arr ) :\n    right_greater = [ 0 ] * n\n    right_lesser = [ 0 ] * n\n    st = stack ( )\n    for i in range ( n ) :\n        while not st.empty ( ) and arr [ st.top ( ) ] < arr [ i ] :\n            right_greater [ st.top ( ) ] = i\n            st.pop ( )\n        st.push ( i )\n    st1 = stack ( )\n    st = st1\n    for i in range ( n ) :\n        while not st.empty ( ) and arr [ st.top ( ) ] > arr [ i ] :\n            right_lesser [ st.top ( ) ] = i\n            st.pop ( )\n        st.push ( i )\n    queue = deque ( )\n    queue.append ( ( 0 , 0 ) )\n    visited = [ 0 ] * n\n    while not queue.empty ( ) :\n        p = queue.pop ( )\n        queue.extend ( p )\n        idx = p [ 0 ]\n        d = p [ 1 ]\n        if visited [ idx ] == 1 :\n            continue\n        visited [ idx ] = 1\n        if idx == n - 1 :\n            return d\n        temp = idx + 1\n        if arr [ temp ] > arr [ idx ] :\n            while temp != n and arr [ temp ] > arr [ idx ] :\n                queue.append ( ( temp , d + 1 ) )\n                temp = right_lesser [ temp ]\n            if temp != n :\n                queue.append ( ( temp , d + 1 ) )\n        else :\n            while temp != n and arr [ temp ] < arr [ idx ] :\n                queue.append ( ( temp , d + 1 ) )\n                temp = right_greater [ temp ]\n            if temp != n :\n                queue.append ( ( temp , d + 1 ) )\n    return -1\n", "reference_code": "def minJumps( n, arr):\n    right_greater = [n] * n\n    right_lesser = [n] * n\n    stack = []\n    for i in range(n):\n        while stack and arr[stack[-1]] < arr[i]:\n            right_greater[stack[-1]] = i\n            stack.pop()\n        stack.append(i)\n    stack.clear()\n    for i in range(n):\n        while stack and arr[stack[-1]] > arr[i]:\n            right_lesser[stack[-1]] = i\n            stack.pop()\n        stack.append(i)\n    queue = deque([(0, 0)])\n    visited = [0] * n\n    while queue:\n        p, d = queue.popleft()\n        if visited[p] == 1:\n            continue\n        visited[p] = 1\n        if p == n - 1:\n            return d\n        temp = p + 1\n        # max(arr[i], arr[j]) < min(arr[i+1], arr[i+2], ......, arr[j-2], arr[j-1])\n        if arr[temp] > arr[p]:\n            while temp != n and arr[temp] > arr[p]:\n                queue.append((temp, d + 1))\n                temp = right_lesser[temp]\n            if temp != n:\n                queue.append((temp, d + 1))\n        # min(arr[i], arr[j]) < max(arr[i+1], arr[i+2], ......, arr[j-2], arr[j-1])\n        else:\n            while temp != n and arr[temp] < arr[p]:\n                queue.append((temp, d + 1))\n                temp = right_greater[temp]\n            if temp != n:\n                queue.append((temp, d + 1))\n    return -1", "target_Lan": "python###minJumps.py", "target_code_shell": "from collections import deque\nfrom collections import deque\n# TOFILL\nif __name__ == \"__main__\":\n    print(minJumps(5, [1,2,3,4,5]))\n    print(minJumps(5, [5,4,3,2,1]))\n    print(minJumps(5, [1,1,1,1,1]))\n    print(minJumps(5, [1,2,1,2,1]))\n    print(minJumps(5, [2,1,2,1,2]))"}, {"source_Lan": "cpp###prefixDistinct.cpp", "source_code": "    vector<int> prefixDistinct(int n, vector<int> &arr)\n    {\n        vector<int>ans(n);\n        set<int>s;\n        for(int i=0;i<n;i++)\n        {\n            s.insert(arr[i]);\n            ans[i]=s.size();\n        }\n        return ans;\n    }", "trans_code": "def prefix_distinct ( n , arr ) :\n    ans = [ 0 ] * n\n    s = set ( )\n    for i in range ( n ) :\n        s.add ( arr [ i ] )\n        ans [ i ] = len ( s )\n    return ans\n", "reference_code": "def prefixDistinct(n,arr):\n    ans=[]\n    s=set()\n    for el in arr:\n        s.add(el)\n        ans.append(len(s))\n    return ans", "target_Lan": "python###prefixDistinct.py", "target_code_shell": "# TOFILL\nif __name__ == \"__main__\":\n    print(prefixDistinct(0, []))\n    print(prefixDistinct(1, [1]))\n    print(prefixDistinct(2, [1, 2]))\n    print(prefixDistinct(3, [1, 2, 1]))\n    print(prefixDistinct(4, [1, 2, 3, 4]))"}, {"source_Lan": "cpp###maximumSetSize.cpp", "source_code": "    int maximumSetSize(vector<int> &nums1, vector<int> &nums2) {\n        unordered_set<int> set1(nums1.begin(), nums1.end());\n        unordered_set<int> set2(nums2.begin(), nums2.end());\n        int common = 0;\n        for (int x : set1) {\n            common += set2.count(x);\n        }\n        int n1 = set1.size();\n        int n2 = set2.size();\n        int ans = n1 + n2 - common;\n        int m = nums1.size() / 2;\n        if (n1 > m) {\n            int mn = min(n1 - m, common);\n            ans -= n1 - mn - m;\n            common -= mn;\n        }\n        if (n2 > m) {\n            n2 -= min(n2 - m, common);\n            ans -= n2 - m;\n        }\n        return ans;\n    }", "trans_code": "def maximumSetSize ( nums1 , nums2 ) :\n    set1 = set ( nums1 )\n    set2 = set ( nums2 )\n    common = 0\n    for x in set1 :\n        common += set2.count ( x )\n    n1 = len ( set1 )\n    n2 = len ( set2 )\n    ans = n1 + n2 - common\n    m = len ( nums1 ) / 2\n    if n1 > m :\n        mn = min ( n1 - m , common )\n        ans -= n1 - mn - m\n        common -= mn\n    if n2 > m :\n        n2 -= min ( n2 - m , common )\n        ans -= n2 - m\n    return ans\n", "reference_code": "def maximumSetSize( nums1: List[int], nums2: List[int]) -> int:\n    set1 = set(nums1)\n    set2 = set(nums2)\n    common = len(set1 & set2)\n    n1 = len(set1)\n    n2 = len(set2)\n    ans = n1 + n2 - common\n    m = len(nums1) // 2\n    if n1 > m:\n        mn = min(n1 - m, common)\n        ans -= n1 - mn - m\n        common -= mn\n    if n2 > m:\n        n2 -= min(n2 - m, common)\n        ans -= n2 - m\n    return ans", "target_Lan": "python###maximumSetSize.py", "target_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(maximumSetSize([1,2,3,4,5], [4,5,6,7,8]))\n    print(maximumSetSize([1,1,1,1,1], [1,1,1,1,1]))\n    print(maximumSetSize([1,2,3,4,5], [6,7,8,9,10]))\n    print(maximumSetSize([1,2,3,4,5,6,7,8,9,10], [1,2,3,4,5,6,7,8,9,10]))\n    print(maximumSetSize([1,2,3,4,5,6,7,8,9,10], [11,12,13,14,15,16,17,18,19,20]))"}, {"source_Lan": "cpp###sumDigitDifferences.cpp", "source_code": "    long long sumDigitDifferences(vector<int>& nums) {\n        long long ans = 0;\n        vector<array<int, 10>> cnt(to_string(nums[0]).length());\n        for (int k = 0; k < nums.size(); k++) {\n            int x = nums[k];\n            for (int i = 0; x; x /= 10, i++) {\n                int d = x % 10;\n                ans += k - cnt[i][d]++;\n            }\n        }\n        return ans;\n    }", "trans_code": "def sumDigitDifferences ( nums ) :\n    ans = 0\n    cnt = array ( str ( nums [ 0 ] ).split ( ) )\n    for k in range ( len ( nums ) ) :\n        x = nums [ k ]\n        for i in range ( 0 , x , 10 ) :\n            d = x % 10\n            ans += k - cnt [ i ] [ d ] + 1\n    return ans\n", "reference_code": "def sumDigitDifferences( nums: List[int]) -> int:\n    ans = 0\n    cnt = [[0] * 10 for _ in str(nums[0])]\n    for k, x in enumerate(nums):\n        i = 0\n        while x:\n            x, d = divmod(x, 10)\n            ans += k - cnt[i][d]\n            cnt[i][d] += 1\n            i += 1\n    return ans", "target_Lan": "python###sumDigitDifferences.py", "target_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(sumDigitDifferences([1, 2, 3, 4, 5]))\n    print(sumDigitDifferences([10, 20, 30, 40, 50]))\n    print(sumDigitDifferences([100, 200, 300, 400, 500]))\n    print(sumDigitDifferences([1000, 2000, 3000, 4000, 5000]))\n    print(sumDigitDifferences([10000, 20000, 30000, 40000, 50000]))"}, {"source_Lan": "cpp###maximumPrimeDifference.cpp", "source_code": "    int maximumPrimeDifference(vector<int>& nums) {\n        unordered_set<int> primes = {\n            2, 3, 5, 7, 11,\n            13, 17, 19, 23, 29,\n            31, 37, 41, 43, 47,\n            53, 59, 61, 67, 71,\n            73, 79, 83, 89, 97\n        };\n        int n = nums.size();\n        int first = -1, ans = 0;\n        for (int i = 0; i < n; ++i) {\n            if (primes.count(nums[i])) {\n                if (first != -1) {\n                    ans = max(ans, i - first);\n                }\n                else {\n                    first = i;\n                }\n            }\n        }\n        return ans;\n    }", "trans_code": "def maximum_prime_difference ( nums ) :\n    primes = set ( [ 2 , 3 , 5 , 7 , 11 , 13 , 17 , 19 , 23 , 29 , 31 , 37 , 41 , 43 , 47 , 53 , 59 , 61 , 67 , 71 , 73 , 79 , 83 , 89 , 97 ] )\n    n = len ( nums )\n    first , ans = -1 , 0\n    for i in range ( n ) :\n        if primes.issuperset ( nums [ i ] ) :\n            if first != -1 :\n                ans = max ( ans , i - first )\n            else :\n                first = i\n    return ans\n", "reference_code": "def maximumPrimeDifference( nums: List[int]) -> int:\n    primes = {\n        2, 3, 5, 7, 11,\n        13, 17, 19, 23, 29,\n        31, 37, 41, 43, 47,\n        53, 59, 61, 67, 71,\n        73, 79, 83, 89, 97\n    }\n    first, ans = -1, 0\n    for i, num in enumerate(nums):\n        if num in primes:\n            if first != -1:\n                ans = max(ans, i - first)\n            else:\n                first = i\n    return ans", "target_Lan": "python###maximumPrimeDifference.py", "target_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(maximumPrimeDifference([2, 3, 5, 7, 11]))\n    print(maximumPrimeDifference([13, 17, 19, 23, 29]))\n    print(maximumPrimeDifference([31, 37, 41, 43, 47]))\n    print(maximumPrimeDifference([53, 59, 61, 67, 71]))\n    print(maximumPrimeDifference([73, 79, 83, 89, 97]))"}, {"source_Lan": "cpp###goodSubsetofBinaryMatrix.cpp", "source_code": "    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid) {\n        vector<int> ans;\n        unordered_map<int, int> mp;\n        int m = grid.size();\n        int n = grid[0].size();\n        for (int j = 0; j < m; j++) {\n            int st = 0;\n            for (int i = 0; i < n; i++) {\n                st |= (grid[j][i] << i);\n            }\n            mp[st] = j;\n        }\n        if (mp.count(0)) {\n            ans.push_back(mp[0]);\n            return ans;\n        }\n        for (auto [x, i]: mp) {\n            for (auto [y, j]: mp) {\n                if (!(x & y)) {\n                    return {min(i, j), max(i, j)};\n                }\n            }\n        }\n        return ans;\n    }", "trans_code": "def goodSubsetofBinaryMatrix ( grid ) :\n    ans = [ ]\n    mp = { }\n    m = len ( grid )\n    n = len ( grid [ 0 ] )\n    for j in range ( m ) :\n        st = 0\n        for i in range ( n ) :\n            st |= ( grid [ j ] [ i ] << i )\n        mp [ st ] = j\n    if mp.has_key ( 0 ) :\n        ans.append ( mp [ 0 ] )\n        return ans\n    for [ x , i ] in mp.items ( ) :\n        for [ y , j ] in mp.items ( ) :\n            if not ( x & y ) :\n                return [ min ( i , j ) , max ( i , j ) ]\n    return ans\n", "reference_code": "def goodSubsetofBinaryMatrix( grid: List[List[int]]) -> List[int]:\n    ans = []\n    mp = {}\n    m = len(grid)\n    n = len(grid[0])\n    for j in range(m):\n        st = 0\n        for i in range(n):\n            st |= (grid[j][i] << i)\n        mp[st] = j\n    if 0 in mp:\n        ans.append(mp[0])\n        return ans\n    for x, i in mp.items():\n        for y, j in mp.items():\n            if not (x & y):\n                return [min(i, j), max(i, j)]\n    return ans", "target_Lan": "python###goodSubsetofBinaryMatrix.py", "target_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(goodSubsetofBinaryMatrix([[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]]))\n    print(goodSubsetofBinaryMatrix([[1,1,1,1,1],[1,1,1,1,1],[1,1,1,1,1],[1,1,1,1,1],[1,1,1,1,1]]))\n    print(goodSubsetofBinaryMatrix([[1,0,1,0,1],[0,1,0,1,0],[1,0,1,0,1],[0,1,0,1,0],[1,0,1,0,1]]))\n    print(goodSubsetofBinaryMatrix([[1,1,1,1,1],[0,0,0,0,0],[1,1,1,1,1],[0,0,0,0,0],[1,1,1,1,1]]))\n    print(goodSubsetofBinaryMatrix([[0,1,0,1,0],[1,0,1,0,1],[0,1,0,1,0],[1,0,1,0,1],[0,1,0,1,0]]))"}, {"source_Lan": "cpp###stoneGameVI.cpp", "source_code": "    int stoneGameVI(vector<int>& aliceValues, vector<int>& bobValues) {\n        int n = aliceValues.size();\n        vector<tuple<int, int, int>> values;\n        for (int i = 0; i < aliceValues.size(); i++) {\n            values.emplace_back(aliceValues[i] + bobValues[i], aliceValues[i], bobValues[i]);\n        }\n        sort(values.begin(), values.end(), [](tuple<int, int, int> &a, tuple<int, int, int> &b) {\n            return get<0>(a) > get<0>(b);\n        });\n        int aliceSum = 0, bobSum = 0;\n        for (int i = 0; i < n; i++) {\n            if (i % 2 == 0) {\n                aliceSum += get<1>(values[i]);\n            } else {\n                bobSum += get<2>(values[i]);\n            }\n        }\n        if (aliceSum > bobSum) {\n            return 1;\n        } else if (aliceSum == bobSum) {\n            return 0;\n        } else {\n            return -1;\n        }\n    }", "trans_code": "def stoneGameVI ( aliceValues , bobValues ) :\n    n = len ( aliceValues )\n    values = [ ]\n    for i in range ( len ( aliceValues ) ) :\n        values.append ( ( aliceValues [ i ] + bobValues [ i ] , aliceValues [ i ] , bobValues [ i ] ) )\n    values.sort ( key = lambda a , b : get ( 0 , a ) > get ( 0 , b ) )\n    aliceSum , bobSum = 0 , 0\n    for i in range ( n ) :\n        if i % 2 == 0 :\n            aliceSum += get ( 1 , values [ i ] )\n        else :\n            bobSum += get ( 2 , values [ i ] )\n    if aliceSum > bobSum :\n        return 1\n    elif aliceSum == bobSum :\n        return 0\n    else :\n        return -1\n", "reference_code": "def stoneGameVI( aliceValues: List[int], bobValues: List[int]) -> int:\n    values = [[a+b, a, b] for a, b in zip(aliceValues, bobValues)]\n    values.sort(reverse=True)\n    aliceSum, bobSum = sum(value[1] for value in values[::2]), sum(value[2] for value in values[1::2])\n    if aliceSum > bobSum:\n        return 1\n    elif aliceSum == bobSum:\n        return 0\n    else:\n        return -1", "target_Lan": "python###stoneGameVI.py", "target_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(stoneGameVI([1,2,3,4,5], [2,3,4,5,1]))\n    print(stoneGameVI([10,20,30,40,50], [50,40,30,20,10]))\n    print(stoneGameVI([1,1,1,1,1], [1,1,1,1,1]))\n    print(stoneGameVI([100,200,300,400,500], [500,400,300,200,100]))\n    print(stoneGameVI([1,2,3,4,5], [5,4,3,2,1]))"}, {"source_Lan": "cpp###arrangingHorses.cpp", "source_code": "    vector<int> arrangingHorses(int n, int m, vector<vector<int>>& data) {\n        vector<int> inDegree(n, 0);\n        vector<vector<int>> adjList(n);\n        for (const auto& edge : data) {\n            int a = edge[0], b = edge[1];\n            adjList[b].push_back(a); \n            ++inDegree[a];\n        }\n        priority_queue<int, vector<int>, greater<int>> pq; \n        for (int i = 0; i < n; ++i) {\n            if (inDegree[i] == 0)\n                pq.push(i);\n        }\n        vector<int> order;\n        while (!pq.empty()) {\n            int horse = pq.top();\n            pq.pop();\n            order.push_back(horse);\n            for (int neigh : adjList[horse]) {\n                --inDegree[neigh];\n                if (inDegree[neigh] == 0)\n                    pq.push(neigh);\n            }\n        }\n        return order;\n    }", "trans_code": "def arranging_horses ( n , m , data ) :\n    in_degree = [ 0 ] * n\n    adj_list = [ ]\n    for edge in data :\n        a , b = edge\n        adj_list [ b ].append ( a )\n        in_degree [ a ] += 1\n    pq = PriorityQueue ( )\n    for i in range ( n ) :\n        if in_degree [ i ] == 0 :\n            pq.put ( i )\n    order = [ ]\n    while not pq.empty ( ) :\n        horse = pq.get ( )\n        pq.put ( )\n        order.append ( horse )\n        for neigh in adj_list [ horse ] :\n            del in_degree [ neigh ]\n            if in_degree [ neigh ] == 0 :\n                pq.put ( neigh )\n    return order\n", "reference_code": "def arrangingHorses( n: int, m: int,\n                    data: List[List[int]]) -> List[int]:\n    deg = [0] * (n)\n    g = [[] for _ in range(n)]\n    for el in data:\n        deg[el[0]] += 1\n        g[el[1]].append(el[0])\n    q = []\n    ans = []\n    for i in range(n):\n        if deg[i] == 0:\n            heappush(q, i)\n    while q:\n        node = heappop(q)\n        ans.append(node)\n        for el in g[node]:\n            deg[el] -= 1\n            if deg[el] == 0:\n                heappush(q, el)\n    return ans", "target_Lan": "python###arrangingHorses.py", "target_code_shell": "from typing import List\nfrom heapq import *\nfrom typing import List\nfrom typing import List\nfrom heapq import heappush, heappop\n# TOFILL\nif __name__ == \"__main__\":\n    print(arrangingHorses(0, 0, []))\n    print(arrangingHorses(1, 0, []))\n    print(arrangingHorses(3, 0, [])) \n    print(arrangingHorses(4, 4, [[0, 1], [0, 2], [1, 3], [2, 3]]))"}, {"source_Lan": "cpp###matchingCnt.cpp", "source_code": "    vector<int> matchingCnt(int n, vector<string>& X) {\n        unordered_map<int, array<int, 26>> map;\n        vector<int> ans(n);\n        for (int i = n - 1; i >= 0; i--) {\n            string x = X[i];\n            int cans = 0;\n            for (int j = 0; j < x.length(); j++) {\n                if (map.find(j) == map.end()) {\n                    map[j] = array<int, 26>{};\n                }\n                cans += map[j][x[j] - 'a'];\n                map[j][x[j] - 'a']++;\n            }\n            ans[i] = cans;\n        }\n        return ans;\n    }", "trans_code": "def matching_cnt ( n , X ) :\n    d = { }\n    ans = [ 0 ] * n\n    for i in range ( n - 1 , - 1 , - 1 ) :\n        x = X [ i ]\n        cans = 0\n        for j in range ( len ( x ) ) :\n            if d.get ( j ) == None :\n                d [ j ] = { }\n            cans += d [ j ] [ x [ j ] - 'a' ]\n            d [ j ] [ x [ j ] - 'a' ] += 1\n        ans [ i ] = cans\n    return ans\n", "reference_code": "def matchingCnt( n: int, X: List[str]) -> List[int]:\n    mp = []\n    ans = [0] * n\n    for i in range(n - 1, -1, -1):\n        s = X[i]\n        for j in range(len(s)):\n            #if the length of mp is equal to current index, add a new row.\n            if len(mp) == j:\n                mp.append([0] * 26)\n            #update the answer with the count of matching characters.\n            ans[i] += mp[j][ord(s[j]) - 97]\n            mp[j][ord(s[j]) - 97] += 1\n    return ans", "target_Lan": "python###matchingCnt.py", "target_code_shell": "from typing import List\nfrom typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(matchingCnt(0, []))\n    print(matchingCnt(1, [\"abc\"]))\n    print(matchingCnt(3, [\"a\", \"ab\", \"abc\"]))\n    print(matchingCnt(4, [\"a\", \"a\", \"a\", \"a\"]))\n    print(matchingCnt(5, [\"abc\", \"cba\", \"abc\", \"xyz\", \"abc\"]))"}, {"source_Lan": "cpp###findAnswer.cpp", "source_code": "  vector<int> findAnswer(int n, vector<int> &A)\n  {\n    vector<long long> pref(n, A[0]);\n    for (int i = 1; i < n; i++)\n    {\n      pref[i] = pref[i - 1] + A[i];\n    }\n    stack<int> s;\n    vector<int> res(n+1, 0);\n    for (int i = 0; i < n; i++)\n    {\n      if (pref[i] > 0)\n      {\n        res[0] = i + 1;\n        break;\n      }\n    }\n    for (int i = n - 1; i >= 0; i--)\n    {\n      while (!s.empty() && pref[s.top()] <= pref[i])\n        s.pop();\n      if (s.empty())\n        res[i+1] = 0;\n      else if (i < n - 1)\n        res[i + 1] = s.top() - i;\n      s.push(i);\n    }\n    res.pop_back();\n    return res;\n  }", "trans_code": "def findAnswer ( n , A ) :\n    pref = [ A [ 0 ] ]\n    for i in range ( 1 , n ) :\n        pref [ i ] = pref [ i - 1 ] + A [ i ]\n    s = stack ( )\n    res = [ 0 ] * ( n + 1 )\n    for i in range ( n ) :\n        if pref [ i ] > 0 :\n            res [ 0 ] = i + 1\n            break\n    for i in range ( n - 1 , - 1 , - 1 ) :\n        while not s and pref [ s.pop ( ) ] <= pref [ i ] :\n            s.pop ( )\n        if not s :\n            res [ i + 1 ] = 0\n        elif i < n - 1 :\n            res [ i + 1 ] = s.pop ( ) - i\n        s.append ( i )\n    res.reverse ( )\n    return res\n", "reference_code": "def findAnswer( n : int, A : List[int]) -> List[int]:\n    pref=[A[0]]\n    for i in range(1,n):\n        pref.append(pref[-1]+A[i])\n    s=[]\n    res=[0]*(n+1)\n    for i in range(n):\n        if pref[i]>0:\n            res[0]=i+1\n            break\n    for i in range(n-1,-1,-1):\n        while s and pref[s[-1]]<=pref[i]:\n            s.pop()\n        if not s:\n            res[i+1]=0\n        elif i<n-1:\n            res[i+1]=s[-1]-i\n        s.append(i)\n    res.pop()\n    return res", "target_Lan": "python###findAnswer.py", "target_code_shell": "from typing import List\nfrom typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(findAnswer(5, [1, 2, 3, 4, 5]))\n    print(findAnswer(5, [-1, -2, -3, -4, -5]))\n    print(findAnswer(6, [-1, 0, 1, -2, 2, 0]))\n    print(findAnswer(3, [int(1e9), int(1e9), int(1e9)]))\n    print(findAnswer(1, [2]))"}, {"source_Lan": "cpp###isArraySpecial.cpp", "source_code": "    bool isArraySpecial(vector<int>& nums) {\n        for (int i = 1; i < nums.size(); i++) {\n            if (nums[i - 1] % 2 == nums[i] % 2) {\n                return false;\n            }\n        }\n        return true;\n    }", "trans_code": "def isArraySpecial ( nums ) :\n    for i in range ( 1 , len ( nums ) ) :\n        if nums [ i - 1 ] % 2 == nums [ i ] % 2 :\n            return False\n    return True\n", "reference_code": "def isArraySpecial( nums: List[int]) -> bool:\n    return all(x % 2 != y % 2 for x, y in pairwise(nums))", "target_Lan": "python###isArraySpecial.py", "target_code_shell": "from typing import List\nfrom more_itertools import pairwise\n# TOFILL\nif __name__ == \"__main__\":\n    print(isArraySpecial([]))                       # Test input 1\n    print(isArraySpecial([1]))                      # Test input 2\n    print(isArraySpecial([2, 4]))                   # Test input 3\n    print(isArraySpecial([1, 2, 3, 4, 5]))         # Test input 4\n    print(isArraySpecial([2, 3, 2, 5]))             # Test input 5"}, {"source_Lan": "cpp###distinctDifferenceArray.cpp", "source_code": "    vector<int> distinctDifferenceArray(vector<int>& nums) {\n        int n = nums.size();\n        unordered_set<int> st;\n        vector<int> sufCnt(n + 1, 0);\n        for (int i = n - 1; i > 0; i--) {\n            st.insert(nums[i]);\n            sufCnt[i] = st.size();\n        }\n        vector<int> res;\n        st.clear();\n        for (int i = 0; i < n; i++) {\n            st.insert(nums[i]);\n            res.push_back(int(st.size()) - sufCnt[i + 1]);\n        }\n        return res;\n    }", "trans_code": "def distinctDifferenceArray ( nums ) :\n    n = len ( nums )\n    st = set ( )\n    sufCnt = [ 0 ] * ( n + 1 )\n    for i in range ( n - 1 , 0 , - 1 ) :\n        st.add ( nums [ i ] )\n        sufCnt [ i ] = len ( st )\n    res = [ ]\n    st = set ( )\n    for i in range ( n ) :\n        st.add ( nums [ i ] )\n        res.append ( int ( len ( st ) ) - sufCnt [ i + 1 ] )\n    return res\n", "reference_code": "def distinctDifferenceArray( nums: List[int]) -> List[int]:\n    st = set()\n    sufCnt = [0] * (len(nums) + 1)\n    for i in range(len(nums) - 1, 0, -1):\n        st.add(nums[i])\n        sufCnt[i] = len(st)\n    res = []\n    st.clear()\n    for i in range(len(nums)):\n        st.add(nums[i])\n        res.append(len(st) - sufCnt[i + 1])\n    return res", "target_Lan": "python###distinctDifferenceArray.py", "target_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(distinctDifferenceArray([]))\n    print(distinctDifferenceArray([1]))\n    print(distinctDifferenceArray([7, 7, 7, 7]))\n    print(distinctDifferenceArray([1, 2, 3, 4, 5]))\n    print(distinctDifferenceArray([-1, -2, -2, -3, -4]))"}, {"source_Lan": "cpp###maximumRows.cpp", "source_code": "    int maximumRows(vector<vector<int>>& matrix, int numSelect) {\n        int m = matrix.size();\n        int n = matrix[0].size();\n        vector<int> mask(m, 0);\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++){\n                mask[i] += matrix[i][j] << (n - j - 1);\n            }\n        }\n        int res = 0;\n        int cur = 0;\n        int limit = (1 << n);\n        while ((++cur) < limit) {\n            if (__builtin_popcount(cur) != numSelect) {\n                continue;\n            }\n            int t = 0;\n            for (int j = 0; j < m; j++) {\n                if ((mask[j] & cur) == mask[j]) {\n                    ++t;\n                }\n            }\n            res = max(res, t);\n        }\n        return res;\n    }", "trans_code": "def maximumRows ( matrix , numSelect ) :\n    m = len ( matrix )\n    n = len ( matrix [ 0 ] )\n    mask = [ 0 ] * m\n    for i in range ( m ) :\n        for j in range ( n ) :\n            mask [ i ] += matrix [ i ] [ j ] << ( n - j - 1 )\n    res = 0\n    cur = 0\n    limit = ( 1 << n )\n    while ( cur < limit ) :\n        if __builtins__ [ cur ] != numSelect :\n            continue\n        t = 0\n        for j in range ( m ) :\n            if ( mask [ j ] & cur ) == mask [ j ] :\n                t += 1\n        res = max ( res , t )\n    return res\n", "reference_code": "def maximumRows( matrix: List[List[int]], numSelect: int) -> int:\n    m, n = len(matrix), len(matrix[0])\n    mask = [sum(v << j for j, v in enumerate(row)) for i, row in enumerate(matrix)]\n    res, limit = 0, 1 << n\n    for cur in range(1, limit):\n        if cur.bit_count() != numSelect:\n            continue\n        t = sum((mask[j] & cur) == mask[j] for j in range(m))\n        res = max(res, t)\n    return res", "target_Lan": "python###maximumRows.py", "target_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(maximumRows([[]], 0))                           # Test Input 1"}, {"source_Lan": "cpp###minEnd.cpp", "source_code": "    long long minEnd(int n, int x) {\n        n--; \n        long long ans = x;\n        int i = 0, j = 0;\n        while (n >> j) {\n            \n            if ((ans >> i & 1) == 0) {\n                \n                ans |= (long long) (n >> j & 1) << i;\n                j++;\n            }\n            i++;\n        }\n        return ans;\n    }", "trans_code": "def minEnd ( n , x ) :\n    n -= 1\n    ans = x\n    i , j = 0 , 0\n    while n >> j :\n        if ( ans >> i & 1 ) == 0 :\n            ans |= long ( n >> j & 1 ) << i\n            j += 1\n        i += 1\n    return ans\n", "reference_code": "def minEnd( n: int, x: int) -> int:\n    n -= 1  # \u5148\u628a n \u51cf\u4e00\uff0c\u8fd9\u6837\u4e0b\u9762\u8ba8\u8bba\u7684 n \u5c31\u662f\u539f\u6765\u7684 n-1\n    i = j = 0\n    while n >> j:\n        # x \u7684\u7b2c i \u4e2a\u6bd4\u7279\u503c\u662f 0\uff0c\u5373\u300c\u7a7a\u4f4d\u300d\n        if (x >> i & 1) == 0:\n            # \u7a7a\u4f4d\u586b\u5165 n \u7684\u7b2c j \u4e2a\u6bd4\u7279\u503c\n            x |= (n >> j & 1) << i\n            j += 1\n        i += 1\n    return x", "target_Lan": "python###minEnd.py", "target_code_shell": "# TOFILL\nif __name__ == \"__main__\":\n    # Test Input 1: Basic edge case with smallest values\n    print(minEnd(1, 0))\n    # Test Input 2: Large values to test for overflow\n    print(minEnd(int(1e6), int(1e6)))\n    # Test Input 3: Test with negative x\n    print(minEnd(10, 1))\n    # Test Input 4: Mixed bits\n    print(minEnd(255, 170))  # n=11111111 (binary), x=10101010 (binary)\n    # Test Input 5: Another large value for n and x\n    print(minEnd(123456, 654321))"}, {"source_Lan": "cpp###numberOfStableArrays.cpp", "source_code": "int numberOfStableArrays(int zero, int one, int limit) {\n        vector<vector<vector<long long>>> dp(zero + 1, vector<vector<long long>>(one + 1, vector<long long>(2)));\n        long long mod = 1e9 + 7;\n        for (int i = 0; i <= min(zero, limit); i++) {\n            dp[i][0][0] = 1;\n        }\n        for (int j = 0; j <= min(one, limit); j++) {\n            dp[0][j][1] = 1;\n        }\n        for (int i = 1; i <= zero; i++) {\n            for (int j = 1; j <= one; j++) {\n                if (i > limit) {\n                    dp[i][j][0] = dp[i - 1][j][0] + dp[i - 1][j][1] - dp[i - limit - 1][j][1];\n                } else {\n                    dp[i][j][0] = dp[i - 1][j][0] + dp[i - 1][j][1];\n                }\n                dp[i][j][0] = (dp[i][j][0] % mod + mod) % mod;\n                if (j > limit) {\n                    dp[i][j][1] = dp[i][j - 1][1] + dp[i][j - 1][0] - dp[i][j - limit - 1][0];\n                } else {\n                    dp[i][j][1] = dp[i][j - 1][1] + dp[i][j - 1][0];\n                }\n                dp[i][j][1] = (dp[i][j][1] % mod + mod) % mod;\n            }\n        }\n        return (dp[zero][one][0] + dp[zero][one][1]) % mod;\n    }", "trans_code": "def number_of_stable_arrays ( zero , one , limit ) :\n    dp = np.zeros ( ( zero + 1 , one + 1 , 2 ) )\n    mod = 1e9 + 7\n    for i in range ( 0 , min ( zero , limit ) ) :\n        dp [ i ] [ 0 ] [ 0 ] = 1\n    for j in range ( 0 , min ( one , limit ) ) :\n        dp [ 0 ] [ j ] [ 1 ] = 1\n    for i in range ( 1 , zero + 1 ) :\n        for j in range ( 1 , one + 1 ) :\n            if i > limit :\n                dp [ i ] [ j ] [ 0 ] = dp [ i - 1 ] [ j ] [ 0 ] + dp [ i - 1 ] [ j ] [ 1 ] - dp [ i - limit - 1 ] [ j ] [ 1 ]\n            else :\n                dp [ i ] [ j ] [ 0 ] = dp [ i - 1 ] [ j ] [ 0 ] + dp [ i - 1 ] [ j ] [ 1 ]\n            dp [ i ] [ j ] [ 0 ] = ( dp [ i ] [ j ] [ 0 ] % mod + mod ) % mod\n            if j > limit :\n                dp [ i ] [ j ] [ 1 ] = dp [ i ] [ j - 1 ] [ 1 ] + dp [ i ] [ j - 1 ] [ 0 ] - dp [ i ] [ j - limit - 1 ] [ 0 ]\n            else :\n                dp [ i ] [ j ] [ 1 ] = dp [ i ] [ j - 1 ] [ 1 ] + dp [ i ] [ j - 1 ] [ 0 ]\n            dp [ i ] [ j ] [ 1 ] = ( dp [ i ] [ j ] [ 1 ] % mod + mod ) % mod\n    return ( dp [ zero ] [ one ] [ 0 ] + dp [ zero ] [ one ] [ 1 ] ) % mod\n", "reference_code": "def numberOfStableArrays( zero: int, one: int, limit: int) -> int:\n        dp = [[[0, 0] for _ in range(one + 1)] for _ in range(zero + 1)]\n        mod = int(1e9 + 7)\n        for i in range(min(zero, limit) + 1):\n            dp[i][0][0] = 1\n        for j in range(min(one, limit) + 1):\n            dp[0][j][1] = 1\n        for i in range(1, zero + 1):\n            for j in range(1, one + 1):\n                if i > limit:\n                    dp[i][j][0] = dp[i - 1][j][0] + dp[i - 1][j][1] - dp[i - limit - 1][j][1]\n                else:\n                    dp[i][j][0] = dp[i - 1][j][0] + dp[i - 1][j][1]\n                dp[i][j][0] = (dp[i][j][0] % mod + mod) % mod\n                if j > limit:\n                    dp[i][j][1] = dp[i][j - 1][1] + dp[i][j - 1][0] - dp[i][j - limit - 1][0]\n                else:\n                    dp[i][j][1] = dp[i][j - 1][1] + dp[i][j - 1][0]\n                dp[i][j][1] = (dp[i][j][1] % mod + mod) % mod\n        return (dp[zero][one][0] + dp[zero][one][1]) % mod\n", "target_Lan": "python###numberOfStableArrays.py", "target_code_shell": "# TOFILL\nif __name__ == \"__main__\":\n    zero1, one1, limit1 = 0, 0, 1\n    zero2, one2, limit2 = 1, 1, 1\n    zero3, one3, limit3 = 2, 2, 2\n    zero4, one4, limit4 = 3, 3, 1\n    zero5, one5, limit5 = 5, 5, 3\n    print(numberOfStableArrays(zero1, one1, limit1))  \n    print(numberOfStableArrays(zero2, one2, limit2))  \n    print(numberOfStableArrays(zero3, one3, limit3))  \n    print(numberOfStableArrays(zero4, one4, limit4))  \n    print(numberOfStableArrays(zero5, one5, limit5))"}, {"source_Lan": "cpp###maxPointsInsideSquare.cpp", "source_code": "int maxPointsInsideSquare(vector<vector<int>>& points, string s) {\n        vector<int> min1(26, 1000000001);\n        int min2 = 1000000001;\n        int n = s.length();\n        for (int i = 0; i < n; ++i) {\n            int x = points[i][0], y = points[i][1], j = s[i] - 'a';\n            int d = max(abs(x), abs(y));\n            if (d < min1[j]) {\n                min2 = min(min2, min1[j]);\n                min1[j] = d;\n            } else if (d < min2) {\n                min2 = d;\n            }\n        }\n        int res = 0;\n        for (int d : min1) {\n            if (d < min2) {\n                ++res;\n            }\n        }\n        return res;\n    }", "trans_code": "def maxPointsInsideSquare ( points , s ) :\n    min1 = range ( 26 , 1000000001 )\n    min2 = 1000000001\n    n = len ( s )\n    for i in range ( n ) :\n        x , y , j = points [ i ] [ 0 ] , points [ i ] [ 1 ] , s [ i ] - 'a'\n        d = max ( abs ( x ) , abs ( y ) )\n        if d < min1 [ j ] :\n            min2 = min ( min2 , min1 [ j ] )\n            min1 [ j ] = d\n        elif d < min2 :\n            min2 = d\n    res = 0\n    for d in min1 :\n        if d < min2 :\n            res += 1\n    return res\n", "reference_code": " def maxPointsInsideSquare( points: List[List[int]], s: str) -> int:\n        min1 = [inf] * 26\n        min2 = inf\n        n = len(s)\n        for i in range(n):\n            x, y = points[i]\n            j = ord(s[i]) - ord('a')\n            d = max(abs(x), abs(y))\n            if d < min1[j]:\n                min2 = min(min2, min1[j])\n                min1[j] = d\n            elif d < min2:\n                min2 = d\n        return sum(d < min2 for d in min1)", "target_Lan": "python###maxPointsInsideSquare.py", "target_code_shell": "from typing import List\nfrom math import inf\n# TOFILL\nif __name__ == \"__main__\":\n    points1 = [[0, 0]]\n    s1 = \"a\"\n    points2 = [[1, 1], [-1, -1], [2, 2]]\n    s2 = \"abc\"\n    points3 = [[1, 1], [2, 2], [3, 3]]\n    s3 = \"aaa\"\n    points4 = [[1, 1], [0, 0], [-1, -1], [2, 2]]\n    s4 = \"aabb\"\n    points5 = [[1000000, 1000000], [-1000000, -1000000], [500000, 500000]]\n    s5 = \"xyz\"\n    print(maxPointsInsideSquare(points1, s1))  \n    print(maxPointsInsideSquare(points2, s2))  \n    print(maxPointsInsideSquare(points3, s3))  \n    print(maxPointsInsideSquare(points4, s4))  \n    print(maxPointsInsideSquare(points5, s5))"}, {"source_Lan": "cpp###numberOfRightTriangles.cpp", "source_code": "long long numberOfRightTriangles(vector<vector<int>>& grid) {\n        int n = grid.size(), m = grid[0].size();\n        vector<int> col(m);\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                col[j] += grid[i][j];\n            }\n        }\n        long long res = 0;\n        for (int i = 0; i < n; i++) {\n            int row = accumulate(grid[i].begin(), grid[i].end(), 0);\n            for (int j = 0; j < m; j++) {\n                if (grid[i][j] == 1) {\n                    res += (row - 1) * (col[j] - 1);\n                }\n            }\n        }\n        return res;\n    }", "trans_code": "def number_of_right_triangles ( grid ) :\n    n , m = len ( grid ) , len ( grid [ 0 ] )\n    col = [ 0 ] * m\n    for i in range ( n ) :\n        for j in range ( m ) :\n            col [ j ] += grid [ i ] [ j ]\n    res = 0\n    for i in range ( n ) :\n        row = sum ( grid [ i ] )\n        for j in range ( m ) :\n            if grid [ i ] [ j ] == 1 :\n                res += ( row - 1 ) * ( col [ j ] - 1 )\n    return res\n", "reference_code": "def numberOfRightTriangles( grid: List[List[int]]) -> int:\n        n, m = len(grid), len(grid[0])\n        col = [0] * m\n        for j in range(m):\n            for i in range(n):\n                col[j] += grid[i][j]\n        res = 0\n        for i in range(n):\n            row = sum(grid[i])\n            for j in range(m):\n                if grid[i][j] == 1:\n                    res += (row - 1) * (col[j] - 1)\n        return res", "target_Lan": "python###numberOfRightTriangles.py", "target_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    grid1 = [[0]]\n    grid2 = [[1]]\n    grid3 = [[1, 0], [0, 1]]\n    grid4 = [[1, 1], [1, 1]]\n    grid5 = [[0, 1, 0], [1, 0, 1], [0, 1, 0]]\n    print(numberOfRightTriangles(grid1))\n    print(numberOfRightTriangles(grid2))\n    print(numberOfRightTriangles(grid3))\n    print(numberOfRightTriangles(grid4))\n    print(numberOfRightTriangles(grid5))"}, {"source_Lan": "cpp###maxmiumScore.cpp", "source_code": "int maxmiumScore(vector<int>& cards, int cnt) {\n        sort(cards.begin(), cards.end());\n        \n        int ans = 0;\n        int tmp = 0;\n        int odd, even = -1;\n        int end = cards.size() - cnt;\n        for (int i = cards.size() - 1; i >= end; i--) {\n            tmp += cards[i];\n            if (cards[i] & 1) {\n                odd = cards[i];\n            } else {\n                even = cards[i];\n            }\n        }\n\n        if (!(tmp & 1)) {\n            return tmp;\n        }\n\n        for (int i = cards.size() - cnt - 1; i >= 0; i--) {\n            if (cards[i] & 1) {\n                if (even != -1) {\n                    ans = max(ans, tmp - even + cards[i]);\n                }\n            } else {\n                if (odd != -1) {\n                    ans = max(ans, tmp - odd + cards[i]);\n                }\n            }\n        }\n        return ans;\n    }", "trans_code": "def maxmiumScore ( cards , cnt ) :\n    cards.sort ( )\n    ans = 0\n    tmp = 0\n    odd , even = -1\n    end = len ( cards ) - cnt\n    for i in range ( len ( cards ) - 1 , - 1 , - 1 ) :\n        tmp += cards [ i ]\n        if cards [ i ] & 1 : odd = cards [ i ]\n        else : even = cards [ i ]\n    if not ( tmp & 1 ) : return tmp\n    for i in range ( len ( cards ) - cnt - 1 , - 1 , - 1 ) :\n        if cards [ i ] & 1 :\n            if even != -1 : ans = max ( ans , tmp - even + cards [ i ] )\n        else :\n            if odd != -1 : ans = max ( ans , tmp - odd + cards [ i ] )\n    return ans\n", "reference_code": "def maxmiumScore( cards: List[int], cnt: int) -> int:\n        cards.sort(reverse=True)\n        ans = 0\n        tmp = 0\n        odd = even = -1\n        end = len(cards) - cnt\n        for i in range(cnt):\n            tmp += cards[i]\n            if cards[i] % 2 == 1:\n                odd = cards[i]\n            else:\n                even = cards[i]\n        if tmp % 2 == 0:\n            return tmp\n        for i in range(cnt, len(cards)):\n            if cards[i] % 2 == 1:\n                if even != -1:\n                    ans = max(ans, tmp - even + cards[i])\n            else:\n                if odd != -1:\n                    ans = max(ans, tmp - odd + cards[i])\n\n        return ans", "target_Lan": "python###maxmiumScore.py", "target_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    cards1 = [1]\n    cnt1 = 1\n    cards2 = [2, 4, 6]\n    cnt2 = 2\n    cards3 = [1, 3, 5, 7]\n    cnt3 = 3\n    cards4 = [1, 2, 3, 4, 5, 6]\n    cnt4 = 4\n    cards5 = [10, 20, 30, 40, 50]\n    cnt5 = 3\n    print(maxmiumScore(cards1, cnt1))\n    print(maxmiumScore(cards2, cnt2))\n    print(maxmiumScore(cards3, cnt3))\n    print(maxmiumScore(cards4, cnt4))\n    print(maxmiumScore(cards5, cnt5))"}, {"source_Lan": "cpp###minRectanglesToCoverPoints.cpp", "source_code": "int minRectanglesToCoverPoints(vector<vector<int>>& points, int w) {\n        sort(points.begin(), points.end());\n        int res = 0;\n        int bound = -1;\n        for (auto &p : points) {\n            if (p[0] > bound) {\n                bound = p[0] + w;\n                res++;\n            }\n        }\n        return res;\n    }", "trans_code": "def minRectanglesToCoverPoints ( points , w ) :\n    points = sorted ( points )\n    res = 0\n    bound = -1\n    for p in points :\n        if p [ 0 ] > bound :\n            bound = p [ 0 ] + w\n            res += 1\n    return res\n", "reference_code": "def minRectanglesToCoverPoints( points: List[List[int]], w: int) -> int:\n        points.sort()\n        res = 0\n        bound = -1\n        for p in points:\n            if p[0] > bound:\n                bound = p[0] + w\n                res += 1\n        return res\n", "target_Lan": "python###minRectanglesToCoverPoints.py", "target_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    points1 = [[0, 0]]\n    w1 = 1\n    points2 = [[0, 0], [2, 0]]\n    w2 = 1\n    points3 = [[0, 0], [1, 0], [2, 0]]\n    w3 = 2\n    points4 = [[1, 0], [3, 0], [5, 0], [7, 0]]\n    w4 = 3\n    points5 = [[0, 0], [100, 0], [200, 0]]\n    w5 = 50\n    print(minRectanglesToCoverPoints(points1, w1))\n    print(minRectanglesToCoverPoints(points2, w2))\n    print(minRectanglesToCoverPoints(points3, w3))\n    print(minRectanglesToCoverPoints(points4, w4))\n    print(minRectanglesToCoverPoints(points5, w5))"}, {"source_Lan": "cpp###getSmallestString2.cpp", "source_code": "string getSmallestString2(string s, int k) {\n        for (int i = 0; i < s.size(); ++i) {\n            int dis = min(s[i] - 'a', 'z' - s[i] + 1);\n            if (dis <= k) {\n                s[i] = 'a';\n                k -= dis;\n            }\n            else {\n                s[i] -= k;\n                break;\n            }\n        }\n        return s;\n    }", "trans_code": "def getSmallestString2 ( s , k ) :\n    for i in range ( len ( s ) ) :\n        dis = min ( s [ i ] - 'a' , 'z' - s [ i ] + 1 )\n        if dis <= k :\n            s [ i ] = 'a'\n            k -= dis\n        else :\n            s [ i ] -= k\n            break\n    return s\n", "reference_code": "def getSmallestString2( s: str, k: int) -> str:\n        ans = list(s)\n        for i, ch in enumerate(s):\n            dis = min(ord(s[i]) - ord('a'), ord('z') - ord(s[i]) + 1)\n            if dis <= k:\n                ans[i] = 'a'\n                k -= dis\n            else:\n                ans[i] = chr(ord(ans[i]) - k)\n                break\n        return \"\".join(ans)", "target_Lan": "python###getSmallestString2.py", "target_code_shell": "# TOFILL\nif __name__ == \"__main__\":\n    s1, k1 = \"abc\", 1\n    s2, k2 = \"abc\", 2\n    s3, k3 = \"azb\", 3\n    s4, k4 = \"xyz\", 5\n    s5, k5 = \"hello\", 5\n    print(getSmallestString2(s1, k1))\n    print(getSmallestString2(s2, k2))\n    print(getSmallestString2(s3, k3))\n    print(getSmallestString2(s4, k4))\n    print(getSmallestString2(s5, k5))"}, {"source_Lan": "cpp###minimumOperations.cpp", "source_code": "int minimumOperations(string num) {\n        int n = num.length();\n        bool find0 = false, find5 = false;\n        for (int i = n - 1; i >= 0; --i) {\n            if (num[i] == '0' || num[i] == '5') {\n                if (find0) {\n                    return n - i - 2;\n                }\n                if (num[i] == '0') {\n                    find0 = true;\n                } else {\n                    find5 = true;\n                }\n            } else if (num[i] == '2' || num[i] == '7') {\n                if (find5) {\n                    return n - i - 2;\n                }\n            }\n        }\n        if (find0) {\n            return n - 1;\n        }\n        return n;\n    }", "trans_code": "def minimumOperations ( num ) :\n    n = len ( num )\n    find0 , find5 = False , False\n    for i in range ( n - 1 , - 1 , - 1 ) :\n        if num [ i ] == '0' or num [ i ] == '5' :\n            if find0 :\n                return n - i - 2\n            if num [ i ] == '0' :\n                find0 = True\n            else :\n                find5 = True\n        elif num [ i ] == '2' or num [ i ] == '7' :\n            if find5 :\n                return n - i - 2\n    if find0 :\n        return n - 1\n    return n\n", "reference_code": " def minimumOperations( num: str) -> int:\n        n = len(num)\n        find0 = find5 = False\n        for i in range(n - 1, -1, -1):\n            if num[i] in ['0', '5']:\n                if find0:\n                    return n - i - 2\n                if num[i] == '0':\n                    find0 = True\n                else:\n                    find5 = True\n            elif num[i] in ['2', '7']:\n                if find5:\n                    return n - i - 2\n        if find0:\n            return n - 1\n        return n", "target_Lan": "python###minimumOperations.py", "target_code_shell": "# TOFILL\nif __name__ == \"__main__\":\n    num1 = \"123450\"\n    num2 = \"1234050\"\n    num3 = \"1750\"\n    num4 = \"122567\"\n    num5 = \"000\"\n    print(minimumOperations(num1))  \n    print(minimumOperations(num2))  \n    print(minimumOperations(num3))  \n    print(minimumOperations(num4))  \n    print(minimumOperations(num5))"}, {"source_Lan": "cpp###relocateMarbles.cpp", "source_code": "vector<int> relocateMarbles(vector<int>& nums, vector<int>& moveFrom, vector<int>& moveTo) {\n        vector<int> ans;\n        unordered_map<int, bool> mp;\n\n        for (int i = 0; i < nums.size(); i++) {\n            mp[nums[i]] = true;\n        }\n\n        for (int i = 0; i < moveFrom.size(); i++) {\n            mp.erase(moveFrom[i]);\n            mp[moveTo[i]] = true;\n        }\n\n        for (const auto& pair : mp) {\n            ans.push_back(pair.first);\n        }\n        sort(ans.begin(), ans.end());\n        return ans;\n    }", "trans_code": "def relocate_marbles ( nums , moveFrom , moveTo ) :\n    ans = [ ]\n    mp = { }\n    for i in nums : mp [ i ] = True\n    for i in moveFrom :\n        mp.pop ( i )\n        mp [ moveTo [ i ] ] = True\n    for pair in mp.keys ( ) : ans.append ( pair [ 0 ] )\n    ans.sort ( )\n    return ans\n", "reference_code": "def relocateMarbles( nums: List[int], moveFrom: List[int], moveTo: List[int]) -> List[int]:\n        mp = {}\n        ans = []\n        for num in nums:\n            mp[num] = True\n        for i in range(len(moveFrom)):\n            if moveFrom[i] in mp:\n                del mp[moveFrom[i]]\n            mp[moveTo[i]] = True\n        ans = list(mp.keys())\n        ans.sort()\n        return ans", "target_Lan": "python###relocateMarbles.py", "target_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    nums1 = [1, 2, 3]\n    moveFrom1 = [1]\n    moveTo1 = [4]\n    result1 = relocateMarbles(nums1, moveFrom1, moveTo1)\n    print(result1)  \n    nums2 = [1, 2, 3]\n    moveFrom2 = [1, 2]\n    moveTo2 = [5, 6]\n    result2 = relocateMarbles(nums2, moveFrom2, moveTo2)\n    print(result2)  \n    nums3 = [1, 2, 3]\n    moveFrom3 = [1]\n    moveTo3 = [1]\n    result3 = relocateMarbles(nums3, moveFrom3, moveTo3)\n    print(result3)  \n    nums4 = [1, 2, 3, 4]\n    moveFrom4 = [1, 2]\n    moveTo4 = [5, 6]\n    result4 = relocateMarbles(nums4, moveFrom4, moveTo4)\n    print(result4)  \n    nums5 = [1, 2, 3]\n    moveFrom5 = []\n    moveTo5 = []\n    result5 = relocateMarbles(nums5, moveFrom5, moveTo5)\n    print(result5)"}, {"source_Lan": "cpp###findValueOfPartition.cpp", "source_code": "int findValueOfPartition(vector<int>& nums) {\n        sort(nums.begin(), nums.end());\n        int res = INT_MAX;\n        for (int i = 1; i < nums.size(); i++) {\n            res = min(res, nums[i] - nums[i - 1]);\n        }\n        return res;\n    }", "trans_code": "def findValueOfPartition ( nums ) :\n    nums = sorted ( nums )\n    res = sys.maxint\n    for i in range ( 1 , len ( nums ) ) :\n        res = min ( res , nums [ i ] - nums [ i - 1 ] )\n    return res\n", "reference_code": "def findValueOfPartition( nums: List[int]) -> int:\n        nums.sort()\n        res = float('inf')\n        for i in range(1, len(nums)):\n            res = min(res, nums[i] - nums[i - 1])\n        return res", "target_Lan": "python###findValueOfPartition.py", "target_code_shell": "from typing import List\nimport sys\n# TOFILL\nif __name__ == \"__main__\":\n    nums1 = [1, 3, 6, 10]\n    print(findValueOfPartition(nums1))\n    nums2 = [1, 2, 2, 4, 6]\n    print(findValueOfPartition(nums2))\n    nums3 = [1]\n    print(findValueOfPartition(nums3))\n    nums4 = [10, 20, 30, 40, 50]\n    print(findValueOfPartition(nums4))\n    nums5 = [1, 1000000000, 500000000]\n    print(findValueOfPartition(nums5))"}, {"source_Lan": "cpp###MinSize.cpp", "source_code": "    int MinSize(vector<int> A, int n) {\n        \n        \n        int curr = A[0];\n        int count = 1;\n        for (int i = 1; i < n; ++i) {\n            if (A[i] == curr) {\n                count += 1;\n            } else {\n                count -= 1;\n                if (count == 0) {\n                    curr = A[i];\n                    count = 1;\n                }\n            }\n        }\n        int max_f = 0;\n        for (int i = 0; i < n; i++){\n            if (curr == A[i]){\n                max_f++;\n        }\n}\nif (max_f <= (n + 1) / 2) {\n            return n & 1;\n        } else {\n            return 2 * max_f - n;\n        }\n    }", "trans_code": "def MinSize ( A , n ) :\n    curr = A [ 0 ]\n    count = 1\n    for i in range ( 1 , n ) :\n        if A [ i ] == curr :\n            count += 1\n        else :\n            count -= 1\n            if count == 0 :\n                curr = A [ i ]\n                count = 1\n    max_f = 0\n    for i in range ( n ) :\n        if curr == A [ i ] :\n            max_f += 1\n    if max_f <= ( n + 1 ) / 2 :\n        return n & 1\n    else :\n        return 2 * max_f - n\n", "reference_code": "def MinSize(A: List[int], n: int) -> int:\n    #find majority element which may occur more than n/2 (Boyer-Moore Majority Voting Algorithm)\n    curr = A[0]\n    count = 1\n    for i in range(1, n):\n        if A[i] == curr:\n            count += 1\n        else:\n            count -= 1\n            if count == 0:\n                curr = A[i]\n                count = 1\n    max_f = A.count(curr)\n    if max_f <= (n + 1) // 2:\n        return n & 1\n    else:\n        return 2 * max_f - n", "target_Lan": "python###MinSize.py", "target_code_shell": "from typing import List\nfrom typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(MinSize([1, 2, 3, 4, 5],5))\n    print(MinSize([1, 1, 1, 1, 1],5))\n    print(MinSize([1, 2, 3, 2, 1], 5))\n    print(MinSize([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10))\n    print(MinSize([1, 1, 1, 1, 1, 2, 2, 2, 2, 2], 10))"}, {"source_Lan": "cpp###minimumAddedCoins.cpp", "source_code": "int minimumAddedCoins(vector<int>& coins, int target) {\n        sort(coins.begin(), coins.end());\n        int ans = 0;\n        int x = 1;\n        int length = coins.size(), index = 0;\n        while (x <= target) {\n            if (index < length && coins[index] <= x) {\n                x += coins[index];\n                index++;\n            } else {\n                x <<= 1;\n                ans++;\n            }\n        }\n        return ans;\n    }", "trans_code": "def minimumAddedCoins ( coins , target ) :\n    coins = sorted ( coins )\n    ans = 0\n    x = 1\n    length , index = len ( coins ) , 0\n    while x <= target :\n        if index < length and coins [ index ] <= x :\n            x += coins [ index ]\n            index += 1\n        else :\n            x <<= 1\n            ans += 1\n    return ans\n", "reference_code": "def minimumAddedCoins( coins: List[int], target: int) -> int:\n        coins.sort()\n        ans, x = 0, 1\n        length, index = len(coins), 0\n        while x <= target:\n            if index < length and coins[index] <= x:\n                x += coins[index]\n                index += 1\n            else:\n                x <<= 1\n                ans += 1\n        return ans", "target_Lan": "python###minimumAddedCoins.py", "target_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(minimumAddedCoins([], 1))                  \n    print(minimumAddedCoins([1, 2, 5], 10))          \n    print(minimumAddedCoins([1, 2, 3], 100))         \n    print(minimumAddedCoins([1, 2, 4, 8], 30))      \n    print(minimumAddedCoins([5], 1000000))"}, {"source_Lan": "cpp###maximumSumOfHeights.cpp", "source_code": "long long maximumSumOfHeights(vector<int>& maxHeights) {\n        int n = maxHeights.size();\n        long long res = 0;\n        vector<long long> prefix(n), suffix(n);\n        stack<int> stack1, stack2;\n        for (int i = 0; i < n; i++) {\n            while (!stack1.empty() && maxHeights[i] < maxHeights[stack1.top()]) {\n                stack1.pop();\n            }\n            if (stack1.empty()) {\n                prefix[i] = (long long)(i + 1) * maxHeights[i];\n            } else {\n                prefix[i] = prefix[stack1.top()] + (long long)(i - stack1.top()) * maxHeights[i];\n            }\n            stack1.emplace(i);\n        }\n        for (int i = n - 1; i >= 0; i--) {\n            while (!stack2.empty() && maxHeights[i] < maxHeights[stack2.top()]) {\n                stack2.pop();\n            }\n            if (stack2.empty()) {\n                suffix[i] = (long long)(n - i) * maxHeights[i];\n            } else {\n                suffix[i] = suffix[stack2.top()] + (long long)(stack2.top() - i) * maxHeights[i];\n            }\n            stack2.emplace(i);\n            res = max(res, prefix[i] + suffix[i] - maxHeights[i]);\n        }\n        return res;\n    }", "trans_code": "def maximumSumOfHeights ( maxHeights ) :\n    n = len ( maxHeights )\n    res = 0\n    prefix , suffix = [ ] , [ ]\n    stack1 , stack2 = stack ( )\n    for i in range ( n ) :\n        while not stack1.empty ( ) and maxHeights [ i ] < maxHeights [ stack1.top ( ) ] : stack1.pop ( )\n        if stack1.empty ( ) : prefix.append ( int ( i + 1 ) * maxHeights [ i ] )\n        else : prefix.append ( prefix [ stack1.top ( ) ] + int ( i - stack1.top ( ) ) * maxHeights [ i ] )\n        stack1.emplace ( i )\n    for i in range ( n - 1 , - 1 , - 1 ) :\n        while not stack2.empty ( ) and maxHeights [ i ] < maxHeights [ stack2.top ( ) ] : stack2.pop ( )\n        if stack2.empty ( ) : suffix.append ( int ( n - i ) * maxHeights [ i ] )\n        else : suffix.append ( suffix [ stack2.top ( ) ] + int ( stack2.top ( ) - i ) * maxHeights [ i ] )\n        stack2.emplace ( i )\n        res = max ( res , prefix [ i ] + suffix [ i ] - maxHeights [ i ] )\n    return res\n", "reference_code": "def maximumSumOfHeights( maxHeights: List[int]) -> int:\n        n = len(maxHeights)\n        res = 0\n        prefix, suffix = [0] * n, [0] * n\n        stack1, stack2 = [], []\n        for i in range(n):\n            while len(stack1) > 0 and maxHeights[i] < maxHeights[stack1[-1]]:\n                stack1.pop()\n            if len(stack1) == 0:\n                prefix[i] = (i + 1) * maxHeights[i]\n            else:\n                prefix[i] = prefix[stack1[-1]] + (i - stack1[-1]) * maxHeights[i]\n            stack1.append(i)\n        for i in range(n - 1, -1, -1):\n            while len(stack2) > 0 and maxHeights[i] < maxHeights[stack2[-1]]:\n                stack2.pop()\n            if len(stack2) == 0:\n                suffix[i] = (n - i) * maxHeights[i]\n            else:\n                suffix[i] = suffix[stack2[-1]] + (stack2[-1] - i) * maxHeights[i]\n            stack2.append(i)\n            res = max(res, prefix[i] + suffix[i] - maxHeights[i])\n        return res", "target_Lan": "python###maximumSumOfHeights.py", "target_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(maximumSumOfHeights([0, 0, 0, 0]))         \n    print(maximumSumOfHeights([1, 2, 3, 4, 5]))      \n    print(maximumSumOfHeights([5, 4, 3, 2, 1]))      \n    print(maximumSumOfHeights([1e9, 1e9, 1e9, 1e9])) \n    print(maximumSumOfHeights([10, 1, 10, 1, 10]))"}, {"source_Lan": "cpp###isAcronym.cpp", "source_code": "bool isAcronym(vector<string>& words, string s) {\n        if (s.size() != words.size()) {\n            return false;\n        }\n        for (int i = 0; i < s.size(); i++) {\n            if (words[i][0] != s[i]) {\n                return false;\n            }\n        }\n        return true;\n    }", "trans_code": "def isAcronym ( words , s ) :\n    if len ( s ) != len ( words ) :\n        raise ValueError\n    for i in range ( len ( s ) ) :\n        if words [ i ] [ 0 ] != s [ i ] :\n            raise ValueError\n    return True\n", "reference_code": "def isAcronym( words: List[str], s: str) -> bool:\n        return len(words) == len(s) and all(words[i][0] == s[i] for i in range(len(s)))", "target_Lan": "python###isAcronym.py", "target_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(isAcronym([\"apple\", \"banana\", \"cherry\"], \"abc\"))  \n    print(isAcronym([\"apple\", \"banana\"], \"ab\"))            \n    print(isAcronym([\"apple\", \"banana\", \"date\"], \"abcd\"))  \n    print(isAcronym([\"apple\", \"banana\"], \"a\"))              \n    print(isAcronym([], \"\"))"}, {"source_Lan": "cpp###possibleToStamp.cpp", "source_code": "bool possibleToStamp(vector<vector<int>>& grid, int stampHeight, int stampWidth) {\n        int m = grid.size(), n = grid[0].size();\n        vector<vector<int>> sum(m + 2, vector<int>(n + 2, 0));\n        vector<vector<int>> diff(m + 2, vector<int>(n + 2, 0));\n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                sum[i][j] = sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1] + grid[i - 1][j - 1];\n            }\n        }\n        for (int i = 1; i + stampHeight - 1 <= m; i++) {\n            for (int j = 1; j + stampWidth - 1 <= n; j++) {\n                int x = i + stampHeight - 1;\n                int y = j + stampWidth - 1;\n                if (sum[x][y] - sum[x][j - 1] - sum[i - 1][y] + sum[i - 1][j - 1] == 0) {\n                    diff[i][j]++;\n                    diff[i][y + 1]--;\n                    diff[x + 1][j]--;\n                    diff[x + 1][y + 1]++;\n                }\n            }\n        }\n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                diff[i][j] += diff[i - 1][j] + diff[i][j - 1] - diff[i - 1][j - 1];\n                if (diff[i][j] == 0 && grid[i - 1][j - 1] == 0) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }", "trans_code": "def possibleToStamp ( grid , stampHeight , stampWidth ) :\n    m , n = len ( grid ) , len ( grid [ 0 ] )\n    sum = np.zeros ( ( m + 2 , n + 2 ) )\n    diff = np.zeros ( ( m + 2 , n + 2 ) )\n    for i in range ( 1 , m + 1 ) :\n        for j in range ( 1 , n + 1 ) :\n            sum [ i ] [ j ] = sum [ i - 1 ] [ j ] + sum [ i ] [ j - 1 ] - sum [ i - 1 ] [ j - 1 ] + grid [ i - 1 ] [ j - 1 ]\n    for i in range ( 1 , m + stampHeight - 1 <= m ) :\n        for j in range ( 1 , n + stampWidth - 1 <= n ) :\n            x = i + stampHeight - 1\n            y = j + stampWidth - 1\n            if sum [ x ] [ y ] - sum [ x ] [ j - 1 ] - sum [ i - 1 ] [ y ] + sum [ i - 1 ] [ j - 1 ] == 0 :\n                diff [ i ] [ j ] += 1\n                diff [ i ] [ y + 1 ] -= 1\n                diff [ x + 1 ] [ j ] -= 1\n                diff [ x + 1 ] [ y + 1 ] += 1\n    for i in range ( 1 , m + stampHeight - 1 <= m ) :\n        for j in range ( 1 , n + stampWidth - 1 ) :\n            diff [ i ] [ j ] += diff [ i - 1 ] [ j ] + diff [ i ] [ j - 1 ] - diff [ i - 1 ] [ j - 1 ]\n            if diff [ i ] [ j ] == 0 and grid [ i - 1 ] [ j - 1 ] == 0 :\n                return False\n    return True\n", "reference_code": "def possibleToStamp( grid: List[List[int]], stampHeight: int, stampWidth: int) -> bool:\n        m, n = len(grid), len(grid[0])\n        psum = [[0] * (n + 2) for _ in range(m + 2)]\n        diff = [[0] * (n + 2) for _ in range(m + 2)]\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                psum[i][j] = psum[i - 1][j] + psum[i][j - 1] - psum[i - 1][j - 1] + grid[i - 1][j - 1]\n        for i in range(1, m + 2 - stampHeight):\n            for j in range(1, n + 2 - stampWidth):\n                x = i + stampHeight - 1\n                y = j + stampWidth - 1\n                if psum[x][y] - psum[x][j - 1] - psum[i - 1][y] + psum[i - 1][j - 1] == 0:\n                    diff[i][j] += 1\n                    diff[i][y + 1] -= 1\n                    diff[x + 1][j] -= 1\n                    diff[x + 1][y + 1] += 1\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                diff[i][j] += diff[i - 1][j] + diff[i][j - 1] - diff[i - 1][j - 1]\n                if diff[i][j] == 0 and grid[i - 1][j - 1] == 0:\n                    return False\n        return True", "target_Lan": "python###possibleToStamp.py", "target_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(possibleToStamp([[]], 1, 1))\n    print(possibleToStamp([[0, 0], [0, 0]], 1, 1))\n    print(possibleToStamp([[1, 1], [1, 1]], 1, 1))\n    print(possibleToStamp([[0, 0], [0, 1]], 2, 2))\n    print(possibleToStamp([[0, 1, 0], [0, 0, 0], [1, 1, 0]], 2, 2))"}, {"source_Lan": "cpp###makeSmallestPalindrome.cpp", "source_code": "string makeSmallestPalindrome(string s) {\n        int left = 0, right = s.size() - 1;\n        while (left < right) {\n            if (s[left] != s[right]) {\n                s[left] = s[right] = min(s[left], s[right]);\n            }\n            ++left;\n            --right;\n        }\n        return s;\n    }", "trans_code": "def makeSmallestPalindrome ( s ) :\n    left , right = 0 , len ( s ) - 1\n    while left < right :\n        if s [ left ] != s [ right ] :\n            s [ left ] , s [ right ] = min ( s [ left ] , s [ right ] )\n        left += 1\n        right -= 1\n    return s\n", "reference_code": "def makeSmallestPalindrome( s: str) -> str:\n        s = list(s)\n        left, right = 0, len(s) - 1\n        while left < right:\n            if s[left] != s[right]:\n                s[left] = s[right] = min(s[left], s[right])\n            left += 1\n            right -= 1\n        return \"\".join(s)", "target_Lan": "python###makeSmallestPalindrome.py", "target_code_shell": "# TOFILL\nif __name__ == \"__main__\":\n    print(makeSmallestPalindrome(\"\"))          \n    print(makeSmallestPalindrome(\"abcba\"))     \n    print(makeSmallestPalindrome(\"aaaa\"))      \n    print(makeSmallestPalindrome(\"abac\"))      \n    print(makeSmallestPalindrome(\"AaBb\"))"}, {"source_Lan": "cpp###secondGreaterElement.cpp", "source_code": "vector<int> secondGreaterElement(vector<int>& nums) {\n        vector<int> res(nums.size(), -1);\n        stack<int> st;\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> q;\n        for (int i = 0; i < nums.size(); ++i) {\n            while (!q.empty() && q.top().first < nums[i]) {\n                res[q.top().second] = nums[i];\n                q.pop();\n            }\n            while (!st.empty() && nums[st.top()] < nums[i]) {\n                q.push({nums[st.top()], st.top()});\n                st.pop();\n            }\n            st.push(i);\n        }\n        return res;\n    }", "trans_code": "def secondGreaterElement ( nums ) :\n    res = np.zeros ( len ( nums ) , dtype = int )\n    st = [ ]\n    q = collections.deque ( )\n    for i in range ( len ( nums ) ) :\n        while not q.empty ( ) and q.popleft ( ) [ 0 ] < nums [ i ] :\n            res [ q.popleft ( ) [ 1 ] ] = nums [ i ]\n            q.popleft ( )\n        while not st.empty ( ) and nums [ st.popleft ( ) ] < nums [ i ] :\n            q.append ( [ nums [ st.popleft ( ) ] , st.popleft ( ) ] )\n            st.popleft ( )\n        st.append ( i )\n    return res\n", "reference_code": "def secondGreaterElement( nums: List[int]) -> List[int]:\n    res = [-1] * len(nums)\n    stack = []\n    q = []\n    for i in range(len(nums)):\n        while len(q) and q[0][0] < nums[i]:\n            res[q[0][1]] = nums[i]\n            heappop(q)\n        while len(stack) and nums[stack[-1]] < nums[i]:\n            heappush(q, (nums[stack[-1]], stack[-1]))\n            stack.pop()\n        stack.append(i)\n    return res", "target_Lan": "python###secondGreaterElement.py", "target_code_shell": "from typing import List\nfrom heapq import heappop, heappush\n# TOFILL\nif __name__ == \"__main__\":\n    print(secondGreaterElement([])) \n    print(secondGreaterElement([1])) \n    print(secondGreaterElement([3, 3, 3])) \n    print(secondGreaterElement([1, 2, 3, 4])) \n    print(secondGreaterElement([4, 3, 2, 1]))"}, {"source_Lan": "cpp###maxTaxiEarnings.cpp", "source_code": "long long maxTaxiEarnings(int n, vector<vector<int>> &rides) {\n        vector<long long> dp(n + 1);\n        unordered_map<int, vector<vector<int>>> rideMap;\n        for (const auto &ride : rides) {\n            rideMap[ride[1]].push_back(ride);\n        }\n        for (int i = 1; i <= n; i++) {\n            dp[i] = dp[i - 1];\n            for (const auto &ride : rideMap[i]) {\n                dp[i] = max(dp[i], dp[ride[0]] + ride[1] - ride[0] + ride[2]);\n            }\n        }\n        return dp[n];\n    }", "trans_code": "def maxTaxiEarnings ( n , rides ) :\n    dp = [ 0 ] * ( n + 1 )\n    rideMap = { }\n    for ride in rides :\n        rideMap [ ride [ 1 ] ].append ( ride )\n    for i in range ( 1 , n + 1 ) :\n        dp [ i ] = dp [ i - 1 ]\n        for ride in rideMap [ i ] :\n            dp [ i ] = max ( dp [ i ] , dp [ ride [ 0 ] ] + ride [ 1 ] - ride [ 0 ] + ride [ 2 ] )\n    return dp [ n ]\n", "reference_code": "def maxTaxiEarnings( n: int, rides: List[List[int]]) -> int:\n        dp = [0] * (n + 1)\n        rideMap = {}\n        for ride in rides:\n            if ride[1] not in rideMap:\n                rideMap[ride[1]] = []\n            rideMap[ride[1]].append(ride)\n        for i in range(1, n + 1):\n            dp[i] = dp[i - 1]\n            if i not in rideMap:\n                continue\n            for ride in rideMap[i]:\n                dp[i] = max(dp[i], dp[ride[0]] + ride[1] - ride[0] + ride[2])\n        return dp[n]", "target_Lan": "python###maxTaxiEarnings.py", "target_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(maxTaxiEarnings(0, []))\n    print(maxTaxiEarnings(5, [[0, 5, 10], [1, 3, 5], [2, 5, 7]]))\n    print(maxTaxiEarnings(10, [[1, 2, 1], [2, 3, 1], [3, 4, 3], [4, 10, 10]]))\n    print(maxTaxiEarnings(7, [[0, 2, 1], [1, 4, 2], [2, 7, 8]]))\n    print(maxTaxiEarnings(6, [[0, 6, 12], [1, 3, 5], [1, 4, 7]]))"}, {"source_Lan": "cpp###carPooling.cpp", "source_code": "bool carPooling(vector<vector<int>>& trips, int capacity) {\n        int to_max = 0;\n        for (const auto& trip: trips) {\n            to_max = max(to_max, trip[2]);\n        }\n        vector<int> diff(to_max + 1);\n        for (const auto& trip: trips) {\n            diff[trip[1]] += trip[0];\n            diff[trip[2]] -= trip[0];\n        }\n        int count = 0;\n        for (int i = 0; i <= to_max; ++i) {\n            count += diff[i];\n            if (count > capacity) {\n                return false;\n            }\n        }\n        return true;\n    }", "trans_code": "def carPooling ( trips , capacity ) :\n    to_max = 0\n    for trip in trips :\n        to_max = max ( to_max , trip [ 2 ] )\n    diff = [ 0 ] * ( to_max + 1 )\n    for trip in trips :\n        diff [ trip [ 1 ] ] += trip [ 0 ]\n        diff [ trip [ 2 ] ] -= trip [ 0 ]\n    count = 0\n    for i in range ( 0 , to_max ) :\n        count += diff [ i ]\n        if count > capacity :\n            return False\n    return True\n", "reference_code": "def carPooling( trips: List[List[int]], capacity: int) -> bool:\n        to_max = max(trip[2] for trip in trips)\n        diff = [0] * (to_max + 1)\n        for num_i, from_i, to_i in trips:\n            diff[from_i] += num_i\n            diff[to_i] -= num_i\n        count = 0\n        for i in range(to_max + 1):\n            count += diff[i]\n            if count > capacity:\n                return False\n        return True", "target_Lan": "python###carPooling.py", "target_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(carPooling([[1, 0, 1]], 1))\n    print(carPooling([[3, 2, 4]], 5))\n    print(carPooling([[2, 1, 3]], 5))\n    print(carPooling([[1, 4, 5]], 1))"}, {"source_Lan": "cpp###firstCompleteIndex.cpp", "source_code": "int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\n        int n = mat.size();\n        int m = mat[0].size();\n        unordered_map<int, pair<int, int>> mp;\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                mp[mat[i][j]] = {i, j};\n            }\n        }\n        vector<int> rowCnt(n, 0);\n        vector<int> colCnt(m, 0);\n        for (int i = 0; i < arr.size(); ++i) {\n            auto& v = mp[arr[i]];\n            ++rowCnt[v.first];\n            if (rowCnt[v.first] == m) {\n                return i;\n            }\n            ++colCnt[v.second];\n            if (colCnt[v.second] == n) {\n                return i;\n            }\n        }\n        return -1;\n    }", "trans_code": "def firstCompleteIndex ( arr , mat ) :\n    n = len ( mat )\n    m = len ( mat [ 0 ] )\n    mp = { }\n    for i in range ( n ) :\n        for j in range ( m ) :\n            mp [ mat [ i ] [ j ] ] = [ i , j ]\n    rowCnt = [ 0 ] * n\n    colCnt = [ 0 ] * m\n    for i in range ( len ( arr ) ) :\n        v = mp [ arr [ i ] ]\n        yield rowCnt [ v [ 0 ] ]\n        if rowCnt [ v [ 0 ] ] == m :\n            return i\n        yield colCnt [ v [ 1 ] ]\n        if colCnt [ v [ 1 ] ] == n :\n            return i\n", "reference_code": "def firstCompleteIndex( arr: List[int], mat: List[List[int]]) -> int:\n        n, m = len(mat), len(mat[0])\n        mp = {}\n        for i in range(n):\n            for j in range(m):\n                mp[mat[i][j]] = [i, j]\n        rowCnt, colCnt = [0] * n, [0] * m\n        for i in range(len(arr)):\n            v = mp[arr[i]]\n            rowCnt[v[0]] += 1\n            if rowCnt[v[0]] == m:\n                return i\n            colCnt[v[1]] += 1\n            if colCnt[v[1]] == n:\n                return i\n        return -1", "target_Lan": "python###firstCompleteIndex.py", "target_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(firstCompleteIndex([1, 2, 3, 4, 5], [[1, 2], [3, 4]]))\n    print(firstCompleteIndex([1, 3, 2, 4, 5], [[1, 2], [3, 4]]))\n    print(firstCompleteIndex([1, 2, 3], [[1, 3], [2, 4]]))\n    print(firstCompleteIndex([], [[1, 2], [3, 4]]))"}, {"source_Lan": "cpp###closeStrings.cpp", "source_code": "bool closeStrings(string word1, string word2) {\n        vector<int> count1(26), count2(26);\n        for (char c : word1) {\n            count1[c - 'a']++;\n        }\n        for (char c : word2) {\n            count2[c - 'a']++;\n        }\n        for (int i = 0; i < 26; i++) {\n            if (count1[i] > 0 && count2[i] == 0 || count1[i] == 0 && count2[i] > 0) {\n                return false;\n            }\n        }\n        sort(count1.begin(), count1.end());\n        sort(count2.begin(), count2.end());\n        return count1 == count2;\n    }", "trans_code": "def close_strings ( word1 , word2 ) :\n    count1 , count2 = [ 0 ] , [ 0 ]\n    for c in word1 :\n        count1 [ c - 'a' ] += 1\n    for c in word2 :\n        count2 [ c - 'a' ] += 1\n    for i in range ( 26 ) :\n        if count1 [ i ] > 0 and count2 [ i ] == 0 or count1 [ i ] == 0 and count2 [ i ] > 0 :\n            return False\n    count1.sort ( )\n    count2.sort ( )\n    return count1 == count2\n", "reference_code": "def closeStrings( word1: str, word2: str) -> bool:\n        return Counter(word1).keys() == Counter(word2).keys() and sorted(Counter(word1).values()) == sorted(Counter(word2).values())", "target_Lan": "python###closeStrings.py", "target_code_shell": "from collections import Counter\n# TOFILL\nif __name__ == \"__main__\":\n    print(closeStrings(\"\", \"\"))          \n    print(closeStrings(\"abc\", \"abc\"))    \n    print(closeStrings(\"aabbcc\", \"abcabc\"))  \n    print(closeStrings(\"abc\", \"aabb\"))    \n    print(closeStrings(\"abcd\", \"xyz\"))"}, {"source_Lan": "cpp###minDeletion.cpp", "source_code": "int minDeletion(vector<int>& nums) {\n        int n = nums.size();\n        int ans = 0;\n        bool check = true;\n        for (int i = 0; i + 1 < n; ++i) {\n            if (nums[i] == nums[i + 1] && check) {\n                ++ans;\n            }\n            else {\n                check = !check;\n            }\n        }\n        if ((n - ans) % 2 != 0) {\n            ++ans;\n        }\n        return ans;\n    }", "trans_code": "def minDeletion ( nums ) :\n    n = len ( nums )\n    ans = 0\n    check = True\n    for i in range ( 0 , i + 1 ) :\n        if nums [ i ] == nums [ i + 1 ] and check :\n            ans += 1\n        else :\n            check = not check\n    if ( n - ans ) % 2 != 0 :\n        ans += 1\n    return ans\n", "reference_code": "def minDeletion( nums: List[int]) -> int:\n        n = len(nums)\n        ans, check = 0, True\n        for i in range(n - 1):\n            if nums[i] == nums[i + 1] and check:\n                ans += 1\n            else:\n                check = not check\n        if (n - ans) % 2 != 0:\n            ans += 1\n        return ans", "target_Lan": "python###minDeletion.py", "target_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(minDeletion([]))  \n    print(minDeletion([1, 2, 3, 4]))  \n    print(minDeletion([1, 1, 1, 1]))  \n    print(minDeletion([1, 1, 2, 2, 1]))  \n    print(minDeletion([1, 2, 2, 3, 3, 3]))"}, {"source_Lan": "cpp###maximumSum.cpp", "source_code": "int maximumSum(vector<int>& nums) {\n        unordered_map<int, int> dict;\n        int res = -1;\n        for (int i : nums) {\n            int digitsSum = 0;\n            int temp = i;\n            while (temp > 0) {\n                digitsSum += temp % 10;\n                temp /= 10;\n            }\n            if (dict.count(digitsSum)) {\n                res = max(res, dict[digitsSum] + i);\n                dict[digitsSum] = max(dict[digitsSum], i);\n            } else {\n                dict[digitsSum] = i;\n            }\n        }\n        return res;\n    }", "trans_code": "def maximumSum ( nums ) :\n    dict = { }\n    res = -1\n    for i in nums :\n        digitsSum = 0\n        temp = i\n        while temp > 0 :\n            digitsSum += temp % 10\n            temp /= 10\n        if dict.has_key ( digitsSum ) :\n            res = max ( res , dict [ digitsSum ] + i )\n            dict [ digitsSum ] = max ( dict [ digitsSum ] , i )\n        else :\n            dict [ digitsSum ] = i\n    return res\n", "reference_code": "def maximumSum( nums: List[int]) -> int:\n        d = defaultdict(int)\n        res = -1\n        for i in nums:\n            digitsSum = sum(int(c) for c in str(i))\n            if digitsSum in d:\n                res = max(res, d[digitsSum] + i)\n                d[digitsSum] = max(d[digitsSum], i)\n            else:\n                d[digitsSum] = i\n        return res", "target_Lan": "python###maximumSum.py", "target_code_shell": "from collections import defaultdict\nfrom typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(maximumSum([12, 21, 30, 39]))\n    print(maximumSum([111, 123, 222, 0]))\n    print(maximumSum([5, 15, 25, 35]))"}, {"source_Lan": "cpp###minPathCost.cpp", "source_code": "int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\n        int m = grid.size(), n = grid[0].size();\n        vector<vector<int>> dp(2, vector<int>(n));\n        dp[0] = grid[0];\n        int cur = 0;\n        for (int i = 1; i < m; i++) {\n            int next = 1 - cur;\n            for (int j = 0; j < n; j++) {\n                dp[next][j] = INT_MAX;\n                for (int k = 0; k < n; k++) {\n                    dp[next][j] = min(dp[next][j], dp[cur][k] + moveCost[grid[i - 1][k]][j] + grid[i][j]);\n                }\n            }\n            cur = next;\n        }\n        return *min_element(dp[cur].begin(), dp[cur].end());\n    }", "trans_code": "def min_path_cost ( grid , move_cost ) :\n    m , n = len ( grid ) , len ( grid [ 0 ] )\n    dp = np.zeros ( ( 2 , n ) )\n    dp [ 0 ] = grid [ 0 ]\n    cur = 0\n    for i in range ( 1 , m ) :\n        next = 1 - cur\n        for j in range ( n ) :\n            dp [ next ] [ j ] = np.inf\n            for k in range ( n ) :\n                dp [ next ] [ j ] = min ( dp [ next ] [ j ] , dp [ cur ] [ k ] + move_cost [ grid [ i - 1 ] [ k ] ] [ j ] + grid [ i ] [ j ] )\n        cur = next\n    return * min_element ( dp [ cur ] )\n", "reference_code": "def minPathCost( grid: List[List[int]], moveCost: List[List[int]]) -> int:\n       m, n = len(grid), len(grid[0])\n       dp = grid[0]\n       for i in range(1, len(grid)):\n           dp = [grid[i][j] + min(dp[k] + moveCost[grid[i - 1][k]][j] for k in range(n)) for j in range(n)]\n       return min(dp)", "target_Lan": "python###minPathCost.py", "target_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(minPathCost([[1]], [[0]]))"}, {"source_Lan": "cpp###maximizeSum.cpp", "source_code": "int maximizeSum(vector<int>& nums, int k) {\n        int m = *max_element(nums.begin(), nums.end());\n        return (2 * m + k - 1) * k / 2;\n    }", "trans_code": "def maximize_sum ( nums , k ) :\n    m = * max_element ( nums )\n    return ( 2 * m + k - 1 ) * k / 2\n", "reference_code": "def maximizeSum( nums: List[int], k: int) -> int:\n        return (2 * max(nums) + k - 1) * k // 2", "target_Lan": "python###maximizeSum.py", "target_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    test_inputs = [\n        ([-2, 5, -1, 3], 3),\n        ([1, 2, 3, 4], 1),\n        ([-10, -5, -3, -7], 5),\n        ([0], 10),\n        ([-100, 100], 2)\n    ]\n    for nums, k in test_inputs:\n        print(maximizeSum(nums, k))"}, {"source_Lan": "cpp###longestAlternatingSubarray.cpp", "source_code": "int longestAlternatingSubarray(vector<int>& nums, int threshold) {\n        int res = 0, dp = 0, n = nums.size();\n        for (int l = n - 1; l >= 0; l--) {\n            if (nums[l] > threshold) {\n                dp = 0;\n            } else if (l == n - 1 || nums[l] % 2 != nums[l + 1] % 2) {\n                dp++;\n            } else {\n                dp = 1;\n            }\n            if (nums[l] % 2 == 0) {\n                res = max(res, dp);\n            }\n        }\n        return res;\n    }", "trans_code": "def longest_alternating_subarray ( nums , threshold ) :\n    res , dp , n = 0 , 0 , len ( nums )\n    for l in range ( n - 1 , - 1 , - 1 ) :\n        if nums [ l ] > threshold : dp = 0\n        elif l == n - 1 or nums [ l ] % 2 != nums [ l + 1 ] % 2 : dp += 1\n        else : dp = 1\n        if nums [ l ] % 2 == 0 : res = max ( res , dp )\n    return res\n", "reference_code": "def longestAlternatingSubarray( nums: List[int], threshold: int) -> int:\n        res, dp = 0, 0\n        for l in range(len(nums) - 1, -1, -1):\n            if nums[l] > threshold:\n                dp = 0\n            elif l == len(nums) - 1 or nums[l] % 2 != nums[l + 1] % 2:\n                dp = dp + 1\n            else:\n                dp = 1\n            res = dp if nums[l] % 2 == 0 and dp > res else res\n        return res", "target_Lan": "python###longestAlternatingSubarray.py", "target_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(longestAlternatingSubarray([], 5))\n    print(longestAlternatingSubarray([7], 10))\n    print(longestAlternatingSubarray([5, 5, 5], 10))\n    print(longestAlternatingSubarray([1, 2, 1, 2, 1], 5))\n    print(longestAlternatingSubarray([2, 7, 4, 3, 6, 1], 6))"}, {"source_Lan": "cpp###findTheLongestBalancedSubstring.cpp", "source_code": "int findTheLongestBalancedSubstring(string s) {\n        int res = 0, n = s.size();\n        vector<int> count(2);\n        for (int i = 0; i < n; i++) {\n            if (s[i] == '1') {\n                count[1]++;\n                res = max(res, 2 * min(count[0], count[1]));\n            } else if (i == 0 || s[i - 1] == '1') {\n                count[0] = 1;\n                count[1] = 0;\n            } else {\n                count[0]++;\n            }\n        }\n        return res;            \n    }", "trans_code": "def findTheLongestBalancedSubstring ( s ) :\n    res , n = 0 , len ( s )\n    count = [ 0 ] * 2\n    for i in range ( n ) :\n        if s [ i ] == '1' :\n            count [ 1 ] += 1\n            res = max ( res , 2 * min ( count [ 0 ] , count [ 1 ] ) )\n        elif i == 0 or s [ i - 1 ] == '1' :\n            count [ 0 ] = 1\n            count [ 1 ] = 0\n        else :\n            count [ 0 ] += 1\n    return res\n", "reference_code": "def findTheLongestBalancedSubstring( s: str) -> int:\n        res = 0\n        n = len(s)\n        count = [0, 0]\n        for i in range(n):\n            if s[i] == '1':\n                count[1] += 1\n                res = max(res, 2 * min(count))\n            elif i == 0 or s[i-1] == '1':\n                count[0] = 1\n                count[1] = 0\n            else:\n                count[0] += 1\n        return res", "target_Lan": "python###findTheLongestBalancedSubstring.py", "target_code_shell": "# TOFILL\nif __name__ == \"__main__\":\n    print(findTheLongestBalancedSubstring(\"\"))          \n    print(findTheLongestBalancedSubstring(\"0101\"))      \n    print(findTheLongestBalancedSubstring(\"000111\"))    \n    print(findTheLongestBalancedSubstring(\"1100\"))      \n    print(findTheLongestBalancedSubstring(\"00110011\"))"}, {"source_Lan": "cpp###vowelStrings.cpp", "source_code": "int vowelStrings(vector<string>& words, int left, int right) {\n        unordered_set<char> vowels = {'a', 'e', 'i', 'o', 'u'};\n        int ans = 0;\n        for (int i = left; i <= right; ++i) {\n            const string& word = words[i];\n            if (vowels.count(word[0]) && vowels.count(word.back())) {\n                ++ans;\n            }\n        }\n        return ans;\n    }", "trans_code": "def vowelStrings ( words , left , right ) :\n    vowels = set ( [ 'a' , 'e' , 'i' , 'o' , 'u' ] )\n    ans = 0\n    for i in range ( left , right + 1 ) :\n        word = words [ i ]\n        if vowels.intersection ( word [ 0 ] ) and vowels.intersection ( word [ - 1 ] ) :\n            ans += 1\n    return ans\n", "reference_code": "def vowelStrings( words: List[str], left: int, right: int) -> int:\n        vowels = set(\"aeiou\")\n        ans = 0\n        for i in range(left, right + 1):\n            word = words[i]\n            if word[0] in vowels and word[-1] in vowels:\n                ans += 1\n        return ans", "target_Lan": "python###vowelStrings.py", "target_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(vowelStrings([\"apple\"], 0, 0))  \n    print(vowelStrings([\"apple\"], 0, 0))  \n    print(vowelStrings([\"bat\"], 0, 0))  \n    print(vowelStrings([\"apple\", \"banana\", \"orange\", \"kiwi\"], 0, 3))"}, {"source_Lan": "cpp###categorizeBox.cpp", "source_code": "string categorizeBox(int length, int width, int height, int mass) {\n        long long maxd = max(length, max(width, height)), vol = 1L * length * width * height;\n        bool isBulky = maxd >= 10000 || vol >= 1000000000, isHeavy = mass >= 100;\n        if (isBulky && isHeavy) {\n             return \"Both\";\n        } else if (isBulky) {\n            return \"Bulky\";\n        } else if (isHeavy) {\n            return \"Heavy\";\n        } else {\n            return \"Neither\";\n        }\n    }", "trans_code": "def categorizeBox ( length , width , height , mass ) :\n    maxd , vol = max ( length , max ( width , height ) ) , 1L * length * width * height\n    isBulky , isHeavy = maxd >= 10000 or vol >= 1000000000 , mass >= 100\n    if isBulky and isHeavy :\n        return \"Both\"\n    elif isBulky :\n        return \"Bulky\"\n    elif isHeavy :\n        return \"Heavy\"\n    else :\n        return \"Neither\"\n", "reference_code": "def categorizeBox( length, width, height, mass):\n        maxd = max(length, width, height)\n        vol = length * width * height\n        isBulky = maxd >= 10000 or vol >= 10**9\n        isHeavy = mass >= 100\n        if isBulky and isHeavy:\n            return 'Both'\n        if isBulky:\n            return 'Bulky'\n        if isHeavy:\n            return 'Heavy'\n        return 'Neither'", "target_Lan": "python###categorizeBox.py", "target_code_shell": "# TOFILL\nif __name__ == \"__main__\":\n    print(categorizeBox(10001, 1, 1, 150))  \n    print(categorizeBox(1, 1, 1, 50))        \n    print(categorizeBox(1, 1, 1, 150))       \n    print(categorizeBox(100, 100, 100, 100)) \n    print(categorizeBox(10, 10, 10, 90))"}, {"source_Lan": "cpp###maxKelements.cpp", "source_code": "long long maxKelements(vector<int>& nums, int k) {\n        priority_queue<int> q(nums.begin(), nums.end());\n        long long ans = 0;\n        for (int _ = 0; _ < k; ++_) {\n            int x = q.top();\n            q.pop();\n            ans += x;\n            q.push((x + 2) / 3);\n        }\n        return ans;\n    }", "trans_code": "def max_kelements ( nums , k ) :\n    q = PriorityQueue ( nums )\n    ans = 0\n    for _ in range ( k ) :\n        x = q.get ( )\n        q.put ( x )\n        ans += x\n        q.put ( ( x + 2 ) / 3 )\n    return ans\n", "reference_code": "def maxKelements( nums: List[int], k: int) -> int:\n        # python \u4e2d\u7684 heap \u9ed8\u8ba4\u662f\u5c0f\u6839\u5806\uff0c\u9700\u8981\u5bf9\u5143\u7d20\u53d6\u76f8\u53cd\u6570\n        q = [-x for x in nums]\n        heapify(q)\n        ans = 0\n        for _ in range(k):\n            x = heappop(q)\n            ans += -x\n            heappush(q, -((-x + 2) // 3))\n        return ans", "target_Lan": "python###maxKelements.py", "target_code_shell": "from typing import List\nfrom heapq import heapify, heappop, heappush\n# TOFILL\nif __name__ == \"__main__\":\n    print(maxKelements([3, 1, 4, 1, 5], 3))\n    print(maxKelements([0, 0, 0, 0], 2))\n    print(maxKelements([-1, -2, -3, -4], 2))\n    print(maxKelements([10, 20, 30], 5))\n    print(maxKelements([1, 2, 3, 4, 5], 0))"}, {"source_Lan": "cpp###pickGifts.cpp", "source_code": "    long long pickGifts(vector<int>& gifts, int k) {\n        priority_queue<int> q(gifts.begin(), gifts.end());\n        while (k--) {\n            int x = q.top(); \n            q.pop();\n            q.push(int(sqrt(x)));\n        }\n        long long res = 0;\n        while (q.size()) {\n            res += q.top(); \n            q.pop();\n        }\n        return res;\n    }", "trans_code": "def pickGifts ( gifts , k ) :\n    q = PriorityQueue ( gifts )\n    while k :\n        x = q.get ( )\n        q.put ( int ( math.sqrt ( x ) ) )\n    res = 0\n    while q :\n        res += q.get ( )\n        q.put ( int ( math.sqrt ( x ) ) )\n    return res\n", "reference_code": "def pickGifts(gifts: List[int], k: int) -> int:\n    q = [-gift for gift in gifts]\n    heapify(q)\n    while k:\n        x = heappop(q)\n        heappush(q, -int(sqrt(-x)))\n        k -= 1\n    return -sum(q)\n", "target_Lan": "python###pickGifts.py", "target_code_shell": "from typing import List\nfrom heapq import heapify, heappop, heappush\nfrom math import sqrt\n# TOFILL\nif __name__ == \"__main__\":\n    print(pickGifts([0, 1, 4, 9], 2))      \n    print(pickGifts([16, 25, 36], 3))      \n    print(pickGifts([1e6, 1e6, 1e6], 1))  \n    print(pickGifts([2, 2, 2, 2], 10))"}, {"source_Lan": "cpp###minimumOneBitOperations.cpp", "source_code": "int minimumOneBitOperations(int n) {\n        int ans = 0;\n        int sign = 1;\n        for (int i = 29; i >= 0; --i) {\n            if (n & (1 << i)) {\n                ans += sign * ((1 << (i + 1)) - 1);\n                sign = -sign;\n            }\n        }\n        return ans;\n    }", "trans_code": "def minimumOneBitOperations ( n ) :\n    ans = 0\n    sign = 1\n    for i in range ( 29 , - 1 , - 1 ) :\n        if n & ( 1 << i ) :\n            ans += sign * ( ( 1 << ( i + 1 ) ) - 1 )\n            sign = - sign\n    return ans\n", "reference_code": "def minimumOneBitOperations( n: int) -> int:\n        ans = 0\n        sign = 1\n        for i in range(29, -1, -1):\n            if n & (1 << i):\n                ans += sign * ((1 << (i + 1)) - 1)\n                sign = -sign\n        return ans", "target_Lan": "python###minimumOneBitOperations.py", "target_code_shell": "# TOFILL\nif __name__ == \"__main__\":\n    print(minimumOneBitOperations(0))   \n    print(minimumOneBitOperations(1))   \n    print(minimumOneBitOperations(2))   \n    print(minimumOneBitOperations(10))  \n    print(minimumOneBitOperations(-1))"}, {"source_Lan": "cpp###successfulPairs.cpp", "source_code": "vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\n        vector<int> res(spells.size());\n        vector<int> idx(spells.size());\n        iota(idx.begin(), idx.end(), 0);\n        sort(idx.begin(), idx.end(), [&](int a, int b) {\n            return spells[a] < spells[b];\n        });\n        sort(potions.begin(), potions.end(), [](int a, int b) {\n            return a > b;\n        });\n        for (int i = 0, j = 0; i < spells.size(); ++i) {\n            int p = idx[i];\n            int v = spells[p];\n            while (j < potions.size() && (long long) potions[j] * v >= success) {\n                ++j;\n            }\n            res[p] = j;\n        }\n        return res;\n    }", "trans_code": "def successfulPairs ( spells , potions , success ) :\n    res = [ 0 ] * len ( spells )\n    idx = [ 0 ] * len ( spells )\n    iota ( idx )\n    idx.sort ( key = lambda a , b : spells [ a ] < spells [ b ] )\n    idx.sort ( key = lambda a , b : a > b )\n    for i , p in enumerate ( spells ) :\n        v = spells [ p ]\n        while j < len ( potions ) and ( long ( potions [ j ] * v ) >= success ) :\n            j += 1\n        res [ p ] = j\n    return res\n", "reference_code": "def successfulPairs( spells: List[int], potions: List[int], success: int) -> List[int]:\n        res = [0] * len(spells)\n        idx = [i for i in range(len(spells))]\n        idx.sort(key = lambda x: spells[x])\n        potions.sort(key = lambda x : -x)\n        j = 0\n        for p in idx:\n            v = spells[p]\n            while j < len(potions) and potions[j] * v >= success:\n                j += 1\n            res[p] = j\n        return res", "target_Lan": "python###successfulPairs.py", "target_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(successfulPairs([], [], 1))  \n    print(successfulPairs([1, 2], [], 1))  \n    print(successfulPairs([1, 2, 3], [1, 2], 10))  \n    print(successfulPairs([2**31-1, 2**31-1], [1, 1], 2**31))  \n    print(successfulPairs([1, 2], [5, 10, 15], 10))"}, {"source_Lan": "cpp###countPairs.cpp", "source_code": "int countPairs(vector<int>& nums, int target) {\n        int res = 0;\n        for (int i = 0; i < nums.size(); i++) {\n            for (int j = i + 1; j < nums.size(); j++) {\n                if (nums[i] + nums[j] < target) {\n                    res++;\n                }\n            }\n        }\n        return res;\n    }", "trans_code": "def countPairs ( nums , target ) :\n    res = 0\n    for i in range ( len ( nums ) ) :\n        for j in range ( i + 1 , len ( nums ) ) :\n            if nums [ i ] + nums [ j ] < target :\n                res += 1\n    return res\n", "reference_code": "def countPairs( nums: List[int], target: int) -> int:\n        return sum(x + y < target for x, y in combinations(nums, 2))", "target_Lan": "python###countPairs.py", "target_code_shell": "from itertools import combinations\nfrom typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(countPairs([], 5))               \n    print(countPairs([3], 5))               \n    print(countPairs([1, 2, 3, 4], 6))     \n    print(countPairs([5, 5, 5, 5], 10))    \n    print(countPairs([-1, 0, 1, 2], 1))"}, {"source_Lan": "cpp###tupleSameProduct.cpp", "source_code": "int tupleSameProduct(vector<int>& nums) {\n        int n = nums.size();\n        int ans = 0;\n        unordered_map<int, int> cnt;\n        for (int i = 0; i < n; i++) {\n            for(int j = i + 1; j < n; j++) {\n                cnt[nums[i] * nums[j]]++;\n            }\n        }\n        for (auto &[k, v] : cnt) {\n            ans += v * (v - 1) * 4;\n        }\n        return ans;\n    }", "trans_code": "def tuple_same_product ( nums ) :\n    n = len ( nums )\n    ans = 0\n    cnt = { }\n    for i in range ( n ) :\n        for j in range ( i + 1 , n ) :\n            cnt [ nums [ i ] * nums [ j ] ] += 1\n    for [ k , v ] in cnt.items ( ) :\n        ans += v * ( v - 1 ) * 4\n    return ans\n", "reference_code": "def tupleSameProduct( nums: List[int]) -> int:\n        n = len(nums)\n        cnt = Counter([nums[i] * nums[j] for i in range(n) for j in range(i + 1, n)])\n        ans = 0\n        for _, v in cnt.items():\n            ans += v * (v - 1) * 4\n        return ans", "target_Lan": "python###tupleSameProduct.py", "target_code_shell": "from collections import Counter\nfrom typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(tupleSameProduct([1, 2, 3, 4]))          \n    print(tupleSameProduct([0, 1, 2, 3]))          \n    print(tupleSameProduct([-1, 1, -2, 2]))        \n    print(tupleSameProduct([100000, 200000]))      \n    print(tupleSameProduct([1, 1, 1, 1]))"}, {"source_Lan": "cpp###sumOfMultiples.cpp", "source_code": "int sumOfMultiples(int n) {\n        int res = 0;\n        for (int i = 1; i <= n; i++) {\n            if (i % 3 == 0 || i % 5 == 0 || i % 7 == 0) {\n                res += i;\n            }\n        }\n        return res;\n    }", "trans_code": "def sumOfMultiples ( n ) :\n    res = 0\n    for i in range ( 1 , n ) :\n        if i % 3 == 0 or i % 5 == 0 or i % 7 == 0 :\n            res += i\n    return res\n", "reference_code": "def sumOfMultiples( n: int) -> int:\n        return sum(i for i in range(1, n + 1) if i % 3 == 0 or i % 5 == 0 or i % 7 == 0)", "target_Lan": "python###sumOfMultiples.py", "target_code_shell": "# TOFILL\nif __name__ == \"__main__\":\n    print(sumOfMultiples(0))\n    print(sumOfMultiples(1))\n    print(sumOfMultiples(8))\n    print(sumOfMultiples(15))\n    print(sumOfMultiples(100))"}, {"source_Lan": "cpp###topStudents.cpp", "source_code": "vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& student_id, int k) {\n        unordered_map<std::string, int> words;\n        for (const auto& word : positive_feedback) {\n            words[word] = 3;\n        }\n        for (const auto& word : negative_feedback) {\n            words[word] = -1;\n        }\n        vector<vector<int>> A;\n        for (int i = 0; i < report.size(); i++) {\n            stringstream ss; \n            string w;\n            int score = 0;\n            ss << report[i];\n            while (ss >> w) {\n                if (words.count(w)) {\n                    score += words[w];\n                }\n            }\n            A.push_back({-score, student_id[i]});\n        }\n        sort(A.begin(), A.end());\n        vector<int> top_k;\n        for (int i = 0; i < k; i++) {\n            top_k.push_back(A[i][1]);\n        }\n        return top_k;\n    }", "trans_code": "def top_students ( positive_feedback , negative_feedback , report , student_id , k ) :\n    words = { }\n    for word in positive_feedback :\n        words [ word ] = 3\n    for word in negative_feedback :\n        words [ word ] = -1\n    A = [ ]\n    for i in range ( len ( report ) ) :\n        try :\n            w = report [ i ]\n            score = 0\n        except IndexError :\n            pass\n        else :\n            if words.has_key ( w ) :\n                score += words [ w ]\n        A.append ( [ - score , student_id [ i ] ] )\n    A.sort ( )\n    top_k = [ ]\n    for i in range ( k ) :\n        top_k.append ( A [ i ] [ 1 ] )\n    return top_k\n", "reference_code": "def topStudents( positive_feedback, negative_feedback, report, student_id, k):\n        words = {}\n        for w in positive_feedback:\n            words[w] = 3\n        for w in negative_feedback:\n            words[w] = -1\n        A = []\n        for s, i in zip(report, student_id):\n            score = sum(words.get(w, 0)for w in s.split())\n            A.append([-score, i])\n        A.sort()\n        return [i for v,i in A[:k]]", "target_Lan": "python###topStudents.py", "target_code_shell": "# TOFILL\nif __name__ == \"__main__\":\n    print(topStudents([], [], [\"good job\", \"bad work\"], [1, 2], 1))\n    print(topStudents([\"excellent\", \"great\"], [\"poor\"], [\"excellent work\", \"poor performance\"], [1, 2], 2))\n    print(topStudents([\"awesome\"], [\"bad\"], [\"awesome job\", \"bad job\", \"bad day\"], [1, 2, 3], 2))\n    print(topStudents([\"good\"], [\"terrible\"], [\"good effort\", \"\", \"just okay\"], [1, 2, 3], 1))\n    print(topStudents([\"fantastic\"], [\"mediocre\"], [\"fantastic performance\", \"mediocre execution\", \"wonderful effort\"], [1, 2, 3], 3))"}, {"source_Lan": "cpp###splitNum.cpp", "source_code": "int splitNum(int num) {\n        string stnum = to_string(num);\n        sort(stnum.begin(), stnum.end());\n        int num1 = 0, num2 = 0;\n        for (int i = 0; i < stnum.size(); ++i) {\n            if (i % 2 == 0) {\n                num1 = num1 * 10 + (stnum[i] - '0');\n            }\n            else {\n                num2 = num2 * 10 + (stnum[i] - '0');\n            }\n        }\n        return num1 + num2;\n    }", "trans_code": "def splitNum ( num ) :\n    stnum = str ( num )\n    stnum = sorted ( stnum )\n    num1 , num2 = 0 , 0\n    for i in range ( len ( stnum ) ) :\n        if i % 2 == 0 :\n            num1 = num1 * 10 + ( stnum [ i ] - '0' )\n        else :\n            num2 = num2 * 10 + ( stnum [ i ] - '0' )\n    return num1 + num2\n", "reference_code": "def splitNum( num: int) -> int:\n        stnum = \"\".join(sorted(str(num)))\n        num1, num2 = int(stnum[::2]), int(stnum[1::2])\n        return num1 + num2", "target_Lan": "python###splitNum.py", "target_code_shell": "# TOFILL\nif __name__ == \"__main__\":\n    print(splitNum(42))         \n    print(splitNum(321))        \n    print(splitNum(112233))     \n    print(splitNum(987654321))"}, {"source_Lan": "cpp###filterRestaurants.cpp", "source_code": "vector<int> filterRestaurants(vector<vector<int>>& restaurants, int veganFriendly, int maxPrice, int maxDistance) {\n        int n = restaurants.size();\n        vector<vector<int>> filtered;\n        for (int i = 0; i < n; i++) {\n            if (restaurants[i][3] <= maxPrice && restaurants[i][4] <= maxDistance && !(veganFriendly && !restaurants[i][2])) {\n                filtered.push_back(restaurants[i]);\n            }\n        }\n        sort(filtered.begin(), filtered.end(), [](vector<int> &v1, vector<int> &v2) -> bool {\n            return v1[1] > v2[1] || (v1[1] == v2[1] && v1[0] > v2[0]);\n        });\n        vector<int> res;\n        for (auto &v : filtered) {\n            res.push_back(v[0]);\n        }\n        return res;\n    }", "trans_code": "def filterRestaurants ( restaurants , veganFriendly , maxPrice , maxDistance ) :\n    n = len ( restaurants )\n    filtered = [ ]\n    for i in range ( n ) :\n        if restaurants [ i ] [ 3 ] <= maxPrice and restaurants [ i ] [ 4 ] <= maxDistance and not ( veganFriendly and not restaurants [ i ] [ 2 ] ) :\n            filtered.append ( restaurants [ i ] )\n    filtered.sort ( key = lambda v1 , v2 : v1 [ 1 ] > v2 [ 1 ] or ( v1 [ 1 ] == v2 [ 1 ] and v1 [ 0 ] > v2 [ 0 ] ) )\n    res = [ ]\n    for v in filtered :\n        res.append ( v [ 0 ] )\n    return res\n", "reference_code": "def filterRestaurants( restaurants: List[List[int]], veganFriendly: int, maxPrice: int, maxDistance: int) -> List[int]:\n        filtered = [r for r in restaurants if r[3] <= maxPrice and r[4] <= maxDistance and not (veganFriendly and not r[2])]\n        filtered.sort(key=lambda r: (-r[1], -r[0]))\n        return [r[0] for r in filtered]", "target_Lan": "python###filterRestaurants.py", "target_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    input1 = ([[1, 4, 1, 10, 5], [2, 5, 1, 20, 7], [3, 3, 0, 30, 10]], 1, 25, 8)\n    input2 = ([[1, 4, 1, 10, 5], [2, 5, 1, 20, 7], [3, 3, 0, 30, 10]], 0, 15, 6)\n    input3 = ([[1, 4, 1, 10, 5]], 1, 10, 5)\n    input4 = ([[1, 4, 0, 30, 10], [2, 5, 1, 50, 2]], 1, 20, 10)\n    input5 = ([[1, 5, 1, 10, 5], [2, 4, 1, 15, 3], [3, 2, 0, 20, 8], [4, 3, 0, 5, 1]], 0, 100, 100)\n    print(filterRestaurants(*input1))  \n    print(filterRestaurants(*input2))  \n    print(filterRestaurants(*input3))  \n    print(filterRestaurants(*input4))  \n    print(filterRestaurants(*input5))"}, {"source_Lan": "cpp###passThePillow.cpp", "source_code": "    int passThePillow(int n, int time) {\n        time %= (n - 1) * 2;\n        return time < n ? time + 1 : n * 2 - time - 1;\n    }", "trans_code": "def passThePillow ( n , time ) :\n    time %= ( n - 1 ) * 2\n    return time < n and time + 1 or n * 2 - time - 1\n", "reference_code": "def passThePillow( n: int, time: int) -> int:\n        time %= (n - 1) * 2\n        return time + 1 if time < n else n * 2 - time - 1", "target_Lan": "python###passThePillow.py", "target_code_shell": "# TOFILL\nif __name__ == \"__main__\":\n    print(passThePillow(2, 1))\n    print(passThePillow(3, 6))\n    print(passThePillow(5, 10))\n    print(passThePillow(1000, 1999))"}, {"source_Lan": "cpp###collectTheCoins.cpp", "source_code": "int collectTheCoins(vector<int>& coins, vector<vector<int>>& edges) {\n        int n = coins.size();\n        vector<vector<int>> g(n);\n        vector<int> degree(n);\n        for (const auto& edge: edges) {\n            int x = edge[0], y = edge[1];\n            g[x].push_back(y);\n            g[y].push_back(x);\n            ++degree[x];\n            ++degree[y];\n        }\n        int rest = n;\n        {\n            \n            queue<int> q;\n            for (int i = 0; i < n; ++i) {\n                if (degree[i] == 1 && !coins[i]) {\n                    q.push(i);\n                }\n            }\n            while (!q.empty()) {\n                int u = q.front();\n                --degree[u];\n                q.pop();\n                --rest;\n                for (int v: g[u]) {\n                    --degree[v];\n                    if (degree[v] == 1 && !coins[v]) {\n                        q.push(v);\n                    }\n                }\n            }\n        }\n        {\n            \n            for (int _ = 0; _ < 2; ++_) {\n                queue<int> q;\n                for (int i = 0; i < n; ++i) {\n                    if (degree[i] == 1) {\n                        q.push(i);\n                    }\n                }\n                while (!q.empty()) {\n                    int u = q.front();\n                    --degree[u];\n                    q.pop();\n                    --rest;\n                    for (int v: g[u]) {\n                        --degree[v];\n                    }\n                }\n            }\n        }\n        return rest == 0 ? 0 : (rest - 1) * 2;\n    }", "trans_code": "def collectTheCoins ( coins , edges ) :\n    n = len ( coins )\n    g = [ [ ] for _ in range ( n ) ]\n    degree = { }\n    for edge in edges :\n        x , y = edge\n        g [ x ].append ( y )\n        g [ y ].append ( x )\n        yield degree [ x ] , degree [ y ]\n    rest = n\n    try :\n        q = queue.Queue ( )\n        for i in range ( n ) :\n            if degree [ i ] == 1 and not coins [ i ] : q.put ( i )\n        while not q.empty ( ) :\n            u = q.get ( )\n            del degree [ u ]\n            q.put ( )\n            del rest\n            for v in g [ u ] :\n                del degree [ v ]\n                if degree [ v ] == 1 and not coins [ v ] : q.put ( v )\n    finally :\n        for _ in range ( 2 ) :\n            q = queue.Queue ( )\n            for i in range ( n ) :\n                if degree [ i ] == 1 : q.put ( i )\n            while not q.empty ( ) :\n                u = q.get ( )\n                del degree [ u ]\n                q.put ( )\n                del rest\n                for v in g [ u ] :\n                    del degree [ v ]\n", "reference_code": "def collectTheCoins( coins: List[int], edges: List[List[int]]) -> int:\n        n = len(coins)\n        g = defaultdict(list)\n        degree = [0] * n\n        for x, y in edges:\n            g[x].append(y)\n            g[y].append(x)\n            degree[x] += 1\n            degree[y] += 1\n        rest = n\n        # \u5220\u9664\u6811\u4e2d\u6240\u6709\u65e0\u91d1\u5e01\u7684\u53f6\u5b50\u8282\u70b9\uff0c\u76f4\u5230\u6811\u4e2d\u6240\u6709\u7684\u53f6\u5b50\u8282\u70b9\u90fd\u662f\u542b\u6709\u91d1\u5e01\u7684\n        q = deque(i for i in range(n) if degree[i] == 1 and coins[i] == 0)\n        while q:\n            u = q.popleft()\n            degree[u] -= 1\n            rest -= 1\n            for v in g[u]:\n                degree[v] -= 1\n                if degree[v] == 1 and coins[v] == 0:\n                    q.append(v)\n        # \u5220\u9664\u6811\u4e2d\u6240\u6709\u7684\u53f6\u5b50\u8282\u70b9, \u8fde\u7eed\u5220\u96642\u6b21\n        for _ in range(2):\n            q = deque(i for i in range(n) if degree[i] == 1)\n            while q:\n                u = q.popleft()\n                degree[u] -= 1\n                rest -= 1\n                for v in g[u]:\n                    degree[v] -= 1\n        return 0 if rest == 0 else (rest - 1) * 2", "target_Lan": "python###collectTheCoins.py", "target_code_shell": "from collections import defaultdict, deque\nfrom typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(collectTheCoins([0, 0, 0], []))\n    print(collectTheCoins([1, 0], [[0, 1]]))\n    print(collectTheCoins([1, 1, 1], [[0, 1], [1, 2]]))\n    print(collectTheCoins([0, 1, 1, 0], [[0, 1], [1, 2], [1, 3]]))\n    print(collectTheCoins([0, 0, 0, 0], [[0, 1], [1, 2], [2, 3], [1, 3]]))"}, {"source_Lan": "cpp###distMoney.cpp", "source_code": "int distMoney(int money, int children) {\n        if (money < children) {\n            return -1;\n        }\n        money -= children;\n        int cnt = min(money / 7, children);\n        money -= cnt * 7;\n        children -= cnt;\n        if ((children == 0 && money > 0) || (children == 1 && money == 3)) {\n            cnt--;\n        }\n        return cnt;\n    }", "trans_code": "def distMoney ( money , children ) :\n    if money < children :\n        return -1\n    money -= children\n    cnt = min ( money / 7 , children )\n    money -= cnt * 7\n    children -= cnt\n    if ( children == 0 and money > 0 ) or ( children == 1 and money == 3 ) :\n        cnt -= 1\n    return cnt\n", "reference_code": "def distMoney( money: int, children: int) -> int:\n        if money < children:\n            return -1\n        money -= children\n        cnt = min(money // 7, children)\n        money -= cnt * 7\n        children -= cnt\n        if (children == 0 and money > 0) or (children == 1 and money == 3):\n            cnt -= 1\n        return cnt", "target_Lan": "python###distMoney.py", "target_code_shell": "# TOFILL\nif __name__ == \"__main__\":\n    print(distMoney(3, 5))\n    print(distMoney(5, 5))\n    print(distMoney(20, 3))\n    print(distMoney(30, 5))\n    print(distMoney(1000000000, 142857143))"}, {"source_Lan": "cpp###queensAttacktheKing.cpp", "source_code": "vector<vector<int>> queensAttacktheKing(vector<vector<int>>& queens, vector<int>& king) {\n        unordered_set<int> queen_pos;\n        for (const auto& queen: queens) {\n            int x = queen[0], y = queen[1];\n            queen_pos.insert(x * 8 + y);\n        }\n        vector<vector<int>> ans;\n        for (int dx = -1; dx <= 1; ++dx) {\n            for (int dy = -1; dy <= 1; ++dy) {\n                if (dx == 0 && dy == 0) {\n                    continue;\n                }\n                int kx = king[0] + dx, ky = king[1] + dy;\n                while (kx >= 0 && kx < 8 && ky >= 0 && ky < 8) {\n                    int pos = kx * 8 + ky;\n                    if (queen_pos.count(pos)) {\n                        ans.push_back({kx, ky});\n                        break;\n                    }\n                    kx += dx;\n                    ky += dy;\n                }\n            }\n        }\n        return ans;\n    }", "trans_code": "def queensAttacktheKing ( queens , king ) :\n    queen_pos = set ( )\n    for queen in queens :\n        x , y = queen\n        queen_pos.add ( x * 8 + y )\n    ans = [ ]\n    for dx in [ -1 , 1 ] :\n        for dy in [ -1 , 1 ] :\n            if dx == 0 and dy == 0 :\n                continue\n            kx , ky = king + dx , king + dy\n            while kx >= 0 and kx < 8 and ky >= 0 and ky < 8 :\n                pos = kx * 8 + ky\n                if queen_pos.add ( pos ) :\n                    ans.append ( [ kx , ky ] )\n                    break\n                kx += dx\n                ky += dy\n    return ans\n", "reference_code": "def queensAttacktheKing( queens: List[List[int]], king: List[int]) -> List[List[int]]:\n        queen_pos = set((x, y) for x, y in queens)\n        ans = list()\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == dy == 0:\n                    continue\n                kx, ky = king[0] + dx, king[1] + dy\n                while 0 <= kx < 8 and 0 <= ky < 8:\n                    if (kx, ky) in queen_pos:\n                        ans.append([kx, ky])\n                        break\n                    kx += dx\n                    ky += dy\n        return ans", "target_Lan": "python###queensAttacktheKing.py", "target_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(queensAttacktheKing([], [4, 4]))  \n    print(queensAttacktheKing([[3, 3], [4, 3], [4, 5], [5, 4]], [4, 4]))  \n    print(queensAttacktheKing([[0, 0], [2, 1], [5, 5]], [4, 4]))  \n    print(queensAttacktheKing([[4, 5], [5, 4], [2, 4]], [4, 4]))  \n    print(queensAttacktheKing([[0, 0], [0, 1], [1, 0], [1, 1]], [0, 2]))"}, {"source_Lan": "cpp###giveGem.cpp", "source_code": "int giveGem(vector<int>& gem, vector<vector<int>>& operations) {\n        for (auto &operation : operations) {\n            int x = operation[0], y = operation[1];\n            int number = gem[x] / 2;\n            gem[x] -= number;\n            gem[y] += number;\n        }\n        int mn = *min_element(gem.begin(), gem.end());\n        int mx = *max_element(gem.begin(), gem.end());\n        return mx - mn;\n    }", "trans_code": "def give_gem ( gem , operations ) :\n    for operation in operations :\n        x , y = operation\n        number = gem [ x ] / 2\n        gem [ x ] -= number\n        gem [ y ] += number\n    mn = * min_element ( gem )\n    mx = * max_element ( gem )\n    return mx - mn\n", "reference_code": "def giveGem( gem: List[int], operations: List[List[int]]) -> int:\n        for x, y in operations:\n            number = gem[x] // 2\n            gem[x] -= number\n            gem[y] += number\n        mn, mx = gem[0], gem[0]\n        for number in gem:\n            mn = min(number, mn)\n            mx = max(number, mx)\n        return mx - mn", "target_Lan": "python###giveGem.py", "target_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    gem1 = [3, 2, 5, 1]\n    operations1 = [[0, 2], [1, 3]]\n    gem2 = [1000, 2000, 3000, 4000]\n    operations2 = [[1, 3], [0, 2]]\n    gem3 = [-5, -3, -1, 2]\n    operations3 = [[2, 1], [3, 0]]\n    gem4 = [7, 8, 9, 10]\n    operations4 = [[0, 1], [2, 3]]\n    gem5 = [1, 2, 3, 4]\n    operations5 = [[2, 0], [3, 1]]\n    test_inputs = [\n        (gem1, operations1),\n        (gem2, operations2),\n        (gem3, operations3),\n        (gem4, operations4),\n        (gem5, operations5)\n    ]\n    for gem, operations in test_inputs:\n        print(giveGem(gem, operations))"}, {"source_Lan": "cpp###checkValidGrid.cpp", "source_code": "bool checkValidGrid(vector<vector<int>>& grid) {\n        if (grid[0][0] != 0) {\n            return false;\n        }\n        int n = grid.size();\n        vector<array<int, 2>> indices(n * n);\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                indices[grid[i][j]] = {i, j};\n            }\n        }\n        for (int i = 1; i < indices.size(); i++) {\n            int dx = abs(indices[i][0] - indices[i - 1][0]);\n            int dy = abs(indices[i][1] - indices[i - 1][1]);\n            if (dx * dy != 2) {\n                return false;\n            }\n        }\n        return true;\n    }", "trans_code": "def checkValidGrid ( grid ) :\n    if grid [ 0 ] [ 0 ] != 0 :\n        return False\n    n = len ( grid )\n    indices = [ array ( 'i' ) for i in range ( n * n ) ]\n    for i in range ( n ) :\n        for j in range ( n ) :\n            indices [ grid [ i ] [ j ] ] = [ i , j ]\n    for i in range ( 1 , len ( indices ) ) :\n        dx = abs ( indices [ i ] [ 0 ] - indices [ i - 1 ] [ 0 ] )\n        dy = abs ( indices [ i ] [ 1 ] - indices [ i - 1 ] [ 1 ] )\n        if dx * dy != 2 :\n            return False\n    return True\n", "reference_code": "def checkValidGrid( grid: List[List[int]]) -> bool:\n        if grid[0][0] != 0:\n            return False\n        n = len(grid)\n        indices = [[] for _ in range(n * n)]\n        for i in range(n):\n            for j in range(n):\n                indices[grid[i][j]] = [i, j]\n        for i in range(1, n * n, 1):\n            dx = abs(indices[i][0] - indices[i - 1][0])\n            dy = abs(indices[i][1] - indices[i - 1][1])\n            if dx * dy != 2:\n                return False\n        return True", "target_Lan": "python###checkValidGrid.py", "target_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(checkValidGrid([[0]]))  \n    print(checkValidGrid([[0, 1], [2, 3]]))  \n    print(checkValidGrid([[0, 1], [3, 2]]))  \n    print(checkValidGrid([[0, 2, 4], [3, 1, 5], [6, 7, 8]]))  \n    print(checkValidGrid([[0, 1, 3], [2, 4, 5], [6, 7, 8]]))"}, {"source_Lan": "cpp###findDelayedArrivalTime.cpp", "source_code": "    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\n        return (arrivalTime + delayedTime) % 24;\n    }", "trans_code": "def findDelayedArrivalTime ( arrivalTime , delayedTime ) :\n    return ( arrivalTime + delayedTime ) % 24\n", "reference_code": "def findDelayedArrivalTime( arrivalTime: int, delayedTime: int) -> int:\n        return (arrivalTime + delayedTime) % 24", "target_Lan": "python###findDelayedArrivalTime.py", "target_code_shell": "# TOFILL\nif __name__ == \"__main__\":\n    print(findDelayedArrivalTime(0, 0))\n    print(findDelayedArrivalTime(23, 1))\n    print(findDelayedArrivalTime(23, 5))\n    print(findDelayedArrivalTime(-1, 10))\n    print(findDelayedArrivalTime(10, 15))"}, {"source_Lan": "cpp###checkIfPrerequisite.cpp", "source_code": "vector<bool> checkIfPrerequisite(int numCourses, vector<vector<int>>& prerequisites, vector<vector<int>>& queries) {\n        vector<vector<int>> g(numCourses);\n        vector<int> indgree(numCourses, 0);\n        vector<vector<bool>> isPre(numCourses, vector<bool>(numCourses, false));\n        for (auto& p : prerequisites) {\n            ++indgree[p[1]];\n            g[p[0]].push_back(p[1]);\n        }\n        queue<int> q;\n        for (int i = 0; i < numCourses; ++i) {\n            if (indgree[i] == 0) {\n                q.push(i);\n            }\n        }\n        while (!q.empty()) {\n            auto cur = q.front();\n            q.pop();\n            for (auto& ne : g[cur]) {\n                isPre[cur][ne] = true;\n                for (int i = 0; i < numCourses; ++i) {\n                    isPre[i][ne] = isPre[i][ne] | isPre[i][cur];\n                }\n                --indgree[ne];\n                if (indgree[ne] == 0) {\n                    q.push(ne);\n                }\n            }\n        }\n        vector<bool> res;\n        for (auto& query : queries) {\n            res.push_back(isPre[query[0]][query[1]]);\n        }\n        return res;\n    }", "trans_code": "def check_if_prerequisite ( num_courses , prerequisites , queries ) :\n    g = defaultdict ( list )\n    indgree = defaultdict ( list )\n    is_pre = defaultdict ( list )\n    for p in prerequisites :\n        yield indgree [ p [ 1 ] ]\n        g [ p [ 0 ] ].append ( p [ 1 ] )\n    q = queue.Queue ( )\n    for i in range ( num_courses ) :\n        if indgree [ i ] == 0 : q.put ( i )\n    while not q.empty ( ) :\n        cur = q.get ( )\n        q.put ( )\n        for ne in g [ cur ] :\n            is_pre [ cur ] [ ne ] = True\n            for i in range ( num_courses ) :\n                is_pre [ i ] [ ne ] = is_pre [ i ] [ ne ] | is_pre [ i ] [ cur ]\n            del indgree [ ne ]\n            if indgree [ ne ] == 0 : q.put ( ne )\n    res = [ ]\n    for query in queries :\n        res.append ( is_pre [ query [ 0 ] ] [ query [ 1 ] ] )\n    return res\n", "reference_code": "def checkIfPrerequisite( numCourses: int, prerequisites: List[List[int]], queries: List[List[int]]) -> List[bool]:\n        g = [[] for _ in range(numCourses)]\n        indgree = [0] * numCourses\n        isPre = [[False] * numCourses for _ in range(numCourses)]\n        for p in prerequisites:\n            indgree[p[1]] += 1\n            g[p[0]].append(p[1])\n        q = []\n        for i in range(numCourses):\n            if indgree[i] == 0:\n                q.append(i)\n        while len(q) > 0:\n            cur = q[0]\n            q.pop(0)\n            for ne in g[cur]:\n                isPre[cur][ne] = True\n                for i in range(numCourses):\n                    isPre[i][ne] = isPre[i][ne] or isPre[i][cur]\n                indgree[ne] -= 1\n                if indgree[ne] == 0:\n                    q.append(ne)\n        res = []\n        for query in queries:\n            res.append(isPre[query[0]][query[1]])\n        return res", "target_Lan": "python###checkIfPrerequisite.py", "target_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(checkIfPrerequisite(1, [], [[0, 0]]))\n    print(checkIfPrerequisite(3, [[0, 1], [1, 2]], [[0, 1], [1, 2], [0, 2]]))\n    print(checkIfPrerequisite(3, [[0, 1], [0, 2]], [[1, 0], [2, 0], [0, 1], [0, 2]]))\n    print(checkIfPrerequisite(4, [[0, 1], [1, 2], [2, 3]], [[0, 3], [3, 0], [0, 2], [1, 3], [2, 1]]))"}, {"source_Lan": "cpp###minTrioDegree.cpp", "source_code": "int minTrioDegree(int n, vector<vector<int>>& edges) {\n        \n        vector<unordered_set<int>> g(n);\n        \n        vector<vector<int>> h(n);\n        vector<int> degree(n);\n        for (auto&& edge: edges) {\n            int x = edge[0] - 1, y = edge[1] - 1;\n            g[x].insert(y);\n            g[y].insert(x);\n            ++degree[x];\n            ++degree[y];\n        }\n        for (auto&& edge: edges) {\n            int x = edge[0] - 1, y = edge[1] - 1;\n            if (degree[x] < degree[y] || (degree[x] == degree[y] && x < y)) {\n                h[x].push_back(y);\n            }\n            else {\n                h[y].push_back(x);\n            }\n        }\n        int ans = INT_MAX;\n        for (int i = 0; i < n; ++i) {\n            for (int j: h[i]) {\n                for (int k: h[j]) {\n                    if (g[i].count(k)) {\n                        ans = min(ans, degree[i] + degree[j] + degree[k] - 6);\n                    }\n                }\n            }\n        }\n        return ans == INT_MAX ? -1 : ans;\n    }", "trans_code": "def minTrioDegree ( n , edges ) :\n    g = defaultdict ( set )\n    h = defaultdict ( set )\n    degree = defaultdict ( int )\n    for edge in edges :\n        x , y = edge [ 0 ] - 1 , edge [ 1 ] - 1\n        g [ x ].add ( y )\n        g [ y ].add ( x )\n        yield degree [ x ] , degree [ y ]\n    for edge in edges :\n        x , y = edge [ 0 ] - 1 , edge [ 1 ] - 1\n        if degree [ x ] < degree [ y ] or ( degree [ x ] == degree [ y ] and x < y ) :\n            h [ x ].add ( y )\n        else :\n            h [ y ].add ( x )\n    ans = sys.maxint\n    for i in range ( n ) :\n        for j in range ( h [ i ] ) :\n            for k in range ( h [ j ] ) :\n                if g [ i ].count ( k ) :\n                    ans = min ( ans , degree [ i ] + degree [ j ] + degree [ k ] - 6 )\n", "reference_code": "def minTrioDegree( n: int, edges: List[List[int]]) -> int:\n        # \u539f\u56fe\n        g = defaultdict(set)\n        # \u5b9a\u5411\u540e\u7684\u56fe\n        h = defaultdict(list)\n        degree = [0] * n\n        for x, y in edges:\n            x, y = x - 1, y - 1\n            g[x].add(y)\n            g[y].add(x)\n            degree[x] += 1\n            degree[y] += 1\n        for x, y in edges:\n            x, y = x - 1, y - 1\n            if degree[x] < degree[y] or (degree[x] == degree[y] and x < y):\n                h[x].append(y)\n            else:\n                h[y].append(x)\n        ans = inf\n        for i in range(n):\n            for j in h[i]:\n                for k in h[j]:\n                    if k in g[i]:\n                        ans = min(ans, degree[i] + degree[j] + degree[k] - 6)\n        return -1 if ans == inf else ans", "target_Lan": "python###minTrioDegree.py", "target_code_shell": "from typing import List\nfrom collections import defaultdict\nfrom math import inf\n# TOFILL\nif __name__ == \"__main__\":\n    print(minTrioDegree(3, [[1,2],[2,3],[1,3]]))  \n    print(minTrioDegree(5, [[1,2],[2,3],[3,4],[4,5]]))  \n    print(minTrioDegree(4, [[1,2],[2,3],[3,4],[1,3],[1,4]]))  \n    print(minTrioDegree(6, [[1,2],[2,3],[3,4],[1,4],[3,5],[5,6]]))  \n    print(minTrioDegree(7, [[1,2],[2,3],[3,4],[1,5],[5,6],[6,7],[3,6]]))"}, {"source_Lan": "cpp###minimumJumps.cpp", "source_code": "int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\n        queue<tuple<int, int, int>> q;\n        unordered_set<int> visited;\n        q.emplace(0, 1, 0);\n        visited.emplace(0);\n        int lower = 0, upper = max(*max_element(forbidden.begin(), forbidden.end()) + a, x) + b;\n        unordered_set<int> forbiddenSet(forbidden.begin(), forbidden.end());\n        while (!q.empty()) {\n            auto [position, direction, step] = q.front();\n            q.pop();\n            if (position == x) {\n                return step;\n            }\n            int nextPosition = position + a;\n            int nextDirection = 1;\n            if (lower <= nextPosition && nextPosition <= upper && !visited.count(nextPosition * nextDirection) && !forbiddenSet.count(nextPosition)) {\n                visited.emplace(nextPosition * nextDirection);\n                q.emplace(nextPosition, nextDirection, step + 1);\n            }\n            if (direction == 1) {\n                nextPosition = position - b;\n                nextDirection = -1;\n                if (lower <= nextPosition && nextPosition <= upper && !visited.count(nextPosition * nextDirection) && !forbiddenSet.count(nextPosition)) {\n                    visited.emplace(nextPosition * nextDirection);\n                    q.emplace(nextPosition, nextDirection, step + 1);\n                }\n            }\n        }\n        return -1;\n    }", "trans_code": "def minimum_jumps ( forbidden , a , b , x ) :\n    q = queue.Queue ( )\n    visited = set ( )\n    q.put ( ( 0 , 1 , 0 ) )\n    visited.add ( 0 )\n    lower , upper = 0 , max ( * max_element ( forbidden ) + a , x ) + b\n    forbidden_set = set ( forbidden )\n    while not q.empty ( ) :\n        [ position , direction , step ] = q.get ( )\n        q.put ( ( position , direction , step + 1 ) )\n        if position == x :\n            return step\n        next_position = position + a\n        next_direction = 1\n        if lower <= next_position <= upper and not visited.add ( next_position * next_direction ) and not forbidden_set.add ( next_position ) :\n            visited.add ( next_position * next_direction )\n            q.put ( ( next_position , next_direction , step + 1 ) )\n        if direction == 1 :\n            next_position = position - b\n            next_direction = -1\n            if lower <= next_position <= upper and not visited.add ( next_position * next_direction ) and not forbidden_set.add ( next_position ) :\n                visited.add ( next_position * next_direction )\n                q.put ( ( next_position , next_direction , step + 1 ) )\n    return -1\n", "reference_code": "def minimumJumps( forbidden: List[int], a: int, b: int, x: int) -> int:\n        q, visited = deque([[0, 1, 0]]), set([0])\n        lower, upper = 0, max(max(forbidden) + a, x) + b\n        forbiddenSet = set(forbidden)\n        while q:\n            position, direction, step = q.popleft()\n            if position == x:\n                return step\n            nextPosition = position + a\n            nextDirection = 1\n            if lower <= nextPosition <= upper and nextPosition * nextDirection not in visited and nextPosition not in forbiddenSet:\n                visited.add(nextPosition * nextDirection)\n                q.append([nextPosition, nextDirection, step + 1])\n            if direction == 1:\n                nextPosition = position - b\n                nextDirection = -1\n                if lower <= nextPosition <= upper and nextPosition * nextDirection not in visited and nextPosition not in forbiddenSet:\n                    visited.add(nextPosition * nextDirection)\n                    q.append([nextPosition, nextDirection, step + 1])\n        return -1", "target_Lan": "python###minimumJumps.py", "target_code_shell": "from collections import deque\nfrom typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(minimumJumps([3], 2, 1, 5))       \n    print(minimumJumps([2, 4], 1, 2, 5))    \n    print(minimumJumps([1, 2, 5], 5, 1, 10)) \n    print(minimumJumps([6, 7, 8], 1, 1, 10))"}, {"source_Lan": "cpp###numFactoredBinaryTrees.cpp", "source_code": "int numFactoredBinaryTrees(vector<int>& arr) {\n        sort(arr.begin(), arr.end());\n        int n = arr.size();\n        vector<long long> dp(n);\n        long long res = 0, mod = 1e9 + 7;\n        for (int i = 0; i < n; i++) {\n            dp[i] = 1;\n            for (int left = 0, right = i - 1; left <= right; left++) {\n                while (right >= left && (long long)arr[left] * arr[right] > arr[i]) {\n                    right--;\n                }\n                if (right >= left && (long long)arr[left] * arr[right] == arr[i]) {\n                    if (right != left) {\n                        dp[i] = (dp[i] + dp[left] * dp[right] * 2) % mod;\n                    } else {\n                        dp[i] = (dp[i] + dp[left] * dp[right]) % mod;\n                    }\n                }\n            }\n            res = (res + dp[i]) % mod;\n        }\n        return res;\n    }", "trans_code": "def numFactoredBinaryTrees ( arr ) :\n    arr = sorted ( arr )\n    n = len ( arr )\n    dp = [ 0 ] * n\n    res , mod = 0 , 1e9 + 7\n    for i in range ( n ) :\n        dp [ i ] = 1\n        for left , right in zip ( arr , i - 1 ) :\n            while right >= left and int ( arr [ left ] * arr [ right ] ) > arr [ i ] :\n                right -= 1\n            if right >= left and int ( arr [ left ] * arr [ right ] ) == arr [ i ] :\n                if right != left :\n                    dp [ i ] = ( dp [ i ] + dp [ left ] * dp [ right ] ** 2 ) % mod\n                else :\n                    dp [ i ] = ( dp [ i ] + dp [ left ] * dp [ right ] ) % mod\n        res = ( res + dp [ i ] ) % mod\n    return res\n", "reference_code": "def numFactoredBinaryTrees( arr: List[int]) -> int:\n        n = len(arr)\n        arr = sorted(arr)\n        dp = [1] * n\n        res, mod = 0, 10**9 + 7\n        for i in range(n):\n            left, right = 0, i - 1\n            while left <= right:\n                while right >= left and arr[left] * arr[right] > arr[i]:\n                    right -= 1\n                if right >= left and arr[left] * arr[right] == arr[i]:\n                    if right != left:\n                        dp[i] = (dp[i] + dp[left] * dp[right] * 2) % mod\n                    else:\n                        dp[i] = (dp[i] + dp[left] * dp[right]) % mod\n                left += 1\n            res = (res + dp[i]) % mod\n        return res", "target_Lan": "python###numFactoredBinaryTrees.py", "target_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(numFactoredBinaryTrees([]))                     \n    print(numFactoredBinaryTrees([2]))                    \n    print(numFactoredBinaryTrees([2, 4, 8]))              \n    print(numFactoredBinaryTrees([2, 2, 4, 4, 8]))        \n    print(numFactoredBinaryTrees([3, 5, 7, 11]))"}, {"source_Lan": "cpp###countPairs.cpp", "source_code": "vector<int> countPairs(int n, vector<vector<int>>& edges, vector<int>& queries) {\n        vector<int> degree(n);\n        unordered_map<int, int> cnt;\n        for (auto edge : edges) {\n            int x = edge[0] - 1, y = edge[1] - 1;\n            if (x > y) {\n                swap(x, y);\n            }\n            degree[x]++;\n            degree[y]++;\n            cnt[x * n + y]++;\n        }\n        vector<int> arr = degree;\n        vector<int> ans;\n        sort(arr.begin(), arr.end());\n        for (int bound : queries) {\n            int total = 0;\n            for (int i = 0, j = n - 1; i < n; i++) {\n                while (j > i && arr[i] + arr[j] > bound) {\n                    j--;\n                }\n                total += n - 1 - max(i, j);\n            }\n            for (auto &[val, freq] : cnt) {\n                int x = val / n;\n                int y = val % n;\n                if (degree[x] + degree[y] > bound && degree[x] + degree[y] - freq <= bound) {\n                    total--;\n                }\n            }\n            ans.emplace_back(total);\n        }\n        return ans;\n    }", "trans_code": "def countPairs ( n , edges , queries ) :\n    degree = [ 0 ] * n\n    cnt = { }\n    for edge in edges :\n        x , y = edge [ 0 ] - 1 , edge [ 1 ] - 1\n        if x > y : swap ( x , y )\n        degree [ x ] += 1\n        degree [ y ] += 1\n        cnt [ x * n + y ] += 1\n    arr = degree\n    ans = [ ]\n    arr.sort ( )\n    for bound in queries :\n        total = 0\n        for i , j in enumerate ( arr ) :\n            while j > i and arr [ i ] + arr [ j ] > bound : j -= 1\n            total += n - 1 - max ( i , j )\n        for [ val , freq ] in cnt.items ( ) :\n            x = val // n\n            y = val % n\n            if degree [ x ] + degree [ y ] > bound and degree [ x ] + degree [ y ] - freq <= bound :\n                total -= 1\n        ans.append ( total )\n    return ans\n", "reference_code": "def countPairs( n: int, edges: List[List[int]], queries: List[int]) -> List[int]:\n        degree = [0 for _ in range(n)]\n        cnt = collections.defaultdict(int)\n        for edge in edges:\n            x, y = edge[0] - 1, edge[1] - 1\n            if x > y:\n                x, y = y, x\n            degree[x] += 1\n            degree[y] += 1\n            cnt[x * n + y] += 1\n        arr = sorted(degree)\n        ans = []\n        for bound in queries:\n            total = 0\n            j = n - 1\n            for i in range(n):\n                while j > i and arr[i] + arr[j] > bound:\n                    j -= 1\n                total += n - 1 - max(i, j)\n            for val, freq in cnt.items():\n                x, y = val // n, val % n\n                if degree[x] + degree[y] > bound and degree[x] + degree[y] - freq <= bound:\n                    total -= 1\n            ans.append(total)\n        return ans", "target_Lan": "python###countPairs.py", "target_code_shell": "import collections\nfrom typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(countPairs(3, [[1, 2], [2, 3]], [1, 2, 3]))  \n    print(countPairs(3, [[1, 2], [2, 3], [1, 3]], [2, 3]))  \n    print(countPairs(5, [[1, 2], [2, 3]], [1, 2, 5]))  \n    print(countPairs(4, [[1, 2], [1, 3], [1, 4]], [1, 3, 4]))  \n    print(countPairs(4, [[1, 2], [1, 3]], [1, 10]))"}, {"source_Lan": "cpp###captureForts.cpp", "source_code": "int captureForts(vector<int>& forts) {\n        int ans = 0, pre = -1;\n        for (int i = 0; i < forts.size(); i++) {\n            if (forts[i] == 1 || forts[i] == -1) {\n                if (pre >= 0 && forts[i] != forts[pre]) {\n                    ans = max(ans, i - pre - 1);\n                }\n                pre = i;\n            }\n        }\n        return ans;\n    }", "trans_code": "def captureForts ( forts ) :\n    ans , pre = 0 , -1\n    for i in range ( len ( forts ) ) :\n        if forts [ i ] == 1 or forts [ i ] == -1 :\n            if pre >= 0 and forts [ i ] != forts [ pre ] : ans = max ( ans , i - pre - 1 )\n            pre = i\n    return ans\n", "reference_code": "def captureForts( forts: List[int]) -> int:\n        ans, pre = 0, -1\n        for i, fort in enumerate(forts):\n            if fort == -1 or fort == 1:\n                if pre >= 0 and fort != forts[pre]:\n                    ans = max(ans, i - pre - 1)\n                pre = i\n        return ans", "target_Lan": "python###captureForts.py", "target_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(captureForts([]))  \n    print(captureForts([1, 1, 1]))  \n    print(captureForts([-1, -1, -1]))  \n    print(captureForts([1, 0, -1, 0, 1]))  \n    print(captureForts([0, 0, 1, 0, -1, 0, 0]))"}, {"source_Lan": "cpp###maxDistToClosest.cpp", "source_code": "int maxDistToClosest(vector<int>& seats) {\n        int res = 0;\n        int l = 0;\n        while (l < seats.size() && seats[l] == 0) {\n            ++l;\n        }\n        res = max(res, l);\n        while (l < seats.size()) {\n            int r = l + 1;\n            while (r < seats.size() && seats[r] == 0) {\n                ++r;\n            }\n            if (r == seats.size()) {\n                res = max(res, r - l - 1);\n            } else {\n                res = max(res, (r - l) / 2);\n            }\n            l = r;\n        }\n        return res;\n    }", "trans_code": "def maxDistToClosest ( seats ) :\n    res = 0\n    l = 0\n    while l < len ( seats ) and seats [ l ] == 0 : l += 1\n    res = max ( res , l )\n    while l < len ( seats ) :\n        r = l + 1\n        while r < len ( seats ) and seats [ r ] == 0 : r += 1\n        if r == len ( seats ) : res = max ( res , r - l - 1 )\n        else : res = max ( res , ( r - l ) / 2 )\n        l = r\n    return res\n", "reference_code": "def maxDistToClosest( seats: List[int]) -> int:\n        res, l = 0, 0\n        while l < len(seats) and seats[l] == 0:\n            l += 1\n        res = max(res, l)\n        while l < len(seats):\n            r = l + 1\n            while r < len(seats) and seats[r] == 0:\n                r += 1\n            if r == len(seats):\n                res = max(res, r - l - 1)\n            else:\n                res = max(res, (r - l) // 2)\n            l = r\n        return res", "target_Lan": "python###maxDistToClosest.py", "target_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(maxDistToClosest([0, 0, 0, 0]))           \n    print(maxDistToClosest([1, 1, 1, 1]))           \n    print(maxDistToClosest([1, 0, 0, 1]))           \n    print(maxDistToClosest([0, 1, 0, 0, 1]))        \n    print(maxDistToClosest([1, 0, 1, 0, 0, 1]))"}, {"source_Lan": "cpp###ways.cpp", "source_code": "int ways(vector<string>& pizza, int k) {\n        int m = pizza.size(), n = pizza[0].size(), mod = 1e9 + 7;\n        vector<vector<int>> apples(m + 1, vector<int>(n + 1));\n        vector<vector<vector<int>>> dp(k + 1, vector<vector<int>>(m + 1, vector<int>(n + 1)));\n        \n        for (int i = m - 1; i >= 0; i--) {\n            for (int j = n - 1; j >= 0; j--) {\n                apples[i][j] = apples[i][j + 1] + apples[i + 1][j] - apples[i + 1][j + 1] + (pizza[i][j] == 'A');\n                dp[1][i][j] = apples[i][j] > 0;\n            }\n        }\n        for (int ki = 2; ki <= k; ki++) {\n            for (int i = 0; i < m; i++) {\n                for (int j = 0; j < n; j++) {\n                    \n                    for (int i2 = i + 1; i2 < m; i2++) {\n                        if (apples[i][j] > apples[i2][j]) {\n                            dp[ki][i][j] = (dp[ki][i][j] + dp[ki - 1][i2][j]) % mod;\n                        }\n                    }\n                    \n                    for (int j2 = j + 1; j2 < n; j2++) {\n                        if (apples[i][j] > apples[i][j2]) {\n                            dp[ki][i][j] = (dp[ki][i][j] + dp[ki - 1][i][j2]) % mod;\n                        }\n                    }\n                }\n            }\n        }\n        return dp[k][0][0];\n    }", "trans_code": "def ways ( pizza , k ) :\n    m , n , mod = len ( pizza ) , len ( pizza [ 0 ] ) , 1e9 + 7\n    apples = np.zeros ( ( m + 1 , n + 1 ) )\n    dp = np.zeros ( ( k + 1 , m + 1 ) )\n    for i in range ( m - 1 , - 1 , - 1 ) :\n        for j in range ( n - 1 , - 1 , - 1 ) :\n            apples [ i ] [ j ] = apples [ i ] [ j + 1 ] + apples [ i + 1 ] [ j ] - apples [ i + 1 ] [ j + 1 ] + ( pizza [ i ] [ j ] == 'A' )\n            dp [ 1 ] [ i ] [ j ] = apples [ i ] [ j ] > 0\n    for ki in range ( 2 , k + 1 ) :\n        for i in range ( m ) :\n            for j in range ( n ) :\n                for i2 in range ( i + 1 , m ) :\n                    if apples [ i ] [ j ] > apples [ i2 ] [ j ] :\n                        dp [ ki ] [ i ] [ j ] = ( dp [ ki ] [ i ] [ j ] + dp [ ki - 1 ] [ i2 ] [ j ] ) % mod\n                for j2 in range ( j + 1 , n ) :\n                    if apples [ i ] [ j ] > apples [ i ] [ j2 ] :\n                        dp [ ki ] [ i ] [ j ] = ( dp [ ki ] [ i ] [ j ] + dp [ ki - 1 ] [ i ] [ j2 ] ) % mod\n    return dp [ k ] [ 0 ] [ 0 ]\n", "reference_code": "def ways( pizza: List[str], k: int) -> int:\n        m, n, mod = len(pizza), len(pizza[0]), 10 ** 9 + 7\n        apples = [[0] * (n + 1) for _ in range(m + 1)]\n        dp = [[[0 for j in range(n)] for i in range(m)] for _ in range(k + 1)]\n        # \u9884\u5904\u7406\n        for i in range(m - 1, -1, -1):\n            for j in range(n - 1, -1, -1):\n                apples[i][j] = apples[i][j + 1] + apples[i + 1][j] - apples[i + 1][j + 1] + (pizza[i][j] == 'A')\n                dp[1][i][j] = 1 if apples[i][j] > 0 else 0\n        for k in range(1, k + 1):\n            for i in range(m):\n                for j in range(n):\n                    # \u6c34\u5e73\u65b9\u5411\u5207\n                    for i2 in range(i + 1, m):\n                        if apples[i][j] > apples[i2][j]:\n                            dp[k][i][j] = (dp[k][i][j] + dp[k - 1][i2][j]) % mod\n                    # \u5782\u76f4\u65b9\u5411\u5207\n                    for j2 in range(j + 1, n):\n                        if apples[i][j] > apples[i][j2]:\n                            dp[k][i][j] = (dp[k][i][j] + dp[k - 1][i][j2]) % mod\n        return dp[k][0][0]", "target_Lan": "python###ways.py", "target_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    pizza1 = [\"A\"]\n    k1 = 1\n    print(ways(pizza1, k1))  \n    pizza2 = [\"AA\", \"AA\"]\n    k2 = 2\n    print(ways(pizza2, k2))  \n    pizza3 = [\"AAAAAAAAAA\"] * 10\n    k3 = 1\n    print(ways(pizza3, k3))  \n    pizza4 = [\"A.A\", \".A.\", \"A.A\"]\n    k4 = 3\n    print(ways(pizza4, k4))  \n    pizza5 = [\"A\" * 100] * 100\n    k5 = 10\n    print(ways(pizza5, k5))"}, {"source_Lan": "cpp###findReplaceString.cpp", "source_code": "string findReplaceString(string s, vector<int>& indices, vector<string>& sources, vector<string>& targets) {\n        int n = s.size(), m = indices.size();\n        vector<int> ops(m);\n        iota(ops.begin(), ops.end(), 0);\n        sort(ops.begin(), ops.end(), [&](int i, int j) { return indices[i] < indices[j]; });\n        string ans;\n        int pt = 0;\n        for (int i = 0; i < n;) {\n            while (pt < m && indices[ops[pt]] < i) {\n                ++pt;\n            }\n            bool succeed = false;\n            while (pt < m && indices[ops[pt]] == i) {\n                if (s.substr(i, sources[ops[pt]].size()) == sources[ops[pt]]) {\n                    succeed = true;\n                    break;\n                }\n                ++pt;\n            }\n            if (succeed) {\n                ans += targets[ops[pt]];\n                i += sources[ops[pt]].size();\n            }\n            else {\n                ans += s[i];\n                ++i;\n            }\n        }\n        return ans;\n    }", "trans_code": "def findReplaceString ( s , indices , sources , targets ) :\n    n , m = len ( s ) , len ( indices )\n    ops = [ i for i in range ( m ) if indices [ i ] < indices [ j ] ]\n    ans = ''\n    pt = 0\n    for i in range ( n ) :\n        while pt < m and indices [ ops [ pt ] ] < i :\n            pt += 1\n        succeed = False\n        while pt < m and indices [ ops [ pt ] ] == i :\n            if s [ i : sources [ ops [ pt ] ] ] == sources [ ops [ ops [ pt ] ] ] :\n                succeed = True\n                break\n            pt += 1\n        if succeed :\n            ans += targets [ ops [ pt ] ]\n            i += len ( sources [ ops [ pt ] ] )\n        else :\n            ans += s [ i ]\n            i += 1\n    return ans\n", "reference_code": "def findReplaceString( s: str, indices: List[int], sources: List[str], targets: List[str]) -> str:\n        n, m = len(s), len(indices)\n        ops = list(range(m))\n        ops.sort(key=lambda x: indices[x])\n        ans = list()\n        i = pt = 0\n        while i < n:\n            while pt < m and indices[ops[pt]] < i:\n                pt += 1\n            succeed = False\n            while pt < m and indices[ops[pt]] == i:\n                if s[i:i + len(sources[ops[pt]])] == sources[ops[pt]]:\n                    succeed = True\n                    break\n                pt += 1\n            if succeed:\n                ans.append(targets[ops[pt]])\n                i += len(sources[ops[pt]])\n            else:\n                ans.append(s[i])\n                i += 1\n        return \"\".join(ans)", "target_Lan": "python###findReplaceString.py", "target_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(findReplaceString(\"abcde\", [0, 2], [\"ab\", \"cd\"], [\"12\", \"34\"]))\n    print(findReplaceString(\"abcde\", [0, 1, 2], [\"a\", \"b\", \"c\"], [\"x\", \"y\", \"z\"]))\n    print(findReplaceString(\"abcde\", [0, 0, 0], [\"abc\", \"a\", \"abcd\"], [\"1\", \"2\", \"3\"]))\n    print(findReplaceString(\"abcde\", [5], [\"\"], [\"xyz\"]))\n    print(findReplaceString(\"\", [], [], []))"}, {"source_Lan": "cpp###circularGameLosers.cpp", "source_code": "vector<int> circularGameLosers(int n, int k) {\n        vector<bool> visit(n, false);\n        for (int i = k, j = 0; !visit[j]; i += k) {\n            visit[j] = true;\n            j = (j + i) % n;\n        }\n        vector<int> ans;\n        for (int i = 0; i < n; i++) {\n            if (!visit[i]) {\n                ans.emplace_back(i + 1);\n            }\n        }\n        return ans;\n    }", "trans_code": "def circularGameLosers ( n , k ) :\n    visit = [ False ] * n\n    for i , j in enumerate ( visit ) :\n        visit [ j ] = True\n        j = ( j + i ) % n\n    ans = [ ]\n    for i in range ( n ) :\n        if not visit [ i ] :\n            ans.append ( i + 1 )\n    return ans\n", "reference_code": "def circularGameLosers( n: int, k: int) -> List[int]:\n        visit = [False] * n\n        i = k\n        j = 0\n        while not visit[j]:\n            visit[j] = True\n            j = (j + i) % n\n            i += k\n        ans = []\n        for i in range(n):\n            if not visit[i]:\n                ans.append(i + 1)\n        return ans", "target_Lan": "python###circularGameLosers.py", "target_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(circularGameLosers(1, 1))   \n    print(circularGameLosers(5, 1))   \n    print(circularGameLosers(7, 3))   \n    print(circularGameLosers(10, 11))  \n    print(circularGameLosers(100, 20))"}, {"source_Lan": "cpp###countSeniors.cpp", "source_code": "int countSeniors(vector<string>& details) {\n        int count = 0;\n        for (string & info : details) {\n            if (stoi(info.substr(11, 2)) > 60) {\n                count++;\n            }\n        }\n        return count;\n    }", "trans_code": "def countSeniors ( details ) :\n    count = 0\n    for info in details :\n        if int ( info [ 11 : 2 ] ) > 60 :\n            count += 1\n    return count\n", "reference_code": "def countSeniors( details: List[str]) -> int:\n        return sum(1 for info in details if int(info[11:13]) > 60)", "target_Lan": "python###countSeniors.py", "target_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(countSeniors([]))  \n    print(countSeniors([\"John Doe 01-01-1960\"]))  \n    print(countSeniors([\"Jane Smith 01-01-1962\"]))"}, {"source_Lan": "cpp###maxAbsoluteSum.cpp", "source_code": "int maxAbsoluteSum(vector<int>& nums) {\n        int positiveMax = 0, negativeMin = 0;\n        int positiveSum = 0, negativeSum = 0;\n        for (int num : nums) {\n            positiveSum += num;\n            positiveMax = max(positiveMax, positiveSum);\n            positiveSum = max(0, positiveSum);\n            negativeSum += num;\n            negativeMin = min(negativeMin, negativeSum);\n            negativeSum = min(0, negativeSum);\n        }\n        return max(positiveMax, -negativeMin);\n    }", "trans_code": "def maxAbsoluteSum ( nums ) :\n    positiveMax , negativeMin = 0 , 0\n    positiveSum , negativeSum = 0 , 0\n    for num in nums :\n        positiveSum += num\n        positiveMax = max ( positiveMax , positiveSum )\n        positiveSum = max ( 0 , positiveSum )\n        negativeSum += num\n        negativeMin = min ( negativeMin , negativeSum )\n        negativeSum = min ( 0 , negativeSum )\n    return max ( positiveMax , - negativeMin )\n", "reference_code": "def maxAbsoluteSum( nums: List[int]) -> int:\n        positiveMax, negativeMin = 0, 0\n        positiveSum, negativeSum = 0, 0\n        for n in nums:\n            positiveSum += n\n            positiveMax = max(positiveMax, positiveSum)\n            positiveSum = max(0, positiveSum)\n            negativeSum += n\n            negativeMin = min(negativeMin, negativeSum)\n            negativeSum = min(0, negativeSum)\n        return max(positiveMax, -negativeMin)", "target_Lan": "python###maxAbsoluteSum.py", "target_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    nums1 = []\n    print(maxAbsoluteSum(nums1))  \n    nums2 = [1, 2, 3, 4, 5]\n    print(maxAbsoluteSum(nums2))  \n    nums3 = [-1, -2, -3, -4, -5]\n    print(maxAbsoluteSum(nums3))  \n    nums4 = [1, -2, 3, -4, 5, -6]\n    print(maxAbsoluteSum(nums4))  \n    nums5 = [10]\n    print(maxAbsoluteSum(nums5))"}, {"source_Lan": "cpp###minimumOperationsToMakeKPeriodic.cpp", "source_code": "int minimumOperationsToMakeKPeriodic(string word, int k) {\n        int n = word.size(), res = INT_MAX;\n        unordered_map<string, int> count;\n        for (int i = 0; i < n; i += k) {\n            string &&part = word.substr(i, k);\n            count[part]++;\n            res = min(res, n / k - count[part]);\n        }\n        return res;\n    }", "trans_code": "def minimumOperationsToMakeKPeriodic ( word , k ) :\n    n , res = len ( word ) , int ( 0 )\n    count = { }\n    for i in range ( 0 , n , k ) :\n        part = word [ i : i + k ]\n        count [ part ] += 1\n        res = min ( res , n / k - count [ part ] )\n    return res\n", "reference_code": "def minimumOperationsToMakeKPeriodic( word: str, k: int) -> int:\n        n = len(word)\n        count = Counter(word[i: i + k] for i in range(0, n, k))\n        return n // k - max(count.values())", "target_Lan": "python###minimumOperationsToMakeKPeriodic.py", "target_code_shell": "from collections import Counter\n# TOFILL\nif __name__ == \"__main__\":\n    print(minimumOperationsToMakeKPeriodic(\"aaaa\", 2))      \n    print(minimumOperationsToMakeKPeriodic(\"abc\", 5))       \n    print(minimumOperationsToMakeKPeriodic(\"abababab\", 2))  \n    print(minimumOperationsToMakeKPeriodic(\"abcde\", 3))"}, {"source_Lan": "cpp###maxScore.cpp", "source_code": "int maxScore(vector<vector<int>>& grid) {\n        int m = grid.size(), n = grid[0].size();\n        vector<vector<int>> prerow(m, vector<int>(n));\n        vector<vector<int>> precol(m, vector<int>(n));\n        vector<vector<int>> f(m, vector<int>(n, INT_MIN));\n        int ans = INT_MIN;\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (i > 0) {\n                    f[i][j] = max(f[i][j], grid[i][j] + precol[i - 1][j]);\n                }\n                if (j > 0) {\n                    f[i][j] = max(f[i][j], grid[i][j] + prerow[i][j - 1]);\n                }\n                ans = max(ans, f[i][j]);\n                prerow[i][j] = precol[i][j] = max(f[i][j], 0) - grid[i][j];\n                if (i > 0) {\n                    precol[i][j] = max(precol[i][j], precol[i - 1][j]);\n                }\n                if (j > 0) {\n                    prerow[i][j] = max(prerow[i][j], prerow[i][j - 1]);\n                }\n            }\n        }\n        return ans;\n    }", "trans_code": "def maxScore ( grid ) :\n    m , n = len ( grid ) , len ( grid [ 0 ] )\n    prerow = np.zeros ( ( m , n ) )\n    precol = np.zeros ( ( m , n ) )\n    f = np.zeros ( ( m , n , np.inf ) )\n    ans = np.inf\n    for i in range ( m ) :\n        for j in range ( n ) :\n            if i > 0 : f [ i ] [ j ] = max ( f [ i ] [ j ] , grid [ i ] [ j ] + precol [ i - 1 ] [ j ] )\n            if j > 0 : f [ i ] [ j ] = max ( f [ i ] [ j ] , grid [ i ] [ j ] + prerow [ i ] [ j - 1 ] )\n            ans = max ( ans , f [ i ] [ j ] )\n            prerow [ i ] [ j ] = precol [ i ] [ j ] = max ( f [ i ] [ j ] , 0 ) - grid [ i ] [ j ]\n            if i > 0 : precol [ i ] [ j ] = max ( precol [ i ] [ j ] , precol [ i - 1 ] [ j ] )\n            if j > 0 : prerow [ i ] [ j ] = max ( prerow [ i ] [ j ] , prerow [ i ] [ j - 1 ] )\n    return ans\n", "reference_code": "def maxScore( grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        prerow = [[0] * n for _ in range(m)]\n        precol = [[0] * n for _ in range(m)]\n        f = [[-inf] * n for _ in range(m)]\n        ans = -inf\n        for i in range(m):\n            for j in range(n):\n                if i > 0:\n                    f[i][j] = max(f[i][j], grid[i][j] + precol[i - 1][j])\n                if j > 0:\n                    f[i][j] = max(f[i][j], grid[i][j] + prerow[i][j - 1])\n                ans = max(ans, f[i][j])\n                prerow[i][j] = precol[i][j] = max(f[i][j], 0) - grid[i][j]\n                if i > 0:\n                    precol[i][j] = max(precol[i][j], precol[i - 1][j])\n                if j > 0:\n                    prerow[i][j] = max(prerow[i][j], prerow[i][j - 1])\n        return ans", "target_Lan": "python###maxScore.py", "target_code_shell": "from typing import List\nfrom math import inf\n# TOFILL\nif __name__ == \"__main__\":\n    grid1 = [[1,2]]\n    print(maxScore(grid1))  \n    grid2 = [[1, 2], [3, 4]]\n    print(maxScore(grid2))  \n    grid3 = [[100, -1], [-1, 100]]\n    print(maxScore(grid3))  \n    grid4 = [[0, 0, 0], [0, 0, 0], [0, 0, 0]]\n    print(maxScore(grid4))  \n    grid5 = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    print(maxScore(grid5))"}, {"source_Lan": "cpp###isArraySpecial.cpp", "source_code": "vector<bool> isArraySpecial(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        vector<int> dp(n, 1);\n        for (int i = 1; i < n; i++) {\n            if ((nums[i] ^ nums[i - 1]) & 1) {\n                dp[i] = dp[i - 1] + 1;\n            }\n        }\n        vector<bool> res;\n        for (auto &q : queries) {\n            int x = q[0], y = q[1];\n            res.emplace_back(dp[y] >= y - x + 1);\n        }\n        return res;\n    }", "trans_code": "def isArraySpecial ( nums , queries ) :\n    n = len ( nums )\n    dp = [ 1 ]\n    for i in range ( 1 , n ) :\n        if ( nums [ i ] ^ nums [ i - 1 ] ) & 1 :\n            dp [ i ] = dp [ i - 1 ] + 1\n    res = [ ]\n    for q in queries :\n        x , y = q\n        res.append ( dp [ y ] >= y - x + 1 )\n    return res\n", "reference_code": "def isArraySpecial( nums: List[int], queries: List[List[int]]) -> List[bool]:\n       n = len(nums)\n       dp = [1] * n\n       for i in range(1, n):\n           if (nums[i] ^ nums[i - 1]) & 1 == 1:\n               dp[i] = dp[i - 1] + 1\n       return [dp[y] >= y - x + 1 for x, y in queries]", "target_Lan": "python###isArraySpecial.py", "target_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(isArraySpecial([1, 2, 3, 4, 5], [[0, 4], [1, 3], [0, 1]]))\n    print(isArraySpecial([2, 4, 6, 8], [[0, 3], [1, 2]]))\n    print(isArraySpecial([1, 3, 5, 2], [[0, 3], [1, 2]]))\n    print(isArraySpecial([1, 2, 3, 0], [[0, 2], [2, 3]]))"}, {"source_Lan": "cpp###leftmostBuildingQueries.cpp", "source_code": "vector<int> leftmostBuildingQueries(vector<int>& heights, vector<vector<int>>& queries) {\n        int n = heights.size();\n        int m = queries.size();\n        vector<vector<pair<int, int>>> query(n);\n        vector<int> ans(m);\n        vector<int> st;\n        for (int i = 0; i < m; i++) {\n            int a = queries[i][0];\n            int b = queries[i][1];\n            if (a > b) swap(a, b);\n            if (a == b || heights[a] < heights[b]) {\n                ans[i] = b;\n                continue;\n            }\n            query[b].push_back(make_pair(i, heights[a]));\n        }\n        int top = -1;\n        for (int i = n - 1; i >= 0; i--) {\n            for (int j = 0; j < query[i].size(); j++) {\n                int q = query[i][j].first;\n                int val = query[i][j].second;\n                if (top == -1 || heights[st[0]] <= val) {\n                    ans[q] = -1;\n                    continue;\n                }\n                int l = 0, r = top;\n                while (l <= r) {\n                    int mid = (l + r) >> 1;\n                    if (heights[st[mid]] > val) {\n                        l = mid + 1;\n                    } else {\n                        r = mid - 1;\n                    }\n                }\n                ans[q] = st[r];\n            }\n            while (top >= 0 && heights[st[top]] <= heights[i]) {\n                st.pop_back();\n                top--;\n            }\n            st.push_back(i);\n            top++;\n        }\n        return ans;\n    }", "trans_code": "def leftmostBuildingQueries ( heights , queries ) :\n    n = len ( heights )\n    m = len ( queries )\n    query = [ ( i , heights [ a ] ) for i in range ( n ) ]\n    ans = [ ]\n    st = [ ]\n    for i in range ( m ) :\n        a = queries [ i ] [ 0 ]\n        b = queries [ i ] [ 1 ]\n        if a > b :\n            swap ( a , b )\n        if a == b or heights [ a ] < heights [ b ] :\n            ans.append ( b )\n            continue\n        query [ b ].append ( ( i , heights [ a ] ) )\n    top = -1\n    for i in range ( n - 1 , - 1 , - 1 ) :\n        for j in range ( len ( query [ i ] ) ) :\n            q = query [ i ] [ j ] [ 0 ]\n            val = query [ i ] [ j ] [ 1 ]\n            if top == -1 or heights [ st [ 0 ] ] <= val :\n                ans.append ( q )\n                continue\n            l , r = 0 , top\n            while l <= r :\n                mid = ( l + r ) >> 1\n                if heights [ st [ mid ] ] > val :\n                    l = mid + 1\n                else :\n                    r = mid - 1\n            ans.append ( q )\n        while top >= 0 and heights [ st [ top ] ] <= heights [ i ] :\n            st.pop ( )\n            top -= 1\n        st.append ( i )\n        top += 1\n    return ans\n", "reference_code": "def leftmostBuildingQueries( heights: List[int], queries: List[List[int]]) -> List[int]:\n        n = len(heights)\n        m = len(queries)\n        query = [[] for _ in range(n)]\n        ans = [-1] * m\n        st = []\n        for i in range(m):\n            a, b = queries[i]\n            if a > b:\n                a, b = b, a\n            if a == b or heights[a] < heights[b]:\n                ans[i] = b\n                continue\n            query[b].append((i, heights[a]))\n        top = -1\n        for i in range(n - 1, -1, -1):\n            for q, val in query[i]:\n                if top == -1 or heights[st[0]] <= val:\n                    ans[q] = -1\n                    continue\n                l, r = 0, top\n                while l <= r:\n                    mid = (l + r) // 2\n                    if heights[st[mid]] > val:\n                        l = mid + 1\n                    else:\n                        r = mid - 1\n                ans[q] = st[r]\n            while top >= 0 and heights[st[top]] <= heights[i]:\n                st.pop()\n                top -= 1\n            st.append(i)\n            top += 1\n        return ans", "target_Lan": "python###leftmostBuildingQueries.py", "target_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(leftmostBuildingQueries([5, 3, 6, 7, 4], [[0, 3], [1, 4], [3, 2], [2, 2], [0, 0]]))\n    print(leftmostBuildingQueries([1, 2, 3], [[0, 2], [1, 1], [2, 0]]))\n    print(leftmostBuildingQueries([10, 20, 30, 40], [[1, 3], [0, 3], [2, 2]]))\n    print(leftmostBuildingQueries([5, 5, 5, 5, 5], [[0, 1], [1, 4], [0, 3]]))\n    print(leftmostBuildingQueries([0, 10, 5, 15], [[0, 1], [3, 0], [2, 3], [1, 1]]))"}, {"source_Lan": "cpp###isArraySpecial.cpp", "source_code": "bool isArraySpecial(vector<int>& nums) {\n        int n = nums.size();\n        for (int i = 1; i < n; ++i) {\n            if (nums[i - 1] % 2 == nums[i] % 2) {\n                return false;\n            }\n        }\n        return true;\n    }", "trans_code": "def isArraySpecial ( nums ) :\n    n = len ( nums )\n    for i in range ( 1 , n ) :\n        if nums [ i - 1 ] % 2 == nums [ i ] % 2 :\n            return False\n    return True\n", "reference_code": "def isArraySpecial( nums: List[int]) -> bool:\n        n = len(nums)\n        for i in range(1, n):\n            if nums[i - 1] % 2 == nums[i] % 2:\n                return False\n        return True", "target_Lan": "python###isArraySpecial.py", "target_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(isArraySpecial([]))                       \n    print(isArraySpecial([1]))                      \n    print(isArraySpecial([2, 1, 4, 3]))            \n    print(isArraySpecial([2, 4, 6, 8]))             \n    print(isArraySpecial([3, 5, 7, 2, 4, 6]))"}, {"source_Lan": "cpp###finalPositionOfSnake.cpp", "source_code": "int finalPositionOfSnake(int n, vector<string>& commands) {\n        int i = 0, j = 0;\n        for (auto& s : commands) {\n            switch (s[0]) {\n                case 'U': i--; break;\n                case 'D': i++; break;\n                case 'L': j--; break;\n                default:  j++;\n            }\n        }\n        return i * n + j;\n    }", "trans_code": "def finalPositionOfSnake ( n , commands ) :\n    i , j = 0 , 0\n    for s in commands :\n        try :\n            i -= 1\n        except IndexError :\n            j += 1\n    return i * n + j\n", "reference_code": "def finalPositionOfSnake( n: int, commands: List[str]) -> int:\n        i = j = 0\n        for s in commands:\n            if s[0] == 'U': i -= 1\n            elif s[0] == 'D': i += 1\n            elif s[0] == 'L': j -= 1\n            else: j += 1\n        return i * n + j", "target_Lan": "python###finalPositionOfSnake.py", "target_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(finalPositionOfSnake(1, [\"U\", \"D\", \"L\", \"R\"]))\n    print(finalPositionOfSnake(1000, [\"U\", \"U\", \"D\"]))\n    print(finalPositionOfSnake(1, [\"L\", \"L\", \"R\"]))\n    print(finalPositionOfSnake(0, [\"D\", \"D\", \"U\", \"L\"]))\n    print(finalPositionOfSnake(1000000, [\"U\", \"D\", \"R\", \"L\", \"D\", \"U\", \"R\", \"R\"]))"}, {"source_Lan": "cpp###countOfPairs.cpp", "source_code": "int countOfPairs(vector<int>& nums) {\n        const int MOD = 1e9 + 7;\n        int m = nums.size();\n        int n = *max_element(nums.begin(), nums.end());\n        vector<int> f(n + 1);\n        \n        for (int v = 0; v <= nums[0]; ++v)\n            f[v] = 1;\n        vector<int> preSums;\n        \n        for (int i = 1; i <= m; ++i) {\n            \n            preSums.clear();\n            int preSum = 0;\n            for(int v : f){\n                preSum += v;\n                preSum %= MOD; \n                preSums.push_back(preSum);\n            }\n            \n            if (i == m) return preSums.back();\n            \n            for (int j = 0; j <= nums[i]; ++j) {\n                int ceil = min(j, nums[i-1] - nums[i] + j);\n                if (ceil >= 0)\n                    f[j] = preSums[ceil];\n                else \n                    f[j] = 0;\n            }\n            for (int j = nums[i] + 1; j < f.size(); ++j) {\n                f[j] = 0;\n            }\n        }\n        \n        return 0;\n    }", "trans_code": "def countOfPairs ( nums ) :\n    MOD = 1e9 + 7\n    m = len ( nums )\n    n = * max_element ( nums )\n    f = [ 0 ] * ( n + 1 )\n    for v in nums :\n        f [ v ] = 1\n    pre_sums = [ ]\n    for i in range ( 1 , m + 1 ) :\n        pre_sums = [ ]\n        pre_sum = 0\n        for v in f :\n            pre_sum += v\n            pre_sum %= MOD\n            pre_sums.append ( pre_sum )\n        if i == m :\n            return pre_sums [ - 1 ]\n        for j in range ( 0 , nums [ i ] ) :\n            ceil = min ( j , nums [ i - 1 ] - nums [ i ] + j )\n            if ceil >= 0 :\n                f [ j ] = pre_sums [ ceil ]\n            else :\n                f [ j ] = 0\n        for j in range ( nums [ i ] + 1 , len ( f ) ) :\n            f [ j ] = 0\n    return 0\n", "reference_code": "def countOfPairs( nums):\n        MOD = 1_000_000_007\n        m = len(nums)\n        n = max(nums)\n        f = [0] * (n + 1)\n        # \u521d\u59cb\u72b6\u6001\n        for v in range(nums[0] + 1):\n            f[v] = 1\n        preSums = []\n        # \u591a\u6267\u884c\u4e00\u8f6e\n        for i in range(1, m + 1):\n            # \u524d\u7f00\u548c\uff0c\u6b64\u5904\u4e0d\u91cd\u590d\u5f00\u8f9f\u7a7a\u95f4\u4ee5\u63d0\u5347\u6027\u80fd\u3002\n            preSums.clear()\n            preSum = 0\n            for v in f:\n                preSum += v\n                preSum %= MOD\n                preSums.append(preSum)\n            # \u6700\u540e\u4e00\u8f6e\u63d0\u524d\u8fd4\u56de\u7ed3\u5c3e\u5904\u7684\u65b9\u6848\u6570\u603b\u548c\n            if i == m:\n                return preSums[-1]\n            # \u4f18\u5316\u7a7a\u95f4\uff0c\u4e8c\u7ef4\u53d8\u4e00\u7ef4\uff0c\u6ca1\u7528\u5230\u7684\u683c\u5b50\u90fd\u8981\u4f7f\u5143\u7d20\u5f52 0 \n            for j in range(nums[i] + 1):\n                ceil = min(j, nums[i-1] - nums[i] + j)\n                if ceil >= 0:\n                    f[j] = preSums[ceil]\n                else:  # ceil < 0 \u8bf4\u660e\u4e0d\u5b58\u5728\n                    f[j] = 0\n            for j in range(nums[i] + 1, len(f)):\n                f[j] = 0\n        # \u4e0d\u4f1a\u6267\u884c\n        return 0", "target_Lan": "python###countOfPairs.py", "target_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    nums1 = [1, 2, 3]\n    print(countOfPairs(nums1))  \n    nums2 = [5, 5, 5, 5]\n    print(countOfPairs(nums2))  \n    nums3 = [0]\n    print(countOfPairs(nums3))  \n    nums4 = [10, 20, 30, 40, 50]\n    print(countOfPairs(nums4))  \n    nums5 = [3, 1, 4]\n    print(countOfPairs(nums5))"}, {"source_Lan": "cpp###shortestDistanceAfterQueries.cpp", "source_code": "vector<int> shortestDistanceAfterQueries(int n, vector<vector<int>>& queries) {\n        vector<vector<int>> from(n);\n        vector<int> f(n);\n        iota(f.begin(), f.end(), 0);\n        vector<int> ans(queries.size());\n        for (int qi = 0; qi < queries.size(); qi++) {\n            int l = queries[qi][0], r = queries[qi][1];\n            from[r].push_back(l);\n            if (f[l] + 1 < f[r]) {\n                f[r] = f[l] + 1;\n                for (int i = r + 1; i < n; i++) {\n                    f[i] = min(f[i], f[i - 1] + 1);\n                    for (int j : from[i]) {\n                        f[i] = min(f[i], f[j] + 1);\n                    }\n                }\n            }\n            ans[qi] = f[n - 1];\n        }\n        return ans;\n    }", "trans_code": "def shortestDistanceAfterQueries ( n , queries ) :\n    from random import random\n    f = [ 0 ] * n\n    iota = random ( )\n    ans = [ 0 ] * len ( queries )\n    for qi in queries :\n        l , r = qi\n        f [ r ] = l\n        if f [ l ] + 1 < f [ r ] :\n            f [ r ] = f [ l ] + 1\n            for i in range ( r + 1 , n ) :\n                f [ i ] = min ( f [ i ] , f [ i - 1 ] + 1 )\n                for j in range ( from ( i ) ) :\n                    f [ i ] = min ( f [ i ] , f [ j ] + 1 )\n        ans [ qi ] = f [ n - 1 ]\n    return ans\n", "reference_code": "def shortestDistanceAfterQueries( n: int, queries: List[List[int]]) -> List[int]:\n        frm = [[] for _ in range(n)]\n        f = list(range(n))\n        ans = []\n        for l, r in queries:\n            frm[r].append(l)\n            if f[l] + 1 < f[r]:\n                f[r] = f[l] + 1\n                for i in range(r + 1, n):\n                    f[i] = min(f[i], f[i - 1] + 1, min((f[j] for j in frm[i]), default=inf) + 1)\n            ans.append(f[-1])\n        return ans", "target_Lan": "python###shortestDistanceAfterQueries.py", "target_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(shortestDistanceAfterQueries(2, [[0, 1]]))\n    print(shortestDistanceAfterQueries(6, [[0, 5], [1, 2], [4, 5], [0, 1], [1, 5]]))"}, {"source_Lan": "cpp###shortestDistanceAfterQueries2.cpp", "source_code": "vector<int> shortestDistanceAfterQueries2(int n, vector<vector<int>>& queries) {\n        vector<int> nxt(n - 1);\n        iota(nxt.begin(), nxt.end(), 1);\n        vector<int> ans(queries.size());\n        int cnt = n - 1;\n        for (int qi = 0; qi < queries.size(); qi++) {\n            int l = queries[qi][0], r = queries[qi][1];\n            if (nxt[l] && nxt[l] < r) {\n                for (int i = nxt[l]; i < r;) {\n                    cnt--;\n                    int tmp = nxt[i];\n                    nxt[i] = 0;\n                    i = tmp;\n                }\n                nxt[l] = r;\n            }\n            ans[qi] = cnt;\n        }\n        return ans;\n    }", "trans_code": "def shortestDistanceAfterQueries2 ( n , queries ) :\n    nxt = range ( n - 1 )\n    iota ( nxt )\n    ans = [ 0 ] * len ( queries )\n    cnt = n - 1\n    for qi in range ( len ( queries ) ) :\n        l , r = queries [ qi ] [ 0 ] , queries [ qi ] [ 1 ]\n        if nxt [ l ] and nxt [ l ] < r :\n            for i in nxt [ l ] :\n                cnt -= 1\n                tmp = nxt [ i ]\n                nxt [ i ] = 0\n                i = tmp\n            nxt [ l ] = r\n        ans [ qi ] = cnt\n    return ans\n", "reference_code": "def shortestDistanceAfterQueries2( n: int, queries: List[List[int]]) -> List[int]:\n        ans = []\n        nxt = list(range(1, n))\n        cnt = n - 1\n        for l, r in queries:\n            if 0 < nxt[l] < r:\n                i = nxt[l]\n                while i < r:\n                    cnt -= 1\n                    nxt[i], i = 0, nxt[i]\n                nxt[l] = r\n            ans.append(cnt)\n        return ans", "target_Lan": "python###shortestDistanceAfterQueries2.py", "target_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(shortestDistanceAfterQueries2(2, [[0, 1]]))\n    print(shortestDistanceAfterQueries2(10, [[0, 5], [4, 8], [2, 7]]))\n    print(shortestDistanceAfterQueries2(6, [[0, 1], [1, 5], [0, 5], [1, 2]]))"}, {"source_Lan": "cpp###winningPlayerCount.cpp", "source_code": "int winningPlayerCount(int n, vector<vector<int>>& pick) {\n        vector<array<int, 11>> cnts(n);\n        for (auto& p : pick) {\n            cnts[p[0]][p[1]]++;\n        }\n        int ans = 0;\n        for (int i = 0; i < n; i++) {\n            for (int c : cnts[i]) {\n                if (c > i) {\n                    ans++;\n                    break;\n                }\n            }\n        }\n        return ans;\n    }", "trans_code": "def winningPlayerCount ( n , pick ) :\n    cnts = np.zeros ( ( n , 11 ) )\n    for p in pick :\n        cnts [ p [ 0 ] ] [ p [ 1 ] ] += 1\n    ans = 0\n    for i in range ( n ) :\n        for c in cnts [ i ] :\n            if c > i :\n                ans += 1\n                break\n    return ans\n", "reference_code": "def winningPlayerCount( n: int, pick: List[List[int]]) -> int:\n        cnts = [[0] * 11 for _ in range(n)]\n        for x, y in pick:\n            cnts[x][y] += 1\n        ans = 0\n        for i, cnt in enumerate(cnts):\n            if any(c > i for c in cnt):\n                ans += 1\n        return ans", "target_Lan": "python###winningPlayerCount.py", "target_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(winningPlayerCount(0, []))  \n    print(winningPlayerCount(1, [[0, 0]]))  \n    print(winningPlayerCount(3, [[0, 0], [1, 1], [2, 2]]))  \n    print(winningPlayerCount(3, [[0, 1], [1, 2], [2, 2]]))  \n    print(winningPlayerCount(5, [[0, 3], [1, 4], [2, 2], [3, 1], [4, 5]]))"}, {"source_Lan": "cpp###minFlips.cpp", "source_code": "int minFlips(vector<vector<int>>& a) {\n        int m = a.size(), n = a[0].size(), ans = 0;\n        for (int i = 0; i < m / 2; i++) {\n            for (int j = 0; j < n / 2; j++) {\n                int cnt1 = a[i][j] + a[i][n - 1 - j] + a[m - 1 - i][j] + a[m - 1 - i][n - 1 - j];\n                ans += min(cnt1, 4 - cnt1);  \n            }\n        }\n        if (m % 2 && n % 2) {\n            \n            ans += a[m / 2][n / 2];\n        }\n        int diff = 0, cnt1 = 0;\n        if (m % 2) {\n            \n            for (int j = 0; j < n / 2; j++) {\n                if (a[m / 2][j] != a[m / 2][n - 1 - j]) {\n                    diff++;\n                } else {\n                    cnt1 += a[m / 2][j] * 2;\n                }\n            }\n        }\n        if (n % 2) {\n            \n            for (int i = 0; i < m / 2; i++) {\n                if (a[i][n / 2] != a[m - 1 - i][n / 2]) {\n                    diff++;\n                } else {\n                    cnt1 += a[i][n / 2] * 2;\n                }\n            }\n        }\n        return ans + (diff ? diff : cnt1 % 4);\n    }", "trans_code": "def minFlips ( a ) :\n    m , n , ans = len ( a ) , len ( a [ 0 ] ) , 0\n    for i in range ( m // 2 ) :\n        for j in range ( n // 2 ) :\n            cnt1 = a [ i ] [ j ] + a [ i ] [ n - 1 - j ] + a [ m - 1 - i ] [ j ] + a [ m - 1 - i ] [ n - 1 - j ]\n            ans += min ( cnt1 , 4 - cnt1 )\n    if m % 2 and n % 2 :\n        ans += a [ m // 2 ] [ n // 2 ]\n    diff , cnt1 = 0 , 0\n    if m % 2 :\n        for j in range ( n // 2 ) :\n            if a [ m // 2 ] [ j ] != a [ m // 2 ] [ n - 1 - j ] :\n                diff += 1\n            else :\n                cnt1 += a [ m // 2 ] [ j ] * 2\n    if n % 2 :\n        for i in range ( m // 2 ) :\n            if a [ i ] [ n // 2 ] != a [ m - 1 - i ] [ n // 2 ] :\n                diff += 1\n            else :\n                cnt1 += a [ i ] [ n // 2 ] * 2\n    return ans + ( diff or cnt1 % 4 )\n", "reference_code": "def minFlips( a: List[List[int]]) -> int:\n        ans = 0\n        m, n = len(a), len(a[0])\n        for i in range(m // 2):\n            row, row2 = a[i], a[-1 - i]\n            for j in range(n // 2):\n                cnt1 = row[j] + row[-1 - j] + row2[j] + row2[-1 - j]\n                ans += min(cnt1, 4 - cnt1)  # \u5168\u4e3a 1 \u6216\u5168\u4e3a 0\n        if m % 2 and n % 2:\n            # \u6b63\u4e2d\u95f4\u7684\u6570\u5fc5\u987b\u662f 0\n            ans += a[m // 2][n // 2]\n        diff = cnt1 = 0\n        if m % 2:\n            # \u7edf\u8ba1\u6b63\u4e2d\u95f4\u8fd9\u4e00\u6392\n            row = a[m // 2]\n            for j in range(n // 2):\n                if row[j] != row[-1 - j]:\n                    diff += 1\n                else:\n                    cnt1 += row[j] * 2\n        if n % 2:\n            # \u7edf\u8ba1\u6b63\u4e2d\u95f4\u8fd9\u4e00\u5217\n            for i in range(m // 2):\n                if a[i][n // 2] != a[- 1 - i][n // 2]:\n                    diff += 1\n                else:\n                    cnt1 += a[i][n // 2] * 2\n        return ans + (diff if diff else cnt1 % 4)", "target_Lan": "python###minFlips.py", "target_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(minFlips([[0, 0], [0, 0]]))         \n    print(minFlips([[1, 0], [0, 1]]))         \n    print(minFlips([[1, 1], [1, 1]]))         \n    print(minFlips([[0], [1], [0]]))          \n    print(minFlips([[1, 0, 1], [0, 1, 0]]))"}, {"source_Lan": "cpp###canAliceWin.cpp", "source_code": "bool canAliceWin(vector<int>& nums) {\n        int s = 0;\n        for (int x : nums) {\n            s += x < 10 ? x : -x;\n        }\n        return s; \n    }", "trans_code": "def can_alice_win ( nums ) :\n    s = 0\n    for x in nums :\n        s += x < 10\n    return s\n", "reference_code": "def canAliceWin( nums: List[int]) -> bool:\n        return sum(x if x < 10 else -x for x in nums) != 0", "target_Lan": "python###canAliceWin.py", "target_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(canAliceWin([]))                    \n    print(canAliceWin([1, 2, 3, 4, 5]))      \n    print(canAliceWin([10, 20, 30]))          \n    print(canAliceWin([5, 10, 12, 7]))        \n    print(canAliceWin([9, 0, 15, -5, -10]))"}, {"source_Lan": "cpp###numberOfSubstrings.cpp", "source_code": "int numberOfSubstrings(string s) {\n        int n = s.length();\n        vector<int> a;\n        for (int i = 0; i < n; i++) {\n            if (s[i] == '0') {\n                a.push_back(i);\n            }\n        }\n        int tot1 = n - a.size();\n        a.push_back(n); \n        int ans = 0, i = 0; \n        for (int left = 0; left < n; left++) {\n            if (s[left] == '1') {\n                ans += a[i] - left; \n            }\n            for (int k = i; k < a.size() - 1; k++) {\n                int cnt0 = k - i + 1;\n                if (cnt0 * cnt0 > tot1) {\n                    break;\n                }\n                int cnt1 = a[k] - left - (k - i);\n                ans += max(a[k + 1] - a[k] - max(cnt0 * cnt0 - cnt1, 0), 0);\n            }\n            if (s[left] == '0') {\n                i++; \n            }\n        }\n        return ans;\n    }", "trans_code": "def numberOfSubstrings ( s ) :\n    n = len ( s )\n    a = [ ]\n    for i in range ( n ) :\n        if s [ i ] == '0' : a.append ( i )\n    tot1 = n - len ( a )\n    a.append ( n )\n    ans , i = 0 , 0\n    for left in range ( n ) :\n        if s [ left ] == '1' : ans += a [ i ] - left\n        for k in range ( i , len ( a ) - 1 ) :\n            cnt0 = k - i + 1\n            if cnt0 * cnt0 > tot1 : break\n            cnt1 = a [ k ] - left - ( k - i )\n            ans += max ( a [ k + 1 ] - a [ k ] - max ( cnt0 * cnt0 - cnt1 , 0 ) , 0 )\n        if s [ left ] == '0' : i += 1\n    return ans\n", "reference_code": "def numberOfSubstrings( s: str) -> int:\n        n = len(s)\n        a = [i for i, b in enumerate(s) if b == '0']\n        tot1 = n - len(a)\n        a.append(n)  # \u54e8\u5175\n        ans = i = 0  # >= left \u7684\u7b2c\u4e00\u4e2a 0 \u7684\u4e0b\u6807\u662f a[i]\n        for left, b in enumerate(s):\n            if b == '1':\n                ans += a[i] - left  # \u4e0d\u542b 0 \u7684\u5b50\u4e32\u4e2a\u6570\n            for k in range(i, len(a) - 1):\n                cnt0 = k - i + 1\n                if cnt0 * cnt0 > tot1:\n                    break\n                cnt1 = a[k] - left - (k - i)\n                # \u53ef\u4ee5\u6539\u6210\u624b\u52a8\u6bd4\u5927\u5c0f\uff0c\u90a3\u6837\u66f4\u5feb\n                ans += max(a[k + 1] - a[k] - max(cnt0 * cnt0 - cnt1, 0), 0)\n            if b == '0':\n                i += 1  # \u8fd9\u4e2a 0 \u540e\u9762\u4e0d\u4f1a\u518d\u679a\u4e3e\u5230\u4e86\n        return ans", "target_Lan": "python###numberOfSubstrings.py", "target_code_shell": "# TOFILL\nif __name__ == \"__main__\":\n    print(numberOfSubstrings(\"\"))           \n    print(numberOfSubstrings(\"000000\"))     \n    print(numberOfSubstrings(\"111111\"))     \n    print(numberOfSubstrings(\"1010101010\")) \n    print(numberOfSubstrings(\"111000111\"))"}, {"source_Lan": "cpp###mostFrequent.cpp", "source_code": "int mostFrequent(int n, vector<int> &a){\n    map<int,int> m;\n    for(int i:a)m[i]++;\n    int mx=0;\n    for(auto i:m)mx=max(mx,i.second);\n    int ans=-1;\n    for(auto i:m)if(mx==i.second)ans=i.first;\n    return ans;\n}", "trans_code": "def mostFrequent ( n , a ) :\n    m = { }\n    for i in a :\n        m [ i ] += 1\n    mx = 0\n    for i in m :\n        mx = max ( mx , i [ 1 ] )\n    ans = -1\n    for i in m :\n        if mx == i [ 1 ] :\n            ans = i [ 0 ]\n    return ans\n", "reference_code": "def mostFrequent(n,arr):\n    dic={}\n    for ele in arr:\n        if ele in dic:\n            dic[ele]+=1\n        else:\n            dic[ele]=1\n    mx=0\n    for ele in dic.values():\n        mx=max(mx,ele)\n    ans=0\n    for key in sorted(dic):\n        if dic[key]==mx:\n            ans=key\n    return ans", "target_Lan": "python###mostFrequent.py", "target_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(mostFrequent(1, [1]))\n    print(mostFrequent(5, [2, 2, 2, 2, 2]))\n    print(mostFrequent(5, [1, 2, 3, 4, 5]))\n    print(mostFrequent(6, [1, 2, 2, 3, 3, 3]))\n    print(mostFrequent(3, [5, 5, 1]))"}, {"source_Lan": "cpp###getMax.cpp", "source_code": "    int getMax(int x) {\n        \n        bool flag = false;\n        int prev = -1;\n        int cnt = 0;\n        for (int i = 30; i >= 0; i--) {\n            if (cnt >= 2)\n                break;\n            if (flag == false and (x & (1 << i)) > 0) {\n                flag = true;\n                continue;\n            }\n            if (flag) {\n                if ((x & (1 << i)) == 0 and prev == -1) {\n                    prev = i;\n                    x |= (1 << i);\n                    cnt++;\n                }\n                if ((x & (1 << i)) == 0 and prev - i > 1) {\n                    x |= (1 << i);\n                    cnt++;\n                }\n            }\n        }\n        return x;\n    }", "trans_code": "def getMax ( x ) :\n    flag = False\n    prev = -1\n    cnt = 0\n    for i in range ( 30 , - 1 , - 1 ) :\n        if cnt >= 2 :\n            break\n        if flag == False and ( x & ( 1 << i ) ) > 0 :\n            flag = True\n            continue\n        if flag :\n            if ( x & ( 1 << i ) ) == 0 and prev == -1 :\n                prev = i\n                x |= ( 1 << i )\n                cnt += 1\n            if ( x & ( 1 << i ) ) == 0 and prev - i > 1 :\n                x |= ( 1 << i )\n                cnt += 1\n    return x\n", "reference_code": "def getMax( x: int) -> int:\n        # code here\n        flag = False\n        prev = -1\n        cnt = 0\n        for i in range(30, -1, -1):\n            if cnt >= 2:\n                break\n            if not flag and (x & (1 << i)) > 0:\n                flag = True\n                continue\n            if flag:\n                if (x & (1 << i)) == 0 and prev == -1:\n                    prev = i\n                    x |= (1 << i)\n                    cnt += 1\n                if (x & (1 << i)) == 0 and prev - i > 1:\n                    x |= (1 << i)\n                    cnt += 1\n        return x", "target_Lan": "python###getMax.py", "target_code_shell": "# TOFILL\nif __name__ == \"__main__\":\n    print(getMax(0))\n    print(getMax(1))\n    print(getMax(2147483647))\n    print(getMax(34))\n    print(getMax(1073741824))"}, {"source_Lan": "cpp###getMaxProductivity.cpp", "source_code": " int getMaxProductivity(int n, vector<int>& productivity) {\n        int sum = 0;\n        for (int val : productivity) {\n            sum += val;\n        }\n        int halfSum = sum / 2;\n        vector<int> dp(halfSum + 1, 0);\n        dp[0] = 1;\n        for (int prod : productivity) {\n            for (int j = halfSum; j >= prod; j--) {\n                dp[j] = dp[j] || dp[j - prod];\n            }\n        }\n        int maxProductivity = 0;\n        for (int i = 1; i <= halfSum; i++) {\n            if (dp[i]) {\n                maxProductivity = max(maxProductivity, i * (sum - i));\n            }\n        }\n        return maxProductivity;\n    }", "trans_code": "def getMaxProductivity ( n , productivity ) :\n    sum = 0\n    for val in productivity :\n        sum += val\n    half_sum = sum / 2\n    dp = [ 0 ] * ( half_sum + 1 )\n    dp [ 0 ] = 1\n    for prod in productivity :\n        for j in range ( half_sum , prod , - 1 ) :\n            dp [ j ] = dp [ j ] or dp [ j - prod ]\n    max_productivity = 0\n    for i in range ( 1 , half_sum + 1 ) :\n        if dp [ i ] :\n            max_productivity = max ( max_productivity , i * ( sum - i ) )\n    return max_productivity\n", "reference_code": "def getMaxProductivity( n: int, productivity: List[int]) -> int:\n        total_sum = sum(productivity)\n        # Initialize dp array with size total_sum + 1\n        dp = [0] * (total_sum + 1)\n        dp[0] = 1\n        # Update the dp array based on the given logic\n        for prod in productivity:\n            for j in range(total_sum, prod - 1, -1):\n                dp[j] = dp[j] or dp[j - prod]\n        # Calculate the maximum productivity\n        max_productivity = 0\n        for i in range(1, total_sum):\n            if dp[i]:\n                max_productivity = max(max_productivity, i * (total_sum - i))\n        return max_productivity", "target_Lan": "python###getMaxProductivity.py", "target_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    n1, productivity1 = 0, []\n    print(getMaxProductivity(n1, productivity1))\n    n2, productivity2 = 5, [2, 3, 1, 5, 4]\n    print(getMaxProductivity(n2, productivity2))\n    n3, productivity3 = 3, [7, 6, 8]\n    print(getMaxProductivity(n3, productivity3))\n    n4, productivity4 = 4, [10, 5, 3, 2]\n    print(getMaxProductivity(n4, productivity4))\n    n5, productivity5 = 2, [4, 6]\n    print(getMaxProductivity(n5, productivity5))"}, {"source_Lan": "cpp###getCount.cpp", "source_code": "long long getCount(int n, vector<int> &arr, int a, int b) {\n        \n        int ans=0;\n        for(int i=0;i<n;i++){\n            for(int j=i;j<n;j++){\n                bool flag=false;\n                for(int k=i;k<=j;k++){\n                    for(int l=k+1;l<=j;l++){\n                        if(arr[k]+arr[l]<a || arr[k]+arr[l]>b)\n                        flag=true;\n                    }\n                }\n                if(flag==false)  ans++;\n            }\n        }\n        return ans;\n    }", "trans_code": "def getCount ( n , arr , a , b ) :\n    ans = 0\n    for i in range ( n ) :\n        for j in range ( i , n ) :\n            flag = False\n            for k in range ( i , j ) :\n                for l in range ( k + 1 , j ) :\n                    if arr [ k ] + arr [ l ] < a or arr [ k ] + arr [ l ] > b :\n                        flag = True\n            if flag == False :\n                ans += 1\n    return ans\n", "reference_code": "def getCount( n : int, arr : List[int], a : int, b : int) -> int:\n        # code here\n        ans = 0\n        for i in range(n):\n            for j in range(i, n):\n                flag = False\n                for k in range(i, j + 1):\n                    for l in range(k + 1, j + 1):\n                        if arr[k] + arr[l] < a or arr[k] + arr[l] > b:\n                            flag = True\n                if not flag:\n                    ans += 1\n        return ans", "target_Lan": "python###getCount.py", "target_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(getCount(0, [], 1, 10))\n    print(getCount(1, [1], 1, 10))\n    print(getCount(3, [1, 2, 3], 3, 6))\n    print(getCount(4, [5, 6, 7, 8], 12, 20))"}, {"source_Lan": "cpp###minSwaps.cpp", "source_code": "int minSwaps(string S) {\n        int evenSum = 0, oddSum = 0;\n        int n = S.size();\n        \n        for (int i = 0; i < n; i++) {\n            if (i & 1)\n                oddSum += (S[i] == '1');\n            else\n                evenSum += (S[i] == '1');\n        }\n        \n        int difference = abs(oddSum - evenSum);\n        \n        if (difference & 1)\n            return -1;\n        \n        return difference / 2;\n    }", "trans_code": "def minSwaps ( S ) :\n    evenSum , oddSum = 0 , 0\n    n = len ( S )\n    for i in range ( n ) :\n        if i & 1 :\n            oddSum += ( S [ i ] == '1' )\n        else :\n            evenSum += ( S [ i ] == '1' )\n    difference = abs ( oddSum - evenSum )\n    if difference & 1 :\n        return -1\n    return difference / 2\n", "reference_code": "def minSwaps( S):\n        even_sum, odd_sum = 0, 0\n        n = len(S)\n        # Calculating the sum of digits at even and odd positions.\n        for i in range(n):\n            if i % 2 == 1:\n                odd_sum += (S[i] == '1')\n            else:\n                even_sum += (S[i] == '1')\n        # Calculating the absolute difference between even and odd sums.\n        difference = abs(odd_sum - even_sum)\n        # If the difference is odd, return -1.\n        if difference % 2 == 1:\n            return -1\n        # Returning half of the difference as the minimum swaps required.\n        return difference // 2", "target_Lan": "python###minSwaps.py", "target_code_shell": "# TOFILL\nif __name__ == \"__main__\":\n    print(minSwaps(\"\"))               \n    print(minSwaps(\"010101\"))         \n    print(minSwaps(\"1100\"))           \n    print(minSwaps(\"111\"))            \n    print(minSwaps(\"101010\"))"}, {"source_Lan": "cpp###countUniques.cpp", "source_code": "int countUniques(vector<int> a, int k, int l, int r) {\n        \n        unordered_set<int> set;\n        int dup = 0;\n        for (int i : a) {\n            if (!set.insert(i).second) {\n                dup++;\n            }\n        }\n        int unique = set.size();\n        for (int i = l; i <= r; i++) {\n            if (k > 0 && dup > 0 && set.find(i) == set.end()) {\n                unique++;\n                k--;\n                dup--;\n            }\n        }\n        return unique;\n    }", "trans_code": "def countUniques ( a , k , l , r ) :\n    set = set ( )\n    dup = 0\n    for i in a :\n        if not set.add ( i ) : dup += 1\n    unique = len ( set )\n    for i in range ( l , r + 1 ) :\n        if k > 0 and dup > 0 and set.find ( i ) == - 1 :\n            unique += 1\n            k -= 1\n            dup -= 1\n    return unique\n", "reference_code": "def countUniques( a, k, l, r):\n        # code here\n        set_ = set()\n        dup = 0\n        for i in a:\n            if i in set_:\n                dup += 1\n            else:\n                set_.add(i)\n        unique = len(set_)\n        for i in range(l, r + 1):\n            if k > 0 and dup > 0 and i not in set_:\n                unique += 1\n                k -= 1\n                dup -= 1\n        return unique", "target_Lan": "python###countUniques.py", "target_code_shell": "# TOFILL\nif __name__ == \"__main__\":\n    print(countUniques([], 1, 1, 5))\n    print(countUniques([1, 2, 3], 0, 6, 10))\n    print(countUniques([1, 1, 1, 1], 2, 0, 5))\n    print(countUniques([1, 2, 3, 2, 3, 4], 2, 5, 7))\n    print(countUniques([5, 6, 7], 1, 8, 10))"}, {"source_Lan": "cpp###maxLength.cpp", "source_code": "int maxLength(vector<int> arr) {\n        \n        int ans = 0;\n        int N = arr.size();\n        for (int i = 0; i < N; i++) {\n            int or_val = 0;\n            for (int j = i; j < N; j++) {\n                or_val = or_val | arr[j];\n                int x = __builtin_popcount(or_val);\n                if (x == (int)log2(or_val) + 1) {\n                    ans = max(ans, j - i + 1);\n                }\n            }\n        }\n        return ans;\n    }", "trans_code": "def maxLength ( arr ) :\n    ans = 0\n    N = len ( arr )\n    for i in range ( N ) :\n        or_val = 0\n        for j in range ( i , N ) :\n            or_val = or_val | arr [ j ]\n            x = __builtins__.count ( or_val )\n            if x == int ( log2 ( or_val ) + 1 ) :\n                ans = max ( ans , j - i + 1 )\n    return ans\n", "reference_code": "def maxLength( arr):\n        # code here\n        N = len(arr)\n        ans = 0\n        for i in range(N):\n            or_val = 0\n            for j in range(i, n):\n                or_val |= arr[j]\n                x = bin(or_val).count('1')\n                if x == len(bin(or_val)) - 2:  # Subtract 2 for '0b' prefix\n                    ans = max(ans, j - i + 1)\n        return ans", "target_Lan": "python###maxLength.py", "target_code_shell": "# TOFILL\nif __name__ == \"__main__\":\n    print(maxLength([]))"}, {"source_Lan": "cpp###firstWord.cpp", "source_code": "string firstWord(int n, vector<string> &dictionary) {\n        \n        sort(dictionary.begin(), dictionary.end());\n        for(int i=0;i<n;i++) {\n            for(int j=i+1;j<n;j++) {\n                if(dictionary[i]==dictionary[j]){\n                    return \"Invalid\";\n                }\n            }\n        }\n        return dictionary[0];\n    }", "trans_code": "def firstWord ( n , dictionary ) :\n    dictionary.sort ( )\n    for i in range ( n ) :\n        for j in range ( i + 1 , n ) :\n            if dictionary [ i ] == dictionary [ j ] :\n                return \"Invalid\"\n    return dictionary [ 0 ]\n", "reference_code": "def firstWord( n: int, dictionary: List[str]) -> str:\n        dictionary.sort()\n        seen_words = set()\n        for word in dictionary:\n            if word in seen_words:\n                return \"Invalid\"\n            seen_words.add(word)\n        return dictionary[0]", "target_Lan": "python###firstWord.py", "target_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(firstWord(1, [\"apple\"]))  \n    print(firstWord(3, [\"banana\", \"cherry\", \"apple\"]))  \n    print(firstWord(4, [\"pear\", \"banana\", \"banana\", \"cherry\"]))  \n    print(firstWord(3, [\"Grape\", \"apple\", \"banana\"]))"}, {"source_Lan": "cpp###longestSubarray.cpp", "source_code": "int longestSubarray(int n, vector<int> &arr) {\n        \n        int ans=-1;\n        for(int i=0;i<n;i++){\n            int count=0;\n            int sum=0;\n            for(int j=i;j<n;j++) {\n                count++;\n                sum += arr[j];\n                if(count == sum){\n                    ans = max(ans, count);\n                }\n            }\n        }\n        return ans;\n    }", "trans_code": "def longest_subarray ( n , arr ) :\n    ans = -1\n    for i in range ( n ) :\n        count = 0\n        sum = 0\n        for j in range ( i , n ) :\n            count += 1\n            sum += arr [ j ]\n            if count == sum :\n                ans = max ( ans , count )\n    return ans\n", "reference_code": "def longestSubarray( n: int, arr: List[int]) -> int:\n        ans = -1\n        for i in range(n):\n            count = 0\n            total_sum = 0\n            for j in range(i, n):\n                count += 1\n                total_sum += arr[j]\n                if count == total_sum:\n                    ans = max(ans, count)\n        return ans", "target_Lan": "python###longestSubarray.py", "target_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(longestSubarray(0, []))                \n    print(longestSubarray(5, [1, 2, 3, 4, 5]))  \n    print(longestSubarray(6, [1, 1, 2, 2, 2, 2])) \n    print(longestSubarray(5, [3, 3, 2, 2, 4]))  \n    print(longestSubarray(4, [-1, -1, -1, -1]))"}, {"source_Lan": "cpp###minDifference.cpp", "source_code": "int minDifference(int n, vector<int> &arr, int x) {\n        \n        int ans=n+1;\n        for(int i=0;i<n-1;i++){\n            for(int j=i+1;j<n;j++){\n                if((arr[i]^arr[j]) <= x){\n                    ans = min(ans, j-i);\n                }\n            }\n        }\n        return (ans == n+1 ? -1 : ans);\n    }", "trans_code": "def min_difference ( n , arr , x ) :\n    ans = n + 1\n    for i in range ( n - 1 ) :\n        for j in range ( i + 1 , n ) :\n            if ( arr [ i ] ^ arr [ j ] ) <= x :\n                ans = min ( ans , j - i )\n    return ( ans if ans > n + 1 else -1 )\n", "reference_code": "def minDifference( n: int, arr: List[int], x: int) -> int:\n        ans = n + 1\n        for i in range(n - 1):\n            for j in range(i + 1, n):\n                if (arr[i] ^ arr[j]) <= x:\n                    ans = min(ans, j - i)\n        return -1 if ans == n + 1 else ans", "target_Lan": "python###minDifference.py", "target_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(minDifference(5, [1, 0, 0, 0, 0], 1))\n    print(minDifference(5, [5, 5, 5, 5, 5], 0))\n    print(minDifference(5, [3, 7, 8, 9, 10], 1))\n    print(minDifference(5, [1, 2, 3, 4, 10], 5))"}, {"source_Lan": "cpp###reachAlice.cpp", "source_code": "string reachAlice(int d, int x, int y, int k) {\n        int t1 = d / x;\n        int t2 = d / y + k;\n        if (t1 <= t2)\n            return \"Walk\";\n        return \"Bike\";\n    }", "trans_code": "def reachAlice ( d , x , y , k ) :\n    t1 = d / x\n    t2 = d / y + k\n    if t1 <= t2 :\n        return \"Walk\"\n    return \"Bike\"\n", "reference_code": "def reachAlice( d: int, x: int, y: int, k: int) -> str:\n        p = d // x\n        q = d // y\n        q += k\n        return \"Walk\" if p <= q else \"Bike\"", "target_Lan": "python###reachAlice.py", "target_code_shell": "# TOFILL\nif __name__ == \"__main__\":\n    print(reachAlice(0, 1, 1, 0))      \n    print(reachAlice(100, 10, 20, 1))  \n    print(reachAlice(100, 20, 10, 1))"}, {"source_Lan": "cpp###removeOrder.cpp", "source_code": "vector<int> removeOrder(int n, vector<int> &arr, string str) {\n        sort(arr.begin(), arr.end());\n        int i = 0, j = n - 1;\n        vector<int> ans(n);\n        for (int k = 0; k < n; k++) {\n            if (str[k] == '0')\n                ans[k] = arr[i++];\n            else\n                ans[k] = arr[j--];\n        }\n        return ans;\n    }", "trans_code": "def removeOrder ( n , arr , str ) :\n    arr = sorted ( arr )\n    i , j = 0 , n - 1\n    ans = [ ]\n    for k in range ( n ) :\n        if str [ k ] == '0' :\n            ans.append ( arr [ i ++ ] )\n        else :\n            ans.append ( arr [ j -- ] )\n    return ans\n", "reference_code": "def removeOrder( n: int, arr: List[int], str: str) -> List[int]:\n        # Sort the array\n        arr.sort()\n        i = 0\n        j = n - 1\n        ans = [0] * n\n        idx = 0\n        for ch in str:\n            if ch == '0':\n                ans[idx] = arr[i]\n                i += 1\n            else:\n                ans[idx] = arr[j]\n                j -= 1\n            idx += 1\n        return ans", "target_Lan": "python###removeOrder.py", "target_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(removeOrder(5, [5, 3, 1, 4, 2], \"00101\"))  \n    print(removeOrder(4, [10, 20, 30, 40], \"0000\"))   \n    print(removeOrder(6, [4, 3, 2, 1, 0, -1], \"111111\"))  \n    print(removeOrder(5, [9, 8, 7, 6, 5], \"01010\"))   \n    print(removeOrder(3, [-3, 0, 3], \"001\"))"}, {"source_Lan": "cpp###countKConstraintSubstrings.cpp", "source_code": "int countKConstraintSubstrings(string s, int k) {\n        int ans = 0, left = 0, cnt[2]{};\n        for (int i = 0; i < s.length(); i++) {\n            cnt[s[i] & 1]++;\n            while (cnt[0] > k && cnt[1] > k) {\n                cnt[s[left++] & 1]--;\n            }\n            ans += i - left + 1;\n        }\n        return ans;\n    }\n\n", "trans_code": "def countKConstraintSubstrings ( s , k ) :\n    ans , left , cnt = 0 , 0 , { }\n    for i in range ( len ( s ) ) :\n        cnt [ s [ i ] & 1 ] += 1\n        while cnt [ 0 ] > k and cnt [ 1 ] > k :\n            cnt [ s [ left ++ ] & 1 ] -= 1\n        ans += i - left + 1\n    return ans\n", "reference_code": "def countKConstraintSubstrings(s: str, k: int) -> int:\n        ans = left = 0\n        cnt = [0, 0]\n        for i, c in enumerate(s):\n            cnt[ord(c) & 1] += 1\n            while cnt[0] > k and cnt[1] > k:\n                cnt[ord(s[left]) & 1] -= 1\n                left += 1\n            ans += i - left + 1\n        return ans\n\n", "target_Lan": "python###countKConstraintSubstrings.py", "target_code_shell": "# TOFILL\nif __name__ == \"__main__\":\n    print(countKConstraintSubstrings(\"1101\", 1))\n    print(countKConstraintSubstrings(\"0000\", 2))\n    print(countKConstraintSubstrings(\"101010\", 3))\n    print(countKConstraintSubstrings(\"111000\", 0))\n    print(countKConstraintSubstrings(\"10101\", 2))"}, {"source_Lan": "cpp###countKConstraintSubstrings.cpp", "source_code": "vector<long long> countKConstraintSubstrings(string s, int k, vector<vector<int>>& queries) {\n        int n = s.length();\n        vector<int> left(n);\n        vector<long long> sum(n + 1);\n        int cnt[2]{}, l = 0;\n        for (int i = 0; i < n; i++) {\n            cnt[s[i] & 1]++;\n            while (cnt[0] > k && cnt[1] > k) {\n                cnt[s[l++] & 1]--;\n            }\n            left[i] = l;\n            // \u8ba1\u7b97 i-left[i]+1 \u7684\u524d\u7f00\u548c\n            sum[i + 1] = sum[i] + i - l + 1;\n        }\n\n        vector<long long> ans(queries.size());\n        for (int i = 0; i < queries.size(); i++) {\n            int l = queries[i][0], r = queries[i][1];\n            int j = lower_bound(left.begin() + l, left.begin() + r + 1, l) - left.begin();\n            ans[i] = sum[r + 1] - sum[j] + (long long) (j - l + 1) * (j - l) / 2;\n        }\n        return ans;\n    }\n\n", "trans_code": "def countKConstraintSubstrings ( s , k , queries ) :\n    n = len ( s )\n    left = [ 0 ] * n\n    sum = [ 0 ] * ( n + 1 )\n    cnt , l = { } , 0\n    for i in range ( n ) :\n        cnt [ s [ i ] & 1 ] += 1\n        while cnt [ 0 ] > k and cnt [ 1 ] > k : cnt [ s [ l ++ ] & 1 ] -= 1\n        left [ i ] = l\n        sum [ i + 1 ] = sum [ i ] + i - l + 1\n    ans = [ 0 ] * len ( queries )\n    for i in range ( len ( queries ) ) :\n        l , r = queries [ i ]\n        j = bisect.bisect_left ( left , l ) - bisect.bisect_right ( left , r )\n        ans [ i ] = sum [ r + 1 ] - sum [ j ] + int ( j - l + 1 ) * ( j - l ) / 2\n    return ans\n", "reference_code": "def countKConstraintSubstrings(s: str, k: int, queries: List[List[int]]) -> List[int]:\n        n = len(s)\n        left = [0] * n\n        pre = [0] * (n + 1)\n        cnt = [0, 0]\n        l = 0\n        for i, c in enumerate(s):\n            cnt[ord(c) & 1] += 1\n            while cnt[0] > k and cnt[1] > k:\n                cnt[ord(s[l]) & 1] -= 1\n                l += 1\n            left[i] = l\n            # \u8ba1\u7b97 i-left[i]+1 \u7684\u524d\u7f00\u548c\n            pre[i + 1] = pre[i] + i - l + 1\n\n        ans = []\n        for l, r in queries:\n            j = bisect_left(left, l, l, r + 1)\n            ans.append(pre[r + 1] - pre[j] + (j - l + 1) * (j - l) // 2)\n        return ans\n\n", "target_Lan": "python###countKConstraintSubstrings.py", "target_code_shell": "from bisect import bisect_left\nfrom typing import List\n\n# TOFILL\nif __name__ == \"__main__\":\n    print(countKConstraintSubstrings(\"1101\", 1, [[0, 2], [1, 3]]))\n    print(countKConstraintSubstrings(\"0000\", 2, [[0, 1], [1, 2], [2, 3]]))\n    print(countKConstraintSubstrings(\"101010\", 3, [[0, 5], [2, 4]]))\n    print(countKConstraintSubstrings(\"111000\", 0, [[0, 2], [3, 5]]))\n    print(countKConstraintSubstrings(\"10101\", 2, [[0, 3], [1, 4]]))"}, {"source_Lan": "cpp###resultsArray.cpp", "source_code": "vector<int> resultsArray(vector<int>& nums, int k) {\n        vector<int> ans(nums.size() - k + 1, -1);\n        int cnt = 0;\n        for (int i = 0; i < nums.size(); i++) {\n            cnt = i == 0 || nums[i] == nums[i - 1] + 1 ? cnt + 1 : 1;\n            if (cnt >= k) {\n                ans[i - k + 1] = nums[i];\n            }\n        }\n        return ans;\n    }\n\n", "trans_code": "def resultsArray ( nums , k ) :\n    ans = [ -1 ] * len ( nums ) - k + 1\n    cnt = 0\n    for i in range ( len ( nums ) ) :\n        cnt = i == 0 or nums [ i ] == nums [ i - 1 ] + 1\n        if cnt >= k :\n            ans [ i - k + 1 ] = nums [ i ]\n    return ans\n", "reference_code": "def resultsArray(nums: List[int], k: int) -> List[int]:\n        ans = [-1] * (len(nums) - k + 1)\n        cnt = 0\n        for i, x in enumerate(nums):\n            cnt = cnt + 1 if i == 0 or x == nums[i - 1] + 1 else 1\n            if cnt >= k:\n                ans[i - k + 1] = x\n        return ans\n\n", "target_Lan": "python###resultsArray.py", "target_code_shell": "from typing import List\n\n# TOFILL\nif __name__ == \"__main__\":\n    print(resultsArray([1, 2, 3, 4, 5], 3))\n    print(resultsArray([1, 3, 5, 7, 9], 2))\n    print(resultsArray([5, 6, 7, 8, 9, 10], 4))\n    print(resultsArray([2, 4, 6, 8, 10], 1))\n    print(resultsArray([1, 2, 2, 3, 4, 5], 2))"}, {"source_Lan": "cpp###finalPositionOfSnake.cpp", "source_code": "int finalPositionOfSnake(int n, vector<string>& commands) {\n        int i = 0, j = 0;\n        for (auto& s : commands) {\n            switch (s[0]) {\n                case 'U': i--; break;\n                case 'D': i++; break;\n                case 'L': j--; break;\n                default:  j++;\n            }\n        }\n        return i * n + j;\n    }\n\n", "trans_code": "def finalPositionOfSnake ( n , commands ) :\n    i , j = 0 , 0\n    for s in commands :\n        try :\n            i -= 1\n        except IndexError :\n            j += 1\n    return i * n + j\n", "reference_code": "def finalPositionOfSnake(n: int, commands: List[str]) -> int:\n        i = j = 0\n        for s in commands:\n            if s[0] == 'U': i -= 1\n            elif s[0] == 'D': i += 1\n            elif s[0] == 'L': j -= 1\n            else: j += 1\n        return i * n + j\n\n", "target_Lan": "python###finalPositionOfSnake.py", "target_code_shell": "from typing import List\n\n# TOFILL\nif __name__ == \"__main__\":\n    print(finalPositionOfSnake(5, [\"U\", \"R\", \"R\", \"D\", \"L\"]))\n    print(finalPositionOfSnake(10, [\"U\", \"U\", \"D\", \"R\", \"R\", \"L\", \"D\"]))\n    print(finalPositionOfSnake(7, [\"U\", \"L\", \"L\", \"D\", \"R\", \"U\"]))\n    print(finalPositionOfSnake(4, [\"D\", \"D\", \"R\", \"U\", \"U\", \"L\"]))\n    print(finalPositionOfSnake(8, [\"U\", \"U\", \"R\", \"R\", \"D\", \"D\", \"L\", \"L\"]))"}, {"source_Lan": "cpp###satisfiesConditions.cpp", "source_code": "bool satisfiesConditions(vector<vector<int>>& grid) {\n        for (int i = 0; i < grid.size(); ++i) {\n            for (int j = 0; j < grid[0].size(); ++j) {\n                if (i + 1 < grid.size() && grid[i][j] != grid[i + 1][j]) {\n                    return false;\n                }\n                if (j + 1 < grid[0].size() && grid[i][j] == grid[i][j + 1]) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n", "trans_code": "def satisfies_conditions ( grid ) :\n    for i in range ( len ( grid ) ) :\n        for j in range ( len ( grid [ 0 ] ) ) :\n            if i + 1 < len ( grid ) and grid [ i ] [ j ] != grid [ i + 1 ] [ j ] :\n                return False\n            if j + 1 < len ( grid ) and grid [ i ] [ j ] == grid [ i ] [ j + 1 ] :\n                return False\n    return True\n", "reference_code": "def satisfiesConditions(grid: List[List[int]]) -> bool:\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if i + 1 < len(grid) and grid[i][j] != grid[i + 1][j]:\n                    return False\n                if j + 1 < len(grid[0]) and grid[i][j] == grid[i][j + 1]:\n                    return False\n        return True\n\n", "target_Lan": "python###satisfiesConditions.py", "target_code_shell": "from typing import List\n\n# TOFILL\nif __name__ == \"__main__\":\n    print(satisfiesConditions([[1, 2, 3], [1, 2, 3], [1, 2, 3]]))  \n    print(satisfiesConditions([[1, 2, 2], [3, 4, 5], [6, 7, 8]]))  \n    print(satisfiesConditions([[5, 6, 7], [5, 6, 7], [5, 6, 7]]))  \n    print(satisfiesConditions([[1, 2, 1], [1, 2, 1], [1, 2, 1]]))  \n    print(satisfiesConditions([[1, 2, 3], [4, 5, 6], [7, 8, 9]]))"}, {"source_Lan": "cpp###minimumSubstringsInPartition.cpp", "source_code": "\n    int minimumSubstringsInPartition(string s) {\n\tstatic constexpr int inf = 0x3f3f3f3f;\n        int n = s.size();\n        vector<int> d(n + 1, inf);\n        unordered_map<char, int> occ_cnt;\n        d[0] = 0;\n        for (int i = 1; i <= n; i++) {\n            int max_cnt = 0;\n            occ_cnt.clear();\n            for (int j = i; j >= 1; j--) {\n                occ_cnt[s[j - 1]]++;\n                max_cnt = max(max_cnt, occ_cnt[s[j - 1]]);\n                if (max_cnt * occ_cnt.size() == (i - j + 1) && d[j - 1] != inf) {\n                    d[i] = min(d[i], d[j - 1] + 1);\n                }\n            }\n        }\n        return d[n];\n    }", "trans_code": "def minimumSubstringsInPartition ( s ) :\n    def inf ( n ) :\n        return 0x3f3f3f3f\n    n = len ( s )\n    d = [ 0 ] * ( n + 1 )\n    occ_cnt = { }\n    d [ 0 ] = 0\n    for i in range ( 1 , n + 1 ) :\n        max_cnt = 0\n        occ_cnt = { }\n        for j in range ( i , - 1 , - 1 ) :\n            occ_cnt [ s [ j - 1 ] ] += 1\n            max_cnt = max ( max_cnt , occ_cnt [ s [ j - 1 ] ] )\n            if max_cnt * len ( occ_cnt ) == ( i - j + 1 ) and d [ j - 1 ] != inf :\n                d [ i ] = min ( d [ i ] , d [ j - 1 ] + 1 )\n    return d [ n ]\n", "reference_code": "def minimumSubstringsInPartition(s: str) -> int:\n        n = len(s)\n        d = [math.inf] * (n + 1)\n        occ_cnt = defaultdict(int)\n        d[0] = 0\n        for i in range(1, n + 1):\n            occ_cnt.clear()\n            max_cnt = 0\n            for j in range(i, 0, -1):\n                occ_cnt[s[j - 1]] += 1\n                max_cnt = max(max_cnt, occ_cnt[s[j - 1]])\n                if max_cnt * len(occ_cnt) == i - j + 1 and d[j - 1] != math.inf:\n                    d[i] = min(d[i], d[j - 1] + 1)\n        return d[n]\n\n", "target_Lan": "python###minimumSubstringsInPartition.py", "target_code_shell": "from collections import defaultdict\nimport math\n# TOFILL\nif __name__ == \"__main__\":\n    print(minimumSubstringsInPartition(\"aabbcc\"))    \n    print(minimumSubstringsInPartition(\"abac\"))      \n    print(minimumSubstringsInPartition(\"abcabcabc\")) \n    print(minimumSubstringsInPartition(\"aabbccdd\"))  \n    print(minimumSubstringsInPartition(\"aaaabb\"))"}, {"source_Lan": "cpp###countPow.cpp", "source_code": "long long countPow(long long x) {\n        long long res = 0;\n        int sum = 0;\n\n        for (int i = 60; i >= 0; i--) {\n            if (1LL << i & x) {\n                res += 1LL * sum * (1LL << i);\n                sum += i;\n                \n                if (i > 0) {\n                    res += 1LL * i * (i - 1) / 2 * (1LL << (i - 1));\n                }\n            }\n        }\n        res += sum;\n        return res;\n    }\n\n", "trans_code": "def countPow ( x ) :\n    res = 0\n    sum = 0\n    for i in range ( 60 , - 1 , - 1 ) :\n        if 1LL << i & x :\n            res += 1LL * sum * ( 1LL << i )\n            sum += i\n            if i > 0 :\n                res += 1LL * i * ( i - 1 ) / 2 * ( 1LL << ( i - 1 ) )\n    res += sum\n    return res\n", "reference_code": "def countPow(x):\n    res = 0\n    sum = 0\n\n    for i in range(60, -1, -1):\n        if (1 << i) & x:\n            res += sum * (1 << i)\n            sum += i\n\n            if i > 0:\n                res += i * (i - 1) // 2 * (1 << (i - 1))\n    \n    res += sum\n    return res\n\n", "target_Lan": "python###countPow.py", "target_code_shell": "# TOFILL\nif __name__ == \"__main__\":\n    print(countPow(0))\n    print(countPow(16))\n    print(countPow(1023))\n    print(countPow(255))\n    print(countPow(4096))"}, {"source_Lan": "cpp###pow_mod.cpp", "source_code": "int pow_mod(long long x, long long y, int mod) {\n        int res = 1;\n        while (y) {\n            if (y & 1) {\n                res = res * x % mod;\n            }\n            x = x * x % mod;\n            y >>= 1;\n        }\n        return res;\n    }\n\n", "trans_code": "def pow_mod ( x , y , mod ) :\n    res = 1\n    while y :\n        if y & 1 : res = res * x % mod\n        x = x * x % mod\n        y >>= 1\n    return res\n", "reference_code": "def pow_mod(x, y, mod):\n    res = 1\n    while y:\n        if y & 1:\n            res = res * x % mod\n        x = x * x % mod\n        y >>= 1\n    return res\n\n", "target_Lan": "python###pow_mod.py", "target_code_shell": "# TOFILL\nif __name__ == \"__main__\":\n    print(pow_mod(2, 10, 1000))\n    print(pow_mod(3, 7, 50))\n    print(pow_mod(5, 20, 100))\n    print(pow_mod(7, 3, 13))\n    print(pow_mod(10, 5, 17))"}]