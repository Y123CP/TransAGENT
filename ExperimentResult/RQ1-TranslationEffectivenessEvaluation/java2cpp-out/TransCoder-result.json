[
    {
        "source_Lan": "java###ANDequalOR_Test.java",
        "source_code": "    public static long ANDequalOR(int n, int[] arr) {\n        long ans = 0;\n        int pre = 0;\n        long count = 0;\n        for (int i = 0; i < n; i++) {\n            if (arr[i] == arr[pre]) {\n                count++;\n            } else {\n                ans += (count * (count + 1)) / 2;\n                pre = i;\n                count = 1;\n            }\n        }\n        ans += (count * (count + 1)) / 2;\n        return ans;\n    }",
        "trans_code": "long long ANDequalOR ( int n , int * arr ) {\n  long long ans = 0 ;\n  int pre = 0 ;\n  long long count = 0 ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    if ( arr [ i ] == arr [ pre ] ) {\n      count ++ ;\n    }\n    else {\n      ans += ( count * ( count + 1 ) ) / 2 ;\n      pre = i ;\n      count = 1 ;\n    }\n  }\n  ans += ( count * ( count + 1 ) ) / 2 ;\n  return ans ;\n}\n",
        "reference_code": "    long long ANDequalOR(int n, vector<int> arr) {\n        long long ans = 0;\n        for (int i = 0; i < n; i++) {\n            int pt = i;\n            long long ct = 0;\n            while (pt < n) {\n                if (arr[pt] == arr[i]) {\n                    pt++;\n                    ct++;\n                } else\n                    break;\n            }\n            ct *= (ct + 1);\n            ct /= 2;\n            ans += ct;\n            i = pt - 1;\n        }\n        return ans;\n    }",
        "target_Lan": "cpp###ANDequalOR.cpp",
        "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    cout << ANDequalOR(0, {}) << endl;\n    cout << ANDequalOR(1, {1}) << endl;\n    cout << ANDequalOR(2, {1, 1}) << endl;\n    cout << ANDequalOR(3, {1, 2, 2}) << endl;\n    cout << ANDequalOR(4, {1, 1, 2, 2}) << endl;\n}"
    },
    {
        "source_Lan": "java###timeTravel_Test.java",
        "source_code": "    public static int timeTravel(int n, int[] arr) {\n        int ans = 0;\n        for(int i = 1; i < n; i++)\n            ans += (arr[i] > arr[i - 1] ? 1 : (arr[i] < arr[i - 1] ? 2 : 0));\n        return ans;\n    }",
        "trans_code": "int time_travel ( int n , vector < int > arr ) {\n  int ans = 0 ;\n  for ( int i = 1 ;\n  i < n ;\n  i ++ ) {\n    ans += ( arr [ i ] > arr [ i - 1 ] ? 1 : ( arr [ i ] < arr [ i - 1 ] ? 2 : 0 ) ) ;\n  }\n  return ans ;\n}\n",
        "reference_code": "    int timeTravel(int n, vector<int> &arr) {\n        int ans = 0;\n        for(int i = 1; i < n; i++)\n            ans += (arr[i] > arr[i - 1] ? 1 : (arr[i] < arr[i - 1] ? 2 : 0));\n        return ans;\n    }",
        "target_Lan": "cpp###timeTravel.cpp",
        "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    vector<int> arr1 = {};\n    cout << timeTravel(0, arr1) << endl;\n\n    vector<int> arr2 = {1};\n    cout << timeTravel(1, arr2) << endl;\n\n    vector<int> arr3 = {1, 2};\n    cout << timeTravel(2, arr3) << endl;\n\n    vector<int> arr4 = {2, 1};\n    cout << timeTravel(2, arr4) << endl;\n\n    vector<int> arr5 = {1, 2, 3};\n    cout << timeTravel(3, arr5) << endl;\n\n    vector<int> arr6 = {3, 2, 1};\n    cout << timeTravel(3, arr6) << endl;\n\n    vector<int> arr7 = {1, 1, 1};\n    cout << timeTravel(3, arr7) << endl;\n\n    vector<int> arr8 = {1, 2, 3, 4};\n    cout << timeTravel(4, arr8) << endl;\n\n    vector<int> arr9 = {4, 3, 2, 1};\n    cout << timeTravel(4, arr9) << endl;\n\n    vector<int> arr10 = {1, 1, 1, 1};\n    cout << timeTravel(4, arr10) << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###lastFairyStanding_Test.java",
        "source_code": "    public static int lastFairyStanding(int n, int k) {\n        int i = 1, ans = 0;\n        while (i <= n)\n            ans = (ans + k) % i++;\n        return ans + 1;\n    }",
        "trans_code": "public : int lastFairyStanding ( int n , int k ) {\n  int i = 1 , ans = 0 ;\n  while ( i <= n ) {\n    ans = ( ans + k ) % i ++ ;\n  }\n  return ans + 1 ;\n}\n",
        "reference_code": "    int lastFairyStanding(int n, int k) {\n        \n        int i = 1, ans = 0;\n        while (i <= n)\n            ans = (ans + k) % i++;\n        return ans + 1;\n    }",
        "target_Lan": "cpp###lastFairyStanding.cpp",
        "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n// TOFILL\nint main() {\n    cout << lastFairyStanding(0, 0) << endl;\n    cout << lastFairyStanding(1, 1) << endl;\n    cout << lastFairyStanding(2, 2) << endl;\n    cout << lastFairyStanding(3, 3) << endl;\n    cout << lastFairyStanding(4, 4) << endl;\n}"
    },
    {
        "source_Lan": "java###equality_Test.java",
        "source_code": "    public static int equality(int A, int B) {\n        \n        if (B < A) return 0;\n        \n        if (A == B) return 1;\n        \n        if (B % 2 == 0) return 1;\n        \n        return 0;\n    }",
        "trans_code": "int equality ( int A , int B ) {\n  if ( B < A ) return 0 ;\n  if ( A == B ) return 1 ;\n  if ( B % 2 == 0 ) return 1 ;\n  return 0 ;\n}\n",
        "reference_code": "    int equality(int A, int B) {\n        if (B<A) return 0;\n        if (A==B) return 1;\n        if (B%2==0) return 1;\n        return 0;\n    }",
        "target_Lan": "cpp###equality.cpp",
        "target_code_shell": "#include <iostream>\nusing namespace std;\n\n// TOFILL\nint main() {\n    cout << equality(0, 0) << endl;\n    cout << equality(1, 1) << endl;\n    cout << equality(-1, -1) << endl;\n    cout << equality(10, 10) << endl;\n    cout << equality(5, 5) << endl;\n}"
    },
    {
        "source_Lan": "java###findEnemies_Test.java",
        "source_code": "    public static ArrayList<ArrayList<Integer>> findEnemies(int n, int m, int k, int[] col, int[] count) {\n        ArrayList<ArrayList<Integer>> answer = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            ArrayList<Integer> row = new ArrayList<>();\n            for (int j = 0; j < m; j++) {\n                row.add(-1);\n            }\n            answer.add(row);\n        }\n        int curr = 0;\n        int ind = 0;\n        while (curr < k && ind < n) {\n            int total = count[ind];\n            while (total-- > 0) {\n                answer.get(ind).set(col[curr], curr);\n                curr += 1;\n            }\n            ind += 1;\n        }\n        return answer;\n    }",
        "trans_code": "vector < vector < int >> findEnemies ( int n , int m , int k , vector < int > col , vector < int > count ) {\n  vector < vector < int >> answer ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    vector < int > row ;\n    for ( int j = 0 ;\n    j < m ;\n    j ++ ) row . push_back ( - 1 ) ;\n    answer . push_back ( row ) ;\n  }\n  int curr = 0 ;\n  int ind = 0 ;\n  while ( curr < k && ind < n ) {\n    int total = count [ ind ] ;\n    while ( total -- ) {\n      answer [ ind ] [ col [ curr ] ] = curr ;\n      curr += 1 ;\n    }\n    ind += 1 ;\n  }\n  return answer ;\n}\n",
        "reference_code": "    vector<vector<int>> findEnemies(int n, int m, int k, vector<int> &col, vector<int> &count) {\n        vector<vector<int>> answer(n, vector<int>(m, -1));\n        int curr = 0;\n        int ind = 0;\n        while(curr < k && ind < n){\n            int total = count[ind];\n            while(total--){\n                answer[ind][col[curr]] = curr;\n                curr += 1;\n            }\n            ind += 1;\n        }\n        return answer;\n    }",
        "target_Lan": "cpp###findEnemies.cpp",
        "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    int n = 0, m = 0, k = 0;\n    vector<int> col = {};\n    vector<int> count = {};\n    vector<vector<int>> result = findEnemies(n, m, k, col, count);\n    for(int i=0; i<result.size(); i++) {\n        for(int j=0; j<result[i].size(); j++)\n            cout << result[i][j] << \" \";\n        cout << endl;\n    }\n\n    n = 1, m = 1, k = 1;\n    col = {0};\n    count = {1};\n    result = findEnemies(n, m, k, col, count);\n    for(int i=0; i<result.size(); i++) {\n        for(int j=0; j<result[i].size(); j++)\n            cout << result[i][j] << \" \";\n        cout << endl;\n    }\n\n    n = 2, m = 2, k = 2;\n    col = {0, 1};\n    count = {1, 1};\n    result = findEnemies(n, m, k, col, count);\n    for(int i=0; i<result.size(); i++) {\n        for(int j=0; j<result[i].size(); j++)\n            cout << result[i][j] << \" \";\n        cout << endl;\n    }\n\n    n = 3, m = 3, k = 3;\n    col = {0, 1, 2};\n    count = {1, 1, 1};\n    result = findEnemies(n, m, k, col, count);\n    for(int i=0; i<result.size(); i++) {\n        for(int j=0; j<result[i].size(); j++)\n            cout << result[i][j] << \" \";\n        cout << endl;\n    }\n\n    n = 4, m = 4, k = 4;\n    col = {0, 1, 2, 3};\n    count = {1, 1, 1, 1};\n    result = findEnemies(n, m, k, col, count);\n    for(int i=0; i<result.size(); i++) {\n        for(int j=0; j<result[i].size(); j++)\n            cout << result[i][j] << \" \";\n        cout << endl;\n    }\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###isMagicArray_Test.java",
        "source_code": "    public static boolean isMagicArray(int n, int[] arr) {\n        \n        for (int i = 1; i < n; i++) {\n            \n            if ((arr[i] % 2 == 0 && arr[i - 1] % 2 == 0) || (arr[i] % 2 != 0 && arr[i - 1] % 2 != 0)) {\n                return false;\n            }\n        }\n        \n        return true;\n    }",
        "trans_code": "bool isMagicArray ( int n , int arr [ ] ) {\n  for ( int i = 1 ;\n  i < n ;\n  i ++ ) {\n    if ( ( arr [ i ] % 2 == 0 && arr [ i - 1 ] % 2 == 0 ) || ( arr [ i ] % 2 != 0 && arr [ i - 1 ] % 2 != 0 ) ) {\n      return false ;\n    }\n  }\n  return true ;\n}\n",
        "reference_code": "    bool isMagicArray(int n, vector<int> &arr) {\n        for (int i=1;i<n;i++){\n            if ((arr[i]%2==0 && arr[i-1]%2==0) || (arr[i]%2!=0 && arr[i-1]%2!=0)) return 0;\n        }\n        return 1;\n    }",
        "target_Lan": "cpp###isMagicArray.cpp",
        "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    vector<int> arr1 = {};\n    cout << isMagicArray(0, arr1) << endl;\n\n    vector<int> arr2 = {1};\n    cout << isMagicArray(1, arr2) << endl;\n\n    vector<int> arr3 = {1, 2};\n    cout << isMagicArray(2, arr3) << endl;\n\n    vector<int> arr4 = {1, 2, 3};\n    cout << isMagicArray(3, arr4) << endl;\n\n    vector<int> arr5 = {1, 2, 3, 4};\n    cout << isMagicArray(4, arr5) << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###smallestString_Test.java",
        "source_code": "    public static String smallestString(int n, String s) {\n        \n        StringBuilder answer = new StringBuilder(s);\n        int odd = n % 2; \n        if (n == 1) {\n            return \"-1\"; \n        }\n        for (int i = 0; i < n / 2; i++) {\n            if (s.charAt(i) != 'a') {\n                answer.setCharAt(i, 'a'); \n                return answer.toString(); \n            }\n        }\n        answer.setCharAt(answer.length() - 1, 'b'); \n        return answer.toString(); \n    }",
        "trans_code": "public : string smallestString ( int n , string s ) {\n  string answer ( s ) ;\n  int odd = n % 2 ;\n  if ( n == 1 ) {\n    return \"-1\" ;\n  }\n  for ( int i = 0 ;\n  i < n / 2 ;\n  i ++ ) {\n    if ( s [ i ] != 'a' ) {\n      answer [ i ] = 'a' ;\n      return answer ;\n    }\n  }\n  answer [ answer . size ( ) - 1 ] = 'b' ;\n  return answer ;\n}\n",
        "reference_code": "    string smallestString(int n, string s) {\n        string answer = s;\n        int odd = n%2;\n        if(n == 1){\n            return \"-1\";\n        }\n        for(int i = 0; i < (n/2); i ++){\n            if(s[i] != 'a'){\n                answer[i] = 'a';\n                return answer;\n            }\n        }\n        answer[answer.size() - 1] = 'b';\n        return answer;\n    }",
        "target_Lan": "cpp###smallestString.cpp",
        "target_code_shell": "#include <iostream>\nusing namespace std;\n\n// TOFILL\nint main() {\n    cout << smallestString(1, \"a\") << endl;\n    cout << smallestString(2, \"aa\") << endl;\n    cout << smallestString(3, \"baa\") << endl;\n    cout << smallestString(4, \"aaaa\") << endl;\n    cout << smallestString(5, \"abaaa\") << endl;\n}"
    },
    {
        "source_Lan": "java###AreEqual_Test.java",
        "source_code": "    public static boolean AreEqual(String a, String b) {\n        int n = a.length();\n        boolean flag = false;\n        for (int i = 0; i < n - 1; i++) {\n            if (a.charAt(i) == '0' && b.charAt(i + 1) == '1') {\n                if (a.charAt(i) == b.charAt(i) && a.charAt(i + 1) == b.charAt(i + 1)) {\n                    flag = true;\n                }\n            }\n        }\n        return flag;\n    }",
        "trans_code": "bool AreEqual ( string a , string b ) {\n  int n = a . length ( ) ;\n  bool flag = false ;\n  for ( int i = 0 ;\n  i < n - 1 ;\n  i ++ ) {\n    if ( a [ i ] == '0' && b [ i + 1 ] == '1' ) {\n      if ( a [ i ] == b [ i ] && a [ i + 1 ] == b [ i + 1 ] ) {\n        flag = true ;\n      }\n    }\n  }\n  return flag ;\n}\n",
        "reference_code": "    bool AreEqual(string a, string b) {\n        int n = a.length();\n        bool flag = false;\n        for (int i = 0; i < n - 1; i++) {\n            if (a[i] == '0' && b[i + 1] == '1') {\n                if (a[i] == b[i] && a[i + 1] == b[i + 1]) {\n                    flag = true;\n                }\n            }\n        }\n        return flag;\n    }",
        "target_Lan": "cpp###AreEqual.cpp",
        "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <string>\n// TOFILL\nint main() {\n    cout << AreEqual(\"0101\", \"1010\") << endl;\n    cout << AreEqual(\"1010\", \"0101\") << endl;\n    cout << AreEqual(\"0000\", \"1111\") << endl;\n    cout << AreEqual(\"1111\", \"0000\") << endl;\n    cout << AreEqual(\"0101\", \"0101\") << endl;\n}"
    },
    {
        "source_Lan": "java###maxPoints_Test.java",
        "source_code": "    public static long maxPoints(int n, int[][] arr) {\n        long[] dp = new long[200001];\n        for (int i = n - 1; i >= 0; --i)\n            dp[i] = Math.max(arr[i][0] + dp[arr[i][1] + i + 1], dp[i + 1]);\n        return dp[0];\n    }",
        "trans_code": "long long maxPoints ( int n , int * arr ) {\n  long long dp [ 200001 ] ;\n  for ( int i = n - 1 ;\n  i >= 0 ;\n  -- i ) {\n    dp [ i ] = max ( arr [ i ] [ 0 ] + dp [ arr [ i ] [ 1 ] + i + 1 ] , dp [ i + 1 ] ) ;\n  }\n  return dp [ 0 ] ;\n}\n",
        "reference_code": "    long long maxPoints(int n, vector<vector<int>> &arr) {\n        long long dp[200001] = {};\n        for (int i = n - 1; i >= 0; --i)\n            dp[i] = max(arr[i][0] + dp[arr[i][1] + i + 1], dp[i + 1]);\n        return dp[0];\n    }",
        "target_Lan": "cpp###maxPoints.cpp",
        "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    int n1 = 0;\n    vector<vector<int>> arr1 = {};\n    cout << maxPoints(n1, arr1) << endl;\n\n    int n2 = 1;\n    vector<vector<int>> arr2 = {{1,0}};\n    cout << maxPoints(n2, arr2) << endl;\n\n    int n3 = 2;\n    vector<vector<int>> arr3 = {{1,0},{2,1}};\n    cout << maxPoints(n3, arr3) << endl;\n\n    int n4 = 3;\n    vector<vector<int>> arr4 = {{1,0},{2,1},{3,2}};\n    cout << maxPoints(n4, arr4) << endl;\n\n    int n5 = 4;\n    vector<vector<int>> arr5 = {{1,0},{2,1},{3,2},{4,3}};\n    cout << maxPoints(n5, arr5) << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###matrixConundrum_Test.java",
        "source_code": "    public static boolean matrixConundrum(int n, int m, List<String> mat) {\n        String play = \"play\";\n        int fnd = 0;\n        for (int i = 0; i < m; ++i) {\n            boolean check = false;\n            for (int j = 0; j < n; ++j) {\n                if (mat.get(j).charAt(i) == play.charAt(fnd)) {\n                    check = true;\n                }\n            }\n            if (check) {\n                ++fnd;\n                if (fnd == 4) {\n                    break;\n                }\n            }\n        }\n        return fnd == 4;\n    }",
        "trans_code": "bool matrixConundrum ( int n , int m , std :: vector < std :: string > & mat ) {\n  std :: string play = \"play\" ;\n  int fnd = 0 ;\n  for ( int i = 0 ;\n  i < m ;\n  ++ i ) {\n    bool check = false ;\n    for ( int j = 0 ;\n    j < n ;\n    ++ j ) {\n      if ( mat [ j ] [ i ] == play [ fnd ] ) check = true ;\n    }\n    if ( check ) {\n      ++ fnd ;\n      if ( fnd == 4 ) break ;\n    }\n  }\n  return fnd == 4 ;\n}\n",
        "reference_code": "    bool matrixConundrum(int n, int m, vector<string> &mat) {\n        string play = \"play\";\n        int fnd = 0;\n        for (int i = 0; i < m; ++i) {\n            bool check = false;\n            for (int j = 0; j < n; ++j) {\n                if (mat[j][i] == play[fnd]) {\n                    check = true;\n                }\n            }\n            if (check) {\n                ++fnd;\n                if (fnd == 4) {\n                    break;\n                }\n            }\n        }\n        if (fnd == 4)\n            return true;\n        return false;\n    }",
        "target_Lan": "cpp###matrixConundrum.cpp",
        "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <string>\n// TOFILL\nint main() {\n    int n = 0, m = 0;\n    vector<string> mat = {};\n    cout << matrixConundrum(n, m, mat) << endl;\n\n    n = 1, m = 1;\n    mat = {\"play\"};\n    cout << matrixConundrum(n, m, mat) << endl;\n\n    n = 2, m = 2;\n    mat = {\"poy\", \"lay\"};\n    cout << matrixConundrum(n, m, mat) << endl;\n\n    n = 2, m = 2;\n    mat = {\"poy\", \"lay\"};\n    cout << matrixConundrum(n, m, mat) << endl;\n\n    n = 2, m = 2;\n    mat = {\"poy\", \"lay\"};\n    cout << matrixConundrum(n, m, mat) << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###isPossible_Test.java",
        "source_code": "    public static String isPossible(int a, int b, int c) {\n        \n        if ((a + b) > c && (a + c) > b && (b + c) > a)\n            return \"YES\";\n        else\n            return \"NO\";\n    }",
        "trans_code": "string isPossible ( int a , int b , int c ) {\n  if ( ( a + b ) > c && ( a + c ) > b && ( b + c ) > a ) return \"YES\" ;\n  else return \"NO\" ;\n}\n",
        "reference_code": "    string isPossible(int a, int b, int c) {\n        \n        if ((a + b) > c && (a + c) > b && (b + c) > a)\n            return \"YES\";\n        else\n            return \"NO\";\n    }",
        "target_Lan": "cpp###isPossible.cpp",
        "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n// TOFILL\nint main() {\n    cout << isPossible(1, 2, 3) << endl;\n    cout << isPossible(3, 2, 1) << endl;\n    cout << isPossible(0, 0, 0) << endl;\n    cout << isPossible(-1, -2, -3) << endl;\n    cout << isPossible(1000000, 1000000, 1000000) << endl;\n}"
    },
    {
        "source_Lan": "java###countOperations_Test.java",
        "source_code": "    public static int countOperations(String s) {\n        final int mod = 1000000007;\n        int ans = 0;\n        int count_b = 0;\n        for (int i = s.length() - 1; i >= 0; --i) {\n            if (s.charAt(i) == 'b') {\n                count_b = (count_b + 1) % mod;\n            } else {\n                ans = (ans + count_b) % mod;\n                count_b = (count_b + count_b) % mod;\n            }\n        }\n        return ans;\n    }",
        "trans_code": "public : int countOperations ( string s ) {\n  const int mod = 1000000007 ;\n  int ans = 0 ;\n  int count_b = 0 ;\n  for ( int i = s . length ( ) - 1 ;\n  i >= 0 ;\n  -- i ) {\n    if ( s [ i ] == 'b' ) count_b = ( count_b + 1 ) % mod ;\n    else {\n      ans = ( ans + count_b ) % mod ;\n      count_b = ( count_b + count_b ) % mod ;\n    }\n  }\n  return ans ;\n}\n",
        "reference_code": "    int countOperations(string s) {\n        const int mod = 1000000007;\n        int ans = 0;\n        int count_b = 0;\n        for (int i = s.length() - 1; i >= 0; --i) {\n            if (s[i] == 'b')\n                count_b = (count_b + 1) % mod;\n            else {\n                ans = (ans + count_b) % mod;\n                count_b = (count_b + count_b) % mod;\n            }\n        }\n        return ans;\n    }",
        "target_Lan": "cpp###countOperations.cpp",
        "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <string>\n// TOFILL\nint main() {\n    cout << countOperations(\"ab\") << endl;\n    cout << countOperations(\"bbbb\") << endl;\n    cout << countOperations(\"baab\") << endl;\n    cout << countOperations(\"babab\") << endl;\n    cout << countOperations(\"aaabbb\") << endl;\n    return 0;\n}"
    },
    {
        "source_Lan": "java###maximumStrongIndices_Test.java",
        "source_code": "    public static int maximumStrongIndices(int n, int x, int y, int[] a, int[] b) {\n        int j = 0, ans = 0;\n        for (int i = 0; i < n; i++) {\n            while (j < n && b[j] < a[i] - x) {\n                j++;\n            }\n            if (j < n && b[j] <= a[i] + y) {\n                ans++;\n                j++;\n            }\n        }\n        return ans;\n    }",
        "trans_code": "public : int maximumStrongIndices ( int n , int x , int y , vector < int > a , vector < int > b ) {\n  int j = 0 , ans = 0 ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    while ( j < n && b [ j ] < a [ i ] - x ) j ++ ;\n    if ( j < n && b [ j ] <= a [ i ] + y ) {\n      ans ++ ;\n      j ++ ;\n    }\n  }\n  return ans ;\n}\n",
        "reference_code": "    int maximumStrongIndices(int n, int x, int y, vector<int> &a, vector<int> &b) {\n        int j = 0, ans = 0;\n        for (int i = 0; i < n; i++) {\n            while (j < n && b[j] < a[i] - x)\n                j++;\n            if (j < n && b[j] <= a[i] + y) {\n                ans++;\n                j++;\n            }\n        }\n        return ans;\n    }",
        "target_Lan": "cpp###maximumStrongIndices.cpp",
        "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    int n1 = 5, x1 = 2, y1 = 3;\n    vector<int> a1 = {1, 2, 3, 4, 5};\n    vector<int> b1 = {3, 4, 5, 6, 7};\n    cout << maximumStrongIndices(n1, x1, y1, a1, b1) << endl;\n\n    int n2 = 5, x2 = 1, y2 = 1;\n    vector<int> a2 = {1, 2, 3, 4, 5};\n    vector<int> b2 = {2, 3, 4, 5, 6};\n    cout << maximumStrongIndices(n2, x2, y2, a2, b2) << endl;\n\n    int n3 = 5, x3 = 0, y3 = 0;\n    vector<int> a3 = {1, 2, 3, 4, 5};\n    vector<int> b3 = {1, 2, 3, 4, 5};\n    cout << maximumStrongIndices(n3, x3, y3, a3, b3) << endl;\n\n    int n4 = 5, x4 = 3, y4 = 2;\n    vector<int> a4 = {1, 2, 3, 4, 5};\n    vector<int> b4 = {4, 5, 6, 7, 8};\n    cout << maximumStrongIndices(n4, x4, y4, a4, b4) << endl;\n\n    int n5 = 5, x5 = 4, y5 = 1;\n    vector<int> a5 = {1, 2, 3, 4, 5};\n    vector<int> b5 = {5, 6, 7, 8, 9};\n    cout << maximumStrongIndices(n5, x5, y5, a5, b5) << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###geeklandElections_Test.java",
        "source_code": "    public static boolean geeklandElections(int n, int k, String s) {\n        int votes = 0;\n        for (int i = 0; i < n; i++)\n            if (s.charAt(i) == '1') votes++;\n        return (votes + k) > (n - (votes + k));\n    }",
        "trans_code": "bool geekland_elections ( int n , int k , string s ) {\n  int votes = 0 ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) if ( s [ i ] == '1' ) votes ++ ;\n  return ( votes + k ) > ( n - ( votes + k ) ) ;\n}\n",
        "reference_code": "    bool geeklandElections(int n, int k, string &s) {\n        int votes = 0;\n        for (int i = 0; i < n; i++)\n            votes += (s[i] == '1');\n        return (votes + k) > (n - (votes + k));\n    }",
        "target_Lan": "cpp###geeklandElections.cpp",
        "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <string>\n// TOFILL\nint main() {\n    int n, k;\n    string s;\n\n    n = 0; k = 0; s = \"\";\n    cout << geeklandElections(n, k, s) << endl;\n\n    n = 1; k = 1; s = \"1\";\n    cout << geeklandElections(n, k, s) << endl;\n\n    n = 2; k = 1; s = \"01\";\n    cout << geeklandElections(n, k, s) << endl;\n\n    n = 3; k = 2; s = \"011\";\n    cout << geeklandElections(n, k, s) << endl;\n\n    n = 4; k = 2; s = \"1101\";\n    cout << geeklandElections(n, k, s) << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###totalCount_Test.java",
        "source_code": "    public static int totalCount(int n, String s) {\n        int ans = 0, mod = (int)(1e9 + 7);\n        for(int i = 0; i < s.length(); i++){\n            if(s.charAt(i) == s.charAt(0))\n                ans = (ans + s.length() - i) % mod;\n        }\n        return ans;\n    }",
        "trans_code": "public : int totalCount ( int n , string s ) {\n  int ans = 0 , mod = ( int ) ( 1e9 + 7 ) ;\n  for ( int i = 0 ;\n  i < s . size ( ) ;\n  i ++ ) {\n    if ( s [ i ] == s [ 0 ] ) {\n      ans = ( ans + s . size ( ) - i ) % mod ;\n    }\n  }\n  return ans ;\n}\n",
        "reference_code": "    int totalCount(int n, string s) {\n        int answer = 0;\n        int mod = 1e9 + 7;\n        char now = s[0];\n        for(int i = 0; i < n; i ++){\n            if(s[i] == now){\n                answer += n - i;\n                answer %= mod;\n            }\n        }\n        return answer;\n    }",
        "target_Lan": "cpp###totalCount.cpp",
        "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <string>\n// TOFILL\nint main() {\n    cout << totalCount(0, \"\") << endl;\n    cout << totalCount(1, \"a\") << endl;\n    cout << totalCount(2, \"aa\") << endl;\n    cout << totalCount(3, \"abc\") << endl;\n    cout << totalCount(4, \"abcd\") << endl;\n}"
    },
    {
        "source_Lan": "java###isFriend_Test.java",
        "source_code": "    public static String isFriend(int n, int x, int y, int[] arr) {\n        for(int e : arr)\n            if(x + e == y)\n                return \"yes\";\n        return \"no\";\n    }",
        "trans_code": "string isFriend ( int n , int x , int y , vector < int > arr ) {\n  for ( auto e : arr ) if ( x + e == y ) return \"yes\" ;\n  return \"no\" ;\n}\n",
        "reference_code": "    string isFriend(int n, int x, int y, vector<int> &arr) {\n        for (auto j:arr){\n            if (x+j==y) return \"yes\";\n        }\n        return \"no\";\n    }",
        "target_Lan": "cpp###isFriend.cpp",
        "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    vector<int> arr1 = {};\n    cout << isFriend(0, 0, 0, arr1) << endl;\n\n    vector<int> arr2 = {1};\n    cout << isFriend(1, 1, 2, arr2) << endl;\n\n    vector<int> arr3 = {1, 2};\n    cout << isFriend(2, 2, 4, arr3) << endl;\n\n    vector<int> arr4 = {1, 2, 3};\n    cout << isFriend(3, 3, 6, arr4) << endl;\n\n    vector<int> arr5 = {1, 2, 3, 4};\n    cout << isFriend(4, 4, 8, arr5) << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###geekTasks_Test.java",
        "source_code": "    public static long geekTasks(int n, int m, int q, int[][] tasks) {\n        long total = 0;\n        long minA = Long.MAX_VALUE, minB = Long.MAX_VALUE;\n        \n        for (int i = 0; i < q; i++) {\n            int a = tasks[i][0] + 1;\n            int b = tasks[i][1] + 1;\n            minA = Math.min(minA, a);\n            minB = Math.min(minB, b);\n        }\n        int[] col = new int[n]; \n        \n        for (int[] task : tasks) {\n            int x = task[1] + 1;\n            col[task[0]] = Math.max(col[task[0]], x);\n        }\n        long maxColValue = 0;\n        \n        for (int i = n - 1; i >= 0; i--) {\n            maxColValue = Math.max(maxColValue, col[i]);\n            total += maxColValue;\n        }\n        long cellsWithMaxValue = minA * minB;\n        \n        return total - cellsWithMaxValue;\n    }",
        "trans_code": "long long geekTasks ( int n , int m , int q , vector < vector < int >> & tasks ) {\n  long long total = 0 ;\n  long long minA = numeric_limits < long long > :: max ( ) , minB = numeric_limits < long long > :: max ( ) ;\n  for ( int i = 0 ;\n  i < q ;\n  i ++ ) {\n    int a = tasks [ i ] [ 0 ] + 1 ;\n    int b = tasks [ i ] [ 1 ] + 1 ;\n    minA = min ( minA , a ) ;\n    minB = min ( minB , b ) ;\n  }\n  vector < int > col ( n , 0 ) ;\n  for ( auto & task : tasks ) {\n    int x = task [ 1 ] + 1 ;\n    col [ task [ 0 ] ] = max ( col [ task [ 0 ] ] , x ) ;\n  }\n  long long maxColValue = 0 ;\n  for ( int i = n - 1 ;\n  i >= 0 ;\n  i -- ) {\n    maxColValue = max ( maxColValue , col [ i ] ) ;\n    total += maxColValue ;\n  }\n  long long cellsWithMaxValue = minA * minB ;\n  return total - cellsWithMaxValue ;\n}\n",
        "reference_code": "    long long geekTasks(int n, int m, int q, vector<vector<int>> &tasks) {\n        long long int total = 0;\n        long long int a,b, minA, minB;\n        for(long long int i=0; i<q; i++)\n        {\n            a = tasks[i][0];\n            b = tasks[i][1];\n            a += 1;\n            b += 1;\n            if(i==0){\n                minA=a;\n                minB=b;\n            }\n            if(a<minA){\n                minA=a;\n            }\n            if(b<minB){\n                minB=b;\n            }\n        }\n        vector<int> col(n, 0);\n        for(auto i : tasks){\n            long long int x = i[1] + 1;\n            col[i[0]] = max((long long int)col[i[0]], x);\n        }\n        long long int maxi = 0;\n        for(int i = n - 1; i >= 0; i--){\n            maxi = max(maxi, (long long int)col[i]);\n            total += maxi;\n        }\n        long long int cellsWithMaxValue = minA*minB;\n        total -= cellsWithMaxValue;\n        return total;\n    }",
        "target_Lan": "cpp###geekTasks.cpp",
        "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    vector<vector<int>> tasks1 = {{0,0},{1,1},{2,2}};\n    cout << geekTasks(3, 3, 3, tasks1) << endl;\n\n    vector<vector<int>> tasks2 = {{0,0}};\n    cout << geekTasks(1, 1, 1, tasks2) << endl;\n\n    vector<vector<int>> tasks3 = {{0,0},{1,1}};\n    cout << geekTasks(2, 2, 2, tasks3) << endl;\n\n    vector<vector<int>> tasks4 = {{0,1},{1,2},{2,0}};\n    cout << geekTasks(3, 3, 3, tasks4) << endl;\n\n    vector<vector<int>> tasks5 = {{0,2},{1,1},{2,0}};\n    cout << geekTasks(3, 3, 3, tasks5) << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###majorityWins_Test.java",
        "source_code": "    public static int majorityWins(int arr[], int n, int x, int y) {\n        int count_x = 0;\n        int count_y = 0;\n        \n        \n        for (int i = 0; i < n; i++) {\n            if (arr[i] == x) count_x++;\n            if (arr[i] == y) count_y++;\n        }\n        \n        if (count_x > count_y)\n            \n            return x;\n        else if (count_y > count_x)\n            \n            return y;\n        \n        else if (x < y)\n            return x;\n        else\n            return y;\n    }",
        "trans_code": "int majorityWins ( int arr [ ] , int n , int x , int y ) {\n  int count_x = 0 ;\n  int count_y = 0 ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    if ( arr [ i ] == x ) count_x ++ ;\n    if ( arr [ i ] == y ) count_y ++ ;\n  }\n  if ( count_x > count_y ) return x ;\n  else if ( count_y > count_x ) return y ;\n  else if ( x < y ) return x ;\n  else return y ;\n}\n",
        "reference_code": "    int majorityWins(int arr[], int n, int x, int y) {\n        int count_x = 0;\n        int count_y = 0;\n        \n        \n        for (int i = 0; i < n; i++) {\n            if (arr[i] == x) count_x++;\n            if (arr[i] == y) count_y++;\n        }\n        \n        if (count_x > count_y)\n            \n            return x;\n        else if (count_y > count_x)\n            \n            return y;\n        \n        else\n            return x < y ? x : y;\n    }",
        "target_Lan": "cpp###majorityWins.cpp",
        "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n// TOFILL\nint main() {\n    int arr1[] = {1,2,3,4,5,6,7,8,9,10};\n    int arr2[] = {1,2,3,4,5,6,7,8,9,10};\n    int arr3[] = {1,2,2,2,2,2,2,2,2,2};\n    int arr4[] = {1,1,1,1,1,1,1,1,1,1};\n    int arr5[] = {1,2,3,4,5,6,7,8,9,10};\n\n    cout << majorityWins(arr1, 10, 5, 10) << endl;\n    cout << majorityWins(arr2, 10, 10, 5) << endl;\n    cout << majorityWins(arr3, 10, 2, 1) << endl;\n    cout << majorityWins(arr4, 10, 1, 2) << endl;\n    cout << majorityWins(arr5, 10, 5, 5) << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###areaOfMaxDiagonal_Test.java",
        "source_code": "    public static int areaOfMaxDiagonal(int[][] dimensions) {\n        int ans = 0, maxL = 0;\n        for (int[] d : dimensions) {\n            int x = d[0], y = d[1];\n            int l = x * x + y * y;\n            if (l > maxL || (l == maxL && x * y > ans)) {\n                maxL = l;\n                ans = x * y;\n            }\n        }\n        return ans;\n    }",
        "trans_code": "int areaOfMaxDiagonal ( vector < vector < int >> & dimensions ) {\n  int ans = 0 , maxL = 0 ;\n  for ( auto & d : dimensions ) {\n    int x = d [ 0 ] , y = d [ 1 ] ;\n    int l = x * x + y * y ;\n    if ( l > maxL || ( l == maxL && x * y > ans ) ) {\n      maxL = l ;\n      ans = x * y ;\n    }\n  }\n  return ans ;\n}\n",
        "reference_code": "    int areaOfMaxDiagonal(vector<vector<int>> &dimensions) {\n        int ans = 0, max_l = 0;\n        for (auto &d: dimensions) {\n            int x = d[0], y = d[1];\n            int l = x * x + y * y;\n            if (l > max_l || (l == max_l && x * y > ans)) {\n                max_l = l;\n                ans = x * y;\n            }\n        }\n        return ans;\n    }",
        "target_Lan": "cpp###areaOfMaxDiagonal.cpp",
        "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    vector<vector<int>> dimensions1 = {{1,2},{3,4},{5,6}};\n    vector<vector<int>> dimensions2 = {{10,20},{30,40},{50,60}};\n    vector<vector<int>> dimensions3 = {{0,0},{0,0},{0,0}};\n    vector<vector<int>> dimensions4 = {{1,1},{1,1},{1,1}};\n    vector<vector<int>> dimensions5 = {{100,200},{300,400},{500,600}};\n\n    cout << areaOfMaxDiagonal(dimensions1) << endl;\n    cout << areaOfMaxDiagonal(dimensions2) << endl;\n    cout << areaOfMaxDiagonal(dimensions3) << endl;\n    cout << areaOfMaxDiagonal(dimensions4) << endl;\n    cout << areaOfMaxDiagonal(dimensions5) << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###countKeyChanges_Test.java",
        "source_code": "    public static int countKeyChanges(String s) {\n        int ans = 0;\n        for (int i = 1; i < s.length(); i++) {\n            if ((s.charAt(i - 1) & 31) != (s.charAt(i) & 31)) {\n                ans++;\n            }\n        }\n        return ans;\n    }",
        "trans_code": "public : int countKeyChanges ( string s ) {\n  int ans = 0 ;\n  for ( int i = 1 ;\n  i < s . length ( ) ;\n  i ++ ) {\n    if ( ( s [ i - 1 ] & 31 ) != ( s [ i ] & 31 ) ) ans ++ ;\n  }\n  return ans ;\n}\n",
        "reference_code": "    int countKeyChanges(string s) {\n        int ans = 0;\n        for (int i = 1; i < s.length(); i++) {\n            ans += (s[i - 1] & 31) != (s[i] & 31);\n        }\n        return ans;\n    }",
        "target_Lan": "cpp###countKeyChanges.cpp",
        "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <string>\n// TOFILL\nint main() {\n    cout << countKeyChanges(\"a\") << endl;\n    cout << countKeyChanges(\"A\") << endl;\n    cout << countKeyChanges(\"aA\") << endl;\n    cout << countKeyChanges(\"Aa\") << endl;\n    cout << countKeyChanges(\"aBcDeF\") << endl;\n    return 0;\n}"
    },
    {
        "source_Lan": "java###minOrAfterOperations_Test.java",
        "source_code": "    public static int minOrAfterOperations(int[] nums, int k) {\n        int ans = 0;\n        int mask = 0;\n        for (int b = 29; b >= 0; b--) {\n            mask |= 1 << b;\n            int cnt = 0; \n            int and = -1; \n            for (int x : nums) {\n                and &= x & mask;\n                if (and != 0) {\n                    cnt++; \n                } else {\n                    and = -1; \n                }\n            }\n            if (cnt > k) {\n                ans |= 1 << b; \n                mask ^= 1 << b; \n            }\n        }\n        return ans;\n    }",
        "trans_code": "public : int minOrAfterOperations ( vector < int > & nums , int k ) {\n  int ans = 0 ;\n  int mask = 0 ;\n  for ( int b = 29 ;\n  b >= 0 ;\n  -- b ) {\n    mask |= 1 << b ;\n    int cnt = 0 ;\n    int and = - 1 ;\n    for ( int x : nums ) {\n      and &= x & mask ;\n      if ( and != 0 ) cnt ++ ;\n      else and = - 1 ;\n    }\n    if ( cnt > k ) {\n      ans |= 1 << b ;\n      mask ^= 1 << b ;\n    }\n  }\n  return ans ;\n}\n",
        "reference_code": "    int minOrAfterOperations(vector<int> &nums, int k) {\n        int ans = 0, mask = 0;\n        for (int b = 29; b >= 0; b--) {\n            mask |= 1 << b;\n            int cnt = 0, and_res = -1; \n            for (int x : nums) {\n                and_res &= x & mask;\n                if (and_res) {\n                    cnt++; \n                } else {\n                    and_res = -1; \n                }\n            }\n            if (cnt > k) {\n                ans |= 1 << b; \n                mask ^= 1 << b; \n            }\n        }\n        return ans;\n    }",
        "target_Lan": "cpp###minOrAfterOperations.cpp",
        "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    vector<int> nums1 = {1,2,3,4,5};\n    cout << minOrAfterOperations(nums1, 2) << endl;\n\n    vector<int> nums2 = {10,20,30,40,50};\n    cout << minOrAfterOperations(nums2, 3) << endl;\n\n    vector<int> nums3 = {100,200,300,400,500};\n    cout << minOrAfterOperations(nums3, 4) << endl;\n\n    vector<int> nums4 = {1000,2000,3000,4000,5000};\n    cout << minOrAfterOperations(nums4, 5) << endl;\n\n    vector<int> nums5 = {10000,20000,30000,40000,50000};\n    cout << minOrAfterOperations(nums5, 6) << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###resultArray_Test.java",
        "source_code": "    public static int[] resultArray(int[] nums) {\n        int n = nums.length;\n        List<Integer> a = new ArrayList<>();\n        List<Integer> b = new ArrayList<>();\n        a.add(nums[0]);\n        b.add(nums[1]);\n        for (int i = 2; i < n; i++) {\n            if (a.get(a.size() - 1) > b.get(b.size() - 1)) {\n                a.add(nums[i]);\n            } else {\n                b.add(nums[i]);\n            }\n        }\n        a.addAll(b);\n        for (int i = 0; i < n; i++) {\n            nums[i] = a.get(i);\n        }\n        return nums;\n    }",
        "trans_code": "public : vector < int > resultArray ( vector < int > & nums ) {\n  int n = nums . size ( ) ;\n  vector < int > a ;\n  vector < int > b ;\n  a . push_back ( nums [ 0 ] ) ;\n  b . push_back ( nums [ 1 ] ) ;\n  for ( int i = 2 ;\n  i < n ;\n  i ++ ) {\n    if ( a [ a . size ( ) - 1 ] > b [ b . size ( ) - 1 ] ) a . push_back ( nums [ i ] ) ;\n    else b . push_back ( nums [ i ] ) ;\n  }\n  a . swap ( b ) ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) nums [ i ] = a [ i ] ;\n  return nums ;\n}\n",
        "reference_code": "    vector<int> resultArray(vector<int> &nums) {\n        vector<int> a{nums[0]}, b{nums[1]};\n        for (int i = 2; i < nums.size(); i++) {\n            (a.back() > b.back() ? a : b).push_back(nums[i]);\n        }\n        a.insert(a.end(), b.begin(), b.end());\n        return a;\n    }",
        "target_Lan": "cpp###resultArray.cpp",
        "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    vector<int> nums1 = {1, 2, 3, 4, 5};\n    vector<int> result1 = resultArray(nums1);\n    for(int i=0; i<result1.size(); i++)\n        cout << result1[i] << \" \";\n    cout << endl;\n\n    vector<int> nums2 = {5, 4, 3, 2, 1};\n    vector<int> result2 = resultArray(nums2);\n    for(int i=0; i<result2.size(); i++)\n        cout << result2[i] << \" \";\n    cout << endl;\n\n    vector<int> nums3 = {1, 1, 1, 1, 1};\n    vector<int> result3 = resultArray(nums3);\n    for(int i=0; i<result3.size(); i++)\n        cout << result3[i] << \" \";\n    cout << endl;\n\n    vector<int> nums4 = {-1, -2, -3, -4, -5};\n    vector<int> result4 = resultArray(nums4);\n    for(int i=0; i<result4.size(); i++)\n        cout << result4[i] << \" \";\n    cout << endl;\n\n    vector<int> nums5 = {100, 200, 300, 400, 500};\n    vector<int> result5 = resultArray(nums5);\n    for(int i=0; i<result5.size(); i++)\n        cout << result5[i] << \" \";\n    cout << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###countSubmatrices_Test.java",
        "source_code": "    public static int countSubmatrices(int[][] grid, int k) {\n        int ans = 0;\n        int m = grid.length;\n        int n = grid[0].length;\n        int[][] sum = new int[m + 1][n + 1];\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                sum[i + 1][j + 1] = sum[i + 1][j] + sum[i][j + 1] - sum[i][j] + grid[i][j];\n                if (sum[i + 1][j + 1] <= k) {\n                    ans++;\n                }\n            }\n        }\n        return ans;\n    }",
        "trans_code": "public : int countSubmatrices ( vector < vector < int >> & grid , int k ) {\n  int ans = 0 ;\n  int m = grid . size ( ) ;\n  int n = grid [ 0 ] . size ( ) ;\n  vector < vector < int >> sum ( m + 1 , vector < int > ( n + 1 , 0 ) ) ;\n  for ( int i = 0 ;\n  i < m ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < n ;\n    j ++ ) {\n      sum [ i + 1 ] [ j + 1 ] = sum [ i + 1 ] [ j ] + sum [ i ] [ j + 1 ] - sum [ i ] [ j ] + grid [ i ] [ j ] ;\n      if ( sum [ i + 1 ] [ j + 1 ] <= k ) ans ++ ;\n    }\n  }\n  return ans ;\n}\n",
        "reference_code": "    int countSubmatrices(vector<vector<int>> &grid, int k) {\n        int ans = 0, m = grid.size(), n = grid[0].size();\n        vector<vector<int>> sum(m + 1, vector<int>(n + 1));\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                sum[i + 1][j + 1] = sum[i + 1][j] + sum[i][j + 1] - sum[i][j] + grid[i][j];\n                ans += sum[i + 1][j + 1] <= k;\n            }\n        }\n        return ans;\n    }",
        "target_Lan": "cpp###countSubmatrices.cpp",
        "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    vector<vector<int>> grid1 = {{1,0,1},{0,1,0},{1,0,1}};\n    cout << countSubmatrices(grid1, 1) << endl;\n\n    vector<vector<int>> grid2 = {{1,1,1},{1,1,1},{1,1,1}};\n    cout << countSubmatrices(grid2, 2) << endl;\n\n    vector<vector<int>> grid3 = {{1,0,1},{0,1,0},{1,0,1}};\n    cout << countSubmatrices(grid3, 0) << endl;\n\n    vector<vector<int>> grid4 = {{1,1,1},{1,1,1},{1,1,1}};\n    cout << countSubmatrices(grid4, 9) << endl;\n\n    vector<vector<int>> grid5 = {{0,0,0},{0,0,0},{0,0,0}};\n    cout << countSubmatrices(grid5, 1) << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###minimumOperationsToWriteY_Test.java",
        "source_code": "    public static int minimumOperationsToWriteY(int[][] grid) {\n        int[] cnt1 = new int[3];\n        int[] cnt2 = new int[3];\n        int n = grid.length;\n        int m = n / 2;\n        for (int i = 0; i < m; i++) {\n            cnt1[grid[i][i]]++;\n            cnt1[grid[i][n - 1 - i]]++;\n            for (int j = 0; j < n; j++) {\n                if (j != i && j != n - 1 - i) {\n                    cnt2[grid[i][j]]++;\n                }\n            }\n        }\n        for (int i = m; i < n; i++) {\n            cnt1[grid[i][m]]++;\n            for (int j = 0; j < n; j++) {\n                if (j != m) {\n                    cnt2[grid[i][j]]++;\n                }\n            }\n        }\n        int maxNotChange = 0;\n        for (int i = 0; i < 3; i++) {\n            for (int j = 0; j < 3; j++) {\n                if (i != j) {\n                    maxNotChange = Math.max(maxNotChange, cnt1[i] + cnt2[j]);\n                }\n            }\n        }\n        return n * n - maxNotChange;\n    }",
        "trans_code": "public : int minimumOperationsToWriteY ( vector < vector < int >> & grid ) {\n  vector < int > cnt1 ( 3 , 0 ) ;\n  vector < int > cnt2 ( 3 , 0 ) ;\n  int n = grid . size ( ) ;\n  int m = n / 2 ;\n  for ( int i = 0 ;\n  i < m ;\n  i ++ ) {\n    cnt1 [ grid [ i ] [ i ] ] ++ ;\n    cnt1 [ grid [ i ] [ n - 1 - i ] ] ++ ;\n    for ( int j = 0 ;\n    j < n ;\n    j ++ ) {\n      if ( j != i && j != n - 1 - i ) cnt2 [ grid [ i ] [ j ] ] ++ ;\n    }\n  }\n  for ( int i = m ;\n  i < n ;\n  i ++ ) {\n    cnt1 [ grid [ i ] [ m ] ] ++ ;\n    for ( int j = 0 ;\n    j < n ;\n    j ++ ) {\n      if ( j != m ) cnt2 [ grid [ i ] [ j ] ] ++ ;\n    }\n  }\n  int maxNotChange = 0 ;\n  for ( int i = 0 ;\n  i < 3 ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < 3 ;\n    j ++ ) {\n      if ( i != j ) maxNotChange = max ( maxNotChange , cnt1 [ i ] + cnt2 [ j ] ) ;\n    }\n  }\n  return n * n - maxNotChange ;\n}\n",
        "reference_code": "    int minimumOperationsToWriteY(vector<vector<int>> &grid) {\n        int cnt1[3]{}, cnt2[3]{};\n        int n = grid.size();\n        int m = n / 2;\n        for (int i = 0; i < m; i++) {\n            cnt1[grid[i][i]]++;\n            cnt1[grid[i][n - 1 - i]]++;\n            for (int j = 0; j < n; j++) {\n                if (j != i && j != n - 1 - i) {\n                    cnt2[grid[i][j]]++;\n                }\n            }\n        }\n        for (int i = m; i < n; i++) {\n            cnt1[grid[i][m]]++;\n            for (int j = 0; j < n; j++) {\n                if (j != m) {\n                    cnt2[grid[i][j]]++;\n                }\n            }\n        }\n        int max_not_change = 0;\n        for (int i = 0; i < 3; i++) {\n            for (int j = 0; j < 3; j++) {\n                if (i != j) {\n                    max_not_change = max(max_not_change, cnt1[i] + cnt2[j]);\n                }\n            }\n        }\n        return n * n - max_not_change;\n    }",
        "target_Lan": "cpp###minimumOperationsToWriteY.cpp",
        "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    vector<vector<int>> grid1 = {{1, 1, 1}, {1, 1, 1}, {1, 1, 1}};\n    cout << minimumOperationsToWriteY(grid1) << endl;\n\n    vector<vector<int>> grid2 = {{0, 0, 0}, {0, 0, 0}, {0, 0, 0}};\n    cout << minimumOperationsToWriteY(grid2) << endl;\n\n    vector<vector<int>> grid3 = {{2, 2, 2}, {2, 2, 2}, {2, 2, 2}};\n    cout << minimumOperationsToWriteY(grid3) << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###isSubstringPresent_Test.java",
        "source_code": "    public static boolean isSubstringPresent(String S) {\n        char[] s = S.toCharArray();\n        boolean[][] vis = new boolean[26][26];\n        for (int i = 1; i < s.length; i++) {\n            int x = s[i - 1] - 'a';\n            int y = s[i] - 'a';\n            vis[x][y] = true;\n            if (vis[y][x]) {\n                return true;\n            }\n        }\n        return false;\n    }",
        "trans_code": "bool isSubstringPresent ( string S ) {\n  char * s = S . c_str ( ) ;\n  bool vis [ 26 ] [ 26 ] ;\n  for ( int i = 1 ;\n  i < s . length ( ) ;\n  i ++ ) {\n    int x = s [ i - 1 ] - 'a' ;\n    int y = s [ i ] - 'a' ;\n    vis [ x ] [ y ] = true ;\n    if ( vis [ y ] [ x ] ) {\n      return true ;\n    }\n  }\n  return false ;\n}\n",
        "reference_code": "    bool isSubstringPresent(string s) {\n        bool vis[26][26]{};\n        for (int i = 1; i < s.length(); i++) {\n            int x = s[i - 1] - 'a', y = s[i] - 'a';\n            vis[x][y] = true;\n            if (vis[y][x]) {\n                return true;\n            }\n        }\n        return false;\n    }",
        "target_Lan": "cpp###isSubstringPresent.cpp",
        "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <string>\n// TOFILL\nint main() {\n    cout <<(isSubstringPresent(\"abc\") ? \"True\" : \"False\") << endl;\n    cout <<(isSubstringPresent(\"abcdabcd\") ? \"True\" : \"False\") << endl;\n    cout <<(isSubstringPresent(\"a\") ? \"True\" : \"False\") << endl;\n    cout <<(isSubstringPresent(\"abababab\") ? \"True\" : \"False\") << endl;\n    cout <<(isSubstringPresent(\"abcdefghijklmnopqrstuvwxyz\") ? \"True\" : \"False\") << endl;\n    return 0;\n}"
    },
    {
        "source_Lan": "java###maximumLengthSubstring_Test.java",
        "source_code": "    public static int maximumLengthSubstring(String S) {\n        char[] s = S.toCharArray();\n        int ans = 0;\n        int left = 0;\n        int[] cnt = new int[26];\n        for (int i = 0; i < s.length; i++) {\n            int b = s[i] - 'a';\n            cnt[b]++;\n            while (cnt[b] > 2) {\n                cnt[s[left++] - 'a']--;\n            }\n            ans = Math.max(ans, i - left + 1);\n        }\n        return ans;\n    }",
        "trans_code": "public : int maximumLengthSubstring ( string S ) {\n  char * s = S . c_str ( ) ;\n  int ans = 0 ;\n  int left = 0 ;\n  int cnt [ 26 ] ;\n  for ( int i = 0 ;\n  i < s . length ( ) ;\n  i ++ ) {\n    int b = s [ i ] - 'a' ;\n    cnt [ b ] ++ ;\n    while ( cnt [ b ] > 2 ) cnt [ s [ left ++ ] - 'a' ] -- ;\n    ans = max ( ans , i - left + 1 ) ;\n  }\n  return ans ;\n}\n",
        "reference_code": "    int maximumLengthSubstring(string s) {\n        int ans = 0, left = 0, cnt[26]{};\n        for (int i = 0; i < s.length(); i++) {\n            int b = s[i] - 'a';\n            cnt[b]++;\n            while (cnt[b] > 2) {\n                cnt[s[left++] - 'a']--;\n            }\n            ans = max(ans, i - left + 1);\n        }\n        return ans;\n    }",
        "target_Lan": "cpp###maximumLengthSubstring.cpp",
        "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <string>\n// TOFILL\nint main() {\n    cout << maximumLengthSubstring(\"abcabcbb\") << endl;\n    cout << maximumLengthSubstring(\"bbbbb\") << endl;\n    cout << maximumLengthSubstring(\"pwwkew\") << endl;\n    cout << maximumLengthSubstring(\"abcdefghijklmnopqrstuvwxyz\") << endl;\n    cout << maximumLengthSubstring(\"aabbccdd\") << endl;\n    return 0;\n}"
    },
    {
        "source_Lan": "java###maxBottlesDrunk_Test.java",
        "source_code": "    public static int maxBottlesDrunk(int numBottles, int numExchange) {\n        int ans = numBottles; \n        while (numBottles >= numExchange) { \n            ans++; \n            numBottles += 1 - numExchange++;\n        }\n        return ans;\n    }",
        "trans_code": "public : int maxBottlesDrunk ( int numBottles , int numExchange ) {\n  int ans = numBottles ;\n  while ( numBottles >= numExchange ) {\n    ans ++ ;\n    numBottles += 1 - numExchange ++ ;\n  }\n  return ans ;\n}\n",
        "reference_code": "    int maxBottlesDrunk(int numBottles, int numExchange) {\n        int ans = numBottles; \n        while (numBottles >= numExchange) { \n            ans++; \n            numBottles += 1 - numExchange++;\n        }\n        return ans;\n    }",
        "target_Lan": "cpp###maxBottlesDrunk.cpp",
        "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n// TOFILL\nint main() {\n    cout << maxBottlesDrunk(0, 0) << endl;\n    cout << maxBottlesDrunk(10, 0) << endl;\n    cout << maxBottlesDrunk(0, 10) << endl;\n    cout << maxBottlesDrunk(10, 10) << endl;\n    cout << maxBottlesDrunk(100, 5) << endl;\n    return 0;\n}"
    },
    {
        "source_Lan": "java###longestMonotonicSubarray_Test.java",
        "source_code": "    public static int longestMonotonicSubarray(int[] a) {\n        int ans = 1;\n        int i = 0, n = a.length;\n        while (i < n - 1) {\n            if (a[i + 1] == a[i]) {\n                i++; \n                continue;\n            }\n            int i0 = i; \n            boolean inc = a[i + 1] > a[i]; \n            i += 2; \n            while (i < n && a[i] != a[i - 1] && (a[i] > a[i - 1]) == inc) {\n                i++;\n            }\n            \n            ans = Math.max(ans, i - i0);\n            i--;\n        }\n        return ans;\n    }",
        "trans_code": "public : int longestMonotonicSubarray ( vector < int > a ) {\n  int ans = 1 ;\n  int i = 0 , n = a . size ( ) ;\n  while ( i < n - 1 ) {\n    if ( a [ i + 1 ] == a [ i ] ) {\n      i ++ ;\n      continue ;\n    }\n    int i0 = i ;\n    bool inc = a [ i + 1 ] > a [ i ] ;\n    i += 2 ;\n    while ( i < n && a [ i ] != a [ i - 1 ] && ( a [ i ] > a [ i - 1 ] ) == inc ) i ++ ;\n    ans = max ( ans , i - i0 ) ;\n    i -- ;\n  }\n  return ans ;\n}\n",
        "reference_code": "    int longestMonotonicSubarray(vector<int> &a) {\n        int ans = 1;\n        int i = 0, n = a.size();\n        while (i < n - 1) {\n            if (a[i + 1] == a[i]) {\n                i++; \n                continue;\n            }\n            int i0 = i; \n            bool inc = a[i + 1] > a[i]; \n            i += 2; \n            while (i < n && a[i] != a[i - 1] && (a[i] > a[i - 1]) == inc) {\n                i++;\n            }\n            \n            ans = max(ans, i - i0);\n            i--;\n        }\n        return ans;\n    }",
        "target_Lan": "cpp###longestMonotonicSubarray.cpp",
        "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    vector<int> a1 = {1, 2, 3, 4, 5};\n    cout << longestMonotonicSubarray(a1) << endl;\n\n    vector<int> a2 = {5, 4, 3, 2, 1};\n    cout << longestMonotonicSubarray(a2) << endl;\n\n    vector<int> a3 = {1, 1, 1, 1, 1};\n    cout << longestMonotonicSubarray(a3) << endl;\n\n    vector<int> a4 = {1, 2, 3, 2, 1};\n    cout << longestMonotonicSubarray(a4) << endl;\n\n    vector<int> a5 = {1, 2, 2, 3, 4, 5, 6, 5, 4, 3, 2, 1};\n    cout << longestMonotonicSubarray(a5) << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###getSmallestString2_Test.java",
        "source_code": "    public static String getSmallestString2(String s, int k) {\n        char[] t = s.toCharArray();\n        for (int i = 0; i < t.length; i++) {\n            int dis = Math.min(t[i] - 'a', 'z' - t[i] + 1);\n            if (dis > k) {\n                t[i] -= k;\n                break;\n            }\n            t[i] = 'a';\n            k -= dis;\n        }\n        return new String(t);\n    }",
        "trans_code": "string getSmallestString2 ( string s , int k ) {\n  char * t = s . c_str ( ) ;\n  for ( int i = 0 ;\n  i < t ;\n  i ++ ) {\n    int dis = min ( t [ i ] - 'a' , 'z' - t [ i ] + 1 ) ;\n    if ( dis > k ) {\n      t [ i ] -= k ;\n      break ;\n    }\n    t [ i ] = 'a' ;\n    k -= dis ;\n  }\n  return string ( t ) ;\n}\n",
        "reference_code": "    string getSmallestString2(string s, int k) {\n        for (int i = 0; i < s.length(); i++) {\n            int dis = min(s[i] - 'a', 'z' - s[i] + 1);\n            if (dis > k) {\n                s[i] -= k;\n                break;\n            }\n            s[i] = 'a';\n            k -= dis;\n        }\n        return s;\n    }",
        "target_Lan": "cpp###getSmallestString2.cpp",
        "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <string>\n// TOFILL\nint main() {\n    cout << getSmallestString2(\"abc\", 1) << endl;\n    cout << getSmallestString2(\"zzz\", 1) << endl;\n    cout << getSmallestString2(\"aaa\", 1) << endl;\n    cout << getSmallestString2(\"xyz\", 1) << endl;\n    cout << getSmallestString2(\"abc\", 2) << endl;\n}"
    },
    {
        "source_Lan": "java###isArraySpecial_Test.java",
        "source_code": "    public static boolean isArraySpecial(int[] nums) {\n        for (int i = 1; i < nums.length; i++) {\n            if (nums[i - 1] % 2 == nums[i] % 2) {\n                return false;\n            }\n        }\n        return true;\n    }",
        "trans_code": "public : bool isArraySpecial ( vector < int > & nums ) {\n  for ( int i = 1 ;\n  i < nums . size ( ) ;\n  i ++ ) {\n    if ( nums [ i - 1 ] % 2 == nums [ i ] % 2 ) {\n      return false ;\n    }\n  }\n  return true ;\n}\n",
        "reference_code": "    bool isArraySpecial(vector<int>& nums) {\n        for (int i = 1; i < nums.size(); i++) {\n            if (nums[i - 1] % 2 == nums[i] % 2) {\n                return false;\n            }\n        }\n        return true;\n    }",
        "target_Lan": "cpp###isArraySpecial.cpp",
        "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    vector<int> nums1 = {1, 2, 3, 4, 5};\n    vector<int> nums2 = {2, 4, 6, 8, 10};\n    vector<int> nums3 = {1, 3, 5, 7, 9};\n    vector<int> nums4 = {2, 2, 2, 2, 2};\n    vector<int> nums5 = {1, 1, 1, 1, 1};\n\n    cout << isArraySpecial(nums1) << endl;\n    cout << isArraySpecial(nums2) << endl;\n    cout << isArraySpecial(nums3) << endl;\n    cout << isArraySpecial(nums4) << endl;\n    cout << isArraySpecial(nums5) << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###compressedString_Test.java",
        "source_code": "    public static String compressedString(String word) {\n        StringBuilder t = new StringBuilder();\n        char[] s = word.toCharArray();\n        int i0 = -1;\n        for (int i = 0; i < s.length; i++) {\n            char c = s[i];\n            if (i + 1 == s.length || c != s[i + 1]) {\n                int k = i - i0;\n                for (int j = 0; j < k / 9; j++) {\n                    t.append('9').append(c);\n                }\n                if (k % 9 > 0) {\n                    t.append((char) ('0' + (k % 9))).append(c);\n                }\n                i0 = i;\n            }\n        }\n        return t.toString();\n    }",
        "trans_code": "string compressed_string ( string word ) {\n  string t ;\n  char * s = word . c_str ( ) ;\n  int i0 = - 1 ;\n  for ( int i = 0 ;\n  i < s . size ( ) ;\n  i ++ ) {\n    char c = s [ i ] ;\n    if ( i + 1 == s . size ( ) || c != s [ i + 1 ] ) {\n      int k = i - i0 ;\n      for ( int j = 0 ;\n      j < k / 9 ;\n      j ++ ) t . push_back ( '9' ) ;\n      if ( k % 9 > 0 ) t . push_back ( ( char ) ( '0' + ( k % 9 ) ) ) ;\n      i0 = i ;\n    }\n  }\n  return t ;\n}\n",
        "reference_code": "    string compressedString(string word) {\n        string t;\n        int i0 = -1;\n        for (int i = 0; i < word.length(); i++) {\n            char c = word[i];\n            if (i + 1 == word.length() || c != word[i + 1]) {\n                int k = i - i0;\n                for (int j = 0; j < k / 9; j++) {\n                    t += '9';\n                    t += c;\n                }\n                if (k % 9) {\n                    t += '0' + (k % 9);\n                    t += c;\n                }\n                i0 = i;\n            }\n        }\n        return t;\n    }",
        "target_Lan": "cpp###compressedString.cpp",
        "target_code_shell": "#include <iostream>\nusing namespace std;\n\n// TOFILL\nint main() {\n    cout << compressedString(\"\") << endl;\n    cout << compressedString(\"a\") << endl;\n    cout << compressedString(\"aaa\") << endl;\n    cout << compressedString(\"abc\") << endl;\n    cout << compressedString(\"aabbcc\") << endl;\n    return 0;\n}"
    },
    {
        "source_Lan": "java###minimumArea_Test.java",
        "source_code": "    public static int minimumArea(int[][] grid) {\n        int left = grid[0].length;\n        int right = 0;\n        int top = grid.length;\n        int bottom = 0;\n        for (int i = 0; i < grid.length; i++) {\n            for (int j = 0; j < grid[i].length; j++) {\n                if (grid[i][j] == 1) {\n                    left = Math.min(left, j);\n                    right = Math.max(right, j);\n                    top = Math.min(top, i);\n                    bottom = i;\n                }\n            }\n        }\n        return (right - left + 1) * (bottom - top + 1);\n    }",
        "trans_code": "public : int minimumArea ( vector < vector < int >> & grid ) {\n  int left = grid [ 0 ] . size ( ) ;\n  int right = 0 ;\n  int top = grid . size ( ) ;\n  int bottom = 0 ;\n  for ( int i = 0 ;\n  i < grid . size ( ) ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < grid [ i ] . size ( ) ;\n    j ++ ) {\n      if ( grid [ i ] [ j ] == 1 ) {\n        left = min ( left , j ) ;\n        right = max ( right , j ) ;\n        top = min ( top , i ) ;\n        bottom = i ;\n      }\n    }\n  }\n  return ( right - left + 1 ) * ( bottom - top + 1 ) ;\n}\n",
        "reference_code": "    int minimumArea(vector<vector<int>>& grid) {\n        int left = grid[0].size(), right = 0, top = grid.size(), bottom = 0;\n        for (int i = 0; i < grid.size(); i++) {\n            for (int j = 0; j < grid[i].size(); j++) {\n                if (grid[i][j]) {\n                    left = min(left, j);\n                    right = max(right, j);\n                    top = min(top, i);\n                    bottom = i;\n                }\n            }\n        }\n        return (right - left + 1) * (bottom - top + 1);\n    }",
        "target_Lan": "cpp###minimumArea.cpp",
        "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    vector<vector<int>> grid1 = {{1,0,0},{0,0,0},{0,0,1}};\n    vector<vector<int>> grid2 = {{1,1,1},{1,1,1},{1,1,1}};\n    vector<vector<int>> grid3 = {{0,0,0},{0,0,0},{0,0,0}};\n    vector<vector<int>> grid4 = {{1,0,1},{0,1,0},{1,0,1}};\n    vector<vector<int>> grid5 = {{1,0,0,1},{0,1,1,0},{0,0,0,1}};\n\n    cout << minimumArea(grid1) << endl;\n    cout << minimumArea(grid2) << endl;\n    cout << minimumArea(grid3) << endl;\n    cout << minimumArea(grid4) << endl;\n    cout << minimumArea(grid5) << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###maximumLength_Test.java",
        "source_code": "    public static int maximumLength(int[] nums, int k) {\n        int ans = 0;\n        int[][] f = new int[k][k];\n        for (int x : nums) {\n            x %= k;\n            for (int y = 0; y < k; y++) {\n                f[y][x] = f[x][y] + 1;\n                ans = Math.max(ans, f[y][x]);\n            }\n        }\n        return ans;\n    }",
        "trans_code": "public : int maximumLength ( vector < int > & nums , int k ) {\n  int ans = 0 ;\n  vector < vector < int >> f ( k , vector < int > ( k ) ) ;\n  for ( int x : nums ) {\n    x %= k ;\n    for ( int y = 0 ;\n    y < k ;\n    y ++ ) {\n      f [ y ] [ x ] = f [ x ] [ y ] + 1 ;\n      ans = max ( ans , f [ y ] [ x ] ) ;\n    }\n  }\n  return ans ;\n}\n",
        "reference_code": "    int maximumLength(vector<int>& nums, int k) {\n        int ans = 0;\n        vector<vector<int>> f(k, vector<int>(k));\n        for (int x : nums) {\n            x %= k;\n            for (int y = 0; y < k; y++) {\n                f[y][x] = f[x][y] + 1;\n                ans = max(ans, f[y][x]);\n            }\n        }\n        return ans;\n    }",
        "target_Lan": "cpp###maximumLength.cpp",
        "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    vector<int> nums1 = {1,2,3,4,5};\n    cout << maximumLength(nums1, 2) << endl;\n\n    vector<int> nums2 = {2,4,6,8,10};\n    cout << maximumLength(nums2, 10) << endl;\n\n    vector<int> nums3 = {10,20,30,40,50};\n    cout << maximumLength(nums3, 100) << endl;\n\n    vector<int> nums4 = {5,10,15,20,25};\n    cout << maximumLength(nums4, 5) << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###sumOfEncryptedInt_Test.java",
        "source_code": "    public static int sumOfEncryptedInt(int[] nums) {\n        int ans = 0;\n        for (int x : nums) {\n            int mx = 0;\n            int base = 0;\n            for (; x > 0; x /= 10) {\n                mx = Math.max(mx, x % 10);\n                base = base * 10 + 1;\n            }\n            ans += mx * base;\n        }\n        return ans;\n    }",
        "trans_code": "public : int sumOfEncryptedInt ( vector < int > & nums ) {\n  int ans = 0 ;\n  for ( auto x : nums ) {\n    int mx = 0 ;\n    int base = 0 ;\n    for ( ;\n    x > 0 ;\n    x /= 10 ) {\n      mx = max ( mx , x % 10 ) ;\n      base = base * 10 + 1 ;\n    }\n    ans += mx * base ;\n  }\n  return ans ;\n}\n",
        "reference_code": "    int sumOfEncryptedInt(vector<int> &nums) {\n        int ans = 0;\n        for (int x: nums) {\n            int mx = 0, base = 0;\n            for (; x; x /= 10) {\n                mx = max(mx, x % 10);\n                base = base * 10 + 1;\n            }\n            ans += mx * base;\n        }\n        return ans;\n    }",
        "target_Lan": "cpp###sumOfEncryptedInt.cpp",
        "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    vector<int> nums1 = {0};\n    cout << sumOfEncryptedInt(nums1) << endl;\n\n    vector<int> nums2 = {1000000};\n    cout << sumOfEncryptedInt(nums2) << endl;\n\n    vector<int> nums3 = {-1};\n    cout << sumOfEncryptedInt(nums3) << endl;\n\n    vector<int> nums4 = {10, 20, 30};\n    cout << sumOfEncryptedInt(nums4) << endl;\n\n    vector<int> nums5 = {500, 600, 700};\n    cout << sumOfEncryptedInt(nums5) << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###sumOfPower_Test.java",
        "source_code": "    public static int sumOfPower(int[] nums, int k) {\n        final int MOD = 1_000_000_007;\n        int n = nums.length;\n        int[][] f = new int[k + 1][n + 1];\n        f[0][0] = 1;\n        for (int i = 0; i < n; i++) {\n            for (int j = k; j >= nums[i]; j--) {\n                for (int c = i + 1; c > 0; c--) {\n                    f[j][c] = (f[j][c] + f[j - nums[i]][c - 1]) % MOD;\n                }\n            }\n        }\n        long ans = 0;\n        int pow2 = 1;\n        for (int i = n; i > 0; i--) {\n            ans = (ans + (long) f[k][i] * pow2) % MOD;\n            pow2 = pow2 * 2 % MOD;\n        }\n        return (int) ans;\n    }",
        "trans_code": "public : int sumOfPower ( vector < vector < int >> & nums , int k ) {\n  const int MOD = 1 _000_000_007 ;\n  int n = nums . size ( ) ;\n  vector < vector < int >> f ( k + 1 , vector < int > ( n + 1 , 0 ) ) ;\n  f [ 0 ] [ 0 ] = 1 ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    for ( int j = k ;\n    j >= nums [ i ] ;\n    j -- ) {\n      for ( int c = i + 1 ;\n      c > 0 ;\n      c -- ) {\n        f [ j ] [ c ] = ( f [ j ] [ c ] + f [ j - nums [ i ] ] [ c - 1 ] ) % MOD ;\n      }\n    }\n  }\n  long long ans = 0 ;\n  int pow2 = 1 ;\n  for ( int i = n ;\n  i > 0 ;\n  i -- ) {\n    ans = ( ans + ( long long ) f [ k ] [ i ] * pow2 ) % MOD ;\n    pow2 = pow2 * 2 % MOD ;\n  }\n  return ( int ) ans ;\n}\n",
        "reference_code": "    int sumOfPower(vector<int> &nums, int k) {\n        const int MOD = 1'000'000'007;\n        int n = nums.size();\n        vector<vector<int>> f(k + 1, vector<int>(n + 1));\n        f[0][0] = 1;\n        for (int i = 0; i < n; i++) {\n            for (int j = k; j >= nums[i]; j--) {\n                for (int c = i + 1; c > 0; c--) {\n                    f[j][c] = (f[j][c] + f[j - nums[i]][c - 1]) % MOD;\n                }\n            }\n        }\n        int ans = 0;\n        int pow2 = 1;\n        for (int i = n; i > 0; i--) {\n            ans = (ans + (long long) f[k][i] * pow2) % MOD;\n            pow2 = pow2 * 2 % MOD;\n        }\n        return ans;\n    }",
        "target_Lan": "cpp###sumOfPower.cpp",
        "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    vector<int> nums1 = {1,2,3};\n    cout << sumOfPower(nums1, 3) << endl;\n\n    vector<int> nums2 = {4,5,6};\n    cout << sumOfPower(nums2, 15) << endl;\n\n    vector<int> nums3 = {7,8,9};\n    cout << sumOfPower(nums3, 24) << endl;\n\n    vector<int> nums4 = {10,11,12};\n    cout << sumOfPower(nums4, 30) << endl;\n\n    vector<int> nums5 = {13,14,15};\n    cout << sumOfPower(nums5, 45) << endl;\n}"
    },
    {
        "source_Lan": "java###scoreOfString_Test.java",
        "source_code": "    public static int scoreOfString(String S) {\n        char[] s = S.toCharArray();\n        int ans = 0;\n        for (int i = 1; i < s.length; i++) {\n            ans += Math.abs(s[i] - s[i - 1]);\n        }\n        return ans;\n    }",
        "trans_code": "public : int scoreOfString ( string S ) {\n  vector < char > s = S ;\n  int ans = 0 ;\n  for ( int i = 1 ;\n  i < s . size ( ) ;\n  i ++ ) ans += abs ( s [ i ] - s [ i - 1 ] ) ;\n  return ans ;\n}\n",
        "reference_code": "    int scoreOfString(string s) {\n        int ans = 0;\n        for (int i = 1; i < s.length(); i++) {\n            ans += abs(s[i] - s[i - 1]);\n        }\n        return ans;\n    }",
        "target_Lan": "cpp###scoreOfString.cpp",
        "target_code_shell": "#include <iostream>\nusing namespace std;\n\n// TOFILL\nint main() {\n    cout << scoreOfString(\"a\") << endl;\n    cout << scoreOfString(\"abc\") << endl;\n    cout << scoreOfString(\"aaa\") << endl;\n    cout << scoreOfString(\"abcd\") << endl;\n    cout << scoreOfString(\"zxy\") << endl;\n}"
    },
    {
        "source_Lan": "java###satisfiesConditions_Test.java",
        "source_code": "    public static boolean satisfiesConditions(int[][] grid) {\n        for (int i = 0; i < grid.length; i++) {\n            for (int j = 0; j < grid[i].length; j++) {\n                if (j > 0 && grid[i][j] == grid[i][j - 1] || i > 0 && grid[i][j] != grid[i - 1][j]) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }",
        "trans_code": "bool satisfiesConditions ( vector < vector < int >> & grid ) {\n  for ( int i = 0 ;\n  i < grid . size ( ) ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < grid [ i ] . size ( ) ;\n    j ++ ) {\n      if ( j > 0 && grid [ i ] [ j ] == grid [ i ] [ j - 1 ] || i > 0 && grid [ i ] [ j ] != grid [ i - 1 ] [ j ] ) {\n        return false ;\n      }\n    }\n  }\n  return true ;\n}\n",
        "reference_code": "    bool satisfiesConditions(vector<vector<int>>& grid) {\n        for (int i = 0; i < grid.size(); i++) {\n            for (int j = 0; j < grid[i].size(); j++) {\n                if (j && grid[i][j] == grid[i][j - 1] || i && grid[i][j] != grid[i - 1][j]) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }",
        "target_Lan": "cpp###satisfiesConditions.cpp",
        "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    vector<vector<int>> grid1 = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};\n    cout << satisfiesConditions(grid1) << endl;\n\n    vector<vector<int>> grid2 = {{1, 1, 1}, {2, 2, 2}, {3, 3, 3}};\n    cout << satisfiesConditions(grid2) << endl;\n\n    vector<vector<int>> grid3 = {{1, 2, 3}, {1, 2, 3}, {1, 2, 3}};\n    cout << satisfiesConditions(grid3) << endl;\n\n    vector<vector<int>> grid4 = {{1, 1, 2}, {1, 1, 2}, {3, 3, 3}};\n    cout << satisfiesConditions(grid4) << endl;\n\n    vector<vector<int>> grid5 = {{1, 2, 3}, {4, 5, 6}, {7, 8, 10}};\n    cout << satisfiesConditions(grid5) << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###countAlternatingSubarrays_Test.java",
        "source_code": "    public static long countAlternatingSubarrays(int[] nums) {\n        long res = 0, cur = 0;\n        int pre = -1;\n        for (int a : nums) {\n            cur = (pre != a) ? cur + 1 : 1;\n            pre = a;\n            res += cur;\n        }\n        return res;\n    }",
        "trans_code": "public : long long countAlternatingSubarrays ( vector < int > & nums ) {\n  long long res = 0 , cur = 0 ;\n  int pre = - 1 ;\n  for ( auto a : nums ) {\n    cur = ( pre != a ) ? cur + 1 : 1 ;\n    pre = a ;\n    res += cur ;\n  }\n  return res ;\n}\n",
        "reference_code": "    long long countAlternatingSubarrays(vector<int>& nums) {\n        long long res = 0, cur = 0;\n        int pre = -1;\n        for (int a : nums) {\n            cur = (pre != a) ? cur + 1 : 1;\n            pre = a;\n            res += cur;\n        }\n        return res;\n    }",
        "target_Lan": "cpp###countAlternatingSubarrays.cpp",
        "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    vector<int> nums1 = {1,2,3,4,5};\n    vector<int> nums2 = {1,1,1,1,1};\n    vector<int> nums3 = {1,2,1,2,1};\n    vector<int> nums4 = {1,3,5,7,9};\n    vector<int> nums5 = {2,4,6,8,10};\n\n    cout << countAlternatingSubarrays(nums1) << endl;\n    cout << countAlternatingSubarrays(nums2) << endl;\n    cout << countAlternatingSubarrays(nums3) << endl;\n    cout << countAlternatingSubarrays(nums4) << endl;\n    cout << countAlternatingSubarrays(nums5) << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###modifiedMatrix_Test.java",
        "source_code": "    public static int[][] modifiedMatrix(int[][] matrix) {\n        int n = matrix.length; \n        int m = matrix[0].length; \n        for (int j = 0; j < m; j++) {\n            int zd = -1; \n            for (int i = 0; i < n; i++) {\n                zd = Math.max(zd, matrix[i][j]); \n            }\n            for (int i = 0; i < n; i++) {\n                if (matrix[i][j] == -1) {\n                    matrix[i][j] = zd; \n                }\n            }\n        }\n        return matrix; \n    }",
        "trans_code": "public : vector < vector < int >> modifiedMatrix ( vector < vector < int >> & matrix ) {\n  int n = matrix . size ( ) ;\n  int m = matrix [ 0 ] . size ( ) ;\n  for ( int j = 0 ;\n  j < m ;\n  j ++ ) {\n    int zd = - 1 ;\n    for ( int i = 0 ;\n    i < n ;\n    i ++ ) zd = max ( zd , matrix [ i ] [ j ] ) ;\n    for ( int i = 0 ;\n    i < n ;\n    i ++ ) {\n      if ( matrix [ i ] [ j ] == - 1 ) matrix [ i ] [ j ] = zd ;\n    }\n  }\n  return matrix ;\n}\n",
        "reference_code": "    vector<vector<int>> modifiedMatrix(vector<vector<int>>& matrix) {\n        int n = matrix.size();\n        int m = matrix[0].size();\n        for (int j = 0; j < m; j++) {\n            int zd = -1;\n            for (int i = 0; i < n; i++) {\n                zd = max(zd, matrix[i][j]);\n            }\n            for (int i = 0; i < n; i++) {\n                if (matrix[i][j] == -1) {\n                    matrix[i][j] = zd;\n                }\n            }\n        }\n        return matrix;\n    }",
        "target_Lan": "cpp###modifiedMatrix.cpp",
        "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    vector<vector<int>> matrix1 = {{1,2,3},{4,5,6},{7,8,9}};\n    vector<vector<int>> matrix2 = {{0,0,0},{0,0,0},{0,0,0}};\n    vector<vector<int>> matrix3 = {{-1,-2,-3},{-4,-5,-6},{-7,-8,-9}};\n    vector<vector<int>> matrix4 = {{10,20,30},{40,50,60},{70,80,90}};\n    vector<vector<int>> matrix5 = {{100,200,300},{400,500,600},{700,800,900}};\n\n    vector<vector<int>> result1 = modifiedMatrix(matrix1);\n    vector<vector<int>> result2 = modifiedMatrix(matrix2);\n    vector<vector<int>> result3 = modifiedMatrix(matrix3);\n    vector<vector<int>> result4 = modifiedMatrix(matrix4);\n    vector<vector<int>> result5 = modifiedMatrix(matrix5);\n\n    for(auto& row : result1) {\n        for(auto& elem : row) {\n            cout << elem << \" \";\n        }\n        cout << endl;\n    }\n    // Similarly print result2, result3, result4, result5\n}"
    },
    {
        "source_Lan": "java###accountBalanceAfterPurchase_Test.java",
        "source_code": "    public static int accountBalanceAfterPurchase(int purchaseAmount) {\n        int r = purchaseAmount % 10;\n        if (r < 5) {\n            purchaseAmount -= r;\n        } else {\n            purchaseAmount += 10 - r;\n        }\n        return 100 - purchaseAmount;\n    }",
        "trans_code": "int accountBalanceAfterPurchase ( int purchaseAmount ) {\n  int r = purchaseAmount % 10 ;\n  if ( r < 5 ) purchaseAmount -= r ;\n  else purchaseAmount += 10 - r ;\n  return 100 - purchaseAmount ;\n}\n",
        "reference_code": "    int accountBalanceAfterPurchase(int purchaseAmount) {\n        int r = purchaseAmount % 10;\n        if (r < 5) {\n            purchaseAmount -= r;\n        } else {\n            purchaseAmount += 10 - r;\n        }\n        return 100 - purchaseAmount;\n    }",
        "target_Lan": "cpp###accountBalanceAfterPurchase.cpp",
        "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n// TOFILL\nint main() {\n    cout << accountBalanceAfterPurchase(0) << endl;\n    cout << accountBalanceAfterPurchase(10) << endl;\n    cout << accountBalanceAfterPurchase(15) << endl;\n    cout << accountBalanceAfterPurchase(20) << endl;\n    cout << accountBalanceAfterPurchase(100) << endl;\n}"
    },
    {
        "source_Lan": "java###distributeCandies2_Test.java",
        "source_code": "    public static long distributeCandies2(int n, int limit) {\n        long ans = 0;\n        for (int i = 0; i <= Math.min(limit, n); i++) {\n            if (n - i > 2 * limit) {\n                continue;\n            }\n            ans += Math.min(n - i, limit) - Math.max(0, n - i - limit) + 1;\n        }\n        return ans;\n    }",
        "trans_code": "long long distributeCandies2 ( int n , int limit ) {\n  long long ans = 0 ;\n  for ( int i = 0 ;\n  i <= min ( limit , n ) ;\n  i ++ ) {\n    if ( n - i > 2 * limit ) continue ;\n    ans += min ( n - i , limit ) - max ( 0 , n - i - limit ) + 1 ;\n  }\n  return ans ;\n}\n",
        "reference_code": "    long long distributeCandies2(int n, int limit) {\n        long long ans = 0;\n        for (int i = 0; i <= min(limit, n); i++) {\n            if (n - i > 2 * limit) {\n                continue;\n            }\n            ans += min(n - i, limit) - max(0, n - i - limit) + 1;\n        }\n        return ans;\n    }",
        "target_Lan": "cpp###distributeCandies2.cpp",
        "target_code_shell": "#include <iostream>\nusing namespace std;\n\n// TOFILL\nint main() {\n    cout << distributeCandies2(0, 0) << endl;\n    cout << distributeCandies2(10, 5) << endl;\n    cout << distributeCandies2(20, 10) << endl;\n    cout << distributeCandies2(100, 50) << endl;\n    cout << distributeCandies2(1000, 500) << endl;\n}"
    },
    {
        "source_Lan": "java###distributeCandies_Test.java",
        "source_code": "    public static int distributeCandies(int n, int limit) {\n        int ans = 0;\n        for (int i = 0; i <= limit; i++) {\n            for (int j = 0; j <= limit; j++) {\n                if (i + j > n) {\n                    break;\n                }\n                if (n - i - j <= limit) {\n                    ans++;\n                }\n            }\n        }\n        return ans;\n    }",
        "trans_code": "public : int distributeCandies ( int n , int limit ) {\n  int ans = 0 ;\n  for ( int i = 0 ;\n  i <= limit ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j <= limit ;\n    j ++ ) {\n      if ( i + j > n ) break ;\n      if ( n - i - j <= limit ) ans ++ ;\n    }\n  }\n  return ans ;\n}\n",
        "reference_code": "    int distributeCandies(int n, int limit) {\n        int ans = 0;\n        for (int i = 0; i <= limit; i++) {\n            for (int j = 0; j <= limit; j++) {\n                if (i + j > n) {\n                    break;\n                }\n                if (n - i - j <= limit) {\n                    ans++;\n                }\n            }\n        }\n        return ans;\n    }",
        "target_Lan": "cpp###distributeCandies.cpp",
        "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n// TOFILL\nint main() {\n    cout << distributeCandies(0, 0) << endl;\n    cout << distributeCandies(10, 5) << endl;\n    cout << distributeCandies(20, 10) << endl;\n    cout << distributeCandies(100, 50) << endl;\n    cout << distributeCandies(200, 100) << endl;\n    return 0;\n}"
    },
    {
        "source_Lan": "java###findIndices_Test.java",
        "source_code": "    public static int[] findIndices(int[] nums, int indexDifference, int valueDifference) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i; j < nums.length; j++) {\n                if (j - i >= indexDifference && Math.abs(nums[j] - nums[i]) >= valueDifference) {\n                    return new int[]{i, j};\n                }\n            }\n        }\n        return new int[]{-1, -1};\n    }",
        "trans_code": "public : vector < int > findIndices ( vector < int > & nums , int indexDifference , int valueDifference ) {\n  for ( int i = 0 ;\n  i < nums . size ( ) ;\n  i ++ ) {\n    for ( int j = i ;\n    j < nums . size ( ) ;\n    j ++ ) {\n      if ( j - i >= indexDifference && abs ( nums [ j ] - nums [ i ] ) >= valueDifference ) {\n        return {\n          i , j }\n          ;\n        }\n      }\n    }\n    return {\n      - 1 , - 1 }\n      ;\n    }\n    ",
        "reference_code": "    vector<int> findIndices(vector<int>& nums, int indexDifference, int valueDifference) {\n        for (int i = 0; i < nums.size(); i++) {\n            for (int j = i; j < nums.size(); j++) {\n                if (j - i >= indexDifference && abs(nums[j] - nums[i]) >= valueDifference) {\n                    return {i, j};\n                }\n            }\n        }\n        return {-1, -1};\n    }",
        "target_Lan": "cpp###findIndices.cpp",
        "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    vector<int> nums1 = {1, 2, 3, 4, 5};\n    vector<int> result1 = findIndices(nums1, 2, 1);\n    for(int i=0; i<result1.size(); i++)\n        cout << result1[i] << \" \";\n    cout << endl;\n\n    vector<int> nums2 = {5, 4, 3, 2, 1};\n    vector<int> result2 = findIndices(nums2, 1, 1);\n    for(int i=0; i<result2.size(); i++)\n        cout << result2[i] << \" \";\n    cout << endl;\n\n    vector<int> nums3 = {1, 1, 1, 1, 1};\n    vector<int> result3 = findIndices(nums3, 1, 0);\n    for(int i=0; i<result3.size(); i++)\n        cout << result3[i] << \" \";\n    cout << endl;\n\n    vector<int> nums4 = {1, 2, 3, 4, 5};\n    vector<int> result4 = findIndices(nums4, 5, 0);\n    for(int i=0; i<result4.size(); i++)\n        cout << result4[i] << \" \";\n    cout << endl;\n\n    vector<int> nums5 = {1, 2, 3, 4, 5};\n    vector<int> result5 = findIndices(nums5, 0, 6);\n    for(int i=0; i<result5.size(); i++)\n        cout << result5[i] << \" \";\n    cout << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###theMaximumAchievableX_Test.java",
        "source_code": "    public static int theMaximumAchievableX(int num, int t) {\n        return num + 2 * t;\n    }",
        "trans_code": "int the_maximum_achievable_x ( int num , int t ) {\n  return num + 2 * t ;\n}\n",
        "reference_code": "    int theMaximumAchievableX(int num, int t) {\n        return num + 2 * t;\n    }",
        "target_Lan": "cpp###theMaximumAchievableX.cpp",
        "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n// TOFILL\nint main() {\n    cout << theMaximumAchievableX(0, 0) << endl;\n    cout << theMaximumAchievableX(1000000, 1000000) << endl;\n    cout << theMaximumAchievableX(-1000000, -1000000) << endl;\n    cout << theMaximumAchievableX(1000000, -1000000) << endl;\n    cout << theMaximumAchievableX(-1000000, 1000000) << endl;\n}"
    },
    {
        "source_Lan": "java###numberOfEmployeesWhoMetTarget_Test.java",
        "source_code": "    public static int numberOfEmployeesWhoMetTarget(int[] hours, int target) {\n        int ans = 0;\n        for (int i = 0; i < hours.length; i++) {\n            if (hours[i] >= target) {\n                ans++;\n            }\n        }\n        return ans;\n    }",
        "trans_code": "public : int numberOfEmployeesWhoMetTarget ( vector < int > hours , int target ) {\n  int ans = 0 ;\n  for ( int i = 0 ;\n  i < hours . size ( ) ;\n  i ++ ) {\n    if ( hours [ i ] >= target ) ans ++ ;\n  }\n  return ans ;\n}\n",
        "reference_code": "    int numberOfEmployeesWhoMetTarget(vector<int>& hours, int target) {\n        int ans = 0;\n        for (int i = 0; i < hours.size(); i++) {\n            if (hours[i] >= target) {\n                ans++;\n            }\n        }\n        return ans;\n    }",
        "target_Lan": "cpp###numberOfEmployeesWhoMetTarget.cpp",
        "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    vector<int> hours1 = {0, 1, 2, 3, 4};\n    cout << numberOfEmployeesWhoMetTarget(hours1, 0) << endl;\n\n    vector<int> hours2 = {10, 10, 10, 10, 10};\n    cout << numberOfEmployeesWhoMetTarget(hours2, 10) << endl;\n\n    vector<int> hours3 = {5, 5, 5, 5, 5};\n    cout << numberOfEmployeesWhoMetTarget(hours3, 6) << endl;\n\n    vector<int> hours4 = {1, 2, 3, 4, 5};\n    cout << numberOfEmployeesWhoMetTarget(hours4, 3) << endl;\n\n    vector<int> hours5 = {100, 200, 300, 400, 500};\n    cout << numberOfEmployeesWhoMetTarget(hours5, 300) << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###countTestedDevices_Test.java",
        "source_code": "    public static int countTestedDevices(int[] batteryPercentages) {\n        int n = batteryPercentages.length;\n        int need = 0;\n        for (int i = 0; i < n; i++) {\n            if (batteryPercentages[i] > 0) {\n                need++;\n                for (int j = i + 1; j < n; j++) {\n                    batteryPercentages[j] = Math.max(batteryPercentages[j] - 1, 0);\n                }\n            }\n        }\n        return need;\n    }",
        "trans_code": "int CountTestedDevices ( vector < int > & batteryPercentages ) {\n  int n = batteryPercentages . size ( ) ;\n  int need = 0 ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    if ( batteryPercentages [ i ] > 0 ) {\n      need ++ ;\n      for ( int j = i + 1 ;\n      j < n ;\n      j ++ ) batteryPercentages [ j ] = max ( batteryPercentages [ j ] - 1 , 0 ) ;\n    }\n  }\n  return need ;\n}\n",
        "reference_code": "    int countTestedDevices(vector<int>& batteryPercentages) {\n        int n = batteryPercentages.size();\n        int need = 0;\n        for (int i = 0; i < n; i++) {\n            if (batteryPercentages[i] > 0) {\n                need++;\n                for (int j = i + 1; j < n; j++) {\n                    batteryPercentages[j] = max(batteryPercentages[j] - 1, 0);\n                }\n            }\n        }\n        return need;\n    }",
        "target_Lan": "cpp###countTestedDevices.cpp",
        "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    vector<int> batteryPercentages1 = {0, 0, 0, 0, 0};\n    cout << countTestedDevices(batteryPercentages1) << endl;\n\n    vector<int> batteryPercentages2 = {100, 100, 100, 100, 100};\n    cout << countTestedDevices(batteryPercentages2) << endl;\n\n    vector<int> batteryPercentages3 = {-1, -1, -1, -1, -1};\n    cout << countTestedDevices(batteryPercentages3) << endl;\n\n    vector<int> batteryPercentages4 = {10, 20, 30, 40, 50};\n    cout << countTestedDevices(batteryPercentages4) << endl;\n\n    vector<int> batteryPercentages5 = {5, 15, 25, 35, 45};\n    cout << countTestedDevices(batteryPercentages5) << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###distanceTraveled_Test.java",
        "source_code": "    public static int distanceTraveled(int mainTank, int additionalTank) {\n        int ans = 0;\n        while (mainTank >= 5) {\n            mainTank -= 5;\n            ans += 50;\n            if (additionalTank > 0) {\n                additionalTank--;\n                mainTank++;\n            }\n        }\n        return ans + mainTank * 10;\n    }",
        "trans_code": "int distanceTraveled ( int mainTank , int additionalTank ) {\n  int ans = 0 ;\n  while ( mainTank >= 5 ) {\n    mainTank -= 5 ;\n    ans += 50 ;\n    if ( additionalTank ) {\n      additionalTank -- ;\n      mainTank ++ ;\n    }\n  }\n  return ans + mainTank * 10 ;\n}\n",
        "reference_code": "    int distanceTraveled(int mainTank, int additionalTank) {\n        int ans = 0;\n        while (mainTank >= 5) {\n            mainTank -= 5;\n            ans += 50;\n            if (additionalTank > 0) {\n                additionalTank--;\n                mainTank++;\n            }\n        }\n        return ans + mainTank * 10;\n    }",
        "target_Lan": "cpp###distanceTraveled.cpp",
        "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n// TOFILL\nint main() {\n    cout << distanceTraveled(0, 0) << endl;\n    cout << distanceTraveled(10, 0) << endl;\n    cout << distanceTraveled(5, 1) << endl;\n    cout << distanceTraveled(10, 2) << endl;\n    cout << distanceTraveled(15, 3) << endl;\n}"
    },
    {
        "source_Lan": "java###maximumBinaryString_Test.java",
        "source_code": "    public static String maximumBinaryString(String binary) {\n        int n = binary.length();\n        char[] s = binary.toCharArray();\n        int j = 0;\n        for (int i = 0; i < n; i++) {\n            if (s[i] == '0') {\n                while (j <= i || (j < n && s[j] == '1')) {\n                    j++;\n                }\n                if (j < n) {\n                    s[j] = '1';\n                    s[i] = '1';\n                    s[i + 1] = '0';\n                }\n            }\n        }\n        return new String(s);\n    }",
        "trans_code": "public : string maximumBinaryString ( string binary ) {\n  int n = binary . size ( ) ;\n  char * s = binary . c_str ( ) ;\n  int j = 0 ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    if ( s [ i ] == '0' ) {\n      while ( j <= i || ( j < n && s [ j ] == '1' ) ) j ++ ;\n      if ( j < n ) {\n        s [ j ] = '1' ;\n        s [ i ] = '1' ;\n        s [ i + 1 ] = '0' ;\n      }\n    }\n  }\n  return string ( s ) ;\n}\n",
        "reference_code": "    string maximumBinaryString(string binary) {\n        int n = binary.size();\n        int j = 0;\n        for (int i = 0; i < n; i++) {\n            if (binary[i] == '0') {\n                while (j <= i || (j < n && binary[j] == '1')) {\n                    j++;\n                }\n                if (j < n) {\n                    binary[j] = '1';\n                    binary[i] = '1';\n                    binary[i + 1] = '0';\n                }\n            }\n        }\n        return binary;\n    }",
        "target_Lan": "cpp###maximumBinaryString.cpp",
        "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <string>\n// TOFILL\nint main() {\n    cout << maximumBinaryString(\"000110\") << endl;\n    cout << maximumBinaryString(\"111000\") << endl;\n    cout << maximumBinaryString(\"000000\") << endl;\n    cout << maximumBinaryString(\"111111\") << endl;\n    cout << maximumBinaryString(\"010101\") << endl;\n    return 0;\n}"
    },
    {
        "source_Lan": "java###findChampion_Test.java",
        "source_code": "    public static int findChampion(int n, int[][] edges) {\n        int[] degree = new int[n];\n        for (int[] e : edges) {\n            degree[e[1]]++;\n        }\n        int champion = -1;\n        for (int i = 0; i < n; i++) {\n            if (degree[i] == 0) {\n                if (champion == -1) {\n                    champion = i;\n                } else {\n                    return -1;\n                }\n            }\n        }\n        return champion;\n    }",
        "trans_code": "int findChampion ( int n , vector < vector < int >> & edges ) {\n  vector < int > degree ( n , 0 ) ;\n  for ( auto & e : edges ) degree [ e . second ] ++ ;\n  int champion = - 1 ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    if ( degree [ i ] == 0 ) {\n      if ( champion == - 1 ) champion = i ;\n      else return - 1 ;\n    }\n  }\n  return champion ;\n}\n",
        "reference_code": "    int findChampion(int n, vector<vector<int>>& edges) {\n        vector<int> degree(n);\n        for (auto e : edges) {\n            degree[e[1]]++;\n        }\n        int champion = -1;\n        for (int i = 0; i < n; i++) {\n            if (degree[i] == 0) {\n                if (champion == -1) {\n                    champion = i;\n                } else {\n                    return -1;\n                }\n            }\n        }\n        return champion;\n    }",
        "target_Lan": "cpp###findChampion.cpp",
        "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    vector<vector<int>> edges1;\n    cout << findChampion(0, edges1) << endl;\n\n    vector<vector<int>> edges2 = {{0,0}};\n    cout << findChampion(1, edges2) << endl;\n\n    vector<vector<int>> edges3 = {{0,1},{1,0}};\n    cout << findChampion(2, edges3) << endl;\n\n    vector<vector<int>> edges4 = {{0,1},{1,2},{2,0}};\n    cout << findChampion(3, edges4) << endl;\n\n    vector<vector<int>> edges5 = {{0,1},{1,2},{2,3},{3,0}};\n    cout << findChampion(4, edges5) << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###firstDayBeenInAllRooms_Test.java",
        "source_code": "    public static int firstDayBeenInAllRooms(int[] nextVisit) {\n        int mod = 1000000007;\n        int len = nextVisit.length;\n        int[] dp = new int[len];\n        dp[0] = 2; \n        for (int i = 1; i < len; i++) {\n            int to = nextVisit[i];\n            dp[i] = 2 + dp[i - 1];\n            if (to != 0) {\n                dp[i] = (dp[i] - dp[to - 1] + mod) % mod; \n            }\n            dp[i] = (dp[i] + dp[i - 1]) % mod;\n        }\n        return dp[len - 2]; \n    }",
        "trans_code": "public : int firstDayBeenInAllRooms ( vector < int > nextVisit ) {\n  int mod = 1000000007 ;\n  int len = nextVisit . size ( ) ;\n  vector < int > dp ( len ) ;\n  dp [ 0 ] = 2 ;\n  for ( int i = 1 ;\n  i < len ;\n  i ++ ) {\n    int to = nextVisit [ i ] ;\n    dp [ i ] = 2 + dp [ i - 1 ] ;\n    if ( to != 0 ) dp [ i ] = ( dp [ i ] - dp [ to - 1 ] + mod ) % mod ;\n    dp [ i ] = ( dp [ i ] + dp [ i - 1 ] ) % mod ;\n  }\n  return dp [ len - 2 ] ;\n}\n",
        "reference_code": "    int firstDayBeenInAllRooms(vector<int>& nextVisit) {\n        int mod = 1e9 + 7;\n        int len = nextVisit.size();\n        vector<int> dp(len);\n        dp[0] = 2; \n        for (int i = 1; i < len; i++) {\n            int to = nextVisit[i];\n            dp[i] = 2 + dp[i - 1];\n            if (to != 0) {\n                dp[i] = (dp[i] - dp[to - 1] + mod) % mod; \n            }\n            dp[i] = (dp[i] + dp[i - 1]) % mod;\n        }\n        return dp[len - 2]; \n    }",
        "target_Lan": "cpp###firstDayBeenInAllRooms.cpp",
        "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    vector<int> nextVisit1 = {1, 2, 3, 4, 5};\n    cout << firstDayBeenInAllRooms(nextVisit1) << endl;\n\n    vector<int> nextVisit2 = {0, 0, 0, 0, 0};\n    cout << firstDayBeenInAllRooms(nextVisit2) << endl;\n\n    vector<int> nextVisit3 = {1, 0, 1, 0, 1};\n    cout << firstDayBeenInAllRooms(nextVisit3) << endl;\n\n    vector<int> nextVisit4 = {5, 4, 3, 2, 1};\n    cout << firstDayBeenInAllRooms(nextVisit4) << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###maxArrayValue_Test.java",
        "source_code": "    public static long maxArrayValue(int[] nums) {\n        long sum = nums[nums.length - 1];\n        for (int i = nums.length - 2; i >= 0; i--) {\n            sum = nums[i] <= sum ? nums[i] + sum : nums[i];\n        }\n        return sum;\n    }",
        "trans_code": "public : long long maxArrayValue ( vector < int > & nums ) {\n  long long sum = nums [ nums . size ( ) - 1 ] ;\n  for ( int i = nums . size ( ) - 2 ;\n  i >= 0 ;\n  i -- ) sum = nums [ i ] <= sum ? nums [ i ] + sum : nums [ i ] ;\n  return sum ;\n}\n",
        "reference_code": "    long long maxArrayValue(vector<int>& nums) {\n        long long sum = nums.back();\n        for (int i = nums.size() - 2; i >= 0; i--) {\n            sum = nums[i] <= sum ? nums[i] + sum : nums[i];\n        }\n        return sum;\n    }",
        "target_Lan": "cpp###maxArrayValue.cpp",
        "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    vector<int> nums1 = {1, 2, 3, 4, 5};\n    cout << maxArrayValue(nums1) << endl;\n\n    vector<int> nums2 = {5, 4, 3, 2, 1};\n    cout << maxArrayValue(nums2) << endl;\n\n    vector<int> nums3 = {-1, -2, -3, -4, -5};\n    cout << maxArrayValue(nums3) << endl;\n\n    vector<int> nums4 = {1000000, 2000000, 3000000, 4000000, 5000000};\n    cout << maxArrayValue(nums4) << endl;\n\n    vector<int> nums5 = {-1000000, -2000000, -3000000, -4000000, -5000000};\n    cout << maxArrayValue(nums5) << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###findKOr_Test.java",
        "source_code": "    public static int findKOr(int[] nums, int k) {\n        int ans = 0;\n        for (int i = 0; i < 31; ++i) {\n            int cnt = 0;\n            for (int num : nums) {\n                if (((num >> i) & 1) != 0) {\n                    ++cnt;\n                }\n            }\n            if (cnt >= k) {\n                ans |= 1 << i;\n            }\n        }\n        return ans;\n    }",
        "trans_code": "public : int findKOr ( vector < int > & nums , int k ) {\n  int ans = 0 ;\n  for ( int i = 0 ;\n  i < 31 ;\n  ++ i ) {\n    int cnt = 0 ;\n    for ( int num : nums ) {\n      if ( ( ( num >> i ) & 1 ) != 0 ) ++ cnt ;\n    }\n    if ( cnt >= k ) ans |= 1 << i ;\n  }\n  return ans ;\n}\n",
        "reference_code": "    int findKOr(vector<int>& nums, int k) {\n        int ans = 0;\n        for (int i = 0; i < 31; ++i) {\n            int cnt = 0;\n            for (int num: nums) {\n                if ((num >> i) & 1) {\n                    ++cnt;\n                }\n            }\n            if (cnt >= k) {\n                ans |= 1 << i;\n            }\n        }\n        return ans;\n    }",
        "target_Lan": "cpp###findKOr.cpp",
        "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    vector<int> nums1 = {1, 2, 3, 4, 5};\n    cout << findKOr(nums1, 3) << endl;\n\n    vector<int> nums2 = {10, 20, 30, 40, 50};\n    cout << findKOr(nums2, 2) << endl;\n\n    vector<int> nums3 = {-1, -2, -3, -4, -5};\n    cout << findKOr(nums3, 4) << endl;\n\n    vector<int> nums4 = {0, 0, 0, 0, 0};\n    cout << findKOr(nums4, 1) << endl;\n\n    vector<int> nums5 = {100, 200, 300, 400, 500};\n    cout << findKOr(nums5, 3) << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###maxNumberOfAlloys_Test.java",
        "source_code": "    public static int maxNumberOfAlloys(int n, int k, int budget, List<List<Integer>> composition, List<Integer> stock, List<Integer> cost) {\n        int left = 1, right = 200000000, ans = 0;\n        while (left <= right) {\n            int mid = (left + right) / 2;\n            boolean valid = false;\n            for (int i = 0; i < k; ++i) {\n                long spend = 0;\n                for (int j = 0; j < n; ++j) {\n                    spend += Math.max((long) composition.get(i).get(j) * mid - stock.get(j), 0) * cost.get(j);\n                }\n                if (spend <= budget) {\n                    valid = true;\n                    break;\n                }\n            }\n            if (valid) {\n                ans = mid;\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n        return ans;\n    }",
        "trans_code": "public : int maxNumberOfAlloys ( int n , int k , int budget , vector < vector < int >> & composition , vector < int > & stock , vector < int > & cost ) {\n  int left = 1 , right = 200000000 , ans = 0 ;\n  while ( left <= right ) {\n    int mid = ( left + right ) / 2 ;\n    bool valid = false ;\n    for ( int i = 0 ;\n    i < k ;\n    ++ i ) {\n      int64_t spend = 0 ;\n      for ( int j = 0 ;\n      j < n ;\n      ++ j ) {\n        spend += max ( ( int64_t ) composition [ i ] [ j ] * mid - stock [ j ] , 0 ) * cost [ j ] ;\n      }\n      if ( spend <= budget ) {\n        valid = true ;\n        break ;\n      }\n    }\n    if ( valid ) {\n      ans = mid ;\n      left = mid + 1 ;\n    }\n    else {\n      right = mid - 1 ;\n    }\n  }\n  return ans ;\n}\n",
        "reference_code": "    int maxNumberOfAlloys(int n, int k, int budget, vector<vector<int>>& composition, vector<int>& stock, vector<int>& cost) {\n        int left = 1, right = 2e8, ans = 0;\n        while (left <= right) {\n            int mid = (left + right) / 2;\n            bool valid = false;\n            for (int i = 0; i < k; ++i) {\n                long long spend = 0;\n                for (int j = 0; j < n; ++j) {\n                    spend += max(static_cast<long long>(composition[i][j]) * mid - stock[j], 0LL) * cost[j];\n                }\n                if (spend <= budget) {\n                    valid = true;\n                    break;\n                }\n            }\n            if (valid) {\n                ans = mid;\n                left = mid + 1;\n            }\n            else {\n                right = mid - 1;\n            }\n        }\n        return ans;\n    }",
        "target_Lan": "cpp###maxNumberOfAlloys.cpp",
        "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    vector<vector<int>> composition1 = {{10, 20, 30}, {20, 30, 40}};\n    vector<int> stock1 = {100, 100, 100};\n    vector<int> cost1 = {10, 20, 30};\n    cout << maxNumberOfAlloys(3, 2, 1000, composition1, stock1, cost1) << endl;\n\n    vector<vector<int>> composition2 = {{50, 60}, {70, 80}};\n    vector<int> stock2 = {100, 100};\n    vector<int> cost2 = {10, 20};\n    cout << maxNumberOfAlloys(2, 2, 500, composition2, stock2, cost2) << endl;\n\n    vector<vector<int>> composition3 = {{100}};\n    vector<int> stock3 = {100};\n    vector<int> cost3 = {10};\n    cout << maxNumberOfAlloys(1, 1, 200, composition3, stock3, cost3) << endl;\n\n    vector<vector<int>> composition4 = {{100, 200, 300}, {200, 300, 400}, {300, 400, 500}};\n    vector<int> stock4 = {100, 100, 100};\n    vector<int> cost4 = {10, 20, 30};\n    cout << maxNumberOfAlloys(3, 3, 3000, composition4, stock4, cost4) << endl;\n\n    vector<vector<int>> composition5 = {{200, 300}, {300, 400}};\n    vector<int> stock5 = {100, 100};\n    vector<int> cost5 = {10, 20};\n    cout << maxNumberOfAlloys(2, 2, 1000, composition5, stock5, cost5) << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###maximumSumOfHeights_Test.java",
        "source_code": "    public static long maximumSumOfHeights(List<Integer> maxHeights) {\n        int n = maxHeights.size();\n        long res = 0;\n        for (int i = 0; i < n; i++) {\n            int pre = maxHeights.get(i);\n            long sum = pre;\n            for (int j = i - 1; j >= 0; j--) {\n                pre = Math.min(pre, maxHeights.get(j));\n                sum += pre;\n            }\n            int suf = maxHeights.get(i);\n            for (int j = i + 1; j < n; j++) {\n                suf = Math.min(suf, maxHeights.get(j));\n                sum += suf;\n            }\n            res = Math.max(res, sum);\n        }\n        return res;\n    }",
        "trans_code": "public : long long maximumSumOfHeights ( vector < int > & maxHeights ) {\n  int n = maxHeights . size ( ) ;\n  long long res = 0 ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    int pre = maxHeights [ i ] ;\n    long long sum = pre ;\n    for ( int j = i - 1 ;\n    j >= 0 ;\n    j -- ) {\n      pre = min ( pre , maxHeights [ j ] ) ;\n      sum += pre ;\n    }\n    int suf = maxHeights [ i ] ;\n    for ( int j = i + 1 ;\n    j < n ;\n    j ++ ) {\n      suf = min ( suf , maxHeights [ j ] ) ;\n      sum += suf ;\n    }\n    res = max ( res , sum ) ;\n  }\n  return res ;\n}\n",
        "reference_code": "    long long maximumSumOfHeights(vector<int>& maxHeights) {\n        int n = maxHeights.size();\n        long long res = 0;\n        for (int i = 0; i < n; i++) {\n            int pre = maxHeights[i];\n            long long sum = pre;\n            for (int j = i - 1; j >= 0; j--) {\n                pre = min(pre, maxHeights[j]);\n                sum += pre;\n            }\n            int suf = maxHeights[i];\n            for (int j = i + 1; j < n; j++) {\n                suf = min(suf, maxHeights[j]);\n                sum += suf;\n            }\n            res = max(res, sum);\n        }\n        return res;\n    }",
        "target_Lan": "cpp###maximumSumOfHeights.cpp",
        "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    vector<int> maxHeights1 = {1, 2, 3, 4, 5};\n    vector<int> maxHeights2 = {5, 4, 3, 2, 1};\n    vector<int> maxHeights3 = {1, 1, 1, 1, 1};\n    vector<int> maxHeights4 = {100, 200, 300, 400, 500};\n    vector<int> maxHeights5 = {10, 20, 30, 40, 50};\n\n    cout << maximumSumOfHeights(maxHeights1) << endl;\n    cout << maximumSumOfHeights(maxHeights2) << endl;\n    cout << maximumSumOfHeights(maxHeights3) << endl;\n    cout << maximumSumOfHeights(maxHeights4) << endl;\n    cout << maximumSumOfHeights(maxHeights5) << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###alternatingSubarray_Test.java",
        "source_code": "    public static int alternatingSubarray(int[] nums) {\n        int res = -1;\n        int n = nums.length;\n        for (int firstIndex = 0; firstIndex < n; firstIndex++) {\n            for (int i = firstIndex + 1; i < n; i++) {\n                int length = i - firstIndex + 1;\n                if (nums[i] - nums[firstIndex] == (length - 1) % 2) {\n                    res = Math.max(res, length);\n                } else {\n                    break;\n                }\n            }\n        }\n        return res;\n    }",
        "trans_code": "public : int alternatingSubarray ( vector < int > & nums ) {\n  int res = - 1 ;\n  int n = nums . size ( ) ;\n  for ( int firstIndex = 0 ;\n  firstIndex < n ;\n  firstIndex ++ ) {\n    for ( int i = firstIndex + 1 ;\n    i < n ;\n    i ++ ) {\n      int length = i - firstIndex + 1 ;\n      if ( nums [ i ] - nums [ firstIndex ] == ( length - 1 ) % 2 ) {\n        res = max ( res , length ) ;\n      }\n      else {\n        break ;\n      }\n    }\n  }\n  return res ;\n}\n",
        "reference_code": "    int alternatingSubarray(vector<int>& nums) {\n        int res = -1;\n        int n = nums.size();\n        for (int firstIndex = 0; firstIndex < n; firstIndex++) {\n            for (int i = firstIndex + 1; i < n; i++) {\n                int length = i - firstIndex + 1;\n                if (nums[i] - nums[firstIndex] == (length - 1) % 2) {\n                    res = max(res, length);\n                } else {\n                    break;\n                }\n            }\n        }\n        return res;\n    }",
        "target_Lan": "cpp###alternatingSubarray.cpp",
        "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    vector<int> nums1 = {1, 2, 3, 4, 5};\n    cout << alternatingSubarray(nums1) << endl;\n\n    vector<int> nums2 = {1, 3, 5, 7, 9};\n    cout << alternatingSubarray(nums2) << endl;\n\n    vector<int> nums3 = {2, 4, 6, 8, 10};\n    cout << alternatingSubarray(nums3) << endl;\n\n    vector<int> nums4 = {1, 1, 1, 1, 1};\n    cout << alternatingSubarray(nums4) << endl;\n\n    vector<int> nums5 = {2, 3, 5, 7, 11};\n    cout << alternatingSubarray(nums5) << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###maximumRows_Test.java",
        "source_code": "    public static int maximumRows(int[][] matrix, int numSelect) {\n        int m = matrix.length;\n        int n = matrix[0].length;\n        int[] mask = new int[m];\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++){\n                mask[i] += matrix[i][j] << (n - j - 1);\n            }\n        }\n        int res = 0;\n        int cur = 0;\n        int limit = (1 << n);\n        while (++cur < limit) {\n            if (Integer.bitCount(cur) != numSelect) {\n                continue;\n            }\n            int t = 0;\n            for (int j = 0; j < m; j++) {\n                if ((mask[j] & cur) == mask[j]) {\n                    ++t;\n                }\n            }\n            res = Math.max(res, t);\n        }\n        return res;\n    }",
        "trans_code": "public : int maximumRows ( vector < vector < int >> & matrix , int numSelect ) {\n  int m = matrix . size ( ) ;\n  int n = matrix [ 0 ] . size ( ) ;\n  vector < int > mask ( m , 0 ) ;\n  for ( int i = 0 ;\n  i < m ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < n ;\n    j ++ ) {\n      mask [ i ] += matrix [ i ] [ j ] << ( n - j - 1 ) ;\n    }\n  }\n  int res = 0 ;\n  int cur = 0 ;\n  int limit = ( 1 << n ) ;\n  while ( ++ cur < limit ) {\n    if ( static_cast < int > ( cur ) != numSelect ) {\n      continue ;\n    }\n    int t = 0 ;\n    for ( int j = 0 ;\n    j < m ;\n    j ++ ) {\n      if ( ( mask [ j ] & cur ) == mask [ j ] ) {\n        ++ t ;\n      }\n    }\n    res = max ( res , t ) ;\n  }\n  return res ;\n}\n",
        "reference_code": "    int maximumRows(vector<vector<int>>& matrix, int numSelect) {\n        int m = matrix.size();\n        int n = matrix[0].size();\n        vector<int> mask(m, 0);\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++){\n                mask[i] += matrix[i][j] << (n - j - 1);\n            }\n        }\n        int res = 0;\n        int cur = 0;\n        int limit = (1 << n);\n        while ((++cur) < limit) {\n            if (__builtin_popcount(cur) != numSelect) {\n                continue;\n            }\n            int t = 0;\n            for (int j = 0; j < m; j++) {\n                if ((mask[j] & cur) == mask[j]) {\n                    ++t;\n                }\n            }\n            res = max(res, t);\n        }\n        return res;\n    }",
        "target_Lan": "cpp###maximumRows.cpp",
        "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    vector<vector<int>> matrix1 = {{1,0,0,1},{0,1,1,0},{1,0,1,0}};\n    int numSelect1 = 2;\n    cout << maximumRows(matrix1, numSelect1) << endl;\n\n    vector<vector<int>> matrix2 = {{1,1,1,1},{1,1,1,1},{1,1,1,1}};\n    int numSelect2 = 3;\n    cout << maximumRows(matrix2, numSelect2) << endl;\n\n    vector<vector<int>> matrix3 = {{0,0,0,0},{0,0,0,0},{0,0,0,0}};\n    int numSelect3 = 1;\n    cout << maximumRows(matrix3, numSelect3) << endl;\n\n    vector<vector<int>> matrix4 = {{1,0,1,0},{0,1,0,1},{1,0,1,0}};\n    int numSelect4 = 4;\n    cout << maximumRows(matrix4, numSelect4) << endl;\n\n    vector<vector<int>> matrix5 = {{1,1,1,1},{0,0,0,0},{1,1,1,1}};\n    int numSelect5 = 2;\n    cout << maximumRows(matrix5, numSelect5) << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###findGoodPairs_Test.java",
        "source_code": "    static long findGoodPairs(int a[], int n, int k){\n        \n        long ans = 0;\n        Map<Integer, Integer> hm = new HashMap<>();\n        for(int i = k; i < n; i++){\n            hm.put(a[i - k], hm.getOrDefault(a[i - k], 0) + 1);\n            ans += hm.getOrDefault(a[i], 0);\n        }\n        return ans;\n    }",
        "trans_code": "long long findGoodPairs ( int a [ ] , int n , int k ) {\n  long long ans = 0 ;\n  map < int , int > hm ;\n  for ( int i = k ;\n  i < n ;\n  i ++ ) {\n    hm [ a [ i - k ] ] = hm . find ( a [ i - k ] ) -> second + 1 ;\n    ans += hm . find ( a [ i ] ) -> second ;\n  }\n  return ans ;\n}\n",
        "reference_code": "    long long findGoodPairs(vector<int> a, int n, int k) {\n        map<int, int > ma;\n        long long ans = 0;\n        for (int i = k; i < n; i++) {\n            ma[a[i - k]]++;\n            ans += ma[a[i]];\n        }\n        return ans;\n    }",
        "target_Lan": "cpp###findGoodPairs.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <map>\n// TOFILL\nint main() {\n    cout << findGoodPairs({1,2,3,4,5}, 5, 2) << endl;\n    cout << findGoodPairs({1,1,1,1,1}, 5, 1) << endl;\n    cout << findGoodPairs({1,2,3,4,5,6,7,8,9,10}, 10, 5) << endl;\n    cout << findGoodPairs({10,20,30,40,50}, 5, 1) << endl;\n    cout << findGoodPairs({1,2,3,4,5,6,7,8,9,10}, 10, 10) << endl;\n    return 0;\n}"
    },
    {
        "source_Lan": "java###collectingCoins_Test.java",
        "source_code": "    public static int collectingCoins(int N, int[][] Coins) {\n        Map<Integer, Integer> hor = new HashMap<>(); \n        Map<Integer, Integer> ver = new HashMap<>(); \n        Map<Integer, Integer> diaa = new HashMap<>(); \n        Map<Integer, Integer> diab = new HashMap<>(); \n        int m = 0; \n            \n            for (int[] el : Coins) {\n                int a = el[0], b = el[1];\n                hor.put(a, hor.getOrDefault(a, 0) + 1); \n                ver.put(b, ver.getOrDefault(b, 0) + 1); \n                diaa.put(a + b, diaa.getOrDefault(a + b, 0) + 1); \n                diab.put(a - b, diab.getOrDefault(a - b, 0) + 1); \n                \n                m = Math.max(m, hor.get(a));\n                m = Math.max(m, ver.get(b));\n                m = Math.max(m, diaa.get(a + b));\n                m = Math.max(m, diab.get(a - b));\n            }\n            return m; \n    }",
        "trans_code": "public : int collectingCoins ( int N , vector < vector < int >> & Coins ) {\n  map < int , int > hor ;\n  map < int , int > ver ;\n  map < int , int > diaa ;\n  map < int , int > diab ;\n  int m = 0 ;\n  for ( auto & el : Coins ) {\n    int a = el [ 0 ] , b = el [ 1 ] ;\n    hor [ a ] = hor . at ( a ) + 1 ;\n    ver [ b ] = ver . at ( b ) + 1 ;\n    diaa [ a + b ] = diaa . at ( a + b ) + 1 ;\n    diab [ a - b ] = diab . at ( a - b ) + 1 ;\n    m = max ( m , hor . at ( a ) ) ;\n    m = max ( m , ver . at ( b ) ) ;\n    m = max ( m , diaa . at ( a + b ) ) ;\n    m = max ( m , diab . at ( a - b ) ) ;\n  }\n  return m ;\n}\n",
        "reference_code": "    int collectingCoins(int N, std::vector<std::vector<int>>& Coins)\n    {\n        \n        \n        unordered_map<int, int> hor,ver,diaa,diab;\n        int m = 0;\n        \n        for (auto& el : Coins)\n        {\n            \n            int a = el[0];\n            int b = el[1];\n            \n            \n            hor[a]++;\n            ver[b]++;\n            diaa[a + b]++;\n            diab[a - b]++;\n            \n            m = max(m, hor[a]);\n            m = max(m, ver[b]);\n            m = max(m, diaa[a + b]);\n            m = max(m, diab[a - b]);\n        }\n        \n        return m;\n    }",
        "target_Lan": "cpp###collectingCoins.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    vector<vector<int>> Coins1 = {};\n    cout << collectingCoins(0, Coins1) << endl;\n\n    vector<vector<int>> Coins2 = {{1,1}};\n    cout << collectingCoins(1, Coins2) << endl;\n\n    vector<vector<int>> Coins3 = {{1,1},{2,2}};\n    cout << collectingCoins(2, Coins3) << endl;\n\n    vector<vector<int>> Coins4 = {{1,1},{2,2},{3,3}};\n    cout << collectingCoins(3, Coins4) << endl;\n\n    vector<vector<int>> Coins5 = {{1,1},{2,2},{3,3},{4,4}};\n    cout << collectingCoins(4, Coins5) << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###trafficLights_Test.java",
        "source_code": "    public static String trafficLights(int n, int q, int[][] queries) {\n        int[] darr = new int[n + 1];\n        for (int[] Q : queries) {\n            int a = Q[0];\n            int b = Q[1];\n            darr[a - 1]++;\n            darr[b]--;\n        }\n        Arrays.parallelPrefix(darr, (A, B) -> A + B);\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < n; i++) {\n            int X = darr[i] % 3;\n            if (X == 0)\n                sb.append(\"R\");\n            else if (X == 1)\n                sb.append(\"Y\");\n            else if (X == 2)\n                sb.append(\"G\");\n        }\n        return sb.toString();\n    }",
        "trans_code": "string trafficLights ( int n , int q , vector < vector < int >> & queries ) {\n  vector < int > darr ( n + 1 , 0 ) ;\n  for ( vector < int > :: iterator Q = queries . begin ( ) ;\n  Q != queries . end ( ) ;\n  Q ++ ) {\n    int a = * Q ;\n    int b = * Q ;\n    darr [ a - 1 ] ++ ;\n    darr [ b ] -- ;\n  }\n  vector < string > result ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    int X = darr [ i ] % 3 ;\n    if ( X == 0 ) {\n      result [ i ] = \"R\" ;\n    }\n    else if ( X == 1 ) {\n      result [ i ] = \"Y\" ;\n    }\n    else if ( X == 2 ) {\n      result [ i ] = \"G\" ;\n    }\n  }\n  return result ;\n}\n",
        "reference_code": "    string trafficLights(int n, int q, vector<vector<int>>& queries) {\n        \n        vector<int> darr(n + 1, 0);\n        for (vector<int>& Q : queries) {\n            int a = Q[0];\n            int b = Q[1];\n            darr[a - 1]++;\n            darr[b]--;\n        }\n        partial_sum(darr.begin(), darr.end(), darr.begin());\n        string result = \"\";\n        for (int i = 0; i < n; i++) {\n            int X = darr[i] % 3;\n            if (X == 0)\n                result += \"R\";\n            else if (X == 1)\n                result += \"Y\";\n            else if (X == 2)\n                result += \"G\";\n        }\n        return result;\n    }",
        "target_Lan": "cpp###trafficLights.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <numeric>\n// TOFILL\nint main() {\n    vector<vector<int>> queries1 = {{1,2},{2,3}};\n    cout << trafficLights(3, 2, queries1) << endl;\n\n    vector<vector<int>> queries2 = {{1,2},{3,5},{2,4}};\n    cout << trafficLights(5, 3, queries2) << endl;\n\n    vector<vector<int>> queries3 = {{1,1}};\n    cout << trafficLights(1, 1, queries3) << endl;\n\n    vector<vector<int>> queries4 = {};\n    cout << trafficLights(0, 0, queries4) << endl;\n\n    vector<vector<int>> queries5 = {{1,10},{2,9},{3,8},{4,7},{5,6},{1,5},{2,6},{3,7},{4,8},{5,9}};\n    cout << trafficLights(10, 10, queries5) << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###BeautifulBits_Test.java",
        "source_code": "    public static ArrayList<Integer> BeautifulBits(int n, int[] arr, int q,\n                                                   int[][] queries) {\n        long[][] pref = new long[n + 1][32];\n        for (int i = 1; i <= n; i++) {\n            for (int j = 0; j < 32; j++) {\n                pref[i][j] = pref[i - 1][j] + ((arr[i - 1] >> j) & 1);\n            }\n        }\n        ArrayList<Integer> ans = new ArrayList<>(Collections.nCopies(q, 0));\n        for (int i = 0; i < q; i++) {\n            for (int j = 0; j < 32; j++) {\n                if (pref[queries[i][1]][j] - pref[queries[i][0] - 1][j] != 0) {\n                    ans.set(i, ans.get(i) + (1 << j));\n                }\n            }\n        }\n        return ans;\n    }",
        "trans_code": "vector < int > BeautifulBits ( int n , vector < int > arr , int q , vector < vector < int >> queries ) {\n  uint32_t pref [ n + 1 ] [ 32 ] ;\n  for ( int i = 1 ;\n  i <= n ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < 32 ;\n    j ++ ) {\n      pref [ i ] [ j ] = pref [ i - 1 ] [ j ] + ( ( arr [ i - 1 ] >> j ) & 1 ) ;\n    }\n  }\n  vector < int > ans ( std :: nth_element ( q , q + 1 ) , 0 ) ;\n  for ( int i = 0 ;\n  i < q ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < 32 ;\n    j ++ ) {\n      if ( pref [ queries [ i ] [ 1 ] ] [ j ] - pref [ queries [ i ] [ 0 ] - 1 ] [ j ] != 0 ) {\n        ans [ i ] = ans [ i ] + ( 1 << j ) ;\n      }\n    }\n  }\n  return ans ;\n}\n",
        "reference_code": "    vector<int> BeautifulBits(int n, vector<int> &arr, int q,\n                              vector<vector<int> > &queries) {\n        vector<vector<long long> > pref(n + 1, vector<long long>(32, 0));\n        for (int i = 1; i <= n; i++) {\n            for (int j = 0; j < 32; j++) {\n                pref[i][j] = pref[i - 1][j] + ((arr[i - 1] >> j) & 1);\n            }\n        }\n        vector<int> ans(q, 0);\n        for (int i = 0; i < q; i++) {\n            for (int j = 0; j < 32; j++) {\n                if (pref[queries[i][1]][j] - pref[queries[i][0] - 1][j] != 0) {\n                    ans[i] += 1 << j;\n                }\n            }\n        }\n        return ans;\n    }",
        "target_Lan": "cpp###BeautifulBits.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    int n1 = 5, q1 = 2;\n    vector<int> arr1 = {1, 2, 3, 4, 5};\n    vector<vector<int> > queries1 = {{1, 3}, {2, 4}};\n    vector<int> ans1 = BeautifulBits(n1, arr1, q1, queries1);\n    for(int i = 0; i < ans1.size(); i++) {\n        cout << ans1[i] << \" \";\n    }\n    cout << endl;\n\n    int n2 = 10, q2 = 3;\n    vector<int> arr2 = {10, 20, 30, 40, 50, 60, 70, 80, 90, 100};\n    vector<vector<int> > queries2 = {{1, 5}, {6, 10}, {3, 8}};\n    vector<int> ans2 = BeautifulBits(n2, arr2, q2, queries2);\n    for(int i = 0; i < ans2.size(); i++) {\n        cout << ans2[i] << \" \";\n    }\n    cout << endl;\n\n    int n3 = 0, q3 = 0;\n    vector<int> arr3 = {};\n    vector<vector<int> > queries3 = {};\n    vector<int> ans3 = BeautifulBits(n3, arr3, q3, queries3);\n    for(int i = 0; i < ans3.size(); i++) {\n        cout << ans3[i] << \" \";\n    }\n    cout << endl;\n\n    int n4 = 1, q4 = 1;\n    vector<int> arr4 = {1};\n    vector<vector<int> > queries4 = {{1, 1}};\n    vector<int> ans4 = BeautifulBits(n4, arr4, q4, queries4);\n    for(int i = 0; i < ans4.size(); i++) {\n        cout << ans4[i] << \" \";\n    }\n    cout << endl;\n\n    int n5 = 2, q5 = 1;\n    vector<int> arr5 = {1, 3};\n    vector<vector<int> > queries5 = {{1, 2}};\n    vector<int> ans5 = BeautifulBits(n5, arr5, q5, queries5);\n    for(int i = 0; i < ans5.size(); i++) {\n        cout << ans5[i] << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###ForYou_Test.java",
        "source_code": "    public static long ForYou(int n, int[] arr, int m, int[][] order) {\n        \n        int[] diff = new int[n + 1];\n        \n        for (int[] it : order) {\n            diff[it[0] - 1]++;\n            diff[it[1]]--;\n        }\n        \n        for (int i = 1; i <= n; i++) {\n            diff[i] += diff[i - 1];\n        }\n        \n        diff = Arrays.copyOf(diff, n);\n        Arrays.sort(diff);\n        \n        Arrays.sort(arr);\n        long ans = 0;\n        int mod = (int)1e9 + 7;\n        \n        for (int i = 0; i < n; i++) {\n            ans += ((long)diff[i]) * ((long)arr[i]);\n            ans %= mod;\n        }\n        return ans;\n    }",
        "trans_code": "long long ForYou ( int n , int * arr , int m , vector < vector < int >> & order ) {\n  vector < int > diff ( n + 1 , 0 ) ;\n  for ( auto it : order ) {\n    diff [ it [ 0 ] - 1 ] ++ ;\n    diff [ it [ 1 ] ] -- ;\n  }\n  for ( int i = 1 ;\n  i <= n ;\n  i ++ ) diff [ i ] += diff [ i - 1 ] ;\n  diff = vector < int > ( diff . begin ( ) , diff . end ( ) ) ;\n  sort ( diff . begin ( ) , diff . end ( ) ) ;\n  sort ( arr . begin ( ) , arr . end ( ) ) ;\n  long long ans = 0 ;\n  int mod = ( int ) 1e9 + 7 ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    ans += ( ( long long ) diff [ i ] ) * ( ( long long ) arr [ i ] ) ;\n    ans %= mod ;\n  }\n  return ans ;\n}\n",
        "reference_code": "    long long ForYou(int n, vector<int> &arr, int m, vector<vector<int> > &order)\n    {\n        vector<int> diff(n+1,0);\n        for(auto it:order)\n        {\n            diff[it[0]-1]++;\n            diff[it[1]]--;\n        }\n        for(int i=1;i<=n;i++)\n        {\n            diff[i] += diff[i-1];\n        }\n        diff.pop_back();\n        sort(diff.begin(),diff.end());\n        sort(arr.begin(),arr.end());\n        long long ans=0;\n        int mod = 1e9+7;\n        for(int i=0;i<n;i++)\n        {\n            ans += (1ll * diff[i]) * (1ll * arr[i]);\n            ans%=mod;\n        }\n        return ans;\n    }",
        "target_Lan": "cpp###ForYou.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <algorithm>\n// TOFILL\nint main() {\n    int n1 = 5, m1 = 3;\n    vector<int> arr1 = {1, 2, 3, 4, 5};\n    vector<vector<int> > order1 = {{1, 3}, {2, 4}, {1, 5}};\n    cout << ForYou(n1, arr1, m1, order1) << endl;\n\n    int n2 = 3, m2 = 2;\n    vector<int> arr2 = {10, 20, 30};\n    vector<vector<int> > order2 = {{1, 2}, {2, 3}};\n    cout << ForYou(n2, arr2, m2, order2) << endl;\n\n    int n3 = 4, m3 = 4;\n    vector<int> arr3 = {5, 10, 15, 20};\n    vector<vector<int> > order3 = {{1, 4}, {2, 3}, {3, 4}, {1, 2}};\n    cout << ForYou(n3, arr3, m3, order3) << endl;\n\n    int n4 = 2, m4 = 1;\n    vector<int> arr4 = {100, 200};\n    vector<vector<int> > order4 = {{1, 2}};\n    cout << ForYou(n4, arr4, m4, order4) << endl;\n\n    int n5 = 1, m5 = 0;\n    vector<int> arr5 = {1000};\n    vector<vector<int> > order5 = {};\n    cout << ForYou(n5, arr5, m5, order5) << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###validStrings_Test.java",
        "source_code": "    public static int validStrings(int n, int k, String[] arr) \n    {\n        int totalValid = 0;\n        for (String str : arr) {\n            int vowelCount = 0;\n            for (char ch : str.toCharArray()) {\n                if (\"aeiou\".indexOf(ch) >= 0) {\n                    vowelCount++;\n                }\n            }\n            if (vowelCount == k) {\n                totalValid++;\n            }\n        }\n        return totalValid;\n    }",
        "trans_code": "public : int validStrings ( int n , int k , vector < string > arr ) {\n  int totalValid = 0 ;\n  for ( string str : arr ) {\n    int vowelCount = 0 ;\n    for ( char ch : str ) {\n      if ( \"aeiou\" . find ( ch ) >= 0 ) vowelCount ++ ;\n    }\n    if ( vowelCount == k ) totalValid ++ ;\n  }\n  return totalValid ;\n}\n",
        "reference_code": "    int validStrings(int n, int k, vector<string> &arr) {\n        int tot=0;\n        for (auto j:arr){\n            int c=0;\n            for (auto q:j){\n                if (q=='a'||q=='e'||q=='i'||q=='o'||q=='u') c+=1;\n            }\n            if (c==k) tot+=1;\n        }\n        return tot;\n    }",
        "target_Lan": "cpp###validStrings.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <string>\n// TOFILL\nint main() {\n    vector<string> arr1 = {};\n    cout << validStrings(0, 0, arr1) << endl;\n\n    vector<string> arr2 = {\"a\"};\n    cout << validStrings(1, 1, arr2) << endl;\n\n    vector<string> arr3 = {\"ae\", \"io\"};\n    cout << validStrings(2, 2, arr3) << endl;\n\n    vector<string> arr4 = {\"aei\", \"ou\", \"u\"};\n    cout << validStrings(3, 3, arr4) << endl;\n\n    vector<string> arr5 = {\"aeio\", \"u\", \"u\", \"u\"};\n    cout << validStrings(4, 4, arr5) << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###maximumBattalions_Test.java",
        "source_code": "    public static int maximumBattalions(int N, String[] names) \n    {\n        Map<String, Integer> nameIndexMap = new HashMap<>();\n        for (int i = 0; i < N; i++) \n        {\n            nameIndexMap.put(names[i], i);\n        }\n        int answer = 0;\n        int maxi = 0;\n        int ind = 0;\n        for (String name : names) \n        {\n            maxi = Math.max(maxi, nameIndexMap.get(name));\n            if (maxi == ind) \n            {\n                answer++;\n            }\n            ind++;\n        }\n        return answer;\n    }",
        "trans_code": "public : int maximumBattalions ( int N , string names [ ] ) {\n  map < string , int > name_index_map ;\n  for ( int i = 0 ;\n  i < N ;\n  i ++ ) name_index_map [ names [ i ] ] = i ;\n  int answer = 0 ;\n  int maxi = 0 ;\n  int ind = 0 ;\n  for ( int i = 0 ;\n  i < N ;\n  i ++ ) {\n    maxi = max ( maxi , name_index_map [ names [ i ] ] ) ;\n    if ( maxi == ind ) answer ++ ;\n    ind ++ ;\n  }\n  return answer ;\n}\n",
        "reference_code": "    int maximumBattalions(int N, vector<string> &names) {\n        unordered_map<string, int> m;\n        for(int i = 0; i < N; i++){\n            m[names[i]] = i;\n        }\n        int answer = 0;\n        int maxi = 0;\n        int ind = 0;\n        for(auto i : names){\n            maxi = max(maxi, m[i]);\n            if(maxi == ind){\n                answer += 1;\n            }\n            ind += 1;\n        }\n        return answer;\n    }",
        "target_Lan": "cpp###maximumBattalions.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n// TOFILL\nint main() {\n    int N = 0;\n    vector<string> names = {};\n    cout << maximumBattalions(N, names) << endl;\n\n    N = 1;\n    names = {\"John\"};\n    cout << maximumBattalions(N, names) << endl;\n\n    N = 2;\n    names = {\"John\", \"John\"};\n    cout << maximumBattalions(N, names) << endl;\n\n    N = 3;\n    names = {\"John\", \"Doe\", \"John\"};\n    cout << maximumBattalions(N, names) << endl;\n\n    N = 5;\n    names = {\"John\", \"Doe\", \"John\", \"Doe\", \"John\"};\n    cout << maximumBattalions(N, names) << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###MaximumEnergy_Test.java",
        "source_code": "    public static int MaximumEnergy(int N, int[] E, int K, int[] P) \n    {\n        Arrays.sort(P);\n        long mod = 1000000007;\n        long[] ps = new long[N + 1];\n        long ans = 0;\n        long s = 0;\n        for (int i = 0; i < N; i++) \n        {\n            s += E[i];\n            s %= mod;\n            ps[i + 1] =  s;\n        }\n        for (int i = 0; i < K / 2; i++) {\n            long a = ps[P[i]];\n            long b = ps[P[K - i - 1] + 1];\n            ans += (b - a + mod) % mod;\n            ans %= mod;\n        }\n        return (int) ans;\n    }",
        "trans_code": "int MaximumEnergy ( int N , vector < int > E , int K , vector < int > P ) {\n  sort ( P . begin ( ) , P . end ( ) ) ;\n  long long mod = 1000000007 ;\n  vector < long long > ps ( N + 1 , 0 ) ;\n  long long ans = 0 ;\n  long long s = 0 ;\n  for ( int i = 0 ;\n  i < N ;\n  i ++ ) {\n    s += E [ i ] ;\n    s %= mod ;\n    ps [ i + 1 ] = s ;\n  }\n  for ( int i = 0 ;\n  i < K / 2 ;\n  i ++ ) {\n    long long a = ps [ P [ i ] ] ;\n    long long b = ps [ P [ K - i - 1 ] + 1 ] ;\n    ans += ( b - a + mod ) % mod ;\n    ans %= mod ;\n  }\n  return ( int ) ans ;\n}\n",
        "reference_code": "    int MaximumEnergy(int N, vector<int> &E, int K, vector<int> &P) {\n        \n        sort(P.begin(),P.end());\n        long long mod = 1e9+7;\n        vector<int> ps(N+1);\n        long long ans = 0;\n        long long s = 0;\n        for(int i=0;i<N;i++){\n            s+=E[i];\n            s%=mod;\n            ps[i+1] = s;\n        }\n        for(int i=0;i<K/2;i++){\n            long long a = ps[P[i]];\n            long long b = ps[P[K-i-1]+1];\n            ans+=(b-a+mod);\n            ans%=mod;\n        }\n        return ans;\n    }",
        "target_Lan": "cpp###MaximumEnergy.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <algorithm>\n// TOFILL\nint main() {\n    int N = 0;\n    vector<int> E = {};\n    int K = 0;\n    vector<int> P = {};\n    cout << MaximumEnergy(N, E, K, P) << endl;\n\n    N = 1;\n    E = {1000000000};\n    K = 1;\n    P = {0};\n    cout << MaximumEnergy(N, E, K, P) << endl;\n\n    N = 2;\n    E = {1000000000, 1000000000};\n    K = 2;\n    P = {0, 1};\n    cout << MaximumEnergy(N, E, K, P) << endl;\n\n    N = 3;\n    E = {1000000000, 1000000000, 1000000000};\n    K = 3;\n    P = {0, 1, 2};\n    cout << MaximumEnergy(N, E, K, P) << endl;\n\n    N = 4;\n    E = {1000000000, 1000000000, 1000000000, 1000000000};\n    K = 4;\n    P = {0, 1, 2, 3};\n    cout << MaximumEnergy(N, E, K, P) << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###minimumDis_Test.java",
        "source_code": "    public static int minimumDis(int N, int[] X) {\n        Arrays.sort(X);\n        return X[(N - 1) / 2];\n    }",
        "trans_code": "int minimumDis ( int N , vector < int > & X ) {\n  sort ( X . begin ( ) , X . end ( ) ) ;\n  return X [ ( N - 1 ) / 2 ] ;\n}\n",
        "reference_code": "    int minimumDis(int N, vector<int> X) {\n        sort(X.begin(), X.end());\n        return X[(N - 1) / 2];\n    }",
        "target_Lan": "cpp###minimumDis.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <algorithm>\n// TOFILL\nint main() {\n    cout << minimumDis(1, {1}) << endl;\n    cout << minimumDis(2, {1, 2}) << endl;\n    cout << minimumDis(3, {1, 2, 3}) << endl;\n    cout << minimumDis(4, {1, 2, 3, 4}) << endl;\n    return 0;\n}"
    },
    {
        "source_Lan": "java###matchingCnt_Test.java",
        "source_code": "    public static int[] matchingCnt(int n, String[] X) {\n        Map<Integer, int[]> map = new HashMap<>();\n        int[] ans = new int[n];\n        for (int i = n - 1; i >= 0; i--) {\n            String x = X[i];\n            int cans = 0;\n            for (int j = 0; j < x.length(); j++) {\n                if (!map.containsKey(j)) {\n                    map.put(j, new int[26]);\n                }\n                cans = cans + map.get(j)[x.charAt(j) - 'a'];\n                map.get(j)[x.charAt(j) - 'a']++;\n            }\n            ans[i] = cans;\n        }\n        return ans;\n    }",
        "trans_code": "public : vector < int > matchingCnt ( int n , vector < string > X ) {\n  map < int , vector < int >> map ;\n  vector < int > ans ;\n  for ( int i = n - 1 ;\n  i >= 0 ;\n  i -- ) {\n    string x = X [ i ] ;\n    int cans = 0 ;\n    for ( int j = 0 ;\n    j < x . length ( ) ;\n    j ++ ) {\n      if ( ! map . count ( j ) ) map [ j ] . resize ( 26 ) ;\n      cans = cans + map [ j ] [ x [ j ] - 'a' ] ;\n      map [ j ] [ x [ j ] - 'a' ] ++ ;\n    }\n    ans . push_back ( cans ) ;\n  }\n  return ans ;\n}\n",
        "reference_code": "    vector<int> matchingCnt(int n, vector<string>& X) {\n        unordered_map<int, array<int, 26>> map;\n        vector<int> ans(n);\n        for (int i = n - 1; i >= 0; i--) {\n            string x = X[i];\n            int cans = 0;\n            for (int j = 0; j < x.length(); j++) {\n                if (map.find(j) == map.end()) {\n                    map[j] = array<int, 26>{};\n                }\n                cans += map[j][x[j] - 'a'];\n                map[j][x[j] - 'a']++;\n            }\n            ans[i] = cans;\n        }\n        return ans;\n    }",
        "target_Lan": "cpp###matchingCnt.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <array>\n// TOFILL\nint main() {\n    vector<string> X1 = {};\n    vector<string> X2 = {\"a\"};\n    vector<string> X3 = {\"a\", \"b\"};\n    vector<string> X4 = {\"a\", \"b\", \"c\"};\n    vector<string> X5 = {\"a\", \"b\", \"c\", \"d\"};\n\n    vector<int> ans1 = matchingCnt(0, X1);\n    vector<int> ans2 = matchingCnt(1, X2);\n    vector<int> ans3 = matchingCnt(2, X3);\n    vector<int> ans4 = matchingCnt(3, X4);\n    vector<int> ans5 = matchingCnt(4, X5);\n\n    for(int i : ans1) cout << i << \" \";\n    cout << endl;\n    for(int i : ans2) cout << i << \" \";\n    cout << endl;\n    for(int i : ans3) cout << i << \" \";\n    cout << endl;\n    for(int i : ans4) cout << i << \" \";\n    cout << endl;\n    for(int i : ans5) cout << i << \" \";\n    cout << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###maxAlternatingSubstring_Test.java",
        "source_code": "    public static long maxAlternatingSubstring(int N, String S) {\n        List<Integer> diff = new ArrayList<>();\n        for (int i = 0; i < N;) {\n            int j = i + 1;\n            while (j < N && S.charAt(j) != S.charAt(j - 1)) j++;\n            diff.add(j - i);\n            i = j;\n        }\n        diff.add(0);\n        long ans_before = 0;\n        for (int x : diff) {\n            ans_before += ((x * 1L * (x + 1)) / 2);\n        }\n        long ans = 0;\n        for (int i = 0; i < diff.size() - 1; i++) {\n            long a = diff.get(i);\n            long b = diff.get(i + 1);\n            long currAns = ans_before - ((a * (a + 1)) / 2) - ((b * (b + 1)) / 2) +\n                           ((a + b + 1) * (a + b + 2)) / 2;\n            ans = Math.max(ans, currAns);\n        }\n        return ans;\n    }",
        "trans_code": "public : long long maxAlternatingSubstring ( int N , string S ) {\n  vector < int > diff ;\n  for ( int i = 0 ;\n  i < N ;\n  ) {\n    int j = i + 1 ;\n    while ( j < N && S [ j ] != S [ j - 1 ] ) {\n      j ++ ;\n    }\n    diff . push_back ( j - i ) ;\n    i = j ;\n  }\n  diff . push_back ( 0 ) ;\n  long long ans_before = 0 ;\n  for ( int x : diff ) ans_before += ( ( x * 1L * ( x + 1 ) ) / 2 ) ;\n  long long ans = 0 ;\n  for ( int i = 0 ;\n  i < diff . size ( ) - 1 ;\n  i ++ ) {\n    long long a = diff [ i ] ;\n    long long b = diff [ i + 1 ] ;\n    long long curr_ans = ans_before - ( ( a * ( a + 1 ) ) / 2 ) - ( ( b * ( b + 1 ) ) / 2 ) + ( ( a + b + 1 ) * ( a + b + 2 ) ) / 2 ;\n    ans = max ( ans , curr_ans ) ;\n  }\n  return ans ;\n}\n",
        "reference_code": "    long long maxAlternatingSubstring(int N, string S) {\n        vector<long long> diff;\n        for (int i = 0; i < N;) {\n            int j = i + 1;\n            while (j < N && S[j] != S[j - 1])\n                j++;\n            diff.push_back(j - i);\n            i = j;\n        }\n        diff.push_back(0);\n        long long ans_before = 0;\n        for (long long x : diff) {\n            ans_before += ((x * (x + 1)) / 2);\n        }\n        long long ans = 0;\n        for (int i = 0; i < diff.size() - 1; ++i) {\n            long long a = diff[i];\n            long long b = diff[i + 1];\n            long long currAns = ans_before - ((a * (a + 1)) / 2) - ((b * (b + 1)) / 2) +\n                                ((a + b + 1) * (a + b + 2)) / 2;\n            ans = max(ans, currAns);\n        }\n        return ans;\n    }",
        "target_Lan": "cpp###maxAlternatingSubstring.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <string>\n#include <vector>\n// TOFILL\nint main() {\n    cout << maxAlternatingSubstring(0, \"\") << endl;\n    cout << maxAlternatingSubstring(1, \"a\") << endl;\n    cout << maxAlternatingSubstring(2, \"aa\") << endl;\n    cout << maxAlternatingSubstring(3, \"aba\") << endl;\n    cout << maxAlternatingSubstring(5, \"ababa\") << endl;\n    return 0;\n}"
    },
    {
        "source_Lan": "java###countSuperPalindrome_Test.java",
        "source_code": "    public static int countSuperPalindrome(int l, int r) {\n        int count = 0;\n        \n        int start = (int)Math.ceil(Math.sqrt(l));\n        \n        while (start * start <= r) {\n            \n            int square = start * start;\n            String s = Integer.toString(square);\n            \n            if (s.equals(new StringBuilder(s).reverse().toString())) {\n                count++;\n            }\n            start++;\n        }\n        return count;\n    }",
        "trans_code": "public : int countSuperPalindrome ( int l , int r ) {\n  int count = 0 ;\n  int start = ( int ) ceil ( sqrt ( l ) ) ;\n  while ( start * start <= r ) {\n    int square = start * start ;\n    string s = to_string ( square ) ;\n    if ( s == string ( s . reverse ( ) . begin ( ) , s . reverse ( ) . end ( ) ) ) count ++ ;\n    start ++ ;\n  }\n  return count ;\n}\n",
        "reference_code": "    int countSuperPalindrome(int l, int r) {\n        int count = 0;\n        \n        int start = static_cast<int>(ceil(sqrt(l)));\n        \n        while (start * start <= r) {\n            \n            int square = start * start;\n            string s = to_string(square);\n            \n            if (s == string(s.rbegin(), s.rend())) {\n                count++;\n            }\n            start++;\n        }\n        return count;\n    }",
        "target_Lan": "cpp###countSuperPalindrome.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <cmath>\n#include <string>\n// TOFILL\nint main() {\n    cout << countSuperPalindrome(0, 10) << endl;\n    cout << countSuperPalindrome(100, 1000) << endl;\n    cout << countSuperPalindrome(-10, 10) << endl;\n    cout << countSuperPalindrome(10000, 100000) << endl;\n    cout << countSuperPalindrome(50000, 60000) << endl;\n}"
    },
    {
        "source_Lan": "java###candyShop2_Test.java",
        "source_code": "    public static int candyShop2(int n, int[] candies) {\n        int ans = 0;\n        Set<Integer> hs = new HashSet<>();\n        for(int x : candies)\n            if(hs.add(x))\n                ans += x;\n        return ans;\n    }",
        "trans_code": "public : int candyShop2 ( int n , vector < int > & candies ) {\n  int ans = 0 ;\n  set < int > hs ;\n  for ( auto x : candies ) if ( hs . insert ( x ) . second ) ans += x ;\n  return ans ;\n}\n",
        "reference_code": "    int candyShop2(int n, vector<int> &candies) {\n        int answer = 0;\n        unordered_map<int, int> m;\n        for(auto i : candies){\n            if(m.find(i) == m.end()){\n                answer += i;\n                m[i] = 1;\n            }\n        }\n        return answer;\n    }",
        "target_Lan": "cpp###candyShop2.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    vector<int> candies1 = {};\n    cout << candyShop2(0, candies1) << endl;\n\n    vector<int> candies2 = {1};\n    cout << candyShop2(1, candies2) << endl;\n\n    vector<int> candies3 = {1, 1};\n    cout << candyShop2(2, candies3) << endl;\n\n    vector<int> candies4 = {1, 2, 3};\n    cout << candyShop2(3, candies4) << endl;\n\n    vector<int> candies5 = {2, 2, 2, 2};\n    cout << candyShop2(4, candies5) << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###candyShop_Test.java",
        "source_code": "    public static int candyShop(int n, int candies[]) {\n        int ans = Integer.MAX_VALUE;\n        int sum = 0;\n        int low = 0, high = 0;\n        Set<Integer> hs = new HashSet<>();\n        for(int x : candies)\n            hs.add(x);\n        Map<Integer, Integer> hm = new HashMap<>();\n        while(high < n){\n            hm.put(candies[high], hm.getOrDefault(candies[high], 0) + 1);\n            sum += candies[high++];\n            while(low < high && hm.get(candies[low]) > 1){\n                hm.put(candies[low], hm.get(candies[low]) - 1);\n                sum -= candies[low++];\n            }\n            if(hm.size() == hs.size())\n                ans = Math.min(ans, sum);\n        }\n        return ans;\n    }",
        "trans_code": "public : int candyShop ( int n , int candies [ ] ) {\n  int ans = INT_MAX ;\n  int sum = 0 ;\n  int low = 0 , high = 0 ;\n  set < int > hs ;\n  for ( int x : candies ) {\n    hs . insert ( x ) ;\n  }\n  map < int , int > hm ;\n  while ( high < n ) {\n    hm [ candies [ high ] ] = hm . find ( candies [ high ] ) -> second + 1 ;\n    sum += candies [ high ++ ] ;\n    while ( low < high && hm [ candies [ low ] ] > 1 ) {\n      hm [ candies [ low ] ] = hm [ candies [ low ] ] - 1 ;\n      sum -= candies [ low ++ ] ;\n    }\n    if ( hm . size ( ) == hs . size ( ) ) {\n      ans = min ( ans , sum ) ;\n    }\n  }\n  return ans ;\n}\n",
        "reference_code": "    int candyShop(int n, vector<int> &candies) {\n        int answer = INT_MAX;\n        unordered_map<int, int> m;\n        for(auto i : candies){\n            m[i] += 1;\n        }\n        int k = m.size();\n        m.clear();\n        int l = 0, r = 0;\n        int total = 0;\n        while(r < n){\n            m[candies[r]] += 1;\n            total += candies[r];\n            while(m[candies[l]] > 1){\n                m[candies[l]] -= 1;\n                total -= candies[l];\n                l += 1;\n            }\n            if(m.size() == k){\n                answer = min(answer, total);\n            }\n            r += 1;\n        }\n        return answer;\n    }",
        "target_Lan": "cpp###candyShop.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <climits>\n// TOFILL\nint main() {\n    vector<int> candies1 = {1,2,3,4,5};\n    cout << candyShop(5, candies1) << endl;\n\n    vector<int> candies2 = {1,1,1,1,1,1,1,1,1,1};\n    cout << candyShop(10, candies2) << endl;\n\n    vector<int> candies3 = {1,2,3};\n    cout << candyShop(3, candies3) << endl;\n\n    vector<int> candies4 = {};\n    cout << candyShop(0, candies4) << endl;\n\n    vector<int> candies5 = {1,1};\n    cout << candyShop(2, candies5) << endl;\n}"
    },
    {
        "source_Lan": "java###minimizeArrayScore_Test.java",
        "source_code": "    public static int minimizeArrayScore(int n, int[] arr) {\n        Arrays.sort(arr);\n        int max = Integer.MIN_VALUE;\n        int low = 0, high = n - 1;\n        while(low < high)\n            max = Math.max(max, arr[high--] + arr[low++]);\n        return max;\n    }",
        "trans_code": "public : int minimizeArrayScore ( int n , vector < int > arr ) {\n  sort ( arr . begin ( ) , arr . end ( ) ) ;\n  int max = INT_MAX ;\n  int low = 0 , high = n - 1 ;\n  while ( low < high ) {\n    max = max ( max , arr [ high -- ] + arr [ low ++ ] ) ;\n  }\n  return max ;\n}\n",
        "reference_code": "    int minimizeArrayScore(int n, vector<int> &arr) {\n        int ans =INT_MIN;\n        sort(arr.begin(),arr.end());\n        int l=0;\n        int r=n-1;\n        while (l<r){\n            ans=max(ans,arr[l]+arr[r]);\n            l+=1;\n            r-=1;\n        }\n        return ans;\n    }",
        "target_Lan": "cpp###minimizeArrayScore.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n// TOFILL\nint main() {\n    int n;\n    vector<int> arr;\n\n    n = 0;\n    arr = {};\n    cout << minimizeArrayScore(n, arr) << endl;\n\n    n = 1;\n    arr = {1};\n    cout << minimizeArrayScore(n, arr) << endl;\n\n    n = 2;\n    arr = {1, 2};\n    cout << minimizeArrayScore(n, arr) << endl;\n\n    n = 3;\n    arr = {1, 2, 3};\n    cout << minimizeArrayScore(n, arr) << endl;\n\n    n = 5;\n    arr = {1, 2, 3, 4, 5};\n    cout << minimizeArrayScore(n, arr) << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###numOfWays_Test.java",
        "source_code": "    public static long numOfWays(int n) {\n        if(n%2==1)\n            return 0;\n        long k = (long)((n-1)/2);\n        k/=2;\n        k*=6;\n        return k;\n    }",
        "trans_code": "long long numOfWays ( int n ) {\n  if ( n % 2 == 1 ) return 0 ;\n  long long k = ( long long ) ( ( n - 1 ) / 2 ) ;\n  k /= 2 ;\n  k *= 6 ;\n  return k ;\n}\n",
        "reference_code": "    long numOfWays(int n)\n    {\n        if(n%2) return 0;\n        long k = (n-1)/2;\n        k/=2;\n        k*=6;\n        return k;\n    }",
        "target_Lan": "cpp###numOfWays.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n// TOFILL\nint main() {\n    cout << numOfWays(0) << endl;\n    cout << numOfWays(10) << endl;\n    cout << numOfWays(-1) << endl;\n    cout << numOfWays(100) << endl;\n    cout << numOfWays(50) << endl;\n    return 0;\n}"
    },
    {
        "source_Lan": "java###minimizeArr_Test.java",
        "source_code": "    public static int minimizeArr(int n, int[] arr) {\n        \n        int mi = Arrays.stream(arr).min().getAsInt();\n        int ct = 0;\n        \n        for (int j : arr) {\n            if (j == mi) ct++;\n        }\n        \n        if (ct == 1) return 1;\n        \n        for (int j : arr) {\n            if (j % mi != 0) return 1;\n        }\n        \n        return (int)Math.ceil((float)ct / 2);\n    }",
        "trans_code": "public : int minimizeArr ( int n , vector < int > arr ) {\n  int mi = std :: min ( arr . begin ( ) , arr . end ( ) ) ;\n  int ct = 0 ;\n  for ( auto j : arr ) {\n    if ( j == mi ) {\n      ct ++ ;\n    }\n  }\n  if ( ct == 1 ) {\n    return 1 ;\n  }\n  for ( auto j : arr ) {\n    if ( j % mi != 0 ) {\n      return 1 ;\n    }\n  }\n  return int ( ceil ( float ( ct ) / 2 ) ) ;\n}\n",
        "reference_code": "    int minimizeArr(int n, vector<int>&arr){\n        int mi=INT_MAX;\n        for (auto j:arr) mi=min(mi,j);\n        int ct=0;\n        for (auto j:arr){\n            if (j==mi)ct+=1;\n        }\n        if (ct==1) return 1;\n        for (auto j:arr){\n            if (j%mi!=0) return 1;\n        }\n        return ceil((float)ct / 2);\n    }",
        "target_Lan": "cpp###minimizeArr.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <climits>\n#include <cmath>\n// TOFILL\nint main() {\n    vector<int> arr1 = {2, 4, 6, 8, 10};\n    cout << minimizeArr(5, arr1) << endl;\n\n    vector<int> arr2 = {3, 6, 9, 12};\n    cout << minimizeArr(4, arr2) << endl;\n\n    vector<int> arr3 = {5, 10, 15};\n    cout << minimizeArr(3, arr3) << endl;\n\n    vector<int> arr4 = {7, 14};\n    cout << minimizeArr(2, arr4) << endl;\n\n    vector<int> arr5 = {11};\n    cout << minimizeArr(1, arr5) << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###consecutiveVal_Test.java",
        "source_code": "    public static String consecutiveVal(int n, List<Integer> a) {\n        StringBuilder result = new StringBuilder();\n        Map<Integer, Boolean> mp = new HashMap<>();\n        for (int i = 0; i < n; i++) {\n            mp.put(a.get(i), true);\n        }\n        for (int i = 0; i < n; i++) {\n            if (Boolean.TRUE.equals(mp.get(a.get(i) - 1)) ||\n                Boolean.TRUE.equals(mp.get(a.get(i) + 1))) {\n                result.append('1');\n            } else {\n                result.append('0');\n            }\n        }\n        return result.toString();\n    }",
        "trans_code": "public : string consecutiveVal ( int n , vector < int > a ) {\n  string result ;\n  map < int , bool > mp ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) mp [ a [ i ] ] = true ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    if ( bool ( mp [ a [ i ] - 1 ] ) || bool ( mp [ a [ i ] + 1 ] ) ) result . push_back ( '1' ) ;\n    else result . push_back ( '0' ) ;\n  }\n  return result ;\n}\n",
        "reference_code": "    string consecutiveVal(int n, vector<int> &a) {\n        \n        string result = \"\";\n        unordered_map<int, bool> mp;\n        for (int i = 0; i < n; i++) {\n            mp[a[i]] = true;\n        }\n        for (int i = 0; i < n; i++) {\n            if (mp[a[i] - 1] == true || mp[a[i] + 1] == true) {\n                result += '1';\n            } else\n                result += '0';\n        }\n        return result;\n    }",
        "target_Lan": "cpp###consecutiveVal.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <string>\n// TOFILL\nint main() {\n    vector<int> a1 = {};\n    cout << consecutiveVal(0, a1) << endl;\n\n    vector<int> a2 = {1};\n    cout << consecutiveVal(1, a2) << endl;\n\n    vector<int> a3 = {1, 2};\n    cout << consecutiveVal(2, a3) << endl;\n\n    vector<int> a4 = {1, 3, 2};\n    cout << consecutiveVal(3, a4) << endl;\n\n    vector<int> a5 = {1, 3, 2, 4};\n    cout << consecutiveVal(4, a5) << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###chocolateDistribution_Test.java",
        "source_code": "    public static int chocolateDistribution(int N, int M, int[] arr, int[] brr) {\n        Arrays.sort(arr);\n        Arrays.sort(brr);\n        int ans = 0;\n        int i = 0, j = 0;\n        while (i < N && j < M) {\n            if (arr[i] <= brr[j]) {\n                ans++;\n                i++;\n                j++;\n            } else {\n                j++;\n            }\n        }\n        return ans;\n    }",
        "trans_code": "public : int chocolateDistribution ( int N , int M , vector < int > arr , vector < int > brr ) {\n  sort ( arr . begin ( ) , arr . end ( ) ) ;\n  sort ( brr . begin ( ) , brr . end ( ) ) ;\n  int ans = 0 ;\n  int i = 0 , j = 0 ;\n  while ( i < N && j < M ) {\n    if ( arr [ i ] <= brr [ j ] ) {\n      ans ++ ;\n      i ++ ;\n      j ++ ;\n    }\n    else {\n      j ++ ;\n    }\n  }\n  return ans ;\n}\n",
        "reference_code": "    int chocolateDistribution(int N, int M, vector<int> &arr, vector<int> &brr) {\n        sort(arr.begin(), arr.end());\n        sort(brr.begin(), brr.end());\n        int ans = 0;\n        int i = 0, j = 0;\n        while (i < N && j < M) {\n            if (arr[i] <= brr[j]) {\n                ans++;\n                i++;\n                j++;\n            } else {\n                j++;\n            }\n        }\n        return ans;\n    }",
        "target_Lan": "cpp###chocolateDistribution.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <algorithm>\n// TOFILL\nint main() {\n    vector<int> arr1 = {};\n    vector<int> brr1 = {};\n    cout << chocolateDistribution(0, 0, arr1, brr1) << endl;\n\n    vector<int> arr2 = {1};\n    vector<int> brr2 = {1};\n    cout << chocolateDistribution(1, 1, arr2, brr2) << endl;\n\n    vector<int> arr3 = {1, 2};\n    vector<int> brr3 = {1, 2};\n    cout << chocolateDistribution(2, 2, arr3, brr3) << endl;\n\n    vector<int> arr4 = {1, 2, 3};\n    vector<int> brr4 = {1, 2, 3};\n    cout << chocolateDistribution(3, 3, arr4, brr4) << endl;\n\n    vector<int> arr5 = {1, 2};\n    vector<int> brr5 = {1, 2, 3};\n    cout << chocolateDistribution(2, 3, arr5, brr5) << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###minElements_Test.java",
        "source_code": "    public static int minElements(int n, int m, int[] arr1, int[] arr2) {\n        long sum = 0;\n        \n        for (int num : arr1) {\n            sum += num;\n        }\n        Arrays.sort(arr2); \n        long currentSum = 0;\n        int count = 0;\n        \n        for (int i = m - 1; i >= 0; i--) {\n            currentSum += arr2[i];\n            count++;\n            \n            if (currentSum >= sum) {\n                break;\n            }\n        }\n        \n        return currentSum >= sum ? count : -1;\n    }",
        "trans_code": "public : int minElements ( int n , int m , vector < int > & arr1 , vector < int > & arr2 ) {\n  ll sum = 0 ;\n  for ( auto num : arr1 ) sum += num ;\n  sort ( arr2 . begin ( ) , arr2 . end ( ) ) ;\n  ll currentSum = 0 ;\n  int count = 0 ;\n  for ( int i = m - 1 ;\n  i >= 0 ;\n  i -- ) {\n    currentSum += arr2 [ i ] ;\n    count ++ ;\n    if ( currentSum >= sum ) break ;\n  }\n  return currentSum >= sum ? count : - 1 ;\n}\n",
        "reference_code": "    int minElements(int n, int m, vector<int> &arr1, vector<int> &arr2) {\n        long long s=0;\n        for (auto j:arr1) s+=j;\n        sort(arr2.begin(),arr2.end());\n        long long cur=0;\n        int ans=0;\n        for (int i=m-1;i>=0;i--){\n            cur+=arr2[i];\n            ans+=1;\n            if (cur>=s)break;\n        }\n        if (cur>=s) return ans;\n        return -1;\n    }",
        "target_Lan": "cpp###minElements.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <algorithm>\n// TOFILL\nint main() {\n    vector<int> arr1 = {1, 2, 3};\n    vector<int> arr2 = {4, 5, 6};\n    cout << minElements(3, 3, arr1, arr2) << endl;\n\n    arr2 = {1, 1, 1};\n    cout << minElements(3, 3, arr1, arr2) << endl;\n\n    arr2 = {0, 0, 0};\n    cout << minElements(3, 3, arr1, arr2) << endl;\n\n    arr2 = {7, 8, 9};\n    cout << minElements(3, 3, arr1, arr2) << endl;\n\n    arr2 = {10, 10, 10};\n    cout << minElements(3, 3, arr1, arr2) << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###maxScoreSubseq_Test.java",
        "source_code": "    public static int maxScoreSubseq(int n, int[] arr) {\n        \n        \n        HashMap<Integer, Integer> map = new HashMap<>();\n        \n        int ma = Integer.MIN_VALUE;\n        \n        for(int i = 0; i < n; i++) {\n            \n            if(arr[i] >= 0) \n                map.put(arr[i] - i, map.getOrDefault(arr[i] - i, 0) + arr[i]);\n            \n            ma = Math.max(ma, arr[i]);\n        }\n        \n        int ele = Integer.MIN_VALUE;\n        \n        for(int j : map.values()){\n            ele = Math.max(ele, j);\n}\n        \n        return Math.max(ele, ma);\n    }",
        "trans_code": "public : int maxScoreSubseq ( int n , vector < int > arr ) {\n  unordered_map < int , int > map ;\n  int ma = INT_MAX ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    if ( arr [ i ] >= 0 ) {\n      map [ arr [ i ] - i ] = map . find ( arr [ i ] - i ) -> second + arr [ i ] ;\n    }\n    ma = max ( ma , arr [ i ] ) ;\n  }\n  int ele = INT_MAX ;\n  for ( auto j : map ) ele = max ( ele , j ) ;\n  return max ( ele , ma ) ;\n}\n",
        "reference_code": "    int maxScoreSubseq(int n, vector<int> &arr) {\n        unordered_map<int,int>mp;\n        int ma=INT_MIN;\n        for (int i=0;i<n;i++){\n            if (arr[i]>=0)mp[arr[i]-i]+=arr[i];\n            ma=max(ma,arr[i]);\n        }\n        int ele=INT_MIN;\n        for (auto j:mp) ele=max(ele,j.second);\n        return max(ele,ma);\n    }",
        "target_Lan": "cpp###maxScoreSubseq.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <climits>\n// TOFILL\nint main() {\n    vector<int> arr1 = {};\n    cout << maxScoreSubseq(0, arr1) << endl;\n\n    vector<int> arr2 = {1};\n    cout << maxScoreSubseq(1, arr2) << endl;\n\n    vector<int> arr3 = {-1, 1};\n    cout << maxScoreSubseq(2, arr3) << endl;\n\n    vector<int> arr4 = {1, 2, 3};\n    cout << maxScoreSubseq(3, arr4) << endl;\n\n    vector<int> arr5 = {1, -1, 1, -1};\n    cout << maxScoreSubseq(4, arr5) << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###minJumps_Test.java",
        "source_code": "    public static int minJumps(int n, int[] arr) {\n        \n        \n        HashMap<Integer, Integer> m = new HashMap<Integer, Integer>();\n        \n        int ans = n - 1;\n        \n        for (int i = n - 1; i >= 0; i--) {\n            \n            if (m.containsKey(arr[i])) {\n                \n                \n                ans = Math.min(ans, n - (m.get(arr[i]) - i));\n            } else {\n                \n                m.put(arr[i], i);\n            }\n        }\n        \n        return ans;\n    }",
        "trans_code": "public : int minJumps ( int n , vector < int > arr ) {\n  unordered_map < int , int > m ;\n  int ans = n - 1 ;\n  for ( int i = n - 1 ;\n  i >= 0 ;\n  i -- ) {\n    if ( m . count ( arr [ i ] ) ) ans = min ( ans , n - ( m [ arr [ i ] ] - i ) ) ;\n    else m [ arr [ i ] ] = i ;\n  }\n  return ans ;\n}\n",
        "reference_code": "    int minJumps(int n, vector<int> &arr) {\n        map<int, int> m;\n        int ans = n - 1;\n        for (int i = n - 1; i >= 0; i--) {\n            if (m.count(arr[i])) {\n                ans = min(ans, n - (m[arr[i]] - i));\n            } else {\n                m[arr[i]] = i;\n            }\n        }\n        return ans;\n    }",
        "target_Lan": "cpp###minJumps.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <map>\n// TOFILL\nint main() {\n    vector<int> arr1 = {1, 2, 3, 4, 5};\n    cout << minJumps(5, arr1) << endl;\n\n    vector<int> arr2 = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n    cout << minJumps(10, arr2) << endl;\n\n    vector<int> arr3 = {1, 2, 3};\n    cout << minJumps(3, arr3) << endl;\n\n    vector<int> arr4 = {1, 2, 3, 4};\n    cout << minJumps(4, arr4) << endl;\n\n    vector<int> arr5 = {1, 2};\n    cout << minJumps(2, arr5) << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###maximumSetSize_Test.java",
        "source_code": "    public static int maximumSetSize(int[] nums1, int[] nums2) {\n        Set<Integer> set1 = new HashSet<>();\n        for (int x : nums1) {\n            set1.add(x);\n        }\n        Set<Integer> set2 = new HashSet<>();\n        for (int x : nums2) {\n            set2.add(x);\n        }\n        int common = 0;\n        for (int x : set1) {\n            if (set2.contains(x)) {\n                common++;\n            }\n        }\n        int n1 = set1.size();\n        int n2 = set2.size();\n        int ans = n1 + n2 - common;\n        int m = nums1.length / 2;\n        if (n1 > m) {\n            int mn = Math.min(n1 - m, common);\n            ans -= n1 - mn - m;\n            common -= mn;\n        }\n        if (n2 > m) {\n            n2 -= Math.min(n2 - m, common);\n            ans -= n2 - m;\n        }\n        return ans;\n    }",
        "trans_code": "public : int maximumSetSize ( vector < int > & nums1 , vector < int > & nums2 ) {\n  set < int > set1 ;\n  for ( auto x : nums1 ) set1 . insert ( x ) ;\n  set < int > set2 ;\n  for ( auto x : nums2 ) set2 . insert ( x ) ;\n  int common = 0 ;\n  for ( auto x : set1 ) if ( set2 . count ( x ) ) common ++ ;\n  int n1 = set1 . size ( ) ;\n  int n2 = set2 . size ( ) ;\n  int ans = n1 + n2 - common ;\n  int m = nums1 . size ( ) / 2 ;\n  if ( n1 > m ) {\n    int mn = min ( n1 - m , common ) ;\n    ans -= n1 - mn - m ;\n    common -= mn ;\n  }\n  if ( n2 > m ) {\n    n2 -= min ( n2 - m , common ) ;\n    ans -= n2 - m ;\n  }\n  return ans ;\n}\n",
        "reference_code": "    int maximumSetSize(vector<int> &nums1, vector<int> &nums2) {\n        unordered_set<int> set1(nums1.begin(), nums1.end());\n        unordered_set<int> set2(nums2.begin(), nums2.end());\n        int common = 0;\n        for (int x : set1) {\n            common += set2.count(x);\n        }\n        int n1 = set1.size();\n        int n2 = set2.size();\n        int ans = n1 + n2 - common;\n        int m = nums1.size() / 2;\n        if (n1 > m) {\n            int mn = min(n1 - m, common);\n            ans -= n1 - mn - m;\n            common -= mn;\n        }\n        if (n2 > m) {\n            n2 -= min(n2 - m, common);\n            ans -= n2 - m;\n        }\n        return ans;\n    }",
        "target_Lan": "cpp###maximumSetSize.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <unordered_set>\n// TOFILL\nint main() {\n    vector<int> nums1 = {1,2,3,4,5};\n    vector<int> nums2 = {3,4,5,6,7};\n    cout << maximumSetSize(nums1, nums2) << endl;\n\n    nums1 = {1,1,1,1,1};\n    nums2 = {2,2,2,2,2};\n    cout << maximumSetSize(nums1, nums2) << endl;\n\n    nums1 = {1,2,3,4,5};\n    nums2 = {1,2,3,4,5};\n    cout << maximumSetSize(nums1, nums2) << endl;\n\n    nums1 = {1,2,3,4,5};\n    nums2 = {6,7,8,9,10};\n    cout << maximumSetSize(nums1, nums2) << endl;\n\n    nums1 = {1,2,3,4,5};\n    nums2 = {2,3,4,5,6};\n    cout << maximumSetSize(nums1, nums2) << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###maxFrequencyElements_Test.java",
        "source_code": "    public static int maxFrequencyElements(int[] nums) {\n        int ans = 0, maxCnt = 0;\n        Map<Integer, Integer> cnt = new HashMap<>();\n        for (int x : nums) {\n            int c = cnt.merge(x, 1, Integer::sum);\n            if (c > maxCnt) {\n                maxCnt = ans = c;\n            } else if (c == maxCnt) {\n                ans += c;\n            }\n        }\n        return ans;\n    }",
        "trans_code": "public : int maxFrequencyElements ( vector < int > & nums ) {\n  int ans = 0 , maxCnt = 0 ;\n  map < int , int > cnt ;\n  for ( int x : nums ) {\n    int c = cnt . merge ( x , 1 , INT_MAX ) ;\n    if ( c > maxCnt ) maxCnt = ans = c ;\n    else if ( c == maxCnt ) ans += c ;\n  }\n  return ans ;\n}\n",
        "reference_code": "    int maxFrequencyElements(vector<int> &nums) {\n        int ans = 0, maxCnt = 0;\n        unordered_map<int, int> cnt;\n        for (int x : nums) {\n            int c = ++cnt[x];\n            if (c > maxCnt) {\n                maxCnt = ans = c;\n            } else if (c == maxCnt) {\n                ans += c;\n            }\n        }\n        return ans;\n    }",
        "target_Lan": "cpp###maxFrequencyElements.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    vector<int> nums1 = {1,2,3,4,5};\n    cout << maxFrequencyElements(nums1) << endl;\n\n    vector<int> nums2 = {1,1,1,1,1};\n    cout << maxFrequencyElements(nums2) << endl;\n\n    vector<int> nums3 = {1,2,2,3,3,3,4,4,4,4};\n    cout << maxFrequencyElements(nums3) << endl;\n\n    vector<int> nums4 = {1,2,3,4,5,5,5,5};\n    cout << maxFrequencyElements(nums4) << endl;\n\n    vector<int> nums5 = {1,1,2,2,3,3,4,4};\n    cout << maxFrequencyElements(nums5) << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###minimumPushes_Test.java",
        "source_code": "    public static int minimumPushes(String word) {\n        int n = word.length();\n        int k = n / 8;\n        return (k * 4 + n % 8) * (k + 1);\n    }",
        "trans_code": "public : int minimumPushes ( string word ) {\n  int n = word . size ( ) ;\n  int k = n / 8 ;\n  return ( k * 4 + n % 8 ) * ( k + 1 ) ;\n}\n",
        "reference_code": "    int minimumPushes(string &word) {\n        int n = word.length();\n        int k = n / 8;\n        return (k * 4 + n % 8) * (k + 1);\n    }",
        "target_Lan": "cpp###minimumPushes.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <string>\n// TOFILL\nint main() {\n    string word1 = \"\";\n    string word2 = \"a\";\n    string word3 = \"abcdefgh\";\n    string word4 = \"abcdefghijklmnop\";\n    string word5 = \"abcdefghijklmnopqrstuvwxyz\";\n\n    cout << minimumPushes(word1) << endl;\n    cout << minimumPushes(word2) << endl;\n    cout << minimumPushes(word3) << endl;\n    cout << minimumPushes(word4) << endl;\n    cout << minimumPushes(word5) << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###minOperations_Test.java",
        "source_code": "    public static int minOperations(int k) {\n        int ans = Integer.MAX_VALUE;\n        for (int m = 1; m <= k; m++) {\n            ans = Math.min(ans, m - 1 + (k - 1) / m);\n        }\n        return ans;\n    }",
        "trans_code": "public : int minOperations ( int k ) {\n  int ans = INT_MAX ;\n  for ( int m = 1 ;\n  m <= k ;\n  m ++ ) ans = min ( ans , m - 1 + ( k - 1 ) / m ) ;\n  return ans ;\n}\n",
        "reference_code": "    int minOperations(int k) {\n        int ans = INT_MAX;\n        for (int m = 1; m <= k; m++) {\n            ans = min(ans, m - 1 + (k - 1) / m);\n        }\n        return ans;\n    }",
        "target_Lan": "cpp###minOperations.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <climits>\n// TOFILL\nint main() {\n    cout << minOperations(0) << endl;\n    cout << minOperations(1) << endl;\n    cout << minOperations(2) << endl;\n    cout << minOperations(10) << endl;\n    cout << minOperations(100) << endl;\n    return 0;\n}"
    },
    {
        "source_Lan": "java###minimumOperationsToMakeKPeriodic_Test.java",
        "source_code": "    public static int minimumOperationsToMakeKPeriodic(String word, int k) {\n        int n = word.length();\n        int mx = 0;\n        HashMap<String, Integer> cnt = new HashMap<>();\n        for (int i = k; i <= n; i += k) {\n            String sub = word.substring(i - k, i);\n            int c = cnt.merge(sub, 1, Integer::sum); \n            mx = Math.max(mx, c);\n        }\n        return n / k - mx;\n    }",
        "trans_code": "public : int minimumOperationsToMakeKPeriodic ( string word , int k ) {\n  int n = word . size ( ) ;\n  int mx = 0 ;\n  unordered_map < string , int > cnt ;\n  for ( int i = k ;\n  i <= n ;\n  i += k ) {\n    string sub = word . substr ( i - k , i ) ;\n    int c = cnt . merge ( sub , 1 , INT_MAX ) ;\n    mx = max ( mx , c ) ;\n  }\n  return n / k - mx ;\n}\n",
        "reference_code": "    int minimumOperationsToMakeKPeriodic(string word, int k) {\n        int n = word.size(), mx = 0;\n        unordered_map<string, int> cnt;\n        for (int i = k; i <= n; i += k) {\n            mx = max(mx, ++cnt[word.substr(i - k, k)]);\n        }\n        return n / k - mx;\n    }",
        "target_Lan": "cpp###minimumOperationsToMakeKPeriodic.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <string>\n#include <unordered_map>\n// TOFILL\nint main() {\n    cout << minimumOperationsToMakeKPeriodic(\"abcabcabcabc\", 3) << endl;\n    cout << minimumOperationsToMakeKPeriodic(\"aaaaa\", 1) << endl;\n    cout << minimumOperationsToMakeKPeriodic(\"abcabcabcabc\", 4) << endl;\n    cout << minimumOperationsToMakeKPeriodic(\"abcabcabcabc\", 6) << endl;\n    cout << minimumOperationsToMakeKPeriodic(\"abcabcabcabc\", 12) << endl;\n    return 0;\n}"
    },
    {
        "source_Lan": "java###maxScore2_Test.java",
        "source_code": "    public static int maxScore2(List<List<Integer>> grid) {\n        int ans = Integer.MIN_VALUE;\n        int m = grid.size(), n = grid.get(0).size();\n        int[][] f = new int[m + 1][n + 1];\n        Arrays.fill(f[0], Integer.MAX_VALUE);\n        for (int i = 0; i < m; i++) {\n            f[i + 1][0] = Integer.MAX_VALUE;\n            List<Integer> row = grid.get(i);\n            for (int j = 0; j < n; j++) {\n                int mn = Math.min(f[i + 1][j], f[i][j + 1]);\n                int x = row.get(j);\n                ans = Math.max(ans, x - mn);\n                f[i + 1][j + 1] = Math.min(mn, x);\n            }\n        }\n        return ans;\n    }",
        "trans_code": "public : int maxScore2 ( std :: vector < std :: vector < int >> & grid ) {\n  int ans = std :: numeric_limits < int > :: min ( ) ;\n  int m = grid . size ( ) , n = grid [ 0 ] . size ( ) ;\n  std :: vector < int > f ( m + 1 , 0 ) ;\n  std :: fill ( f . begin ( ) , f . end ( ) , INT_MAX ) ;\n  for ( int i = 0 ;\n  i < m ;\n  i ++ ) {\n    f [ i + 1 ] = INT_MAX ;\n    std :: vector < int > row = grid [ i ] ;\n    for ( int j = 0 ;\n    j < n ;\n    j ++ ) {\n      int mn = std :: min ( f [ i + 1 ] [ j ] , f [ i ] [ j + 1 ] ) ;\n      int x = row [ j ] ;\n      ans = std :: max ( ans , x - mn ) ;\n      f [ i + 1 ] [ j + 1 ] = std :: min ( mn , x ) ;\n    }\n  }\n  return ans ;\n}\n",
        "reference_code": "    int maxScore2(vector<vector<int>>& grid) {\n        int ans = INT_MIN;\n        int m = grid.size(), n = grid[0].size();\n        vector<vector<int>> f(m + 1, vector<int>(n + 1, INT_MAX));\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                int mn = min(f[i + 1][j], f[i][j + 1]);\n                ans = max(ans, grid[i][j] - mn);\n                f[i + 1][j + 1] = min(mn, grid[i][j]);\n            }\n        }\n        return ans;\n    }",
        "target_Lan": "cpp###maxScore2.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <climits>\n// TOFILL\nint main() {\n    vector<vector<int>> grid1 = {{1,2,3}, {4,5,6}, {7,8,9}};\n    vector<vector<int>> grid2 = {{10,20,30}, {40,50,60}, {70,80,90}};\n    vector<vector<int>> grid3 = {{100,200,300}, {400,500,600}, {700,800,900}};\n    vector<vector<int>> grid4 = {{1,1,1}, {1,1,1}, {1,1,1}};\n    vector<vector<int>> grid5 = {{9,9,9}, {9,9,9}, {9,9,9}};\n\n    cout << maxScore2(grid1) << endl;\n    cout << maxScore2(grid2) << endl;\n    cout << maxScore2(grid3) << endl;\n    cout << maxScore2(grid4) << endl;\n    cout << maxScore2(grid5) << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###countCompleteDayPairs_Test.java",
        "source_code": "    public static long countCompleteDayPairs(int[] hours) {\n        long ans = 0;\n        int[] cnt = new int[24];\n        for (int t : hours) {\n            \n            \n            ans += cnt[(24 - t % 24) % 24];\n            cnt[t % 24]++;\n        }\n        return ans;\n    }",
        "trans_code": "long long countCompleteDayPairs ( vector < int > & hours ) {\n  long long ans = 0 ;\n  vector < int > cnt ( 24 ) ;\n  for ( int t : hours ) {\n    ans += cnt [ ( 24 - t % 24 ) % 24 ] ;\n    cnt [ t % 24 ] ++ ;\n  }\n  return ans ;\n}\n",
        "reference_code": "    long long countCompleteDayPairs(vector<int> &hours) {\n        long long ans = 0;\n        int cnt[24]{};\n        for (int t : hours) {\n            \n            \n            ans += cnt[(24 - t % 24) % 24];\n            cnt[t % 24]++;\n        }\n        return ans;\n    }",
        "target_Lan": "cpp###countCompleteDayPairs.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    vector<int> hours1 = {0, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1};\n    cout << countCompleteDayPairs(hours1) << endl;\n\n    vector<int> hours2 = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n    cout << countCompleteDayPairs(hours2) << endl;\n\n    vector<int> hours3 = {23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23};\n    cout << countCompleteDayPairs(hours3) << endl;\n\n    vector<int> hours4 = {12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12};\n    cout << countCompleteDayPairs(hours4) << endl;\n\n    vector<int> hours5 = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 0};\n    cout << countCompleteDayPairs(hours5) << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###minimumCost_Test.java",
        "source_code": "    public static int minimumCost(int[] nums) {\n        Arrays.sort(nums, 1, nums.length);\n        return nums[0] + nums[1] + nums[2];\n    }",
        "trans_code": "public : int minimumCost ( vector < int > & nums ) {\n  sort ( nums . begin ( ) , nums . end ( ) ) ;\n  return nums [ 0 ] + nums [ 1 ] + nums [ 2 ] ;\n}\n",
        "reference_code": "    int minimumCost(vector<int> &nums) {\n        sort(nums.begin() + 1, nums.end());\n        return accumulate(nums.begin(), nums.begin() + 3, 0);\n    }",
        "target_Lan": "cpp###minimumCost.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <numeric>\n#include <algorithm>\n// TOFILL\nint main() {\n    vector<int> nums1 = {1,2,3,4,5};\n    cout << minimumCost(nums1) << endl;\n\n    vector<int> nums2 = {5,4,3,2,1};\n    cout << minimumCost(nums2) << endl;\n\n    vector<int> nums3 = {1,1,1,1,1};\n    cout << minimumCost(nums3) << endl;\n\n    vector<int> nums4 = {-1,-2,-3,-4,-5};\n    cout << minimumCost(nums4) << endl;\n\n    vector<int> nums5 = {0,0,0,0,0};\n    cout << minimumCost(nums5) << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###triangleType_Test.java",
        "source_code": "    public static String triangleType(int[] nums) {\n        Arrays.sort(nums);\n        int x = nums[0];\n        int y = nums[1];\n        int z = nums[2];\n        if (x + y <= z) { \n            return \"none\";\n        }\n        if (x == z) { \n            return \"equilateral\";\n        }\n        if (x == y || y == z) {\n            return \"isosceles\";\n        }\n        return \"scalene\";\n    }",
        "trans_code": "string triangleType ( vector < int > & nums ) {\n  sort ( nums . begin ( ) , nums . end ( ) ) ;\n  int x = nums [ 0 ] ;\n  int y = nums [ 1 ] ;\n  int z = nums [ 2 ] ;\n  if ( x + y <= z ) return \"none\" ;\n  if ( x == z ) return \"equilateral\" ;\n  if ( x == y || y == z ) return \"isosceles\" ;\n  return \"scalene\" ;\n}\n",
        "reference_code": "    string triangleType(vector<int> &nums) {\n        sort(nums.begin(), nums.end());\n        int x = nums[0], y = nums[1], z = nums[2];\n        if (x + y <= z) { \n            return \"none\";\n        }\n        if (x == z) { \n            return \"equilateral\";\n        }\n        if (x == y || y == z) {\n            return \"isosceles\";\n        }\n        return \"scalene\";\n    }",
        "target_Lan": "cpp###triangleType.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <algorithm>\n// TOFILL\nint main() {\n    vector<int> nums1 = {1,1,1};\n    cout << triangleType(nums1) << endl;\n\n    vector<int> nums2 = {2,2,3};\n    cout << triangleType(nums2) << endl;\n\n    vector<int> nums3 = {3,4,5};\n    cout << triangleType(nums3) << endl;\n\n    vector<int> nums4 = {5,7,10};\n    cout << triangleType(nums4) << endl;\n\n    vector<int> nums5 = {10,10,20};\n    cout << triangleType(nums5) << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###maximumSubarraySum_Test.java",
        "source_code": "    public static long maximumSubarraySum(int[] nums, int k) {\n        long ans = Long.MIN_VALUE;\n        long sum = 0;\n        Map<Integer, Long> minS = new HashMap<>();\n        for (int x : nums) {\n            long s1 = minS.getOrDefault(x - k, Long.MAX_VALUE / 2);\n            long s2 = minS.getOrDefault(x + k, Long.MAX_VALUE / 2);\n            ans = Math.max(ans, sum + x - Math.min(s1, s2));\n            minS.merge(x, sum, Math::min);\n            sum += x;\n        }\n        return ans > Long.MIN_VALUE / 4 ? ans : 0;\n    }",
        "trans_code": "public : long long maximumSubarraySum ( vector < int > & nums , int k ) {\n  long long ans = numeric_limits < long long > :: min ( ) ;\n  long long sum = 0 ;\n  map < int , long long > minS ;\n  for ( auto x : nums ) {\n    auto s1 = minS . getOrDefault ( x - k , numeric_limits < long long > :: max ( ) / 2 ) ;\n    auto s2 = minS . getOrDefault ( x + k , numeric_limits < long long > :: max ( ) / 2 ) ;\n    ans = max ( ans , sum + x - min ( s1 , s2 ) ) ;\n    minS . merge ( x , sum , numeric_limits < long long > :: min ( ) ) ;\n    sum += x ;\n  }\n  return ans > numeric_limits < long long > :: max ( ) / 4 ? ans : 0 ;\n}\n",
        "reference_code": "    long long maximumSubarraySum(vector<int> &nums, int k) {\n        long long ans = LLONG_MIN, sum = 0;\n        unordered_map<int, long long> min_s;\n        for (int x: nums) {\n            auto it = min_s.find(x + k);\n            if (it != min_s.end()) {\n                ans = max(ans, sum + x - it->second);\n            }\n            it = min_s.find(x - k);\n            if (it != min_s.end()) {\n                ans = max(ans, sum + x - it->second);\n            }\n            it = min_s.find(x);\n            if (it == min_s.end() || sum < it->second) {\n                min_s[x] = sum;\n            }\n            sum += x;\n        }\n        return ans == LLONG_MIN ? 0 : ans;\n    }",
        "target_Lan": "cpp###maximumSubarraySum.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <climits>\n// TOFILL\nint main() {\n    vector<int> nums1 = {1, 2, 3, 4, 5};\n    vector<int> nums2 = {-1, -2, -3, -4, -5};\n    vector<int> nums3 = {10, 20, 30, 40, 50};\n    vector<int> nums4 = {0, 0, 0, 0, 0};\n    vector<int> nums5 = {100, 200, 300, 400, 500};\n\n    cout << maximumSubarraySum(nums1, 1) << endl;\n    cout << maximumSubarraySum(nums2, 2) << endl;\n    cout << maximumSubarraySum(nums3, 3) << endl;\n    cout << maximumSubarraySum(nums4, 0) << endl;\n    cout << maximumSubarraySum(nums5, 100) << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###minimumLevels_Test.java",
        "source_code": "    public static int minimumLevels(int[] possible) {\n        \n        int n = possible.length;\n        int s = 0;\n        for (int x : possible) {\n            s += x;\n        }\n        s = s * 2 - n;\n        int pre = 0;\n        for (int i = 0; i < n - 1; i++) {\n            pre += possible[i] == 1 ? 2 : -2;\n            if (pre > s) {\n                return i + 1;\n            }\n        }\n        return -1;\n    }",
        "trans_code": "public : int minimumLevels ( vector < int > possible ) {\n  int n = possible . size ( ) ;\n  int s = 0 ;\n  for ( int x : possible ) s += x ;\n  s = s * 2 - n ;\n  int pre = 0 ;\n  for ( int i = 0 ;\n  i < n - 1 ;\n  i ++ ) {\n    pre += possible [ i ] == 1 ? 2 : - 2 ;\n    if ( pre > s ) return i + 1 ;\n  }\n  return - 1 ;\n}\n",
        "reference_code": "    int minimumLevels(vector<int> &possible) {\n        \n        int n = possible.size();\n        int s = accumulate(possible.begin(), possible.end(), 0) * 2 - n;\n        int pre = 0;\n        for (int i = 0; i < n - 1; i++) {\n            pre += possible[i] ? 2 : -2;\n            if (pre > s) {\n                return i + 1;\n            }\n        }\n        return -1;\n    }",
        "target_Lan": "cpp###minimumLevels.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <numeric>\n// TOFILL\nint main() {\n    vector<int> possible1 = {1, 1, 1, 1, 1};\n    cout << minimumLevels(possible1) << endl;\n\n    vector<int> possible2 = {1, 0, 1, 0, 1};\n    cout << minimumLevels(possible2) << endl;\n\n    vector<int> possible3 = {0, 0, 0, 0, 0};\n    cout << minimumLevels(possible3) << endl;\n\n    vector<int> possible4 = {1, 1, 1, 0, 0};\n    cout << minimumLevels(possible4) << endl;\n\n    vector<int> possible5 = {0, 1, 0, 1, 0};\n    cout << minimumLevels(possible5) << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###minimumDistance_Test.java",
        "source_code": "    public static int minimumDistance(int[][] points) {\n        TreeMap<Integer, Integer> sx = new TreeMap<Integer, Integer>();\n        TreeMap<Integer, Integer> sy = new TreeMap<Integer, Integer>();\n        for (int[] p : points) {\n            sx.put(p[0] - p[1], sx.getOrDefault(p[0] - p[1], 0) + 1);\n            sy.put(p[0] + p[1], sy.getOrDefault(p[0] + p[1], 0) + 1);\n        }\n        int res = Integer.MAX_VALUE;\n        for (int[] p : points) {\n            sx.put(p[0] - p[1], sx.get(p[0] - p[1]) - 1);\n            if (sx.get(p[0] - p[1]) == 0) {\n                sx.remove(p[0] - p[1]);\n            }\n            sy.put(p[0] + p[1], sy.get(p[0] + p[1]) - 1);\n            if (sy.get(p[0] + p[1]) == 0) {\n                sy.remove(p[0] + p[1]);\n            }\n            res = Math.min(res, Math.max(sx.lastKey() - sx.firstKey(), sy.lastKey() - sy.firstKey()));\n            sx.put(p[0] - p[1], sx.getOrDefault(p[0] - p[1], 0) + 1);\n            sy.put(p[0] + p[1], sy.getOrDefault(p[0] + p[1], 0) + 1);\n        }\n        return res;\n    }",
        "trans_code": "public : int minimumDistance ( vector < vector < int >> & points ) {\n  map < int , int > sx ;\n  map < int , int > sy ;\n  for ( auto p : points ) {\n    sx [ p [ 0 ] - p [ 1 ] ] = sx . getOrDefault ( p [ 0 ] - p [ 1 ] , 0 ) + 1 ;\n    sy [ p [ 0 ] + p [ 1 ] ] = sy . getOrDefault ( p [ 0 ] + p [ 1 ] , 0 ) + 1 ;\n  }\n  int res = INT_MAX ;\n  for ( auto p : points ) {\n    sx [ p [ 0 ] - p [ 1 ] ] = sx [ p [ 0 ] - p [ 1 ] ] - 1 ;\n    if ( sx [ p [ 0 ] - p [ 1 ] ] == 0 ) sx . erase ( p [ 0 ] - p [ 1 ] ) ;\n    sy [ p [ 0 ] + p [ 1 ] ] = sy [ p [ 0 ] + p [ 1 ] ] - 1 ;\n    if ( sy [ p [ 0 ] + p [ 1 ] ] == 0 ) sy . erase ( p [ 0 ] + p [ 1 ] ) ;\n    res = min ( res , max ( sx . lastKey ( ) - sx . firstKey ( ) , sy . lastKey ( ) - sy . firstKey ( ) ) ) ;\n    sx [ p [ 0 ] - p [ 1 ] ] = sx [ p [ 0 ] - p [ 1 ] ] + 1 ;\n    sy [ p [ 0 ] + p [ 1 ] ] = sy [ p [ 0 ] + p [ 1 ] ] + 1 ;\n  }\n  return res ;\n}\n",
        "reference_code": "    int minimumDistance(vector<vector<int>>& points) {\n        multiset<int> sx, sy;\n        for (auto & p : points) {\n            sx.emplace(p[0] - p[1]);\n            sy.emplace(p[0] + p[1]);\n        }\n        int res = INT_MAX;\n        for (auto &p : points) {\n            sx.erase(sx.find(p[0] - p[1]));\n            sy.erase(sy.find(p[0] + p[1]));\n            res = min(res, max(*sx.rbegin() - *sx.begin(), *sy.rbegin() - *sy.begin()));\n            sx.emplace(p[0] - p[1]);\n            sy.emplace(p[0] + p[1]);\n        }\n        return res;\n    }",
        "target_Lan": "cpp###minimumDistance.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\n#include <climits>\n// TOFILL\nint main() {\n    vector<vector<int>> points1 = {{0,0},{1,1},{2,2}};\n    cout << minimumDistance(points1) << endl;\n\n    vector<vector<int>> points2 = {{0,0},{1,0},{2,0}};\n    cout << minimumDistance(points2) << endl;\n\n    vector<vector<int>> points3 = {{0,0},{0,1},{0,2}};\n    cout << minimumDistance(points3) << endl;\n\n    vector<vector<int>> points4 = {{0,0},{1,2},{2,1}};\n    cout << minimumDistance(points4) << endl;\n\n    vector<vector<int>> points5 = {{0,0},{0,0},{0,0}};\n    cout << minimumDistance(points5) << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###findMaximumElegance_Test.java",
        "source_code": "    public static long findMaximumElegance(int[][] items, int k) {\n        Arrays.sort(items, (item0, item1) -> item1[0] - item0[0]);\n        var categorySet = new HashSet<Integer>();\n        long profit = 0, res = 0;\n        var st = new ArrayDeque<Integer>();\n        for (int i = 0; i < items.length; i++) {\n            if (i < k) {\n                profit += items[i][0];\n                if (!categorySet.add(items[i][1])) {\n                    st.push(items[i][0]);\n                }\n            } else if (!st.isEmpty() && categorySet.add(items[i][1])) {\n                profit += items[i][0] - st.pop();\n            }\n            res = Math.max(res, profit + (long)categorySet.size() * categorySet.size());\n        }\n        return res;\n    }",
        "trans_code": "long long findMaximumElegance ( vector < int > & items , int k ) {\n  sort ( items . begin ( ) , items . end ( ) , ( item0 , item1 ) ) ;\n  var categorySet ;\n  long long profit = 0 , res = 0 ;\n  var st ;\n  for ( int i = 0 ;\n  i < items . size ( ) ;\n  i ++ ) {\n    if ( i < k ) {\n      profit += items [ i ] [ 0 ] ;\n      if ( ! categorySet . contains ( items [ i ] [ 1 ] ) ) st . push ( items [ i ] [ 0 ] ) ;\n    }\n    else if ( ! st . empty ( ) && categorySet . contains ( items [ i ] [ 1 ] ) ) profit += items [ i ] [ 0 ] - st . top ( ) ;\n    res = max ( res , profit + ( long long ) categorySet . size ( ) * categorySet . size ( ) ) ;\n  }\n  return res ;\n}\n",
        "reference_code": "    long long findMaximumElegance(vector<vector<int>>& items, int k) {\n        sort(items.begin(), items.end(), [&](const vector<int> &item1, const vector<int> &item2) -> bool {\n            return item1[0] > item2[0];\n        });\n        unordered_set<int> categorySet;\n        long long res = 0, profit = 0;\n        stack<int> st;\n        for (int i = 0; i < items.size(); i++) {\n            if (i < k) {\n                profit += items[i][0];\n                if (categorySet.count(items[i][1]) == 0) {\n                    categorySet.insert(items[i][1]);\n                } else {\n                    st.push(items[i][0]);\n                }\n            } else if (categorySet.count(items[i][1]) == 0 && !st.empty()) {\n                profit += items[i][0] - st.top();\n                st.pop();\n                categorySet.insert(items[i][1]);\n            }\n            res = max(res, (long long)(profit + categorySet.size() * categorySet.size()));\n        }\n        return res;\n    }",
        "target_Lan": "cpp###findMaximumElegance.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <unordered_set>\n#include <stack>\n// TOFILL\nint main() {\n    vector<vector<int>> items1 = {{1,1},{2,2},{3,3},{4,4},{5,5}};\n    int k1 = 2;\n    cout << findMaximumElegance(items1, k1) << endl;\n\n    vector<vector<int>> items2 = {{1,1},{2,2},{3,3},{4,4},{5,5}};\n    int k2 = 0;\n    cout << findMaximumElegance(items2, k2) << endl;\n\n    vector<vector<int>> items3 = {{1,1},{2,2},{3,3},{4,4},{5,5}};\n    int k3 = 5;\n    cout << findMaximumElegance(items3, k3) << endl;\n\n    vector<vector<int>> items4 = {{1,1},{2,2},{3,3},{4,4},{5,5}};\n    int k4 = 3;\n    cout << findMaximumElegance(items4, k4) << endl;\n\n    vector<vector<int>> items5 = {{1,1},{2,2},{3,3},{4,4},{5,5}};\n    int k5 = 1;\n    cout << findMaximumElegance(items5, k5) << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###maximumBeauty_Test.java",
        "source_code": "    public static int maximumBeauty(int[] nums, int k) {\n        int res = 0, n = nums.length;\n        Arrays.sort(nums);\n        for (int i = 0, j = 0; i < n; i++) {\n            while (nums[i] - 2 * k > nums[j]) {\n                j++;\n            }\n            res = Math.max(res, i - j + 1);\n        }\n        return res;\n    }",
        "trans_code": "public : int maximumBeauty ( vector < int > & nums , int k ) {\n  int res = 0 , n = nums . size ( ) ;\n  sort ( nums . begin ( ) , nums . end ( ) ) ;\n  for ( int i = 0 , j = 0 ;\n  i < n ;\n  i ++ ) {\n    while ( nums [ i ] - 2 * k > nums [ j ] ) j ++ ;\n    res = max ( res , i - j + 1 ) ;\n  }\n  return res ;\n}\n",
        "reference_code": "    int maximumBeauty(vector<int>& nums, int k) {\n        int res = 0, n = nums.size();\n        sort(nums.begin(), nums.end());\n        for (int i = 0, j = 0; i < n; i++) {\n            while (nums[i] - 2 * k > nums[j]) {\n                j++;\n            }\n            res = max(res, i - j + 1);\n        }\n        return res;\n    }",
        "target_Lan": "cpp###maximumBeauty.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <algorithm>\n// TOFILL\nint main() {\n    vector<int> nums1 = {1,2,3,4,5};\n    cout << maximumBeauty(nums1, 1) << endl;\n\n    vector<int> nums2 = {5,4,3,2,1};\n    cout << maximumBeauty(nums2, 2) << endl;\n\n    vector<int> nums3 = {1,1,1,1,1};\n    cout << maximumBeauty(nums3, 0) << endl;\n\n    vector<int> nums4 = {10,20,30,40,50};\n    cout << maximumBeauty(nums4, 10) << endl;\n\n    vector<int> nums5 = {100,200,300,400,500};\n    cout << maximumBeauty(nums5, 50) << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###maxScore_Test.java",
        "source_code": "    public static long maxScore(int[] nums, int x) {\n        long res = nums[0];\n        long[] dp = {Integer.MIN_VALUE, Integer.MIN_VALUE};\n        dp[nums[0] % 2] = nums[0];\n        for (int i = 1; i < nums.length; i++) {\n            int parity = (int) (nums[i] % 2);\n            long cur = Math.max(dp[parity] + nums[i], dp[1 - parity] - x + nums[i]);\n            res = Math.max(res, cur);\n            dp[parity] = Math.max(dp[parity], cur);\n        }\n        return res;\n    }",
        "trans_code": "public : long long maxScore ( vector < int > & nums , int x ) {\n  long long res = nums [ 0 ] ;\n  vector < long long > dp {\n    INT_MIN , INT_MAX }\n    ;\n    dp [ nums [ 0 ] % 2 ] = nums [ 0 ] ;\n    for ( int i = 1 ;\n    i < nums . size ( ) ;\n    i ++ ) {\n      int parity = ( int ) ( nums [ i ] % 2 ) ;\n      long long cur = max ( dp [ parity ] + nums [ i ] , dp [ 1 - parity ] - x + nums [ i ] ) ;\n      res = max ( res , cur ) ;\n      dp [ parity ] = max ( dp [ parity ] , cur ) ;\n    }\n    return res ;\n  }\n  ",
        "reference_code": "    long long maxScore(vector<int>& nums, int x) {\n        long long res = nums[0];\n        vector<long long> dp(2, INT_MIN);\n        dp[nums[0] % 2] = nums[0];\n        for (int i = 1; i < nums.size(); i++) {\n            int parity = nums[i] % 2;\n            long long cur = max(dp[parity] + nums[i], dp[1 - parity] - x + nums[i]);\n            res = max(res, cur);\n            dp[parity] = max(dp[parity], cur);\n        }\n        return res;\n    }",
        "target_Lan": "cpp###maxScore.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <climits>\n// TOFILL\nint main() {\n    vector<int> nums1 = {1,2,3,4,5};\n    vector<int> nums2 = {10,20,30,40,50};\n    vector<int> nums3 = {100,200,300,400,500};\n    vector<int> nums4 = {1000,2000,3000,4000,5000};\n    int x1 = 1;\n    int x2 = 5;\n    int x3 = 10;\n    int x4 = 20;\n    cout << maxScore(nums1, x1) << endl;\n    cout << maxScore(nums2, x2) << endl;\n    cout << maxScore(nums3, x3) << endl;\n    cout << maxScore(nums4, x4) << endl;\n    return 0;\n}"
    },
    {
        "source_Lan": "java###maxOperations_Test.java",
        "source_code": "    public static int maxOperations(int[] nums) {\n        int n = nums.length, t = 0;\n        for (int i = 1; i < n; i += 2) {\n            if (nums[i] + nums[i - 1] != nums[1] + nums[0]) {\n                break;\n            }\n            t++;\n        }\n        return t;\n    }",
        "trans_code": "public : int maxOperations ( vector < int > & nums ) {\n  int n = nums . size ( ) , t = 0 ;\n  for ( int i = 1 ;\n  i < n ;\n  i += 2 ) {\n    if ( nums [ i ] + nums [ i - 1 ] != nums [ 1 ] + nums [ 0 ] ) break ;\n    t ++ ;\n  }\n  return t ;\n}\n",
        "reference_code": "    int maxOperations(vector<int>& nums) {\n        int n = nums.size(), t = 0;\n        for (int i = 1; i < n; i += 2) {\n            if (nums[i] + nums[i - 1] != nums[1] + nums[0]) {\n                break;\n            }\n            t++;\n        }\n        return t;\n    }",
        "target_Lan": "cpp###maxOperations.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    vector<int> nums1 = {1,2,3,4,5,6};\n    cout << maxOperations(nums1) << endl;\n\n    vector<int> nums2 = {1,1,1,1,1,1};\n    cout << maxOperations(nums2) << endl;\n\n    vector<int> nums3 = {1,2,3,4,5,7};\n    cout << maxOperations(nums3) << endl;\n\n    vector<int> nums4 = {1,1,2,2,3,3};\n    cout << maxOperations(nums4) << endl;\n\n    vector<int> nums5 = {1,2,3,4,5,6,7,8,9,10};\n    cout << maxOperations(nums5) << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###findMissingAndRepeatedValues_Test.java",
        "source_code": "    public static int[] findMissingAndRepeatedValues(int[][] grid) {\n        int n = grid.length;\n        int[] count = new int[n * n + 1];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                count[grid[i][j]]++;\n            }\n        }\n        int[] res = new int[2];\n        for (int i = 1; i <= n * n; i++) {\n            if (count[i] == 2) {\n                res[0] = i;\n            }\n            if (count[i] == 0) {\n                res[1] = i;\n            }\n        }\n        return res;\n    }",
        "trans_code": "public : vector < int > findMissingAndRepeatedValues ( vector < vector < int >> & grid ) {\n  int n = grid . size ( ) ;\n  vector < int > count ( n * n + 1 , 0 ) ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < n ;\n    j ++ ) {\n      count [ grid [ i ] [ j ] ] ++ ;\n    }\n  }\n  vector < int > res ( 2 , 0 ) ;\n  for ( int i = 1 ;\n  i <= n * n ;\n  i ++ ) {\n    if ( count [ i ] == 2 ) res [ 0 ] = i ;\n    if ( count [ i ] == 0 ) res [ 1 ] = i ;\n  }\n  return res ;\n}\n",
        "reference_code": "    vector<int> findMissingAndRepeatedValues(vector<vector<int>>& grid) {\n        int n = grid.size();\n        vector<int> count(n * n + 1);\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                count[grid[i][j]]++;\n            }\n        }\n        vector<int> res(2);\n        for (int i = 1; i <= n * n; i++) {\n            if (count[i] == 2) {\n                res[0] = i;\n            }\n            if (count[i] == 0) {\n                res[1] = i;\n            }\n        }\n        return res;\n    }",
        "target_Lan": "cpp###findMissingAndRepeatedValues.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    vector<vector<int>> grid1 = {{1,2,3},{4,5,6},{7,8,9}};\n    vector<vector<int>> grid2 = {{1,1,1},{2,2,2},{3,3,3}};\n    vector<vector<int>> grid3 = {{1,2,3},{4,5,6},{7,8,8}};\n    vector<vector<int>> grid4 = {{1,2,3},{4,5,6},{7,8,0}};\n    vector<vector<int>> grid5 = {{1,2,3},{4,0,6},{7,8,9}};\n\n    vector<int> res = findMissingAndRepeatedValues(grid1);\n    cout << res[0] << \" \" << res[1] << endl;\n    res = findMissingAndRepeatedValues(grid2);\n    cout << res[0] << \" \" << res[1] << endl;\n    res = findMissingAndRepeatedValues(grid3);\n    cout << res[0] << \" \" << res[1] << endl;\n    res = findMissingAndRepeatedValues(grid4);\n    cout << res[0] << \" \" << res[1] << endl;\n    res = findMissingAndRepeatedValues(grid5);\n    cout << res[0] << \" \" << res[1] << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###findMinimumTime_Test.java",
        "source_code": "    public static int findMinimumTime(int[][] tasks) {\n        int n = tasks.length;\n        Arrays.sort(tasks, (a, b) -> a[1] - b[1]);\n        int[] run = new int[tasks[n - 1][1] + 1];\n        int res = 0;\n        for (int i = 0; i < n; i++) {\n            int start = tasks[i][0], end = tasks[i][1], duration = tasks[i][2];\n            for (int j = start; j <= end; j++) {\n                duration -= run[j];\n            }\n            res += Math.max(duration, 0);\n            for (int j = end; j >= 0 && duration > 0; j--) {\n                if (run[j] == 0) {\n                    duration--;\n                    run[j] = 1;\n                }\n            }\n        }\n        return res;\n    }",
        "trans_code": "public : int findMinimumTime ( vector < vector < int >> & tasks ) {\n  int n = tasks . size ( ) ;\n  sort ( tasks . begin ( ) , tasks . end ( ) ) ;\n  vector < int > run ( tasks [ n - 1 ] . size ( ) + 1 , 0 ) ;\n  int res = 0 ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    int start = tasks [ i ] [ 0 ] , end = tasks [ i ] [ 1 ] , duration = tasks [ i ] [ 2 ] ;\n    for ( int j = start ;\n    j <= end ;\n    j ++ ) duration -= run [ j ] ;\n    res += max ( duration , 0 ) ;\n    for ( int j = end ;\n    j >= 0 && duration > 0 ;\n    j -- ) {\n      if ( run [ j ] == 0 ) {\n        duration -- ;\n        run [ j ] = 1 ;\n      }\n    }\n  }\n  return res ;\n}\n",
        "reference_code": "    int findMinimumTime(vector<vector<int>>& tasks) {\n        int n = tasks.size();\n        sort(tasks.begin(), tasks.end(), [&](const vector<int> &t1, const vector<int> &t2) -> bool {\n            return t1[1] < t2[1];\n        });\n        vector<int> run(tasks[n - 1][1] + 1);\n        int res = 0;\n        for (int i = 0; i < n; i++) {\n            int start = tasks[i][0], end = tasks[i][1], duration = tasks[i][2];\n            duration -= accumulate(run.begin() + start, run.begin() + end + 1, 0);\n            res += max(duration, 0);\n            for (int j = end; j >= 0 && duration > 0; j--) {\n                if (run[j] == 0) {\n                    duration--;\n                    run[j] = 1;\n                }\n            }\n        }\n        return res;\n    }",
        "target_Lan": "cpp###findMinimumTime.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n// TOFILL\nint main() {\n    vector<vector<int>> tasks1 = {{1, 2, 1}, {2, 3, 1}, {3, 4, 1}};\n    cout << findMinimumTime(tasks1) << endl;\n\n    vector<vector<int>> tasks2 = {{1, 3, 2}, {2, 5, 3}, {3, 6, 1}};\n    cout << findMinimumTime(tasks2) << endl;\n\n    vector<vector<int>> tasks3 = {{1, 2, 1}, {2, 3, 2}, {3, 4, 3}};\n    cout << findMinimumTime(tasks3) << endl;\n\n    vector<vector<int>> tasks4 = {{1, 2, 1}, {2, 3, 2}, {3, 4, 4}};\n    cout << findMinimumTime(tasks4) << endl;\n\n    vector<vector<int>> tasks5 = {{1, 2, 1}, {2, 3, 3}, {3, 4, 5}};\n    cout << findMinimumTime(tasks5) << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###garbageCollection_Test.java",
        "source_code": "    public static int garbageCollection(String[] garbage, int[] travel) {\n        Map<Character, Integer> distance = new HashMap<>();\n        int res = 0, curDis = 0;\n        for (int i = 0; i < garbage.length; i++) {\n            res += garbage[i].length();\n            if (i > 0) {\n                curDis += travel[i - 1];\n            }\n            for (char c : garbage[i].toCharArray()) {\n                distance.put(c, curDis);\n            }\n        }\n        return res + distance.values().stream().reduce(0, Integer::sum);\n    }",
        "trans_code": "int garbageCollection ( vector < string > garbage , vector < int > travel ) {\n  map < char , int > distance ;\n  int res = 0 , curDis = 0 ;\n  for ( int i = 0 ;\n  i < garbage . size ( ) ;\n  i ++ ) {\n    res += garbage [ i ] . size ( ) ;\n    if ( i > 0 ) curDis += travel [ i - 1 ] ;\n    for ( char c : garbage [ i ] ) distance [ c ] = curDis ;\n  }\n  return res + distance . size ( ) ;\n}\n",
        "reference_code": "    int garbageCollection(vector<string>& garbage, vector<int>& travel) {\n        unordered_map<char, int> distance;\n        int res = 0, cur_dis = 0;\n        for (int i = 0; i < garbage.size(); i++) {\n            res += garbage[i].size();\n            if (i > 0) {\n                cur_dis += travel[i - 1];\n            }\n            for (auto c : garbage[i]) {\n                distance[c] = cur_dis;\n            }\n        }\n        for (auto &[k, v] : distance) {\n            res += v;\n        }\n        return res;\n    }",
        "target_Lan": "cpp###garbageCollection.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <string>\n// TOFILL\nint main() {\n    vector<string> garbage1 = {\"G\",\"P\",\"GP\",\"GG\"};\n    vector<int> travel1 = {2,4,3};\n    cout << garbageCollection(garbage1, travel1) << endl;\n\n    vector<string> garbage2 = {\"MMM\",\"PGM\",\"GP\"};\n    vector<int> travel2 = {3,10};\n    cout << garbageCollection(garbage2, travel2) << endl;\n\n    vector<string> garbage3 = {\"G\",\"P\",\"GP\",\"GG\",\"GP\"};\n    vector<int> travel3 = {2,4,3,5};\n    cout << garbageCollection(garbage3, travel3) << endl;\n\n    vector<string> garbage4 = {\"MMM\",\"PGM\",\"GP\",\"GP\"};\n    vector<int> travel4 = {3,10,2};\n    cout << garbageCollection(garbage4, travel4) << endl;\n\n    vector<string> garbage5 = {\"G\",\"P\",\"GP\",\"GG\",\"GP\"};\n    vector<int> travel5 = {2,4,3,5,6};\n    cout << garbageCollection(garbage5, travel5) << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###totalCost_Test.java",
        "source_code": "    public static long totalCost(int[] costs, int k, int candidates) {\n        int n = costs.length;\n        PriorityQueue<int[]> pq = new PriorityQueue<int[]>((a, b) -> a[0] != b[0] ? a[0] - b[0] : a[1] - b[1]);\n        int left = candidates - 1, right = n - candidates;\n        if (left + 1 < right) {\n            for (int i = 0; i <= left; ++i) {\n                pq.offer(new int[]{costs[i], i});\n            }\n            for (int i = right; i < n; ++i) {\n                pq.offer(new int[]{costs[i], i});\n            }\n        } else {\n            for (int i = 0; i < n; ++i) {\n                pq.offer(new int[]{costs[i], i});\n            }\n        }\n        long ans = 0;\n        for (int i = 0; i < k; ++i) {\n            int[] arr = pq.poll();\n            int cost = arr[0], id = arr[1];\n            ans += cost;\n            if (left + 1 < right) {\n                if (id <= left) {\n                    ++left;\n                    pq.offer(new int[]{costs[left], left});\n                } else {\n                    --right;\n                    pq.offer(new int[]{costs[right], right});\n                }\n            }\n        }\n        return ans;\n    }",
        "trans_code": "public : long long totalCost ( vector < int > costs , int k , int candidates ) {\n  int n = costs . size ( ) ;\n  priority_queue < int , vector < int > , greater < int >> pq ( ( a , b ) , queue < int > ( ) ) ;\n  int left = candidates - 1 , right = n - candidates ;\n  if ( left + 1 < right ) {\n    for ( int i = 0 ;\n    i <= left ;\n    ++ i ) pq . push ( make_pair ( costs [ i ] , i ) ) ;\n    for ( int i = right ;\n    i < n ;\n    ++ i ) pq . push ( make_pair ( costs [ i ] , i ) ) ;\n  }\n  else {\n    for ( int i = 0 ;\n    i < n ;\n    ++ i ) pq . push ( make_pair ( costs [ i ] , i ) ) ;\n  }\n  long long ans = 0 ;\n  for ( int i = 0 ;\n  i < k ;\n  ++ i ) {\n    vector < int > arr = pq . top ( ) ;\n    int cost = arr [ 0 ] , id = arr [ 1 ] ;\n    ans += cost ;\n    if ( left + 1 < right ) {\n      if ( id <= left ) {\n        ++ left ;\n        pq . push ( make_pair ( costs [ left ] , left ) ) ;\n      }\n      else {\n        -- right ;\n        pq . push ( make_pair ( costs [ right ] , right ) ) ;\n      }\n    }\n  }\n  return ans ;\n}\n",
        "reference_code": "    long long totalCost(vector<int>& costs, int k, int candidates) {\n        int n = costs.size();\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> q;\n        int left = candidates - 1, right = n - candidates;\n        if (left + 1 < right) {\n            for (int i = 0; i <= left; ++i) {\n                q.emplace(costs[i], i);\n            }\n            for (int i = right; i < n; ++i) {\n                q.emplace(costs[i], i);\n            }\n        }\n        else {\n            for (int i = 0; i < n; ++i) {\n                q.emplace(costs[i], i);\n            }\n        }\n        long long ans = 0;\n        for (int _ = 0; _ < k; ++_) {\n            auto [cost, id] = q.top();\n            q.pop();\n            ans += cost;\n            if (left + 1 < right) {\n                if (id <= left) {\n                    ++left;\n                    q.emplace(costs[left], left);\n                }\n                else {\n                    --right;\n                    q.emplace(costs[right], right);\n                }\n            }\n        }\n        return ans;\n    }",
        "target_Lan": "cpp###totalCost.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <queue>\n// TOFILL\nint main() {\n    vector<int> costs1 = {1,2,3,4,5};\n    cout << totalCost(costs1, 2, 2) << endl;\n\n    vector<int> costs2 = {5,4,3,2,1};\n    cout << totalCost(costs2, 3, 1) << endl;\n\n    vector<int> costs3 = {10,20,30,40,50};\n    cout << totalCost(costs3, 1, 3) << endl;\n\n    vector<int> costs4 = {100,200,300,400,500};\n    cout << totalCost(costs4, 5, 5) << endl;\n\n    vector<int> costs5 = {1000,2000,3000,4000,5000};\n    cout << totalCost(costs5, 3, 2) << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###minOperations2_Test.java",
        "source_code": "    public static int minOperations2(int[] nums) {\n        int n = nums.length;\n        Set<Integer> set = new HashSet<Integer>();\n        for (int num : nums) {\n            set.add(num);\n        }\n        List<Integer> sortedUniqueNums = new ArrayList<Integer>(set);\n        Collections.sort(sortedUniqueNums);\n        int res = n;\n        int j = 0;\n        for (int i = 0; i < sortedUniqueNums.size(); i++) {\n            int left = sortedUniqueNums.get(i);\n            int right = left + n - 1;\n            while (j < sortedUniqueNums.size() && sortedUniqueNums.get(j) <= right) {\n                res = Math.min(res, n - (j - i + 1));\n                j++;\n            }\n        }\n        return res;\n    }",
        "trans_code": "public : int minOperations2 ( vector < int > & nums ) {\n  int n = nums . size ( ) ;\n  set < int > set ;\n  for ( int num : nums ) set . insert ( num ) ;\n  vector < int > sortedUniqueNums ( set ) ;\n  sort ( sortedUniqueNums . begin ( ) , sortedUniqueNums . end ( ) ) ;\n  int res = n ;\n  int j = 0 ;\n  for ( int i = 0 ;\n  i < sortedUniqueNums . size ( ) ;\n  i ++ ) {\n    int left = sortedUniqueNums [ i ] ;\n    int right = left + n - 1 ;\n    while ( j < sortedUniqueNums . size ( ) && sortedUniqueNums [ j ] <= right ) {\n      res = min ( res , n - ( j - i + 1 ) ) ;\n      j ++ ;\n    }\n  }\n  return res ;\n}\n",
        "reference_code": "    int minOperations2(vector<int>& nums) {\n        int n = nums.size();\n        unordered_set<int> cnt(nums.begin(), nums.end());\n        vector<int> sortedUniqueNums(cnt.begin(), cnt.end());\n        sort(sortedUniqueNums.begin(), sortedUniqueNums.end());\n        int res = n, j = 0;\n        for (int i = 0; i < sortedUniqueNums.size(); i++) {\n            int right = sortedUniqueNums[i] + n - 1;\n            while (j < sortedUniqueNums.size() && sortedUniqueNums[j] <= right) {\n                res = min(res, n - (j - i + 1));\n                j++;\n            }\n        }            \n        return res;\n    }",
        "target_Lan": "cpp###minOperations2.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <unordered_set>\n// TOFILL\nint main() {\n    vector<int> nums1 = {1,2,3,4,5};\n    vector<int> nums2 = {1,1,1,1,1};\n    vector<int> nums3 = {-1,-2,-3,-4,-5};\n    vector<int> nums4 = {10,20,30,40,50};\n    vector<int> nums5 = {5,4,3,2,1};\n    cout << minOperations2(nums1) << endl;\n    cout << minOperations2(nums2) << endl;\n    cout << minOperations2(nums3) << endl;\n    cout << minOperations2(nums4) << endl;\n    cout << minOperations2(nums5) << endl;\n    return 0;\n}"
    },
    {
        "source_Lan": "java###distinctIntegers_Test.java",
        "source_code": "    public static int distinctIntegers(int n) {\n        int[] nums = new int[n + 1];\n        nums[n] = 1;\n        for (int k = 0; k < n; k++) {\n            for (int x = 1; x <= n; x++) {\n                if (nums[x] == 0) {\n                    continue;\n                }\n                for (int i = 1; i <= n; i++) {\n                    if (x % i == 1) {\n                        nums[i] = 1;\n                    }\n                }\n            }\n        }\n        return Arrays.stream(nums).sum();\n    }",
        "trans_code": "public : int distinctIntegers ( int n ) {\n  vector < int > nums ( n + 1 , 1 ) ;\n  nums [ n ] = 1 ;\n  for ( int k = 0 ;\n  k < n ;\n  k ++ ) {\n    for ( int x = 1 ;\n    x <= n ;\n    x ++ ) {\n      if ( nums [ x ] == 0 ) continue ;\n      for ( int i = 1 ;\n      i <= n ;\n      i ++ ) {\n        if ( x % i == 1 ) nums [ i ] = 1 ;\n      }\n    }\n  }\n  return accumulate ( nums . begin ( ) , nums . end ( ) , 0 ) ;\n}\n",
        "reference_code": "    int distinctIntegers(int n) {\n        vector<int> nums(n + 1);\n        nums[n] = 1;\n        for (int k = 0; k < n; k++) {\n            for (int x = 1; x <= n; x++) {\n                if (nums[x] == 0) {\n                    continue;\n                }\n                for (int i = 1; i <= n; i++) {\n                    if (x % i == 1) {\n                        nums[i] = 1;\n                    }\n                }\n            }\n        }\n        return accumulate(nums.begin(), nums.end(), 0);\n    }",
        "target_Lan": "cpp###distinctIntegers.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <numeric>\n// TOFILL\nint main() {\n    cout << distinctIntegers(0) << endl;\n    cout << distinctIntegers(1) << endl;\n    cout << distinctIntegers(5) << endl;\n    cout << distinctIntegers(10) << endl;\n    cout << distinctIntegers(100) << endl;\n    return 0;\n}"
    },
    {
        "source_Lan": "java###divisibilityArray_Test.java",
        "source_code": "    public static int[] divisibilityArray(String word, int m) {\n        int[] res = new int[word.length()];\n        long cur = 0;\n        for (int i = 0; i < word.length(); i++) {\n            char c = word.charAt(i);\n            cur = (cur * 10 + (c - '0')) % m;\n            res[i] = (cur == 0) ? 1 : 0;\n        }\n        return res;\n    }",
        "trans_code": "public : vector < int > divisibilityArray ( string word , int m ) {\n  vector < int > res ;\n  long cur = 0 ;\n  for ( int i = 0 ;\n  i < word . length ( ) ;\n  i ++ ) {\n    char c = word [ i ] ;\n    cur = ( cur * 10 + ( c - '0' ) ) % m ;\n    res . push_back ( ( cur == 0 ) ? 1 : 0 ) ;\n  }\n  return res ;\n}\n",
        "reference_code": "    vector<int> divisibilityArray(string word, int m) {\n        vector<int> res;\n        long long cur = 0;\n        for (char& c : word) {\n            cur = (cur * 10 + (c - '0')) % m;\n            res.push_back(cur == 0 ? 1 : 0);\n        }\n        return res;\n    }",
        "target_Lan": "cpp###divisibilityArray.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <string>\n// TOFILL\nint main() {\n    vector<int> res = divisibilityArray(\"1234567890\", 1);\n    for(int i : res) {\n        cout << i << \" \";\n    }\n    cout << endl;\n\n    res = divisibilityArray(\"1234567890\", 10);\n    for(int i : res) {\n        cout << i << \" \";\n    }\n    cout << endl;\n\n    res = divisibilityArray(\"1234567890\", 100);\n    for(int i : res) {\n        cout << i << \" \";\n    }\n    cout << endl;\n\n    res = divisibilityArray(\"1234567890\", 1000);\n    for(int i : res) {\n        cout << i << \" \";\n    }\n    cout << endl;\n\n    res = divisibilityArray(\"1234567890\", 10000);\n    for(int i : res) {\n        cout << i << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###minimumTime_Test.java",
        "source_code": "    public static int minimumTime(List<Integer> nums1, List<Integer> nums2, int x) {\n        int n = nums1.size(), s1 = 0, s2 = 0;\n        int[][] dp = new int[n + 1][n + 1];\n        List<List<Integer>> nums = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            int a = nums1.get(i), b = nums2.get(i);\n            nums.add(Arrays.asList(b, a));\n            s1 += a;\n            s2 += b;\n        }\n        Collections.sort(nums, (o1, o2) -> Integer.compare(o1.get(0), o2.get(0)));\n        for (int j = 1; j <= n; ++j) {\n            int b = nums.get(j - 1).get(0), a = nums.get(j - 1).get(1);\n            for (int i = j; i > 0; --i) {\n                dp[j][i] = Math.max(dp[j - 1][i], dp[j - 1][i - 1] + i * b + a);\n            }\n        }\n        for (int i = 0; i <= n; i++) {\n            if (s2 * i + s1 - dp[n][i] <= x) {\n                return i;\n            }\n        }\n        return -1;\n    }",
        "trans_code": "public : int minimumTime ( vector < int > & nums1 , vector < int > & nums2 , int x ) {\n  int n = nums1 . size ( ) , s1 = 0 , s2 = 0 ;\n  vector < vector < int >> dp ( n + 1 , vector < int > ( n + 1 , 0 ) ) ;\n  vector < vector < int >> nums ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    int a = nums1 [ i ] , b = nums2 [ i ] ;\n    nums . push_back ( vector < int > ( b , a ) ) ;\n    s1 += a ;\n    s2 += b ;\n  }\n  sort ( nums . begin ( ) , nums . end ( ) , ( int ( * ) ( int ) ) cmp ) ;\n  for ( int j = 1 ;\n  j <= n ;\n  ++ j ) {\n    int b = nums [ j - 1 ] [ 0 ] , a = nums [ j - 1 ] [ 1 ] ;\n    for ( int i = j ;\n    i > 0 ;\n    -- i ) dp [ j ] [ i ] = max ( dp [ j - 1 ] [ i ] , dp [ j - 1 ] [ i - 1 ] + i * b + a ) ;\n  }\n  for ( int i = 0 ;\n  i <= n ;\n  ++ i ) {\n    if ( s2 * i + s1 - dp [ n ] [ i ] <= x ) return i ;\n  }\n  return - 1 ;\n}\n",
        "reference_code": "    int minimumTime(vector<int>& nums1, vector<int>& nums2, int x) {\n        int n = nums1.size();\n        vector<vector<int>> dp(n + 1, vector<int>(n + 1, 0));\n        vector<pair<int, int>> nums(n);\n        for (int i = 0; i < n; i++) {\n            nums[i] = {nums2[i], nums1[i]};\n        }\n        sort(nums.begin(), nums.end());\n        for (int j = 1; j <= n; j++) {\n            int b = nums[j - 1].first, a = nums[j - 1].second;\n            for (int i = j; i > 0; i--) {\n                dp[j][i] = max(dp[j - 1][i], dp[j - 1][i - 1] + i * b + a);\n            }\n        }\n        int s1 = accumulate(nums1.begin(), nums1.end(), 0);\n        int s2 = accumulate(nums2.begin(), nums2.end(), 0);\n        for (int i = 0; i <= n; i++) {\n            if (s2 * i + s1 - dp[n][i] <= x) {\n                return i;\n            }\n        }\n        return -1;\n    }",
        "target_Lan": "cpp###minimumTime.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <numeric>\n#include <algorithm>\n// TOFILL\nint main() {\n    vector<int> nums1 = {1, 2, 3};\n    vector<int> nums2 = {1, 2, 3};\n    cout << minimumTime(nums1, nums2, 6) << endl;\n\n    nums1 = {1, 1, 1};\n    nums2 = {1, 1, 1};\n    cout << minimumTime(nums1, nums2, 3) << endl;\n\n    nums1 = {1, 2, 3};\n    nums2 = {3, 2, 1};\n    cout << minimumTime(nums1, nums2, 6) << endl;\n\n    nums1 = {1, 1, 1};\n    nums2 = {2, 2, 2};\n    cout << minimumTime(nums1, nums2, 6) << endl;\n\n    nums1 = {1, 2, 3};\n    nums2 = {3, 2, 1};\n    cout << minimumTime(nums1, nums2, 7) << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###minLength_Test.java",
        "source_code": "    public static int minLength(String s) {\n        List<Character> stack = new ArrayList<Character>();\n        for (int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n            stack.add(c);\n            int m = stack.size();\n            if (m >= 2 &&\n                (stack.get(m - 2) == 'A' && stack.get(m - 1) == 'B' ||\n                stack.get(m - 2) == 'C' && stack.get(m - 1) == 'D')) {\n                stack.remove(m - 1);\n                stack.remove(m - 2);\n            }\n        }\n        return stack.size();\n    }",
        "trans_code": "public : int minLength ( string s ) {\n  vector < char > stack ;\n  for ( int i = 0 ;\n  i < s . length ( ) ;\n  i ++ ) {\n    char c = s [ i ] ;\n    stack . push_back ( c ) ;\n    int m = stack . size ( ) ;\n    if ( m >= 2 && ( stack [ m - 2 ] == 'A' && stack [ m - 1 ] == 'B' || stack [ m - 2 ] == 'C' && stack [ m - 1 ] == 'D' ) ) {\n      stack . erase ( stack . begin ( ) + m - 1 ) ;\n      stack . erase ( stack . begin ( ) + m - 2 ) ;\n    }\n  }\n  return stack . size ( ) ;\n}\n",
        "reference_code": "    int minLength(string s) {\n        vector<int> st;\n        for (char c : s) {\n            st.push_back(c);\n            int m = st.size();\n            if (m >= 2 &&\n                (st[m - 2] == 'A' && st[m - 1] == 'B' ||\n                st[m - 2] == 'C' && st[m - 1] == 'D')) {\n                st.pop_back();\n                st.pop_back();\n            }\n        }\n        return st.size();\n    }",
        "target_Lan": "cpp###minLength.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <string>\n// TOFILL\nint main() {\n    cout << minLength(\"\") << endl;\n    cout << minLength(\"AB\") << endl;\n    cout << minLength(\"ABCD\") << endl;\n    cout << minLength(\"AAAABBBBCCCCDDDD\") << endl;\n    cout << minLength(\"ABCDABCDABCDABCD\") << endl;\n    return 0;\n}"
    },
    {
        "source_Lan": "java###frequency_Test.java",
        "source_code": "    public static int[] frequency(int n,int a[]) {\n        HashMap<Integer,Integer> hm=new HashMap<>();\n        int ans[]=new int[n];\n        for(int i:a){\n            hm.put(i,hm.getOrDefault(i,0)+1);\n        }\n        for(int i=0;i<n;i++){\n            ans[i]=hm.get(a[i]);\n            hm.put(a[i],hm.get(a[i])-1);\n        }\n        return ans;\n    }",
        "trans_code": "public : vector < int > frequency ( int n , vector < int > a ) {\n  unordered_map < int , int > hm ;\n  vector < int > ans ;\n  for ( int i : a ) hm [ i ] = hm . getOrDefault ( i , 0 ) + 1 ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    ans [ i ] = hm [ a [ i ] ] ;\n    hm [ a [ i ] ] = hm [ a [ i ] ] - 1 ;\n  }\n  return ans ;\n}\n",
        "reference_code": "    vector<int> frequency(int n, vector<int> &a){\n        vector<int>ans(n);\n        unordered_map<int,int>mp;\n        for(int i=n-1;i>-1;i--)\n        {\n            mp[a[i]]++;\n            ans[i]=mp[a[i]];\n        }\n        return ans;\n    }",
        "target_Lan": "cpp###frequency.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n// TOFILL\nint main() {\n    int n = 0;\n    vector<int> a = {};\n    vector<int> ans = frequency(n, a);\n    for(int i=0; i<ans.size(); i++)\n        cout << ans[i] << \" \";\n    cout << endl;\n\n    n = 1;\n    a = {1};\n    ans = frequency(n, a);\n    for(int i=0; i<ans.size(); i++)\n        cout << ans[i] << \" \";\n    cout << endl;\n\n    n = 2;\n    a = {1, 1};\n    ans = frequency(n, a);\n    for(int i=0; i<ans.size(); i++)\n        cout << ans[i] << \" \";\n    cout << endl;\n\n    n = 3;\n    a = {1, 2, 3};\n    ans = frequency(n, a);\n    for(int i=0; i<ans.size(); i++)\n        cout << ans[i] << \" \";\n    cout << endl;\n\n    n = 5;\n    a = {1, 1, 2, 2, 3};\n    ans = frequency(n, a);\n    for(int i=0; i<ans.size(); i++)\n        cout << ans[i] << \" \";\n    cout << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###canTrade_Test.java",
        "source_code": "    public static int[] canTrade(int n, int[] beautifulness, int q, int[][] queries) {\n        int prev = beautifulness[0];\n        beautifulness[0] = 0;\n        for (int i = 1; i < n; i++) {\n            int curr = beautifulness[i];\n            if (beautifulness[i] == prev) {\n                beautifulness[i] = beautifulness[i - 1];\n            } else {\n                beautifulness[i] = i;\n            }\n            prev = curr;\n        }\n        int[] ans = new int[q];\n        for (int i = 0; i < q; i++) {\n            int u = queries[i][0] - 1, v = queries[i][1] - 1;\n            ans[i] = beautifulness[v] <= u ? 1 : 0;\n        }\n        return ans;\n    }",
        "trans_code": "public : vector < int > canTrade ( int n , vector < int > & beautifulness , int q , vector < vector < int >> & queries ) {\n  int prev = beautifulness [ 0 ] ;\n  beautifulness [ 0 ] = 0 ;\n  for ( int i = 1 ;\n  i < n ;\n  i ++ ) {\n    int curr = beautifulness [ i ] ;\n    if ( beautifulness [ i ] == prev ) beautifulness [ i ] = beautifulness [ i - 1 ] ;\n    else beautifulness [ i ] = i ;\n    prev = curr ;\n  }\n  vector < int > ans ;\n  for ( int i = 0 ;\n  i < q ;\n  i ++ ) {\n    int u = queries [ i ] [ 0 ] - 1 , v = queries [ i ] [ 1 ] - 1 ;\n    ans . push_back ( beautifulness [ v ] <= u ? 1 : 0 ) ;\n  }\n  return ans ;\n}\n",
        "reference_code": "    vector<int> canTrade(int n, vector<int>& beautifulness, int q,\n                         vector<vector<int>>& queries) {\n        int prev = beautifulness[0];\n        beautifulness[0] = 0;\n        for (int i = 1; i < n; i++) {\n            int curr = beautifulness[i];\n            if (beautifulness[i] == prev)\n                beautifulness[i] = beautifulness[i - 1];\n            else\n                beautifulness[i] = i;\n            prev = curr;\n        }\n        vector<int> ans(q);\n        for (int i = 0; i < q; i++) {\n            int u = queries[i][0], v = queries[i][1];\n            u--;\n            v--;\n            if (beautifulness[v] <= u)\n                ans[i] = 1;\n        }\n        return ans;\n    }",
        "target_Lan": "cpp###canTrade.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    int n1 = 5, q1 = 2;\n    vector<int> beautifulness1 = {1, 2, 3, 4, 5};\n    vector<vector<int>> queries1 = {{1, 2}, {3, 4}};\n    vector<int> ans1 = canTrade(n1, beautifulness1, q1, queries1);\n    for(int i = 0; i < ans1.size(); i++)\n        cout << ans1[i] << \" \";\n    cout << endl;\n\n    int n2 = 10, q2 = 3;\n    vector<int> beautifulness2 = {1, 1, 2, 2, 3, 3, 4, 4, 5, 5};\n    vector<vector<int>> queries2 = {{1, 2}, {3, 4}, {5, 6}};\n    vector<int> ans2 = canTrade(n2, beautifulness2, q2, queries2);\n    for(int i = 0; i < ans2.size(); i++)\n        cout << ans2[i] << \" \";\n    cout << endl;\n\n    int n3 = 1, q3 = 1;\n    vector<int> beautifulness3 = {1};\n    vector<vector<int>> queries3 = {{1, 1}};\n    vector<int> ans3 = canTrade(n3, beautifulness3, q3, queries3);\n    for(int i = 0; i < ans3.size(); i++)\n        cout << ans3[i] << \" \";\n    cout << endl;\n\n    int n4 = 2, q4 = 2;\n    vector<int> beautifulness4 = {1, 2};\n    vector<vector<int>> queries4 = {{1, 1}, {2, 2}};\n    vector<int> ans4 = canTrade(n4, beautifulness4, q4, queries4);\n    for(int i = 0; i < ans4.size(); i++)\n        cout << ans4[i] << \" \";\n    cout << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###sumDigitDifferences_Test.java",
        "source_code": "    public static long sumDigitDifferences(int[] nums) {\n        long ans = 0;\n        int[][] cnt = new int[Integer.toString(nums[0]).length()][10];\n        for (int k = 0; k < nums.length; k++) {\n            int x = nums[k];\n            for (int i = 0; x > 0; x /= 10, i++) {\n                int d = x % 10;\n                ans += k - cnt[i][d]++;\n            }\n        }\n        return ans;\n    }",
        "trans_code": "public : long long sumDigitDifferences ( vector < int > & nums ) {\n  long long ans = 0 ;\n  vector < vector < int >> cnt ( vector < int > ( nums . size ( ) ) , vector < int > ( 10 ) ) ;\n  for ( int k = 0 ;\n  k < nums . size ( ) ;\n  k ++ ) {\n    int x = nums [ k ] ;\n    for ( int i = 0 ;\n    x > 0 ;\n    x /= 10 , i ++ ) {\n      int d = x % 10 ;\n      ans += k - cnt [ i ] [ d ] ++ ;\n    }\n  }\n  return ans ;\n}\n",
        "reference_code": "    long long sumDigitDifferences(vector<int>& nums) {\n        long long ans = 0;\n        vector<array<int, 10>> cnt(to_string(nums[0]).length());\n        for (int k = 0; k < nums.size(); k++) {\n            int x = nums[k];\n            for (int i = 0; x; x /= 10, i++) {\n                int d = x % 10;\n                ans += k - cnt[i][d]++;\n            }\n        }\n        return ans;\n    }",
        "target_Lan": "cpp###sumDigitDifferences.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    vector<int> nums1 = {1, 2, 3, 4, 5};\n    cout << sumDigitDifferences(nums1) << endl;\n\n    vector<int> nums2 = {10, 20, 30, 40, 50};\n    cout << sumDigitDifferences(nums2) << endl;\n\n    vector<int> nums3 = {100, 200, 300, 400, 500};\n    cout << sumDigitDifferences(nums3) << endl;\n\n    vector<int> nums4 = {1000, 2000, 3000, 4000, 5000};\n    cout << sumDigitDifferences(nums4) << endl;\n\n    vector<int> nums5 = {10000, 20000, 30000, 40000, 50000};\n    cout << sumDigitDifferences(nums5) << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###numberGame_Test.java",
        "source_code": "    public static int[] numberGame(int[] nums) {\n        Arrays.sort(nums);\n        for (int i = 0; i < nums.length; i += 2) {\n            int tmp = nums[i];\n            nums[i] = nums[i + 1];\n            nums[i + 1] = tmp;\n        }\n        return nums;\n    }",
        "trans_code": "public : vector < int > numberGame ( vector < int > & nums ) {\n  sort ( nums . begin ( ) , nums . end ( ) ) ;\n  for ( int i = 0 ;\n  i < nums . size ( ) ;\n  i += 2 ) {\n    int tmp = nums [ i ] ;\n    nums [ i ] = nums [ i + 1 ] ;\n    nums [ i + 1 ] = tmp ;\n  }\n  return nums ;\n}\n",
        "reference_code": "    vector<int> numberGame(vector<int>& nums) {\n        sort(nums.begin(), nums.end());\n        for (int i = 0; i < nums.size(); i += 2) {\n            swap(nums[i], nums[i + 1]);\n        }\n        return nums;\n    }",
        "target_Lan": "cpp###numberGame.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <algorithm>\n// TOFILL\nint main() {\n    vector<int> nums1 = {1, 2, 3, 4, 5, 6};\n    vector<int> nums2 = {6, 5, 4, 3, 2, 1};\n    vector<int> nums3 = {1, 1, 1, 1, 1, 1};\n    vector<int> nums4 = {-1, -2, -3, -4, -5, -6};\n    vector<int> nums5 = {100, 200, 300, 400, 500, 600};\n\n    vector<int> result1 = numberGame(nums1);\n    vector<int> result2 = numberGame(nums2);\n    vector<int> result3 = numberGame(nums3);\n    vector<int> result4 = numberGame(nums4);\n    vector<int> result5 = numberGame(nums5);\n\n    for(int i = 0; i < result1.size(); i++) {\n        cout << result1[i] << \" \";\n    }\n    cout << endl;\n\n    for(int i = 0; i < result2.size(); i++) {\n        cout << result2[i] << \" \";\n    }\n    cout << endl;\n\n    for(int i = 0; i < result3.size(); i++) {\n        cout << result3[i] << \" \";\n    }\n    cout << endl;\n\n    for(int i = 0; i < result4.size(); i++) {\n        cout << result4[i] << \" \";\n    }\n    cout << endl;\n\n    for(int i = 0; i < result5.size(); i++) {\n        cout << result5[i] << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###minimumSteps_Test.java",
        "source_code": "    public static long minimumSteps(String s) {\n        long ans = 0;\n        int sum = 0;\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == '1') {\n                sum++;\n            } else {\n                ans += sum;\n            }\n        }\n        return ans;\n    }",
        "trans_code": "long long minimumSteps ( string s ) {\n  long long ans = 0 ;\n  int sum = 0 ;\n  for ( int i = 0 ;\n  i < s . length ( ) ;\n  i ++ ) {\n    if ( s [ i ] == '1' ) sum ++ ;\n    else ans += sum ;\n  }\n  return ans ;\n}\n",
        "reference_code": "    long long minimumSteps(string s) {\n        long long ans = 0;\n        int sum = 0;\n        for (int i = 0; i < s.size(); i++) {\n            if (s[i] == '1') {\n                sum++;\n            } else {\n                ans += sum;\n            }\n        }\n        return ans;\n    }",
        "target_Lan": "cpp###minimumSteps.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <string>\n// TOFILL\nint main() {\n    cout << minimumSteps(\"0\") << endl;\n    cout << minimumSteps(\"11111\") << endl;\n    cout << minimumSteps(\"00000\") << endl;\n    cout << minimumSteps(\"10101\") << endl;\n    cout << minimumSteps(\"1101110011\") << endl;\n}"
    },
    {
        "source_Lan": "java###minIncrements_Test.java",
        "source_code": "    public static int minIncrements(int n, int[] cost) {\n        int ans = 0;\n        for (int i = n - 2; i > 0; i -= 2) {\n            ans += Math.abs(cost[i] - cost[i + 1]);\n            \n            cost[i / 2] += Math.max(cost[i], cost[i + 1]);\n        }\n        return ans;\n    }",
        "trans_code": "public : int minIncrements ( int n , vector < int > & cost ) {\n  int ans = 0 ;\n  for ( int i = n - 2 ;\n  i > 0 ;\n  i -= 2 ) {\n    ans += abs ( cost [ i ] - cost [ i + 1 ] ) ;\n    cost [ i / 2 ] += max ( cost [ i ] , cost [ i + 1 ] ) ;\n  }\n  return ans ;\n}\n",
        "reference_code": "    int minIncrements(int n, vector<int>& cost) {\n        int ans = 0;\n        for (int i = n - 2; i > 0; i -= 2) {\n            ans += abs(cost[i] - cost[i + 1]);\n            \n            cost[i / 2] += max(cost[i], cost[i + 1]);\n        }\n        return ans;\n    }",
        "target_Lan": "cpp###minIncrements.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <algorithm>\n// TOFILL\nint main() {\n    vector<int> cost1 = {};\n    cout << minIncrements(0, cost1) << endl;\n\n    vector<int> cost2 = {1};\n    cout << minIncrements(1, cost2) << endl;\n\n    vector<int> cost3 = {1, 2};\n    cout << minIncrements(2, cost3) << endl;\n\n    vector<int> cost4 = {1, 2, 3};\n    cout << minIncrements(3, cost4) << endl;\n\n    vector<int> cost5 = {1, 2, 3, 4};\n    cout << minIncrements(4, cost5) << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###arrangingHorses_Test.java",
        "source_code": "    public static ArrayList<Integer> arrangingHorses(int n, int m, int[][] data) {\n        int[] inDegree = new int[n];\n        ArrayList<ArrayList<Integer>> adjList = new ArrayList<>();\n        for (int i = 0; i < n; i++) adjList.add(new ArrayList<>());\n        for (int[] edge : data) {\n            int a = edge[0], b = edge[1];\n            adjList.get(b).add(a); \n            ++inDegree[a];\n        }\n        PriorityQueue<Integer> pq = new PriorityQueue<>(); \n        for (int i = 0; i < n; ++i) {\n            if (inDegree[i] == 0) pq.add(i);\n        }\n        ArrayList<Integer> order = new ArrayList<>();\n        while (!pq.isEmpty()) {\n            int horse = pq.poll();\n            order.add(horse);\n            for (int neigh : adjList.get(horse)) {\n                --inDegree[neigh];\n                if (inDegree[neigh] == 0) pq.add(neigh);\n            }\n        }\n        return order;\n    }",
        "trans_code": "vector < int > arranging_horses ( int n , int m , vector < vector < int >> & data ) {\n  vector < int > in_degree ( n , 0 ) ;\n  vector < vector < int >> adj_list ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    adj_list . push_back ( vector < int > ( ) ) ;\n  }\n  for ( auto edge : data ) {\n    int a = edge . first , b = edge . second ;\n    adj_list [ b ] . push_back ( a ) ;\n    ++ in_degree [ a ] ;\n  }\n  priority_queue < int , vector < int >> pq ;\n  for ( int i = 0 ;\n  i < n ;\n  ++ i ) {\n    if ( in_degree [ i ] == 0 ) {\n      pq . push ( i ) ;\n    }\n  }\n  vector < int > order ;\n  while ( ! pq . empty ( ) ) {\n    int horse = pq . top ( ) ;\n    order . push_back ( horse ) ;\n    for ( auto neigh : adj_list [ horse ] ) {\n      -- in_degree [ neigh ] ;\n      if ( in_degree [ neigh ] == 0 ) {\n        pq . push ( neigh ) ;\n      }\n    }\n  }\n  return order ;\n}\n",
        "reference_code": "    vector<int> arrangingHorses(int n, int m, vector<vector<int>>& data) {\n        vector<int> inDegree(n, 0);\n        vector<vector<int>> adjList(n);\n        for (const auto& edge : data) {\n            int a = edge[0], b = edge[1];\n            adjList[b].push_back(a); \n            ++inDegree[a];\n        }\n        priority_queue<int, vector<int>, greater<int>> pq; \n        for (int i = 0; i < n; ++i) {\n            if (inDegree[i] == 0)\n                pq.push(i);\n        }\n        vector<int> order;\n        while (!pq.empty()) {\n            int horse = pq.top();\n            pq.pop();\n            order.push_back(horse);\n            for (int neigh : adjList[horse]) {\n                --inDegree[neigh];\n                if (inDegree[neigh] == 0)\n                    pq.push(neigh);\n            }\n        }\n        return order;\n    }",
        "target_Lan": "cpp###arrangingHorses.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <queue>\n// TOFILL\nint main() {\n    vector<vector<int>> data1 = {};\n    vector<vector<int>> data2 = {{1, 0}};\n    vector<vector<int>> data3 = {{1, 0}, {2, 1}, {3, 2}};\n    vector<vector<int>> data4 = {{0, 1}, {1, 2}, {2, 0}};\n    vector<vector<int>> data5 = {{0, 1}, {0, 2}, {1, 3}, {2, 4}};\n    \n    vector<int> result1 = arrangingHorses(3, 0, data1);\n    vector<int> result2 = arrangingHorses(2, 1, data2);\n    vector<int> result3 = arrangingHorses(4, 3, data3);\n    vector<int> result4 = arrangingHorses(3, 3, data4);\n    vector<int> result5 = arrangingHorses(5, 4, data5);\n    \n    for(int i : result1) cout << i << ' ';\n    cout << endl;\n    for(int i : result2) cout << i << ' ';\n    cout << endl;\n    for(int i : result3) cout << i << ' ';\n    cout << endl;\n    for(int i : result4) cout << i << ' ';\n    cout << endl;\n    for(int i : result5) cout << i << ' ';\n    cout << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###substringsAndPermutations_Test.java",
        "source_code": "    public static ArrayList<Integer> substringsAndPermutations(int n, int m, String s,\n                                                        String[] arr) {\n        Map<Character, List<Integer>> mp = new HashMap<>();\n        for (int i = 0; i < n; i++) {\n            char ch = s.charAt(i);\n            mp.computeIfAbsent(ch, k -> new ArrayList<>()).add(i);\n        }\n        ArrayList<Integer> ans = new ArrayList<>();\n        for (int q = 0; q < m; q++) {\n            String query = arr[q];\n            int ma = 0;\n            Map<Character, Integer> ct = new HashMap<>();\n            for (char c : query.toCharArray()) {\n                ct.put(c, ct.getOrDefault(c, 0) + 1);\n            }\n            for (char c : query.toCharArray()) {\n                int ele = ct.get(c);\n                if (ele > mp.getOrDefault(c, Collections.emptyList()).size()) {\n                    ma = -1;\n                    break;\n                } else {\n                    ma = Math.max(ma, mp.get(c).get(ele - 1) + 1);\n                }\n            }\n            ans.add(ma);\n        }\n        return ans;\n    }",
        "trans_code": "vector < int > substringsAndPermutations ( int n , int m , string s , vector < string > arr ) {\n  map < char , vector < int >> mp ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    char ch = s [ i ] ;\n    mp . insert ( make_pair ( ch , vector < int > ( ) ) ) ;\n  }\n  vector < int > ans ;\n  for ( int q = 0 ;\n  q < m ;\n  q ++ ) {\n    string query = arr [ q ] ;\n    int ma = 0 ;\n    map < char , int > ct ;\n    for ( char c : query ) ct [ c ] = ct . count ( c ) + 1 ;\n    for ( char c : query ) {\n      int ele = ct [ c ] ;\n      if ( ele > mp . count ( c ) ) {\n        ma = - 1 ;\n        break ;\n      }\n      else ma = max ( ma , mp [ c ] [ ele - 1 ] + 1 ) ;\n    }\n    ans . push_back ( ma ) ;\n  }\n  return ans ;\n}\n",
        "reference_code": "    vector<int> substringsAndPermutations(int n, int m, string s, vector<string>&arr){\n        map<char,vector<int>>mp;\n        for (int i=0;i<n;i++){\n            char ch=s[i];\n            mp[ch].push_back(i);\n        }\n        vector<int>ans;\n        for (auto j:arr){\n            int ma=0;\n            unordered_map<char,int>ct;\n            for (auto k:j){\n                ct[k]+=1;\n            }\n            for (auto k:j){\n                int ele=ct[k];\n                if (ele>mp[k].size()){\n                    ma=-1;\n                    break;\n                }\n                else {\n                    ma=max(ma,mp[k][ele-1]+1);\n                }\n            }\n            ans.push_back(ma);\n        }\n        return ans;\n    }",
        "target_Lan": "cpp###substringsAndPermutations.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <unordered_map>\n// TOFILL\nint main() {\n    // Test input 1\n    vector<string> arr1 = {};\n    vector<int> result1 = substringsAndPermutations(0, 0, \"\", arr1);\n    for(int res : result1) cout << res << \" \";\n    cout << endl;\n\n    // Test input 2\n    vector<string> arr2 = {\"abc\", \"ace\"};\n    vector<int> result2 = substringsAndPermutations(5, 2, \"abcde\", arr2);\n    for(int res : result2) cout << res << \" \";\n    cout << endl;\n\n    // Test input 3\n    vector<string> arr3 = {\"abc\"};\n    vector<int> result3 = substringsAndPermutations(6, 1, \"aabbcc\", arr3);\n    for(int res : result3) cout << res << \" \";\n    cout << endl;\n\n    // Test input 4\n    vector<string> arr4 = {\"xy\"};\n    vector<int> result4 = substringsAndPermutations(3, 1, \"xyz\", arr4);\n    for(int res : result4) cout << res << \" \";\n    cout << endl;\n\n    // Test input 5\n    vector<string> arr5 = {\"aa\", \"bb\", \"ab\"};\n    vector<int> result5 = substringsAndPermutations(4, 3, \"aabb\", arr5);\n    for(int res : result5) cout << res << \" \";\n    cout << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###numberOfSubarrays_Test.java",
        "source_code": "    public static long numberOfSubarrays(int[] nums) {\n        long ans = nums.length;\n        Deque<int[]> st = new ArrayDeque<>();\n        st.push(new int[]{Integer.MAX_VALUE, 0}); \n        for (int x : nums) {\n            while (x > st.peek()[0]) {\n                st.pop();\n            }\n            if (x == st.peek()[0]) {\n                ans += st.peek()[1]++;\n            } else {\n                st.push(new int[]{x, 1});\n            }\n        }\n        return ans;\n    }",
        "trans_code": "public : long long numberOfSubarrays ( vector < int > & nums ) {\n  long long ans = nums . size ( ) ;\n  deque < pair < int , int >> st ;\n  st . push_back ( make_pair ( INT_MAX , 0 ) ) ;\n  for ( auto x : nums ) {\n    while ( x > st . back ( ) . first ) st . pop_back ( ) ;\n    if ( x == st . back ( ) . first ) ans += st . back ( ) . second ++ ;\n    else st . push_back ( make_pair ( x , 1 ) ) ;\n  }\n  return ans ;\n}\n",
        "reference_code": "    long long numberOfSubarrays(vector<int>& nums) {\n        long long ans = nums.size();\n        stack<pair<int, int>> st;\n        st.emplace(INT_MAX, 0); \n        for (int x : nums) {\n            while (x > st.top().first) {\n                st.pop();\n            }\n            if (x == st.top().first) {\n                ans += st.top().second++;\n            } else {\n                st.emplace(x, 1);\n            }\n        }\n        return ans;\n    }",
        "target_Lan": "cpp###numberOfSubarrays.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <stack>\n#include <utility>\n#include <climits>\n// TOFILL\nint main() {\n    vector<int> input1 = {};\n    vector<int> input2 = {1};\n    vector<int> input3 = {1, 2, 2, 3};\n    vector<int> input4 = {5, 4, 3, 2, 1};\n    vector<int> input5 = {2, 2, 1, 3, 3};\n\n    cout << numberOfSubarrays(input1) << endl;\n    cout << numberOfSubarrays(input2) << endl;\n    cout << numberOfSubarrays(input3) << endl;\n    cout << numberOfSubarrays(input4) << endl;\n    cout << numberOfSubarrays(input5) << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###maximumPrimeDifference_Test.java",
        "source_code": "    public static int maximumPrimeDifference(int[] nums) {\n        Set<Integer> primes = new HashSet<>(Arrays.asList(\n            2, 3, 5, 7, 11,\n            13, 17, 19, 23, 29,\n            31, 37, 41, 43, 47,\n            53, 59, 61, 67, 71,\n            73, 79, 83, 89, 97\n        ));\n        int n = nums.length;\n        int first = -1, ans = 0;\n        for (int i = 0; i < n; ++i) {\n            if (primes.contains(nums[i])) {\n                if (first != -1) {\n                    ans = Math.max(ans, i - first);\n                } else {\n                    first = i;\n                }\n            }\n        }\n        return ans;\n    }",
        "trans_code": "public : int maximumPrimeDifference ( vector < int > & nums ) {\n  set < int > primes {\n    2 , 3 , 5 , 7 , 11 , 13 , 17 , 19 , 23 , 29 , 31 , 37 , 41 , 43 , 47 , 53 , 59 , 61 , 67 , 71 , 73 , 79 , 83 , 89 , 97 }\n    ;\n    int n = nums . size ( ) ;\n    int first = - 1 , ans = 0 ;\n    for ( int i = 0 ;\n    i < n ;\n    ++ i ) {\n      if ( primes . count ( nums [ i ] ) ) {\n        if ( first != - 1 ) ans = max ( ans , i - first ) ;\n        else first = i ;\n      }\n    }\n    return ans ;\n  }\n  ",
        "reference_code": "    int maximumPrimeDifference(vector<int>& nums) {\n        unordered_set<int> primes = {\n            2, 3, 5, 7, 11,\n            13, 17, 19, 23, 29,\n            31, 37, 41, 43, 47,\n            53, 59, 61, 67, 71,\n            73, 79, 83, 89, 97\n        };\n        int n = nums.size();\n        int first = -1, ans = 0;\n        for (int i = 0; i < n; ++i) {\n            if (primes.count(nums[i])) {\n                if (first != -1) {\n                    ans = max(ans, i - first);\n                }\n                else {\n                    first = i;\n                }\n            }\n        }\n        return ans;\n    }",
        "target_Lan": "cpp###maximumPrimeDifference.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <unordered_set>\n#include <vector>\n// TOFILL\nint main() {\n    vector<int> nums1 = {1, 4, 6, 8};\n    vector<int> nums2 = {2};\n    vector<int> nums3 = {2, 3, 5, 2, 3};\n    vector<int> nums4 = {2, 2, 3, 2};\n    vector<int> nums5 = {};\n\n    cout << maximumPrimeDifference(nums1) << endl; // Test input 1\n    cout << maximumPrimeDifference(nums2) << endl; // Test input 2\n    cout << maximumPrimeDifference(nums3) << endl; // Test input 3\n    cout << maximumPrimeDifference(nums4) << endl; // Test input 4\n    cout << maximumPrimeDifference(nums5) << endl; // Test input 5\n}"
    },
    {
        "source_Lan": "java###distinctDifferenceArray_Test.java",
        "source_code": "    public static int[] distinctDifferenceArray(int[] nums) {\n        int n = nums.length;\n        Set<Integer> set = new HashSet<Integer>();\n        int[] sufCnt = new int[n + 1];\n        for (int i = n - 1; i > 0; i--) {\n            set.add(nums[i]);\n            sufCnt[i] = set.size();\n        }\n        int[] res = new int[n];\n        set.clear();\n        for (int i = 0; i < n; i++) {\n            set.add(nums[i]);\n            res[i] = set.size() - sufCnt[i + 1];\n        }\n        return res;\n    }",
        "trans_code": "public : vector < int > distinctDifferenceArray ( vector < int > & nums ) {\n  int n = nums . size ( ) ;\n  set < int > set ;\n  vector < int > sufCnt ( n + 1 , 0 ) ;\n  for ( int i = n - 1 ;\n  i > 0 ;\n  i -- ) {\n    set . insert ( nums [ i ] ) ;\n    sufCnt [ i ] = set . size ( ) ;\n  }\n  vector < int > res ( n , 0 ) ;\n  set . clear ( ) ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    set . insert ( nums [ i ] ) ;\n    res [ i ] = set . size ( ) - sufCnt [ i + 1 ] ;\n  }\n  return res ;\n}\n",
        "reference_code": "    vector<int> distinctDifferenceArray(vector<int>& nums) {\n        int n = nums.size();\n        unordered_set<int> st;\n        vector<int> sufCnt(n + 1, 0);\n        for (int i = n - 1; i > 0; i--) {\n            st.insert(nums[i]);\n            sufCnt[i] = st.size();\n        }\n        vector<int> res;\n        st.clear();\n        for (int i = 0; i < n; i++) {\n            st.insert(nums[i]);\n            res.push_back(int(st.size()) - sufCnt[i + 1]);\n        }\n        return res;\n    }",
        "target_Lan": "cpp###distinctDifferenceArray.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <unordered_set>\n// TOFILL\nint main() {\n    vector<int> input1 = {};\n    vector<int> input2 = {1, 2, 3, 4, 5};\n    vector<int> input3 = {2, 2, 2, 2, 2};\n    vector<int> input4 = {1, 2, 2, 3, 4};\n    vector<int> input5 = {-1, -2, -3, -1, -2};\n\n    vector<int> output1 = distinctDifferenceArray(input1);\n    vector<int> output2 = distinctDifferenceArray(input2);\n    vector<int> output3 = distinctDifferenceArray(input3);\n    vector<int> output4 = distinctDifferenceArray(input4);\n    vector<int> output5 = distinctDifferenceArray(input5);\n\n    for(int val : output1) cout << val << \" \";\n    cout << endl;\n\n    for(int val : output2) cout << val << \" \";\n    cout << endl;\n\n    for(int val : output3) cout << val << \" \";\n    cout << endl;\n\n    for(int val : output4) cout << val << \" \";\n    cout << endl;\n\n    for(int val : output5) cout << val << \" \";\n    cout << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###findAnswer_Test.java",
        "source_code": "    public static ArrayList<Integer> findAnswer(int n, int[] A) \n    {\n        ArrayList<Long> pref = new ArrayList<>();\n        pref.add((long) A[0]);\n        \n        for (int i = 1; i < n; i++) {\n            pref.add(pref.get(i - 1) + A[i]);\n        }\n        Stack<Integer> s = new Stack<>();\n        ArrayList<Integer> res = new ArrayList<>();\n        for(int i=0;i<=n;i++)\n        {\n            res.add(0);\n        }\n        for (int i = 0; i < n; i++) {\n            if (pref.get(i) > 0) \n            {\n                res.set(0,i+1);\n                break;\n            }\n        }\n        for (int i = n - 1; i >= 0; i--) \n        {\n            while (!s.isEmpty() && pref.get(s.peek()) <= pref.get(i)) {\n                s.pop();\n            }\n            if (s.isEmpty()) \n            {\n                res.set(i+1,0);\n            } \n            else if (i < n - 1) \n            {\n                res.set(i + 1, s.peek() - i);\n            }\n            s.push(i);\n        }\n        res.remove(res.size() - 1);\n        return res;\n    }",
        "trans_code": "public : vector < int > findAnswer ( int n , vector < int > & A ) {\n  vector < long long > pref ;\n  pref . push_back ( ( long long ) A [ 0 ] ) ;\n  for ( int i = 1 ;\n  i < n ;\n  i ++ ) pref . push_back ( pref [ i - 1 ] + A [ i ] ) ;\n  stack < int > s ;\n  vector < int > res ;\n  for ( int i = 0 ;\n  i <= n ;\n  i ++ ) res . push_back ( 0 ) ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    if ( pref [ i ] > 0 ) {\n      res [ 0 ] = i + 1 ;\n      break ;\n    }\n  }\n  for ( int i = n - 1 ;\n  i >= 0 ;\n  i -- ) {\n    while ( ! s . empty ( ) && pref [ s . top ( ) ] <= pref [ i ] ) s . pop ( ) ;\n    if ( s . empty ( ) ) res [ i + 1 ] = 0 ;\n    else if ( i < n - 1 ) res [ i + 1 ] = s . top ( ) - i ;\n    s . push ( i ) ;\n  }\n  res . pop_back ( ) ;\n  return res ;\n}\n",
        "reference_code": "  vector<int> findAnswer(int n, vector<int> &A)\n  {\n    vector<long long> pref(n, A[0]);\n    for (int i = 1; i < n; i++)\n    {\n      pref[i] = pref[i - 1] + A[i];\n    }\n    stack<int> s;\n    vector<int> res(n+1, 0);\n    for (int i = 0; i < n; i++)\n    {\n      if (pref[i] > 0)\n      {\n        res[0] = i + 1;\n        break;\n      }\n    }\n    for (int i = n - 1; i >= 0; i--)\n    {\n      while (!s.empty() && pref[s.top()] <= pref[i])\n        s.pop();\n      if (s.empty())\n        res[i+1] = 0;\n      else if (i < n - 1)\n        res[i + 1] = s.top() - i;\n      s.push(i);\n    }\n    res.pop_back();\n    return res;\n  }",
        "target_Lan": "cpp###findAnswer.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <stack>\nusing namespace std;\n// TOFILL\nint main() {\n    // Test Input 1\n    int n1 = 1;\n    vector<int> A1 = {1};\n    vector<int> result1 = findAnswer(n1, A1);\n    for(int val : result1) cout << val << \" \";\n    cout << endl;\n\n    // Test Input 2\n    int n2 = 3;\n    vector<int> A2 = {0, 0, 0};\n    vector<int> result2 = findAnswer(n2, A2);\n    for(int val : result2) cout << val << \" \";\n    cout << endl;\n\n    // Test Input 3\n    int n3 = 5;\n    vector<int> A3 = {-1, -2, -3, -4, -5};\n    vector<int> result3 = findAnswer(n3, A3);\n    for(int val : result3) cout << val << \" \";\n    cout << endl;\n\n    // Test Input 4\n    int n4 = 6;\n    vector<int> A4 = {1000000000, -1000000000, 1000000000, -1000000000, 1000000000, -1000000000};\n    vector<int> result4 = findAnswer(n4, A4);\n    for(int val : result4) cout << val << \" \";\n    cout << endl;\n\n    // Test Input 5\n    int n5 = 4;\n    vector<int> A5 = {1, 2, 3, 4};\n    vector<int> result5 = findAnswer(n5, A5);\n    for(int val : result5) cout << val << \" \";\n    cout << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###stoneGameVI_Test.java",
        "source_code": "    public static int stoneGameVI(int[] aliceValues, int[] bobValues) {\n        int n = aliceValues.length;\n        int[][] values = new int[n][3];\n        for (int i = 0; i < n; i++) {\n            values[i][0] = aliceValues[i] + bobValues[i];\n            values[i][1] = aliceValues[i];\n            values[i][2] = bobValues[i];\n        }\n        Arrays.sort(values, (a, b) -> b[0] - a[0]);\n        int aliceSum = 0, bobSum = 0;\n        for (int i = 0; i < n; i++) {\n            if (i % 2 == 0) {\n                aliceSum += values[i][1];\n            } else {\n                bobSum += values[i][2];\n            }\n        }\n        if (aliceSum > bobSum) {\n            return 1;\n        } else if (aliceSum == bobSum) {\n            return 0;\n        } else {\n            return -1;\n        }\n    }",
        "trans_code": "int stoneGameVI ( vector < int > & aliceValues , vector < int > & bobValues ) {\n  int n = aliceValues . size ( ) ;\n  vector < int > values ( n , 0 ) ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    values [ i ] = aliceValues [ i ] + bobValues [ i ] ;\n    values [ i ] = aliceValues [ i ] ;\n    values [ i ] = bobValues [ i ] ;\n  }\n  sort ( values . begin ( ) , values . end ( ) , ( a , b ) ) ;\n  int aliceSum = 0 , bobSum = 0 ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    if ( i % 2 == 0 ) aliceSum += values [ i ] ;\n    else bobSum += values [ i ] ;\n  }\n  if ( aliceSum > bobSum ) return 1 ;\n  else if ( aliceSum == bobSum ) return 0 ;\n  else return - 1 ;\n}\n",
        "reference_code": "    int stoneGameVI(vector<int>& aliceValues, vector<int>& bobValues) {\n        int n = aliceValues.size();\n        vector<tuple<int, int, int>> values;\n        for (int i = 0; i < aliceValues.size(); i++) {\n            values.emplace_back(aliceValues[i] + bobValues[i], aliceValues[i], bobValues[i]);\n        }\n        sort(values.begin(), values.end(), [](tuple<int, int, int> &a, tuple<int, int, int> &b) {\n            return get<0>(a) > get<0>(b);\n        });\n        int aliceSum = 0, bobSum = 0;\n        for (int i = 0; i < n; i++) {\n            if (i % 2 == 0) {\n                aliceSum += get<1>(values[i]);\n            } else {\n                bobSum += get<2>(values[i]);\n            }\n        }\n        if (aliceSum > bobSum) {\n            return 1;\n        } else if (aliceSum == bobSum) {\n            return 0;\n        } else {\n            return -1;\n        }\n    }",
        "target_Lan": "cpp###stoneGameVI.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <tuple>\n#include <algorithm>\nusing namespace std;\n// TOFILL\nint main() {\n    // Test Input 1\n    vector<int> aliceValues1 = {1, 2, 3};\n    vector<int> bobValues1 = {1, 2, 3};\n    cout << stoneGameVI(aliceValues1, bobValues1) << endl;\n\n    // Test Input 2\n    vector<int> aliceValues2 = {10, 5, 8};\n    vector<int> bobValues2 = {1, 2, 3};\n    cout  << stoneGameVI(aliceValues2, bobValues2) << endl;\n\n    // Test Input 3\n    vector<int> aliceValues3 = {1, 2, 3};\n    vector<int> bobValues3 = {10, 5, 8};\n    cout << stoneGameVI(aliceValues3, bobValues3) << endl;\n\n    // Test Input 4\n    vector<int> aliceValues4 = {3};\n    vector<int> bobValues4 = {5};\n    cout << stoneGameVI(aliceValues4, bobValues4) << endl;\n\n    // Test Input 5\n    vector<int> aliceValues5 = {5, 7, 9};\n    vector<int> bobValues5 = {4, 8, 10};\n    cout << stoneGameVI(aliceValues5, bobValues5) << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###numberOfStableArrays_Test.java",
        "source_code": " public static int numberOfStableArrays(int zero, int one, int limit) {\n        final long MOD = 1000000007;\n        long[][][] dp = new long[zero + 1][one + 1][2];\n        for (int i = 0; i <= Math.min(zero, limit); i++) {\n            dp[i][0][0] = 1;\n        }\n        for (int j = 0; j <= Math.min(one, limit); j++) {\n            dp[0][j][1] = 1;\n        }\n        for (int i = 1; i <= zero; i++) {\n            for (int j = 1; j <= one; j++) {\n                if (i > limit) {\n                    dp[i][j][0] = dp[i - 1][j][0] + dp[i - 1][j][1] - dp[i - limit - 1][j][1];\n                } else {\n                    dp[i][j][0] = dp[i - 1][j][0] + dp[i - 1][j][1];\n                }\n                dp[i][j][0] = (dp[i][j][0] % MOD + MOD) % MOD;\n                if (j > limit) {\n                    dp[i][j][1] = dp[i][j - 1][1] + dp[i][j - 1][0] - dp[i][j - limit - 1][0];\n                } else {\n                    dp[i][j][1] = dp[i][j - 1][1] + dp[i][j - 1][0];\n                }\n                dp[i][j][1] = (dp[i][j][1] % MOD + MOD) % MOD;\n            }\n        }\n        return (int) ((dp[zero][one][0] + dp[zero][one][1]) % MOD);\n    }\n",
        "trans_code": "public : int numberOfStableArrays ( int zero , int one , int limit ) {\n  const long MOD = 1000000007 ;\n  long dp [ zero + 1 ] [ one + 1 ] [ 2 ] ;\n  for ( int i = 0 ;\n  i <= min ( zero , limit ) ;\n  i ++ ) dp [ i ] [ 0 ] [ 0 ] = 1 ;\n  for ( int j = 0 ;\n  j <= min ( one , limit ) ;\n  j ++ ) dp [ 0 ] [ j ] [ 1 ] = 1 ;\n  for ( int i = 1 ;\n  i <= zero ;\n  i ++ ) {\n    for ( int j = 1 ;\n    j <= one ;\n    j ++ ) {\n      if ( i > limit ) dp [ i ] [ j ] [ 0 ] = dp [ i - 1 ] [ j ] [ 0 ] + dp [ i - 1 ] [ j ] [ 1 ] - dp [ i - limit - 1 ] [ j ] [ 1 ] ;\n      else dp [ i ] [ j ] [ 0 ] = dp [ i - 1 ] [ j ] [ 0 ] + dp [ i - 1 ] [ j ] [ 1 ] ;\n      dp [ i ] [ j ] [ 0 ] = ( dp [ i ] [ j ] [ 0 ] % MOD + MOD ) % MOD ;\n      if ( j > limit ) dp [ i ] [ j ] [ 1 ] = dp [ i ] [ j - 1 ] [ 1 ] + dp [ i ] [ j - 1 ] [ 0 ] - dp [ i ] [ j - limit - 1 ] [ 0 ] ;\n      else dp [ i ] [ j ] [ 1 ] = dp [ i ] [ j - 1 ] [ 1 ] + dp [ i ] [ j - 1 ] [ 0 ] ;\n      dp [ i ] [ j ] [ 1 ] = ( dp [ i ] [ j ] [ 1 ] % MOD + MOD ) % MOD ;\n    }\n  }\n  return ( int ) ( ( dp [ zero ] [ one ] [ 0 ] + dp [ zero ] [ one ] [ 1 ] ) % MOD ) ;\n}\n",
        "reference_code": "int numberOfStableArrays(int zero, int one, int limit) {\n        vector<vector<vector<long long>>> dp(zero + 1, vector<vector<long long>>(one + 1, vector<long long>(2)));\n        long long mod = 1e9 + 7;\n        for (int i = 0; i <= min(zero, limit); i++) {\n            dp[i][0][0] = 1;\n        }\n        for (int j = 0; j <= min(one, limit); j++) {\n            dp[0][j][1] = 1;\n        }\n        for (int i = 1; i <= zero; i++) {\n            for (int j = 1; j <= one; j++) {\n                if (i > limit) {\n                    dp[i][j][0] = dp[i - 1][j][0] + dp[i - 1][j][1] - dp[i - limit - 1][j][1];\n                } else {\n                    dp[i][j][0] = dp[i - 1][j][0] + dp[i - 1][j][1];\n                }\n                dp[i][j][0] = (dp[i][j][0] % mod + mod) % mod;\n                if (j > limit) {\n                    dp[i][j][1] = dp[i][j - 1][1] + dp[i][j - 1][0] - dp[i][j - limit - 1][0];\n                } else {\n                    dp[i][j][1] = dp[i][j - 1][1] + dp[i][j - 1][0];\n                }\n                dp[i][j][1] = (dp[i][j][1] % mod + mod) % mod;\n            }\n        }\n        return (dp[zero][one][0] + dp[zero][one][1]) % mod;\n    }",
        "target_Lan": "cpp###numberOfStableArrays.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\nusing namespace std;\n// TOFILL\nint main() {\n       \n    int zero1 = 0, one1 = 0, limit1 = 1;\n    int zero2 = 1, one2 = 1, limit2 = 1;\n    int zero3 = 2, one3 = 2, limit3 = 2;\n    int zero4 = 3, one4 = 3, limit4 = 1;\n    int zero5 = 5, one5 = 5, limit5 = 3;\n\n    \n    cout << numberOfStableArrays(zero1, one1, limit1) << endl; \n    cout << numberOfStableArrays(zero2, one2, limit2) << endl; \n    cout << numberOfStableArrays(zero3, one3, limit3) << endl; \n    cout << numberOfStableArrays(zero4, one4, limit4) << endl; \n    cout << numberOfStableArrays(zero5, one5, limit5) << endl; \n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###maxPointsInsideSquare_Test.java",
        "source_code": " public static int maxPointsInsideSquare(int[][] points, String s) {\n        int[] min1 = new int[26];\n        Arrays.fill(min1, 1000000001);\n        int min2 = 1000000001, n = s.length();\n        for (int i = 0; i < n; ++i) {\n            int x = points[i][0], y = points[i][1], j = s.charAt(i) - 'a';\n            int d = Math.max(Math.abs(x), Math.abs(y));\n            if (d < min1[j]) {\n                min2 = Math.min(min2, min1[j]);\n                min1[j] = d;\n            } else if (d < min2) {\n                min2 = d;\n            }\n        }\n        int res = 0;\n        for (int d : min1) {\n            if (d < min2) {\n                ++res;\n            }\n        }\n        return res;\n    }\n",
        "trans_code": "public : int maxPointsInsideSquare ( vector < vector < int >> & points , string s ) {\n  vector < int > min1 ( 26 ) ;\n  fill ( min1 . begin ( ) , min1 . end ( ) , 1000000001 ) ;\n  int min2 = 1000000001 , n = s . size ( ) ;\n  for ( int i = 0 ;\n  i < n ;\n  ++ i ) {\n    int x = points [ i ] [ 0 ] , y = points [ i ] [ 1 ] , j = s [ i ] - 'a' ;\n    int d = max ( abs ( x ) , abs ( y ) ) ;\n    if ( d < min1 [ j ] ) {\n      min2 = min ( min2 , min1 [ j ] ) ;\n      min1 [ j ] = d ;\n    }\n    else if ( d < min2 ) min2 = d ;\n  }\n  int res = 0 ;\n  for ( int d : min1 ) {\n    if ( d < min2 ) ++ res ;\n  }\n  return res ;\n}\n",
        "reference_code": "int maxPointsInsideSquare(vector<vector<int>>& points, string s) {\n        vector<int> min1(26, 1000000001);\n        int min2 = 1000000001;\n        int n = s.length();\n        for (int i = 0; i < n; ++i) {\n            int x = points[i][0], y = points[i][1], j = s[i] - 'a';\n            int d = max(abs(x), abs(y));\n            if (d < min1[j]) {\n                min2 = min(min2, min1[j]);\n                min1[j] = d;\n            } else if (d < min2) {\n                min2 = d;\n            }\n        }\n        int res = 0;\n        for (int d : min1) {\n            if (d < min2) {\n                ++res;\n            }\n        }\n        return res;\n    }",
        "target_Lan": "cpp###maxPointsInsideSquare.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n// TOFILL\nint main() {\n    \n    vector<vector<int>> points1 = {{0, 0}};\n    string s1 = \"a\";\n    \n    vector<vector<int>> points2 = {{1, 1}, {-1, -1}, {2, 2}};\n    string s2 = \"abc\";\n    \n    vector<vector<int>> points3 = {{1, 1}, {2, 2}, {3, 3}};\n    string s3 = \"aaa\";\n    \n    vector<vector<int>> points4 = {{1, 1}, {0, 0}, {-1, -1}, {2, 2}};\n    string s4 = \"aabb\";\n    \n    vector<vector<int>> points5 = {{1000000, 1000000}, {-1000000, -1000000}, {500000, 500000}};\n    string s5 = \"xyz\";\n\n    \n    cout << maxPointsInsideSquare(points1, s1) << endl;  \n    cout << maxPointsInsideSquare(points2, s2) << endl;  \n    cout << maxPointsInsideSquare(points3, s3) << endl;  \n    cout << maxPointsInsideSquare(points4, s4) << endl;  \n    cout << maxPointsInsideSquare(points5, s5) << endl;  \n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###numberOfRightTriangles_Test.java",
        "source_code": "public static long numberOfRightTriangles(int[][] grid) {\n        int n = grid.length, m = grid[0].length;\n        int[] col = new int[m];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                col[j] += grid[i][j];\n            }\n        }\n        long res = 0;\n        for (int i = 0; i < n; i++) {\n            int row = Arrays.stream(grid[i]).sum();\n            for (int j = 0; j < m; j++) {\n                if (grid[i][j] == 1) {\n                    res += (row - 1) * (col[j] - 1);\n                }\n            }\n        }\n        return res;\n    }",
        "trans_code": "public : long long numberOfRightTriangles ( vector < vector < int >> & grid ) {\n  int n = grid . size ( ) , m = grid [ 0 ] . size ( ) ;\n  vector < int > col ( m , 0 ) ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < m ;\n    j ++ ) col [ j ] += grid [ i ] [ j ] ;\n  }\n  long long res = 0 ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    int row = std :: distance ( grid [ i ] . begin ( ) , grid [ i ] . end ( ) ) ;\n    for ( int j = 0 ;\n    j < m ;\n    j ++ ) {\n      if ( grid [ i ] [ j ] == 1 ) res += ( row - 1 ) * ( col [ j ] - 1 ) ;\n    }\n  }\n  return res ;\n}\n",
        "reference_code": "long long numberOfRightTriangles(vector<vector<int>>& grid) {\n        int n = grid.size(), m = grid[0].size();\n        vector<int> col(m);\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                col[j] += grid[i][j];\n            }\n        }\n        long long res = 0;\n        for (int i = 0; i < n; i++) {\n            int row = accumulate(grid[i].begin(), grid[i].end(), 0);\n            for (int j = 0; j < m; j++) {\n                if (grid[i][j] == 1) {\n                    res += (row - 1) * (col[j] - 1);\n                }\n            }\n        }\n        return res;\n    }",
        "target_Lan": "cpp###numberOfRightTriangles.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <numeric> // for accumulate\nusing namespace std;\n// TOFILL\nint main() {\n    \n    vector<vector<int>> grid1 = {{0}};\n    vector<vector<int>> grid2 = {{1}};\n    vector<vector<int>> grid3 = {{1, 0}, {0, 1}};\n    vector<vector<int>> grid4 = {{1, 1}, {1, 1}};\n    vector<vector<int>> grid5 = {{0, 1, 0}, {1, 0, 1}, {0, 1, 0}};\n    \n    \n    cout  << numberOfRightTriangles(grid1) << endl;\n    cout  << numberOfRightTriangles(grid2) << endl;\n    cout  << numberOfRightTriangles(grid3) << endl;\n    cout  << numberOfRightTriangles(grid4) << endl;\n    cout  << numberOfRightTriangles(grid5) << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###maxmiumScore_Test.java",
        "source_code": "public static int maxmiumScore(int[] cards, int cnt) {\n        Arrays.sort(cards);\n        \n        int ans = 0;\n        int tmp = 0;\n        int odd = -1, even = -1;\n        int end = cards.length - cnt;\n        for (int i = cards.length - 1; i >= end; i--) {\n            tmp += cards[i];\n            if ((cards[i] & 1) != 0) {\n                odd = cards[i];\n            } else {\n                even = cards[i];\n            }\n        }\n\n        if ((tmp & 1) == 0) {\n            return tmp;\n        }\n\n        for (int i = cards.length - cnt - 1; i >= 0; i--) {\n            if ((cards[i] & 1) != 0) {\n                if (even != -1) {\n                    ans = Math.max(ans, tmp - even + cards[i]);\n                    break;\n                }\n            }\n        }\n\n        for (int i = cards.length - cnt - 1; i >= 0; i--) {\n            if ((cards[i] & 1) == 0) {\n                if (odd != -1) {\n                    ans = Math.max(ans, tmp - odd + cards[i]);\n                    break;\n                }\n            }\n        }\n\n        return ans;\n    }",
        "trans_code": "public : int maxmiumScore ( vector < int > & cards , int cnt ) {\n  sort ( cards . begin ( ) , cards . end ( ) ) ;\n  int ans = 0 ;\n  int tmp = 0 ;\n  int odd = - 1 , even = - 1 ;\n  int end = cards . size ( ) - cnt ;\n  for ( int i = cards . size ( ) - 1 ;\n  i >= end ;\n  i -- ) {\n    tmp += cards [ i ] ;\n    if ( ( cards [ i ] & 1 ) != 0 ) odd = cards [ i ] ;\n    else even = cards [ i ] ;\n  }\n  if ( ( tmp & 1 ) == 0 ) return tmp ;\n  for ( int i = cards . size ( ) - cnt - 1 ;\n  i >= 0 ;\n  i -- ) {\n    if ( ( cards [ i ] & 1 ) != 0 ) {\n      if ( even != - 1 ) {\n        ans = max ( ans , tmp - even + cards [ i ] ) ;\n        break ;\n      }\n    }\n  }\n  for ( int i = cards . size ( ) - cnt - 1 ;\n  i >= 0 ;\n  i -- ) {\n    if ( ( cards [ i ] & 1 ) == 0 ) {\n      if ( odd != - 1 ) {\n        ans = max ( ans , tmp - odd + cards [ i ] ) ;\n        break ;\n      }\n    }\n  }\n  return ans ;\n}\n",
        "reference_code": "int maxmiumScore(vector<int>& cards, int cnt) {\n        sort(cards.begin(), cards.end());\n        \n        int ans = 0;\n        int tmp = 0;\n        int odd, even = -1;\n        int end = cards.size() - cnt;\n        for (int i = cards.size() - 1; i >= end; i--) {\n            tmp += cards[i];\n            if (cards[i] & 1) {\n                odd = cards[i];\n            } else {\n                even = cards[i];\n            }\n        }\n\n        if (!(tmp & 1)) {\n            return tmp;\n        }\n\n        for (int i = cards.size() - cnt - 1; i >= 0; i--) {\n            if (cards[i] & 1) {\n                if (even != -1) {\n                    ans = max(ans, tmp - even + cards[i]);\n                }\n            } else {\n                if (odd != -1) {\n                    ans = max(ans, tmp - odd + cards[i]);\n                }\n            }\n        }\n        return ans;\n    }",
        "target_Lan": "cpp###maxmiumScore.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <algorithm> // for sort and max\nusing namespace std;\n// TOFILL\nint main() {\n    \n    vector<int> cards1 = {1};\n    int cnt1 = 1;\n\n    vector<int> cards2 = {2, 4, 6};\n    int cnt2 = 2;\n\n    vector<int> cards3 = {1, 3, 5, 7};\n    int cnt3 = 3;\n\n    vector<int> cards4 = {1, 2, 3, 4, 5, 6};\n    int cnt4 = 4;\n\n    vector<int> cards5 = {10, 20, 30, 40, 50};\n    int cnt5 = 3;\n\n    \n    cout << maxmiumScore(cards1, cnt1) << endl;\n    cout << maxmiumScore(cards2, cnt2) << endl;\n    cout << maxmiumScore(cards3, cnt3) << endl;\n    cout << maxmiumScore(cards4, cnt4) << endl;\n    cout << maxmiumScore(cards5, cnt5) << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###minRectanglesToCoverPoints_Test.java",
        "source_code": "public static int minRectanglesToCoverPoints(int[][] points, int w) {\n        Arrays.sort(points, (a, b) -> Integer.compare(a[0], b[0]));\n        int res = 0;\n        int bound = -1;\n        for (int[] p : points) {\n            if (p[0] > bound) {\n                bound = p[0] + w;\n                res++;\n            }\n        }\n        return res;\n    }\n",
        "trans_code": "int minRectanglesToCoverPoints ( vector < int > & points , int w ) {\n  sort ( points . begin ( ) , points . end ( ) , ( int ( * ) ( int ) ) std :: greater < int > ( ) ) ;\n  int res = 0 ;\n  int bound = - 1 ;\n  for ( auto p : points ) {\n    if ( p > bound ) {\n      bound = p + w ;\n      res ++ ;\n    }\n  }\n  return res ;\n}\n",
        "reference_code": "int minRectanglesToCoverPoints(vector<vector<int>>& points, int w) {\n        sort(points.begin(), points.end());\n        int res = 0;\n        int bound = -1;\n        for (auto &p : points) {\n            if (p[0] > bound) {\n                bound = p[0] + w;\n                res++;\n            }\n        }\n        return res;\n    }",
        "target_Lan": "cpp###minRectanglesToCoverPoints.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n// TOFILL\nint main() {\n    \n    vector<vector<int>> points1 = {{0, 0}};\n    int w1 = 1;\n\n    vector<vector<int>> points2 = {{0, 0}, {2, 0}};\n    int w2 = 1;\n\n    vector<vector<int>> points3 = {{0, 0}, {1, 0}, {2, 0}};\n    int w3 = 2;\n\n    vector<vector<int>> points4 = {{1, 0}, {3, 0}, {5, 0}, {7, 0}};\n    int w4 = 3;\n\n    vector<vector<int>> points5 = {{0, 0}, {100, 0}, {200, 0}};\n    int w5 = 50;\n\n    \n    cout << minRectanglesToCoverPoints(points1, w1) << endl;\n    cout << minRectanglesToCoverPoints(points2, w2) << endl;\n    cout << minRectanglesToCoverPoints(points3, w3) << endl;\n    cout << minRectanglesToCoverPoints(points4, w4) << endl;\n    cout << minRectanglesToCoverPoints(points5, w5) << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###getSmallestString_Test.java",
        "source_code": "public static String getSmallestString(String s, int k) {\n        char[] ans = s.toCharArray();\n        for (int i = 0; i < s.length(); ++i) {\n            int dis = Math.min(s.charAt(i) - 'a', 'z' - s.charAt(i) + 1);\n            if (dis <= k) {\n                ans[i] = 'a';\n                k -= dis;\n            } else {\n                ans[i] -= k;\n                break;\n            }\n        }\n        return new String(ans);\n    }",
        "trans_code": "public : string getSmallestString ( string s , int k ) {\n  char ans [ s . size ( ) ] ;\n  for ( int i = 0 ;\n  i < s . size ( ) ;\n  ++ i ) {\n    int dis = min ( s [ i ] - 'a' , 'z' - s [ i ] + 1 ) ;\n    if ( dis <= k ) {\n      ans [ i ] = 'a' ;\n      k -= dis ;\n    }\n    else {\n      ans [ i ] -= k ;\n      break ;\n    }\n  }\n  return string ( ans ) ;\n}\n",
        "reference_code": "string getSmallestString(string s, int k) {\n        for (int i = 0; i < s.size(); ++i) {\n            int dis = min(s[i] - 'a', 'z' - s[i] + 1);\n            if (dis <= k) {\n                s[i] = 'a';\n                k -= dis;\n            }\n            else {\n                s[i] -= k;\n                break;\n            }\n        }\n        return s;\n    }",
        "target_Lan": "cpp###getSmallestString.cpp",
        "target_code_shell": "#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\n// TOFILL\nint main() {\n    \n    string s1 = \"abc\";\n    int k1 = 1;\n    string s2 = \"abc\";\n    int k2 = 2;\n    string s3 = \"azb\";\n    int k3 = 3;\n    string s4 = \"xyz\";\n    int k4 = 5;\n    string s5 = \"hello\";\n    int k5 = 5;\n\n    \n    cout << getSmallestString(s1, k1) << endl;\n    cout << getSmallestString(s2, k2) << endl;\n    cout << getSmallestString(s3, k3) << endl;\n    cout << getSmallestString(s4, k4) << endl;\n    cout << getSmallestString(s5, k5) << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###minimumOperations_Test.java",
        "source_code": " public static int minimumOperations(String num) {\n        int n = num.length();\n        boolean find0 = false, find5 = false;\n        for (int i = n - 1; i >= 0; --i) {\n            if (num.charAt(i) == '0' || num.charAt(i) == '5') {\n                if (find0) {\n                    return n - i - 2;\n                }\n                if (num.charAt(i) == '0') {\n                    find0 = true;\n                } else {\n                    find5 = true;\n                }\n            } else if (num.charAt(i) == '2' || num.charAt(i) == '7') {\n                if (find5) {\n                    return n - i - 2;\n                }\n            }\n        }\n        if (find0) {\n            return n - 1;\n        }\n        return n;\n    }",
        "trans_code": "public : int minimumOperations ( string num ) {\n  int n = num . size ( ) ;\n  bool find0 = false , find5 = false ;\n  for ( int i = n - 1 ;\n  i >= 0 ;\n  -- i ) {\n    if ( num [ i ] == '0' || num [ i ] == '5' ) {\n      if ( find0 ) return n - i - 2 ;\n      if ( num [ i ] == '0' ) find0 = true ;\n      else find5 = true ;\n    }\n    else if ( num [ i ] == '2' || num [ i ] == '7' ) {\n      if ( find5 ) return n - i - 2 ;\n    }\n  }\n  if ( find0 ) return n - 1 ;\n  return n ;\n}\n",
        "reference_code": "int minimumOperations(string num) {\n        int n = num.length();\n        bool find0 = false, find5 = false;\n        for (int i = n - 1; i >= 0; --i) {\n            if (num[i] == '0' || num[i] == '5') {\n                if (find0) {\n                    return n - i - 2;\n                }\n                if (num[i] == '0') {\n                    find0 = true;\n                } else {\n                    find5 = true;\n                }\n            } else if (num[i] == '2' || num[i] == '7') {\n                if (find5) {\n                    return n - i - 2;\n                }\n            }\n        }\n        if (find0) {\n            return n - 1;\n        }\n        return n;\n    }",
        "target_Lan": "cpp###minimumOperations.cpp",
        "target_code_shell": "#include <iostream>\n#include <string>\nusing namespace std;\n// TOFILL\nint main() {\n    \n    string num1 = \"123450\";\n    string num2 = \"1234050\";\n    string num3 = \"1750\";\n    string num4 = \"122567\";\n    string num5 = \"000\";\n\n    \n    cout << minimumOperations(num1) << endl;\n    cout << minimumOperations(num2) << endl;\n    cout << minimumOperations(num3) << endl;\n    cout << minimumOperations(num4) << endl;\n    cout << minimumOperations(num5) << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###relocateMarbles_Test.java",
        "source_code": "public static List<Integer> relocateMarbles(int[] nums, int[] moveFrom, int[] moveTo) {\n        List<Integer> ans = new ArrayList<Integer>();\n        Map<Integer, Boolean> mp = new HashMap<Integer, Boolean>();\n\n        for (int i = 0; i < nums.length; i++) {\n            mp.put(nums[i], true);\n        }\n\n        for (int i = 0; i < moveFrom.length; i++) {\n            mp.remove(moveFrom[i]);\n            mp.put(moveTo[i], true);\n        }\n\n        for (Map.Entry<Integer, Boolean> entry : mp.entrySet()) {\n            ans.add(entry.getKey());\n        }\n        Collections.sort(ans);\n        return ans;\n    }",
        "trans_code": "public : vector < int > relocateMarbles ( vector < int > & nums , vector < int > & moveFrom , vector < int > & moveTo ) {\n  vector < int > ans ;\n  map < int , bool > mp ;\n  for ( int i = 0 ;\n  i < nums . size ( ) ;\n  i ++ ) mp [ nums [ i ] ] = true ;\n  for ( int i = 0 ;\n  i < moveFrom . size ( ) ;\n  i ++ ) {\n    mp . erase ( moveFrom [ i ] ) ;\n    mp [ moveTo [ i ] ] = true ;\n  }\n  for ( map < int , bool > :: iterator it = mp . begin ( ) ;\n  it != mp . end ( ) ;\n  it ++ ) ans . push_back ( it -> first ) ;\n  sort ( ans . begin ( ) , ans . end ( ) ) ;\n  return ans ;\n}\n",
        "reference_code": "vector<int> relocateMarbles(vector<int>& nums, vector<int>& moveFrom, vector<int>& moveTo) {\n        vector<int> ans;\n        unordered_map<int, bool> mp;\n\n        for (int i = 0; i < nums.size(); i++) {\n            mp[nums[i]] = true;\n        }\n\n        for (int i = 0; i < moveFrom.size(); i++) {\n            mp.erase(moveFrom[i]);\n            mp[moveTo[i]] = true;\n        }\n\n        for (const auto& pair : mp) {\n            ans.push_back(pair.first);\n        }\n        sort(ans.begin(), ans.end());\n        return ans;\n    }",
        "target_Lan": "cpp###relocateMarbles.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <algorithm>\nusing namespace std;\n// TOFILL\nint main() {\n    \n    vector<int> nums1 = {1, 2, 3};\n    vector<int> moveFrom1 = {1};\n    vector<int> moveTo1 = {4};\n\n    vector<int> nums2 = {1, 2, 3};\n    vector<int> moveFrom2 = {1, 2};\n    vector<int> moveTo2 = {5, 6};\n\n    vector<int> nums3 = {1, 2, 3};\n    vector<int> moveFrom3 = {1};\n    vector<int> moveTo3 = {1};\n\n    vector<int> nums4 = {1, 2, 3, 4};\n    vector<int> moveFrom4 = {1, 2};\n    vector<int> moveTo4 = {5, 6};\n\n    vector<int> nums5 = {1, 2, 3};\n    vector<int> moveFrom5 = {};\n    vector<int> moveTo5 = {};\n\n    \n    vector<int> result1 = relocateMarbles(nums1, moveFrom1, moveTo1);\n    for(int i : result1) cout << i << \" \";\n    cout << endl;\n\n    vector<int> result2 = relocateMarbles(nums2, moveFrom2, moveTo2);\n    for(int i : result2) cout << i << \" \";\n    cout << endl;\n\n    vector<int> result3 = relocateMarbles(nums3, moveFrom3, moveTo3);\n    for(int i : result3) cout << i << \" \";\n    cout << endl;\n\n    vector<int> result4 = relocateMarbles(nums4, moveFrom4, moveTo4);\n    for(int i : result4) cout << i << \" \";\n    cout << endl;\n\n    vector<int> result5 = relocateMarbles(nums5, moveFrom5, moveTo5);\n    for(int i : result5) cout << i << \" \";\n    cout << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###findValueOfPartition_Test.java",
        "source_code": "public static int findValueOfPartition(int[] nums) {\n        Arrays.sort(nums);\n        int res = Integer.MAX_VALUE;\n        for (int i = 1; i < nums.length; i++) {\n            res = Math.min(res, nums[i] - nums[i - 1]);\n        }\n        return res;\n    }",
        "trans_code": "public : int findValueOfPartition ( vector < int > & nums ) {\n  sort ( nums . begin ( ) , nums . end ( ) ) ;\n  int res = INT_MAX ;\n  for ( int i = 1 ;\n  i < nums . size ( ) ;\n  i ++ ) res = min ( res , nums [ i ] - nums [ i - 1 ] ) ;\n  return res ;\n}\n",
        "reference_code": "int findValueOfPartition(vector<int>& nums) {\n        sort(nums.begin(), nums.end());\n        int res = INT_MAX;\n        for (int i = 1; i < nums.size(); i++) {\n            res = min(res, nums[i] - nums[i - 1]);\n        }\n        return res;\n    }",
        "target_Lan": "cpp###findValueOfPartition.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\nusing namespace std;\n// TOFILL\nint main() {\n    \n    vector<int> nums1 = {1, 3, 6, 10};\n    cout << findValueOfPartition(nums1) << endl;  \n\n    \n    vector<int> nums2 = {1, 2, 2, 4, 6};\n    cout << findValueOfPartition(nums2) << endl;  \n\n    \n    vector<int> nums3 = {1};\n    cout << findValueOfPartition(nums3) << endl;  \n\n    \n    vector<int> nums4 = {10, 20, 30, 40, 50};\n    cout << findValueOfPartition(nums4) << endl;  \n\n    \n    vector<int> nums5 = {1, 1000000000, 500000000};\n    cout << findValueOfPartition(nums5) << endl;  \n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###MinSize_Test.java",
        "source_code": "    public static int MinSize(int[] A, int n) {\n        \n        \n        int curr = A[0];\n        int count = 1;\n        for (int i = 1; i < n; ++i) {\n            if (A[i] == curr) {\n                count += 1;\n            } else {\n                count -= 1;\n                if (count == 0) {\n                    curr = A[i];\n                    count = 1;\n                }\n            }\n        }\n        int max_f = 0;\n        for (int i = 0; i < n; i++) {\n            if (curr == A[i]) {\n                max_f++;\n            }\n        }\n        if (max_f <= (n + 1) / 2) {\n            return n & 1;\n        } else {\n            return 2 * max_f - n;\n        }\n    }",
        "trans_code": "int MinSize ( int A [ ] , int n ) {\n  int curr = A [ 0 ] ;\n  int count = 1 ;\n  for ( int i = 1 ;\n  i < n ;\n  ++ i ) {\n    if ( A [ i ] == curr ) count += 1 ;\n    else {\n      count -= 1 ;\n      if ( count == 0 ) {\n        curr = A [ i ] ;\n        count = 1 ;\n      }\n    }\n  }\n  int max_f = 0 ;\n  for ( int i = 0 ;\n  i < n ;\n  ++ i ) {\n    if ( curr == A [ i ] ) max_f ++ ;\n  }\n  if ( max_f <= ( n + 1 ) / 2 ) return n & 1 ;\n  else return 2 * max_f - n ;\n}\n",
        "reference_code": "    int MinSize(vector<int> A, int n) {\n        \n        \n        int curr = A[0];\n        int count = 1;\n        for (int i = 1; i < n; ++i) {\n            if (A[i] == curr) {\n                count += 1;\n            } else {\n                count -= 1;\n                if (count == 0) {\n                    curr = A[i];\n                    count = 1;\n                }\n            }\n        }\n        int max_f = 0;\n        for (int i = 0; i < n; i++)\n            if (curr == A[i])\n                max_f++;\n        if (max_f <= (n + 1) / 2) {\n            return n & 1;\n        } else {\n            return 2 * max_f - n;\n        }\n    }",
        "target_Lan": "cpp###MinSize.cpp",
        "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    cout << MinSize(vector<int>{1}, 1) << endl;\n    cout << MinSize(vector<int>{1, 1}, 2) << endl;\n    cout << MinSize(vector<int>{1, 2, 1}, 3) << endl;\n    cout << MinSize(vector<int>{1, 2, 2, 1}, 4) << endl;\n}"
    },
    {
        "source_Lan": "java###buyChoco_Test.java",
        "source_code": "    public static int buyChoco(int[] prices, int money) {\n        int fi = Integer.MAX_VALUE, se = Integer.MAX_VALUE;\n        for (int price : prices) {\n            if (price < fi) {\n                se = fi;\n                fi = price;\n            } else if (price < se) {\n                se = price;\n            }\n        }\n        return money < fi + se ? money : money - fi - se;\n    }",
        "trans_code": "int buyChoco ( vector < int > & prices , int money ) {\n  int fi = INT_MAX , se = INT_MAX ;\n  for ( int price : prices ) {\n    if ( price < fi ) {\n      se = fi ;\n      fi = price ;\n    }\n    else if ( price < se ) se = price ;\n  }\n  return money < fi + se ? money : money - fi - se ;\n}\n",
        "reference_code": "    int buyChoco(vector<int>& prices, int money) {\n        int fi = INT_MAX, se = INT_MAX;\n        for (auto p : prices) {\n            if (p < fi) {\n                se = fi;\n                fi = p;\n            } else if (p < se) {\n                se = p;\n            }\n        }\n        return money < fi + se ? money : money - fi - se;\n    }",
        "target_Lan": "cpp###buyChoco.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <limits.h>\n// TOFILL\nint main() {\n    vector<int> prices1 = {};\n    cout << buyChoco(prices1, 100) << endl;\n\n    vector<int> prices2 = {5};\n    cout << buyChoco(prices2, 10) << endl;\n\n    vector<int> prices3 = {5, 10, 15};\n    cout << buyChoco(prices3, 20) << endl;\n\n    vector<int> prices4 = {20, 30};\n    cout << buyChoco(prices4, 40) << endl;\n\n    vector<int> prices5 = {INT_MAX, INT_MAX};\n    cout << buyChoco(prices5, INT_MAX) << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###minimumAddedCoins_Test.java",
        "source_code": "public static int minimumAddedCoins(int[] coins, int target) {\n        Arrays.sort(coins);\n        int ans = 0;\n        int x = 1;\n        int length = coins.length, index = 0;\n        while (x <= target) {\n            if (index < length && coins[index] <= x) {\n                x += coins[index];\n                index++;\n            } else {\n                x *= 2;\n                ans++;\n            }\n        }\n        return ans;\n    }",
        "trans_code": "int minimumAddedCoins ( vector < int > coins , int target ) {\n  sort ( coins . begin ( ) , coins . end ( ) ) ;\n  int ans = 0 ;\n  int x = 1 ;\n  int length = coins . size ( ) , index = 0 ;\n  while ( x <= target ) {\n    if ( index < length && coins [ index ] <= x ) {\n      x += coins [ index ] ;\n      index ++ ;\n    }\n    else {\n      x *= 2 ;\n      ans ++ ;\n    }\n  }\n  return ans ;\n}\n",
        "reference_code": "int minimumAddedCoins(vector<int>& coins, int target) {\n        sort(coins.begin(), coins.end());\n        int ans = 0;\n        int x = 1;\n        int length = coins.size(), index = 0;\n        while (x <= target) {\n            if (index < length && coins[index] <= x) {\n                x += coins[index];\n                index++;\n            } else {\n                x <<= 1;\n                ans++;\n            }\n        }\n        return ans;\n    }",
        "target_Lan": "cpp###minimumAddedCoins.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <algorithm>\n// TOFILL\nint main() {\n    vector<int> coins1 = {};\n    cout << minimumAddedCoins(coins1, 5) << endl; \n\n    vector<int> coins2 = {1, 2, 5};\n    cout << minimumAddedCoins(coins2, 5) << endl; \n\n    vector<int> coins3 = {2, 4, 8};\n    cout << minimumAddedCoins(coins3, 7) << endl; \n\n    vector<int> coins4 = {10};\n    cout << minimumAddedCoins(coins4, 1) << endl; \n\n    vector<int> coins5 = {1, 5, 10};\n    cout << minimumAddedCoins(coins5, 15) << endl; \n    \n    return 0;\n}"
    },
    {
        "source_Lan": "java###findPeakGrid_Test.java",
        "source_code": "public static int[] findPeakGrid(int[][] mat) {\n        int m = mat.length, n = mat[0].length;\n        int low = 0, high = m - 1;\n        while (low <= high) {\n            int i = (low + high) / 2;\n            int j = -1, maxElement = -1;\n            for (int k = 0; k < n; k++) {\n                if (mat[i][k] > maxElement) {\n                    j = k;\n                    maxElement = mat[i][k];\n                }\n            }\n            if (i - 1 >= 0 && mat[i][j] < mat[i - 1][j]) {\n                high = i - 1;\n                continue;\n            }\n            if (i + 1 < m && mat[i][j] < mat[i + 1][j]) {\n                low = i + 1;\n                continue;\n            }\n            return new int[]{i, j};\n        }\n        return new int[0]; \n    }",
        "trans_code": "public : vector < vector < int >> findPeakGrid ( vector < vector < int >> & mat ) {\n  int m = mat . size ( ) , n = mat [ 0 ] . size ( ) ;\n  int low = 0 , high = m - 1 ;\n  while ( low <= high ) {\n    int i = ( low + high ) / 2 ;\n    int j = - 1 , maxElement = - 1 ;\n    for ( int k = 0 ;\n    k < n ;\n    k ++ ) {\n      if ( mat [ i ] [ k ] > maxElement ) {\n        j = k ;\n        maxElement = mat [ i ] [ k ] ;\n      }\n    }\n    if ( i - 1 >= 0 && mat [ i ] [ j ] < mat [ i - 1 ] [ j ] ) {\n      high = i - 1 ;\n      continue ;\n    }\n    if ( i + 1 < m && mat [ i ] [ j ] < mat [ i + 1 ] [ j ] ) {\n      low = i + 1 ;\n      continue ;\n    }\n    return {\n      i , j }\n      ;\n    }\n    return {\n      0 }\n      ;\n    }\n    ",
        "reference_code": "vector<int> findPeakGrid(vector<vector<int>>& mat) {\n        int m = mat.size();\n        int low = 0, high = m - 1;\n        while (low <= high) {\n            int i = (low + high) / 2;\n            int j = max_element(mat[i].begin(), mat[i].end()) - mat[i].begin();\n            if (i - 1 >= 0 && mat[i][j] < mat[i - 1][j]) {\n                high = i - 1;\n                continue;\n            }\n            if (i + 1 < m && mat[i][j] < mat[i + 1][j]) {\n                low = i + 1;\n                continue;\n            }\n            return {i, j};\n        }\n        return {}; \n    }",
        "target_Lan": "cpp###findPeakGrid.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <algorithm>\n// TOFILL\nint main() {\n    vector<vector<int>> input1 = {{1}};\n    vector<vector<int>> input2 = {{1, 1}, {1, 1}};\n    vector<vector<int>> input3 = {{10, 20}, {5, 8}};\n    vector<vector<int>> input4 = {{5, 4}, {6, 7}};\n    vector<vector<int>> input5 = {{1, 2, 3}, {6, 5, 4}};\n\n    auto result1 = findPeakGrid(input1);\n    auto result2 = findPeakGrid(input2);\n    auto result3 = findPeakGrid(input3);\n    auto result4 = findPeakGrid(input4);\n    auto result5 = findPeakGrid(input5);\n\n    cout << \"Peak in input1:(\" << result1[0] << \", \" << result1[1] << \")\" << endl;\n    cout << \"Peak in input2:(\" << result2[0] << \", \" << result2[1] << \")\" << endl;\n    cout << \"Peak in input3:(\" << result3[0] << \", \" << result3[1] << \")\" << endl;\n    cout << \"Peak in input4:(\" << result4[0] << \", \" << result4[1] << \")\" << endl;\n    cout << \"Peak in input5:(\" << result5[0] << \", \" << result5[1] << \")\" << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###maximumSumOfHeights_Test.java",
        "source_code": "    public static long maximumSumOfHeights(List<Integer> maxHeights) {\n        int n = maxHeights.size();\n        long res = 0;\n        long[] prefix = new long[n];\n        long[] suffix = new long[n];\n        Deque<Integer> stack1 = new ArrayDeque<Integer>();\n        Deque<Integer> stack2 = new ArrayDeque<Integer>();\n        for (int i = 0; i < n; i++) {\n            while (!stack1.isEmpty() && maxHeights.get(i) < maxHeights.get(stack1.peek())) {\n                stack1.pop();\n            }\n            if (stack1.isEmpty()) {\n                prefix[i] = (long) (i + 1) * maxHeights.get(i);\n            } else {\n                prefix[i] = prefix[stack1.peek()] + (long) (i - stack1.peek()) * maxHeights.get(i);\n            }\n            stack1.push(i);\n        }\n        for (int i = n - 1; i >= 0; i--) {\n            while (!stack2.isEmpty() && maxHeights.get(i) < maxHeights.get(stack2.peek())) {\n                stack2.pop();\n            }\n            if (stack2.isEmpty()) {\n                suffix[i] = (long) (n - i) * maxHeights.get(i);\n            } else {\n                suffix[i] = suffix[stack2.peek()] + (long) (stack2.peek() - i) * maxHeights.get(i);\n            }\n            stack2.push(i);\n            res = Math.max(res, prefix[i] + suffix[i] - maxHeights.get(i));\n        }\n        return res;\n    }",
        "trans_code": "public : long long maximumSumOfHeights ( vector < int > & maxHeights ) {\n  int n = maxHeights . size ( ) ;\n  long long res = 0 ;\n  vector < long long > prefix ( n , 0 ) ;\n  vector < long long > suffix ( n , 0 ) ;\n  deque < int > stack1 ;\n  deque < int > stack2 ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    while ( ! stack1 . empty ( ) && maxHeights [ i ] < maxHeights [ stack1 . top ( ) ] ) stack1 . pop ( ) ;\n    if ( stack1 . empty ( ) ) prefix [ i ] = ( long long ) ( i + 1 ) * maxHeights [ i ] ;\n    else prefix [ i ] = prefix [ stack1 . top ( ) ] + ( long long ) ( i - stack1 . top ( ) ) * maxHeights [ i ] ;\n    stack1 . push ( i ) ;\n  }\n  for ( int i = n - 1 ;\n  i >= 0 ;\n  i -- ) {\n    while ( ! stack2 . empty ( ) && maxHeights [ i ] < maxHeights [ stack2 . top ( ) ] ) stack2 . pop ( ) ;\n    if ( stack2 . empty ( ) ) suffix [ i ] = ( long long ) ( n - i ) * maxHeights [ i ] ;\n    else suffix [ i ] = suffix [ stack2 . top ( ) ] + ( long long ) ( stack2 . top ( ) - i ) * maxHeights [ i ] ;\n    stack2 . push ( i ) ;\n    res = max ( res , prefix [ i ] + suffix [ i ] - maxHeights [ i ] ) ;\n  }\n  return res ;\n}\n",
        "reference_code": "long long maximumSumOfHeights(vector<int>& maxHeights) {\n        int n = maxHeights.size();\n        long long res = 0;\n        vector<long long> prefix(n), suffix(n);\n        stack<int> stack1, stack2;\n        for (int i = 0; i < n; i++) {\n            while (!stack1.empty() && maxHeights[i] < maxHeights[stack1.top()]) {\n                stack1.pop();\n            }\n            if (stack1.empty()) {\n                prefix[i] = (long long)(i + 1) * maxHeights[i];\n            } else {\n                prefix[i] = prefix[stack1.top()] + (long long)(i - stack1.top()) * maxHeights[i];\n            }\n            stack1.emplace(i);\n        }\n        for (int i = n - 1; i >= 0; i--) {\n            while (!stack2.empty() && maxHeights[i] < maxHeights[stack2.top()]) {\n                stack2.pop();\n            }\n            if (stack2.empty()) {\n                suffix[i] = (long long)(n - i) * maxHeights[i];\n            } else {\n                suffix[i] = suffix[stack2.top()] + (long long)(stack2.top() - i) * maxHeights[i];\n            }\n            stack2.emplace(i);\n            res = max(res, prefix[i] + suffix[i] - maxHeights[i]);\n        }\n        return res;\n    }",
        "target_Lan": "cpp###maximumSumOfHeights.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <stack>\n#include <algorithm>\nusing namespace std;\n// TOFILL\nint main() {\n    \n    vector<int> maxHeights1 = {1};\n    cout << maximumSumOfHeights(maxHeights1) << endl;  \n\n    \n    vector<int> maxHeights2 = {3, 3, 3};\n    cout << maximumSumOfHeights(maxHeights2) << endl;  \n\n    \n    vector<int> maxHeights3 = {5, 4, 3, 2, 1};\n    cout << maximumSumOfHeights(maxHeights3) << endl;  \n\n    \n    vector<int> maxHeights4 = {1, 2, 3, 4, 5};\n    cout << maximumSumOfHeights(maxHeights4) << endl;  \n\n    \n    vector<int> maxHeights5 = {1000000000, 1000000000, 1000000000, 1000000000};\n    cout << maximumSumOfHeights(maxHeights5) << endl;  \n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###isAcronym_Test.java",
        "source_code": "public static boolean isAcronym(List<String> words, String s) {\n        if (words.size() != s.length()) {\n            return false;\n        }\n        for (int i = 0; i < s.length(); i++) {\n            if (words.get(i).charAt(0) != s.charAt(i)) {\n                return false;\n            }\n        }\n        return true;\n    }",
        "trans_code": "bool isAcronym ( const std :: vector < std :: string > & words , const std :: string & s ) {\n  if ( words . size ( ) != s . length ( ) ) return false ;\n  for ( size_t i = 0 ;\n  i < s . length ( ) ;\n  i ++ ) {\n    if ( words [ i ] [ 0 ] != s [ i ] ) return false ;\n  }\n  return true ;\n}\n",
        "reference_code": "bool isAcronym(vector<string>& words, string s) {\n        if (s.size() != words.size()) {\n            return false;\n        }\n        for (int i = 0; i < s.size(); i++) {\n            if (words[i][0] != s[i]) {\n                return false;\n            }\n        }\n        return true;\n    }",
        "target_Lan": "cpp###isAcronym.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <string>\n// TOFILL\nint main() {\n    vector<string> words1 = {\"apple\", \"banana\", \"cherry\"};\n    string s1 = \"abc\";\n    cout << isAcronym(words1, s1) << endl; \n\n    string s2 = \"ab\";\n    cout << isAcronym(words1, s2) << endl; \n\n    string s3 = \"abcde\";\n    cout << isAcronym(words1, s3) << endl; \n\n    vector<string> words4 = {};\n    string s4 = \"\";\n    cout << isAcronym(words4, s4) << endl; \n\n    vector<string> words5 = {\"apple\"};\n    string s5 = \"\";\n    cout << isAcronym(words5, s5) << endl; \n}"
    },
    {
        "source_Lan": "java###possibleToStamp_Test.java",
        "source_code": "    public static boolean possibleToStamp(int[][] grid, int stampHeight, int stampWidth) {\n        int m = grid.length, n = grid[0].length;\n        int[][] sum = new int[m + 2][n + 2];\n        int[][] diff = new int[m + 2][n + 2];\n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                sum[i][j] = sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1] + grid[i - 1][j - 1];\n            }\n        }\n        for (int i = 1; i + stampHeight - 1 <= m; i++) {\n            for (int j = 1; j + stampWidth - 1 <= n; j++) {\n                int x = i + stampHeight - 1;\n                int y = j + stampWidth - 1;\n                if (sum[x][y] - sum[x][j - 1] - sum[i - 1][y] + sum[i - 1][j - 1] == 0) {\n                    diff[i][j]++;\n                    diff[i][y + 1]--;\n                    diff[x + 1][j]--;\n                    diff[x + 1][y + 1]++;\n                }\n            }\n        }\n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                diff[i][j] += diff[i - 1][j] + diff[i][j - 1] - diff[i - 1][j - 1];\n                if (diff[i][j] == 0 && grid[i - 1][j - 1] == 0) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }",
        "trans_code": "bool possibleToStamp ( vector < vector < int >> & grid , int stampHeight , int stampWidth ) {\n  int m = grid . size ( ) , n = grid [ 0 ] . size ( ) ;\n  vector < vector < int >> sum ( m + 2 , vector < int > ( n + 2 , 0 ) ) ;\n  vector < vector < int >> diff ( m + 2 , vector < int > ( n + 2 , 0 ) ) ;\n  for ( int i = 1 ;\n  i <= m ;\n  i ++ ) {\n    for ( int j = 1 ;\n    j <= n ;\n    j ++ ) {\n      sum [ i ] [ j ] = sum [ i - 1 ] [ j ] + sum [ i ] [ j - 1 ] - sum [ i - 1 ] [ j - 1 ] + grid [ i - 1 ] [ j - 1 ] ;\n    }\n  }\n  for ( int i = 1 ;\n  i + stampHeight - 1 <= m ;\n  i ++ ) {\n    for ( int j = 1 ;\n    j + stampWidth - 1 <= n ;\n    j ++ ) {\n      int x = i + stampHeight - 1 ;\n      int y = j + stampWidth - 1 ;\n      if ( sum [ x ] [ y ] - sum [ x ] [ j - 1 ] - sum [ i - 1 ] [ y ] + sum [ i - 1 ] [ j - 1 ] == 0 ) {\n        diff [ i ] [ j ] ++ ;\n        diff [ i ] [ y + 1 ] -- ;\n        diff [ x + 1 ] [ j ] -- ;\n        diff [ x + 1 ] [ y + 1 ] ++ ;\n      }\n    }\n  }\n  for ( int i = 1 ;\n  i <= m ;\n  i ++ ) {\n    for ( int j = 1 ;\n    j <= n ;\n    j ++ ) {\n      diff [ i ] [ j ] += diff [ i - 1 ] [ j ] + diff [ i ] [ j - 1 ] - diff [ i - 1 ] [ j - 1 ] ;\n      if ( diff [ i ] [ j ] == 0 && grid [ i - 1 ] [ j - 1 ] == 0 ) {\n        return false ;\n      }\n    }\n  }\n  return true ;\n}\n",
        "reference_code": "bool possibleToStamp(vector<vector<int>>& grid, int stampHeight, int stampWidth) {\n        int m = grid.size(), n = grid[0].size();\n        vector<vector<int>> sum(m + 2, vector<int>(n + 2, 0));\n        vector<vector<int>> diff(m + 2, vector<int>(n + 2, 0));\n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                sum[i][j] = sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1] + grid[i - 1][j - 1];\n            }\n        }\n        for (int i = 1; i + stampHeight - 1 <= m; i++) {\n            for (int j = 1; j + stampWidth - 1 <= n; j++) {\n                int x = i + stampHeight - 1;\n                int y = j + stampWidth - 1;\n                if (sum[x][y] - sum[x][j - 1] - sum[i - 1][y] + sum[i - 1][j - 1] == 0) {\n                    diff[i][j]++;\n                    diff[i][y + 1]--;\n                    diff[x + 1][j]--;\n                    diff[x + 1][y + 1]++;\n                }\n            }\n        }\n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                diff[i][j] += diff[i - 1][j] + diff[i][j - 1] - diff[i - 1][j - 1];\n                if (diff[i][j] == 0 && grid[i - 1][j - 1] == 0) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }",
        "target_Lan": "cpp###possibleToStamp.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    vector<vector<int>> grid1 = {{0, 0}, {0, 0}};\n    vector<vector<int>> grid2 = {{0, 1}, {0, 0}};\n    vector<vector<int>> grid3 = {{0}};\n    vector<vector<int>> grid4 = {{0, 0, 0}, {1, 0, 0}, {0, 0, 1}};\n    \n    cout << possibleToStamp(grid1, 2, 2) << endl; \n    cout << possibleToStamp(grid2, 1, 1) << endl; \n    cout << possibleToStamp(grid3, 1, 1) << endl; \n    cout << possibleToStamp(grid4, 2, 2) << endl; \n\n    \n    vector<vector<int>> grid5(1000, vector<int>(1000, 0));\n    cout << possibleToStamp(grid5, 1000, 1000) << endl; \n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###makeSmallestPalindrome_Test.java",
        "source_code": "    public static String makeSmallestPalindrome(String s) {\n        char[] arr = s.toCharArray();\n        int left = 0, right = arr.length - 1;\n        while (left < right) {\n            if (arr[left] != arr[right]) {\n                arr[left] = arr[right] = (char) Math.min(arr[left], arr[right]);\n            }\n            ++left;\n            --right;\n        }\n        return new String(arr);\n    }",
        "trans_code": "public : string makeSmallestPalindrome ( string s ) {\n  char * arr = s . c_str ( ) ;\n  int left = 0 , right = arr - s . c_str ( ) ;\n  while ( left < right ) {\n    if ( arr [ left ] != arr [ right ] ) arr [ left ] = arr [ right ] = ( char ) min ( arr [ left ] , arr [ right ] ) ;\n    ++ left ;\n    -- right ;\n  }\n  return string ( arr ) ;\n}\n",
        "reference_code": "string makeSmallestPalindrome(string s) {\n        int left = 0, right = s.size() - 1;\n        while (left < right) {\n            if (s[left] != s[right]) {\n                s[left] = s[right] = min(s[left], s[right]);\n            }\n            ++left;\n            --right;\n        }\n        return s;\n    }",
        "target_Lan": "cpp###makeSmallestPalindrome.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <string>\n// TOFILL\nint main() {\n    cout << makeSmallestPalindrome(\"\") << endl; \n    cout << makeSmallestPalindrome(\"abc\") << endl; \n    cout << makeSmallestPalindrome(\"abac\") << endl; \n    cout << makeSmallestPalindrome(\"aaabbb\") << endl; \n    cout << makeSmallestPalindrome(\"aaa\") << endl; \n}"
    },
    {
        "source_Lan": "java###secondGreaterElement_Test.java",
        "source_code": "    public static int[] secondGreaterElement(int[] nums) {\n        int[] res = new int[nums.length];\n        Arrays.fill(res, -1);\n        Deque<Integer> stack = new ArrayDeque<Integer>();\n        PriorityQueue<int[]> pq = new PriorityQueue<int[]>((a, b) -> a[0] - b[0]);\n        for (int i = 0; i < nums.length; ++i) {\n            while (!pq.isEmpty() && pq.peek()[0] < nums[i]) {\n                res[pq.poll()[1]] = nums[i];\n            }\n            while (!stack.isEmpty() && nums[stack.peek()] < nums[i]) {\n                pq.offer(new int[]{nums[stack.peek()], stack.peek()});\n                stack.pop();\n            }\n            stack.push(i);\n        }\n        return res;\n    }",
        "trans_code": "public : vector < int > secondGreaterElement ( vector < int > & nums ) {\n  vector < int > res ;\n  std :: fill ( res . begin ( ) , res . end ( ) , - 1 ) ;\n  deque < int > stack ;\n  priority_queue < int , vector < int > , greater < int >> pq ( ( a , b ) ) ;\n  for ( int i = 0 ;\n  i < nums . size ( ) ;\n  ++ i ) {\n    while ( ! pq . empty ( ) && pq . top ( ) [ 0 ] < nums [ i ] ) res [ pq . top ( ) [ 1 ] ] = nums [ i ] ;\n    while ( ! stack . empty ( ) && nums [ stack . top ( ) ] < nums [ i ] ) {\n      pq . push ( make_pair ( nums [ stack . top ( ) ] , stack . top ( ) ) ) ;\n      stack . pop ( ) ;\n    }\n    stack . push ( i ) ;\n  }\n  return res ;\n}\n",
        "reference_code": "vector<int> secondGreaterElement(vector<int>& nums) {\n        vector<int> res(nums.size(), -1);\n        stack<int> st;\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> q;\n        for (int i = 0; i < nums.size(); ++i) {\n            while (!q.empty() && q.top().first < nums[i]) {\n                res[q.top().second] = nums[i];\n                q.pop();\n            }\n            while (!st.empty() && nums[st.top()] < nums[i]) {\n                q.push({nums[st.top()], st.top()});\n                st.pop();\n            }\n            st.push(i);\n        }\n        return res;\n    }",
        "target_Lan": "cpp###secondGreaterElement.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <stack>\n#include <queue>\n// TOFILL\nint main() {\n    vector<int> input1 = {};\n    vector<int> input2 = {1};\n    vector<int> input3 = {1, 2};\n    vector<int> input4 = {3, 2, 1};\n    vector<int> input5 = {1, 2, 1, 2, 3};\n    \n    vector<int> output1 = secondGreaterElement(input1);\n    vector<int> output2 = secondGreaterElement(input2);\n    vector<int> output3 = secondGreaterElement(input3);\n    vector<int> output4 = secondGreaterElement(input4);\n    vector<int> output5 = secondGreaterElement(input5);\n    \n    for(int val : output1) cout << val << \" \";\n    cout << endl;\n    \n    for(int val : output2) cout << val << \" \";\n    cout << endl;\n    \n    for(int val : output3) cout << val << \" \";\n    cout << endl;\n    \n    for(int val : output4) cout << val << \" \";\n    cout << endl;\n    \n    for(int val : output5) cout << val << \" \";\n    cout << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###maxTaxiEarnings_Test.java",
        "source_code": "    public static long maxTaxiEarnings(int n, int[][] rides) {\n        long[] dp = new long[n + 1];\n        Map<Integer, List<int[]>> rideMap = new HashMap<Integer, List<int[]>>();\n        for (int[] ride : rides) {\n            rideMap.putIfAbsent(ride[1], new ArrayList<int[]>());\n            rideMap.get(ride[1]).add(ride);\n        }\n        for (int i = 1; i <= n; i++) {\n            dp[i] = dp[i - 1];\n            for (int[] ride : rideMap.getOrDefault(i, new ArrayList<int[]>())) {\n                dp[i] = Math.max(dp[i], dp[ride[0]] + ride[1] - ride[0] + ride[2]);\n            }\n        }\n        return dp[n];\n    }",
        "trans_code": "public : long maxTaxiEarnings ( int n , vector < vector < int >> rides ) {\n  vector < long > dp ( n + 1 , 0 ) ;\n  map < int , vector < int >> rideMap ;\n  for ( auto & ride : rides ) {\n    rideMap . emplace ( ride [ 1 ] , vector < int > ( ) ) ;\n    rideMap [ ride [ 1 ] ] . push_back ( ride ) ;\n  }\n  for ( int i = 1 ;\n  i <= n ;\n  i ++ ) {\n    dp [ i ] = dp [ i - 1 ] ;\n    for ( auto & ride : rideMap . getOrDefault ( i , vector < int > ( ) ) ) dp [ i ] = max ( dp [ i ] , dp [ ride [ 0 ] ] + ride [ 1 ] - ride [ 0 ] + ride [ 2 ] ) ;\n  }\n  return dp [ n ] ;\n}\n",
        "reference_code": "long long maxTaxiEarnings(int n, vector<vector<int>> &rides) {\n        vector<long long> dp(n + 1);\n        unordered_map<int, vector<vector<int>>> rideMap;\n        for (const auto &ride : rides) {\n            rideMap[ride[1]].push_back(ride);\n        }\n        for (int i = 1; i <= n; i++) {\n            dp[i] = dp[i - 1];\n            for (const auto &ride : rideMap[i]) {\n                dp[i] = max(dp[i], dp[ride[0]] + ride[1] - ride[0] + ride[2]);\n            }\n        }\n        return dp[n];\n    }",
        "target_Lan": "cpp###maxTaxiEarnings.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n// TOFILL\nint main() {\n    vector<vector<int>> rides1 = {{0, 2, 5}, {1, 5, 10}, {3, 4, 7}};\n    cout << maxTaxiEarnings(5, rides1) << endl;\n\n    vector<vector<int>> rides2 = {};\n    cout << maxTaxiEarnings(0, rides2) << endl;\n\n    vector<vector<int>> rides3 = {{0, 1, 2}, {1, 3, 5}, {2, 4, 10}, {0, 5, 1000000000}};\n    cout << maxTaxiEarnings(5, rides3) << endl;\n\n    vector<vector<int>> rides4 = {{0, 1, 10}, {0, 1, 5}};\n    cout << maxTaxiEarnings(1, rides4) << endl;\n\n    vector<vector<int>> rides5 = {{0, 10, 50}, {1, 5, 20}, {5, 10, 30}, {6, 9, 25}};\n    cout << maxTaxiEarnings(10, rides5) << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###carPooling_Test.java",
        "source_code": "public static boolean carPooling(int[][] trips, int capacity) {\n        int toMax = 0;\n        for (int[] trip : trips) {\n            toMax = Math.max(toMax, trip[2]);\n        }\n        int[] diff = new int[toMax + 1];\n        for (int[] trip : trips) {\n            diff[trip[1]] += trip[0];\n            diff[trip[2]] -= trip[0];\n        }\n        int count = 0;\n        for (int i = 0; i <= toMax; ++i) {\n            count += diff[i];\n            if (count > capacity) {\n                return false;\n            }\n        }\n        return true;\n    }",
        "trans_code": "bool carPooling ( vector < vector < int >> & trips , int capacity ) {\n  int to_max = 0 ;\n  for ( auto & trip : trips ) to_max = max ( to_max , trip [ 2 ] ) ;\n  vector < int > diff ( to_max + 1 , 0 ) ;\n  for ( auto & trip : trips ) {\n    diff [ trip [ 1 ] ] += trip [ 0 ] ;\n    diff [ trip [ 2 ] ] -= trip [ 0 ] ;\n  }\n  int count = 0 ;\n  for ( int i = 0 ;\n  i <= to_max ;\n  ++ i ) {\n    count += diff [ i ] ;\n    if ( count > capacity ) return false ;\n  }\n  return true ;\n}\n",
        "reference_code": "bool carPooling(vector<vector<int>>& trips, int capacity) {\n        int to_max = 0;\n        for (const auto& trip: trips) {\n            to_max = max(to_max, trip[2]);\n        }\n        vector<int> diff(to_max + 1);\n        for (const auto& trip: trips) {\n            diff[trip[1]] += trip[0];\n            diff[trip[2]] -= trip[0];\n        }\n        int count = 0;\n        for (int i = 0; i <= to_max; ++i) {\n            count += diff[i];\n            if (count > capacity) {\n                return false;\n            }\n        }\n        return true;\n    }",
        "target_Lan": "cpp###carPooling.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    vector<vector<int>> trips1 = {};\n    cout << carPooling(trips1, 5) << endl;\n\n    vector<vector<int>> trips2 = {{1, 0, 1}, {2, 1, 3}};\n    cout << carPooling(trips2, 5) << endl;\n\n    vector<vector<int>> trips3 = {{2, 1, 5}, {3, 5, 8}};\n    cout << carPooling(trips3, 5) << endl;\n\n    vector<vector<int>> trips4 = {{4, 0, 5}, {5, 3, 7}};\n    cout << carPooling(trips4, 10) << endl;\n\n    vector<vector<int>> trips5 = {{2, 0, 5}, {3, 2, 7}, {1, 3, 6}};\n    cout << carPooling(trips5, 4) << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###firstCompleteIndex_Test.java",
        "source_code": "public static int firstCompleteIndex(int[] arr, int[][] mat) {\n        int n = mat.length;\n        int m = mat[0].length;\n        Map<Integer, int[]> map = new HashMap<Integer, int[]>();\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                map.put(mat[i][j], new int[]{i, j});\n            }\n        }\n        int[] rowCnt = new int[n];\n        int[] colCnt = new int[m];\n        for (int i = 0; i < arr.length; ++i) {\n            int[] v = map.get(arr[i]);\n            ++rowCnt[v[0]];\n            if (rowCnt[v[0]] == m) {\n                return i;\n            }\n            ++colCnt[v[1]];\n            if (colCnt[v[1]] == n) {\n                return i;\n            }\n        }\n        return -1;\n    }",
        "trans_code": "public : int firstCompleteIndex ( vector < vector < int >> & arr , vector < vector < int >> & mat ) {\n  int n = mat . size ( ) ;\n  int m = mat [ 0 ] . size ( ) ;\n  map < int , vector < int >> map ;\n  for ( int i = 0 ;\n  i < n ;\n  ++ i ) {\n    for ( int j = 0 ;\n    j < m ;\n    ++ j ) {\n      map [ mat [ i ] [ j ] ] . push_back ( i , j ) ;\n    }\n  }\n  vector < int > row_cnt ( n , 0 ) ;\n  vector < int > col_cnt ( m , 0 ) ;\n  for ( int i = 0 ;\n  i < arr . size ( ) ;\n  ++ i ) {\n    vector < int > v = map [ arr [ i ] ] ;\n    ++ row_cnt [ v [ 0 ] ] ;\n    if ( row_cnt [ v [ 0 ] ] == m ) return i ;\n    ++ col_cnt [ v [ 1 ] ] ;\n    if ( col_cnt [ v [ 1 ] ] == n ) return i ;\n  }\n  return - 1 ;\n}\n",
        "reference_code": "int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\n        int n = mat.size();\n        int m = mat[0].size();\n        unordered_map<int, pair<int, int>> mp;\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                mp[mat[i][j]] = {i, j};\n            }\n        }\n        vector<int> rowCnt(n, 0);\n        vector<int> colCnt(m, 0);\n        for (int i = 0; i < arr.size(); ++i) {\n            auto& v = mp[arr[i]];\n            ++rowCnt[v.first];\n            if (rowCnt[v.first] == m) {\n                return i;\n            }\n            ++colCnt[v.second];\n            if (colCnt[v.second] == n) {\n                return i;\n            }\n        }\n        return -1;\n    }",
        "target_Lan": "cpp###firstCompleteIndex.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n// TOFILL\nint main() {\n    vector<int> arr1 = {1, 2, 3, 4, 5};\n    vector<vector<int>> mat1 = {{1, 2}, {3, 4}};\n    cout << firstCompleteIndex(arr1, mat1) << endl;\n\n    vector<int> arr2 = {1, 3};\n    vector<vector<int>> mat2 = {{1, 2, 3}, {4, 5, 6}};\n    cout << firstCompleteIndex(arr2, mat2) << endl;\n\n    vector<int> arr3 = {1, 5, 2, 3};\n    vector<vector<int>> mat3 = {{1, 2}, {3, 5}};\n    cout << firstCompleteIndex(arr3, mat3) << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###closeStrings_Test.java",
        "source_code": "public static boolean closeStrings(String word1, String word2) {\n        int[] count1 = new int[26], count2 = new int[26];\n        for (char c : word1.toCharArray()) {\n            count1[c - 'a']++;\n        }\n        for (char c : word2.toCharArray()) {\n            count2[c - 'a']++;\n        }\n        for (int i = 0; i < 26; i++) {\n            if (count1[i] > 0 && count2[i] == 0 || count1[i] == 0 && count2[i] > 0) {\n                return false;\n            }\n        }\n        Arrays.sort(count1);\n        Arrays.sort(count2);\n        return Arrays.equals(count1, count2);\n    }",
        "trans_code": "bool closeStrings ( string word1 , string word2 ) {\n  int count1 [ 26 ] , count2 [ 26 ] ;\n  for ( char c : word1 ) count1 [ c - 'a' ] ++ ;\n  for ( char c : word2 ) count2 [ c - 'a' ] ++ ;\n  for ( int i = 0 ;\n  i < 26 ;\n  i ++ ) {\n    if ( count1 [ i ] > 0 && count2 [ i ] == 0 || count1 [ i ] == 0 && count2 [ i ] > 0 ) return false ;\n  }\n  sort ( count1 , count1 + 26 ) ;\n  sort ( count2 , count2 + 26 ) ;\n  return memcmp ( count1 , count2 , 26 ) == 0 ;\n}\n",
        "reference_code": "bool closeStrings(string word1, string word2) {\n        vector<int> count1(26), count2(26);\n        for (char c : word1) {\n            count1[c - 'a']++;\n        }\n        for (char c : word2) {\n            count2[c - 'a']++;\n        }\n        for (int i = 0; i < 26; i++) {\n            if (count1[i] > 0 && count2[i] == 0 || count1[i] == 0 && count2[i] > 0) {\n                return false;\n            }\n        }\n        sort(count1.begin(), count1.end());\n        sort(count2.begin(), count2.end());\n        return count1 == count2;\n    }",
        "target_Lan": "cpp###closeStrings.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n// TOFILL\nint main() {\n    cout << closeStrings(\"abc\", \"abc\") << endl; \n    cout << closeStrings(\"aabbcc\", \"abcabc\") << endl; \n    cout << closeStrings(\"aabbcc\", \"abc\") << endl; \n    cout << closeStrings(\"abc\", \"def\") << endl; \n    cout << closeStrings(\"\", \"\") << endl; \n}"
    },
    {
        "source_Lan": "java###minDeletion_Test.java",
        "source_code": "public static int minDeletion(int[] nums) {\n        int n = nums.length;\n        int ans = 0;\n        boolean check = true;\n        for (int i = 0; i + 1 < n; ++i) {\n            if (nums[i] == nums[i + 1] && check) {\n                ++ans;\n            } else {\n                check = !check;\n            }\n        }\n        if ((n - ans) % 2 != 0) {\n            ++ans;\n        }\n        return ans;\n    }",
        "trans_code": "public : int minDeletion ( vector < int > & nums ) {\n  int n = nums . size ( ) ;\n  int ans = 0 ;\n  bool check = true ;\n  for ( int i = 0 ;\n  i + 1 < n ;\n  ++ i ) {\n    if ( nums [ i ] == nums [ i + 1 ] && check ) ++ ans ;\n    else check = ! check ;\n  }\n  if ( ( n - ans ) % 2 != 0 ) ++ ans ;\n  return ans ;\n}\n",
        "reference_code": "int minDeletion(vector<int>& nums) {\n        int n = nums.size();\n        int ans = 0;\n        bool check = true;\n        for (int i = 0; i + 1 < n; ++i) {\n            if (nums[i] == nums[i + 1] && check) {\n                ++ans;\n            }\n            else {\n                check = !check;\n            }\n        }\n        if ((n - ans) % 2 != 0) {\n            ++ans;\n        }\n        return ans;\n    }",
        "target_Lan": "cpp###minDeletion.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    vector<int> input1 = {};\n    vector<int> input2 = {1, 2, 3, 4};\n    vector<int> input3 = {1, 1, 2, 2};\n    vector<int> input4 = {1, 1, 1, 2, 2};\n    vector<int> input5 = {1, 2, 2, 3, 3};\n\n    cout << minDeletion(input1) << endl;\n    cout << minDeletion(input2) << endl;\n    cout << minDeletion(input3) << endl;\n    cout << minDeletion(input4) << endl;\n    cout << minDeletion(input5) << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###maximumSum_Test.java",
        "source_code": "public static int maximumSum(int[] nums) {\n        Map<Integer, Integer> map = new HashMap<Integer, Integer>();\n        int res = -1;\n        for (int i : nums) {\n            int digitsSum = 0;\n            int temp = i;\n            while (temp > 0) {\n                digitsSum += temp % 10;\n                temp /= 10;\n            }\n            if (map.containsKey(digitsSum)) {\n                res = Math.max(res, map.get(digitsSum) + i);\n                map.put(digitsSum, Math.max(map.get(digitsSum), i));\n            } else {\n                map.put(digitsSum, i);\n            }\n        }\n        return res;\n    }",
        "trans_code": "public : int maximumSum ( vector < int > & nums ) {\n  map < int , int > map ;\n  int res = - 1 ;\n  for ( int i : nums ) {\n    int digitsSum = 0 ;\n    int temp = i ;\n    while ( temp ) {\n      digitsSum += temp % 10 ;\n      temp /= 10 ;\n    }\n    if ( map . count ( digitsSum ) ) {\n      res = max ( res , map [ digitsSum ] + i ) ;\n      map [ digitsSum ] = max ( map [ digitsSum ] , i ) ;\n    }\n    else {\n      map [ digitsSum ] = i ;\n    }\n  }\n  return res ;\n}\n",
        "reference_code": "int maximumSum(vector<int>& nums) {\n        unordered_map<int, int> dict;\n        int res = -1;\n        for (int i : nums) {\n            int digitsSum = 0;\n            int temp = i;\n            while (temp > 0) {\n                digitsSum += temp % 10;\n                temp /= 10;\n            }\n            if (dict.count(digitsSum)) {\n                res = max(res, dict[digitsSum] + i);\n                dict[digitsSum] = max(dict[digitsSum], i);\n            } else {\n                dict[digitsSum] = i;\n            }\n        }\n        return res;\n    }",
        "target_Lan": "cpp###maximumSum.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n// TOFILL\nint main() {\n    vector<int> input1 = {};\n    vector<int> input2 = {-1, -2, -3};\n    vector<int> input3 = {12, 21, 30, 3};\n    vector<int> input4 = {1, 2, 3, 4, 5};\n    vector<int> input5 = {99, 18, 9, 27};\n\n    cout << maximumSum(input1) << endl;\n    cout << maximumSum(input2) << endl;\n    cout << maximumSum(input3) << endl;\n    cout << maximumSum(input4) << endl;\n    cout << maximumSum(input5) << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###maximizeSum_Test.java",
        "source_code": "public static int maximizeSum(int[] nums, int k) {\n        int m = Arrays.stream(nums).max().getAsInt();\n        return (2 * m + k - 1) * k / 2;\n    }",
        "trans_code": "public : int maximizeSum ( vector < int > & nums , int k ) {\n  int m = accumulate ( nums . begin ( ) , nums . end ( ) , 0 ) ;\n  return ( 2 * m + k - 1 ) * k / 2 ;\n}\n",
        "reference_code": "int maximizeSum(vector<int>& nums, int k) {\n        int m = *max_element(nums.begin(), nums.end());\n        return (2 * m + k - 1) * k / 2;\n    }",
        "target_Lan": "cpp###maximizeSum.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <algorithm>\n// TOFILL\nint main() {\n    vector<int> nums1 = {1};\n    int k1 = 1;\n    cout << maximizeSum(nums1, k1) << endl;\n\n    vector<int> nums2 = {2, 3, 5, 1};\n    int k2 = 3;\n    cout << maximizeSum(nums2, k2) << endl;\n\n    vector<int> nums3 = {10, 20, 30};\n    int k3 = 5;\n    cout << maximizeSum(nums3, k3) << endl;\n\n    vector<int> nums4 = {100, 200, 300};\n    int k4 = 10;\n    cout << maximizeSum(nums4, k4) << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###findTheCity_Test.java",
        "source_code": "public static int findTheCity(int n, int[][] edges, int distanceThreshold) {\n        int[] ans = {Integer.MAX_VALUE / 2, -1};\n        int[][] mp = new int[n][n];\n        for (int i = 0; i < n; ++i) {\n            Arrays.fill(mp[i], Integer.MAX_VALUE / 2);\n        }\n        for (int[] eg : edges) {\n            int from = eg[0], to = eg[1], weight = eg[2];\n            mp[from][to] = mp[to][from] = weight;\n        }\n        for (int k = 0; k < n; ++k) {\n            mp[k][k] = 0;\n            for (int i = 0; i < n; ++i) {\n                for (int j = 0; j < n; ++j) {\n                    mp[i][j] = Math.min(mp[i][j], mp[i][k] + mp[k][j]);\n                }\n            }\n        }\n        for (int i = 0; i < n; ++i) {\n            int cnt = 0;\n            for (int j = 0; j < n; ++j) {\n                if (mp[i][j] <= distanceThreshold) {\n                    cnt++;\n                }\n            }\n            if (cnt <= ans[0]) {\n                ans[0] = cnt;\n                ans[1] = i;\n            }\n        }\n        return ans[1];\n    }",
        "trans_code": "public : int findTheCity ( int n , vector < vector < int >> & edges , int distanceThreshold ) {\n  vector < int > ans {\n    numeric_limits < int > :: max ( ) / 2 , - 1 }\n    ;\n    vector < vector < int >> mp ;\n    for ( int i = 0 ;\n    i < n ;\n    ++ i ) {\n      std :: fill ( mp . begin ( ) , mp . end ( ) , INT_MAX / 2 ) ;\n    }\n    for ( vector < int > :: const_iterator eg = edges . begin ( ) ;\n    eg != edges . end ( ) ;\n    ++ eg ) {\n      int from = * eg , to = * eg , weight = * eg ;\n      mp [ from ] [ to ] = mp [ to ] [ from ] = weight ;\n    }\n    for ( int k = 0 ;\n    k < n ;\n    ++ k ) {\n      mp [ k ] [ k ] = 0 ;\n      for ( int i = 0 ;\n      i < n ;\n      ++ i ) {\n        for ( int j = 0 ;\n        j < n ;\n        ++ j ) {\n          mp [ i ] [ j ] = min ( mp [ i ] [ j ] , mp [ i ] [ k ] + mp [ k ] [ j ] ) ;\n        }\n      }\n    }\n    for ( int i = 0 ;\n    i < n ;\n    ++ i ) {\n      int cnt = 0 ;\n      for ( int j = 0 ;\n      j < n ;\n      ++ j ) {\n        if ( mp [ i ] [ j ] <= distanceThreshold ) cnt ++ ;\n      }\n      if ( cnt <= ans [ 0 ] ) {\n        ans [ 0 ] = cnt ;\n        ans [ 1 ] = i ;\n      }\n    }\n    return ans [ 1 ] ;\n  }\n  ",
        "reference_code": "int findTheCity(int n, vector<vector<int>> &edges, int distanceThreshold) {\n        pair<int, int> ans(INT_MAX / 2, -1);\n        vector<vector<int>> mp(n, vector<int>(n, INT_MAX / 2));\n        for (auto &eg: edges) {\n            int from = eg[0], to = eg[1], weight = eg[2];\n            mp[from][to] = mp[to][from] = weight;\n        }\n        for (int k = 0; k < n; ++k) {\n            mp[k][k] = 0;\n            for (int i = 0; i < n; ++i) {\n                for (int j = 0; j < n; ++j) {\n                    mp[i][j] = min(mp[i][j], mp[i][k] + mp[k][j]);\n                }\n            }\n        }\n        for (int i = 0; i < n; ++i) {\n            int cnt = 0;\n            for (int j = 0; j < n; ++j) {\n                if (mp[i][j] <= distanceThreshold) {\n                    cnt++;\n                }\n            }\n            if (cnt <= ans.first) {\n                ans = {cnt, i};\n            }\n        }\n        return ans.second;\n    }",
        "target_Lan": "cpp###findTheCity.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <climits>\n#include <algorithm>\nusing namespace std;\n// TOFILL\nint main() {\n    \n    int n1 = 3;\n    vector<vector<int>> edges1 = {{0, 1, 5}, {0, 2, 10}};\n    int distanceThreshold1 = 6;\n    cout << findTheCity(n1, edges1, distanceThreshold1) << endl;  \n\n    \n    int n2 = 2;\n    vector<vector<int>> edges2 = {{0, 1, 1}};\n    int distanceThreshold2 = 2;\n    cout << findTheCity(n2, edges2, distanceThreshold2) << endl;  \n\n    \n    int n3 = 3;\n    vector<vector<int>> edges3 = {{0, 1, 2}};\n    int distanceThreshold3 = 3;\n    cout << findTheCity(n3, edges3, distanceThreshold3) << endl;  \n\n    \n    int n4 = 4;\n    vector<vector<int>> edges4 = {{0, 1, 1}, {1, 2, 3}, {0, 2, 2}, {2, 3, 2}};\n    int distanceThreshold4 = 5;\n    cout << findTheCity(n4, edges4, distanceThreshold4) << endl;  \n\n    \n    int n5 = 5;\n    vector<vector<int>> edges5 = {{0, 1, 1}, {1, 2, 2}, {2, 3, 1}, {3, 4, 1}, {0, 4, 10}};\n    int distanceThreshold5 = 10;\n    cout << findTheCity(n5, edges5, distanceThreshold5) << endl;  \n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###longestAlternatingSubarray_Test.java",
        "source_code": "public static int longestAlternatingSubarray(int[] nums, int threshold) {\n        int res = 0, dp = 0;\n        for (int l = nums.length - 1; l >= 0; l--) {\n            if (nums[l] > threshold) {\n                dp = 0;\n            } else if (l == nums.length - 1 || nums[l] % 2 != nums[l + 1] % 2) {\n                dp++;\n            } else {\n                dp = 1;\n            }\n            if (nums[l] % 2 == 0) {\n                res = Math.max(res, dp);\n            }\n        }\n        return res;\n    }",
        "trans_code": "public : int longestAlternatingSubarray ( vector < int > & nums , int threshold ) {\n  int res = 0 , dp = 0 ;\n  for ( int l = nums . size ( ) - 1 ;\n  l >= 0 ;\n  l -- ) {\n    if ( nums [ l ] > threshold ) dp = 0 ;\n    else if ( l == nums . size ( ) - 1 || nums [ l ] % 2 != nums [ l + 1 ] % 2 ) dp ++ ;\n    else dp = 1 ;\n    if ( nums [ l ] % 2 == 0 ) res = max ( res , dp ) ;\n  }\n  return res ;\n}\n",
        "reference_code": "int longestAlternatingSubarray(vector<int>& nums, int threshold) {\n        int res = 0, dp = 0, n = nums.size();\n        for (int l = n - 1; l >= 0; l--) {\n            if (nums[l] > threshold) {\n                dp = 0;\n            } else if (l == n - 1 || nums[l] % 2 != nums[l + 1] % 2) {\n                dp++;\n            } else {\n                dp = 1;\n            }\n            if (nums[l] % 2 == 0) {\n                res = max(res, dp);\n            }\n        }\n        return res;\n    }",
        "target_Lan": "cpp###longestAlternatingSubarray.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    vector<int> input1 = {};\n    vector<int> input2 = {10, 12, 14};\n    vector<int> input3 = {2, 3, 6, 7, 4};\n    vector<int> input4 = {1, 5, 2, 3};\n    vector<int> input5 = {8, 6, 2, 4};\n\n    cout << longestAlternatingSubarray(input1, 5) << endl;\n    cout << longestAlternatingSubarray(input2, 8) << endl;\n    cout << longestAlternatingSubarray(input3, 10) << endl;\n    cout << longestAlternatingSubarray(input4, 2) << endl;\n    cout << longestAlternatingSubarray(input5, 8) << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###findTheLongestBalancedSubstring_Test.java",
        "source_code": "public static int findTheLongestBalancedSubstring(String s) {\n        int res = 0;\n        int n = s.length();\n        int[] count = new int[2];\n        for (int i = 0; i < n; i++) {\n            if (s.charAt(i) == '1') {\n                count[1]++;\n                res = Math.max(res, 2 * Math.min(count[0], count[1]));\n            } else if (i == 0 || s.charAt(i - 1) == '1') {\n                count[0] = 1;\n                count[1] = 0;\n            } else {\n                count[0]++;\n            }\n        }\n        return res;\n    }",
        "trans_code": "public : int findTheLongestBalancedSubstring ( string s ) {\n  int res = 0 ;\n  int n = s . length ( ) ;\n  vector < int > count ( 2 , 0 ) ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    if ( s [ i ] == '1' ) {\n      count [ 1 ] ++ ;\n      res = max ( res , 2 * min ( count [ 0 ] , count [ 1 ] ) ) ;\n    }\n    else if ( i == 0 || s [ i - 1 ] == '1' ) {\n      count [ 0 ] = 1 ;\n      count [ 1 ] = 0 ;\n    }\n    else {\n      count [ 0 ] ++ ;\n    }\n  }\n  return res ;\n}\n",
        "reference_code": "int findTheLongestBalancedSubstring(string s) {\n        int res = 0, n = s.size();\n        vector<int> count(2);\n        for (int i = 0; i < n; i++) {\n            if (s[i] == '1') {\n                count[1]++;\n                res = max(res, 2 * min(count[0], count[1]));\n            } else if (i == 0 || s[i - 1] == '1') {\n                count[0] = 1;\n                count[1] = 0;\n            } else {\n                count[0]++;\n            }\n        }\n        return res;            \n    }",
        "target_Lan": "cpp###findTheLongestBalancedSubstring.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <string>\n// TOFILL\nint main() {\n    cout << findTheLongestBalancedSubstring(\"\") << endl;      \n    cout << findTheLongestBalancedSubstring(\"0000\") << endl;  \n    cout << findTheLongestBalancedSubstring(\"1111\") << endl;  \n    cout << findTheLongestBalancedSubstring(\"010101\") << endl; \n    cout << findTheLongestBalancedSubstring(\"001100\") << endl; \n}"
    },
    {
        "source_Lan": "java###vowelStrings_Test.java",
        "source_code": "public static int vowelStrings(String[] words, int left, int right) {\n        Set<Character> vowels = new HashSet<Character>() {{\n            add('a');\n            add('e');\n            add('i');\n            add('o');\n            add('u');\n        }};\n        int ans = 0;\n        for (int i = left; i <= right; ++i) {\n            String word = words[i];\n            if (vowels.contains(word.charAt(0)) && vowels.contains(word.charAt(word.length() - 1))) {\n                ++ans;\n            }\n        }\n        return ans;\n    }",
        "trans_code": "public : int vowelStrings ( vector < string > & words , int left , int right ) {\n  set < char > vowels {\n    'a' , 'e' , 'i' , 'o' , 'u' }\n    ;\n    int ans = 0 ;\n    for ( int i = left ;\n    i <= right ;\n    ++ i ) {\n      string word = words [ i ] ;\n      if ( vowels . find ( word [ 0 ] ) != vowels . end ( ) && vowels . find ( word [ word . size ( ) - 1 ] ) != vowels . end ( ) ) ++ ans ;\n    }\n    return ans ;\n  }\n  ",
        "reference_code": "int vowelStrings(vector<string>& words, int left, int right) {\n        unordered_set<char> vowels = {'a', 'e', 'i', 'o', 'u'};\n        int ans = 0;\n        for (int i = left; i <= right; ++i) {\n            const string& word = words[i];\n            if (vowels.count(word[0]) && vowels.count(word.back())) {\n                ++ans;\n            }\n        }\n        return ans;\n    }",
        "target_Lan": "cpp###vowelStrings.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <unordered_set>\n// TOFILL\nint main() {\n    vector<string> words1 = {\"apple\", \"banana\", \"orange\", \"grape\", \"umbrella\"};\n    vector<string> words2 = {\"cat\", \"dog\", \"fish\", \"bear\", \"elephant\"};\n    vector<string> words3 = {\"Apple\", \"grapE\", \"Orange\", \"umbrella\", \"fruit\"};\n    vector<string> words4 = {\"kite\", \"none\", \"axe\", \"input\", \"o\"};\n\n    cout << vowelStrings(words1, 0, 4) << endl;\n    cout << vowelStrings(words2, 0, 4) << endl;\n    cout << vowelStrings(words3, 0, 4) << endl;\n    cout << vowelStrings(words4, 2, 3) << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###countDigits_Test.java",
        "source_code": "public static int countDigits(int num) {\n        int t = num;\n        int res = 0;\n        while (t != 0) {\n            if (num % (t % 10) == 0) {\n                res++;\n            }\n            t /= 10;\n        }\n        return res;\n    }",
        "trans_code": "public : int countDigits ( int num ) {\n  int t = num ;\n  int res = 0 ;\n  while ( t != 0 ) {\n    if ( num % ( t % 10 ) == 0 ) res ++ ;\n    t /= 10 ;\n  }\n  return res ;\n}\n",
        "reference_code": "int countDigits(int num) {\n        int t = num, res = 0;\n        while (t) {\n            if (num % (t % 10) == 0) {\n                res += 1;\n            }\n            t /= 10;\n        }\n        return res;\n    }",
        "target_Lan": "cpp###countDigits.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n// TOFILL\nint main() {\n    cout << countDigits(0) << endl;\n    cout << countDigits(12) << endl;\n}"
    },
    {
        "source_Lan": "java###categorizeBox_Test.java",
        "source_code": "public static String categorizeBox(int length, int width, int height, int mass) {\n        long maxd = Math.max(length, Math.max(width, height)), vol = 1L * length * width * height;\n        boolean isBulky = maxd >= 10000 || vol >= 1000000000, isHeavy = mass >= 100;\n        if (isBulky && isHeavy) {\n             return \"Both\";\n        } else if (isBulky) {\n            return \"Bulky\";\n        } else if (isHeavy) {\n            return \"Heavy\";\n        } else {\n            return \"Neither\";\n        }\n    }",
        "trans_code": "string categorizeBox ( int length , int width , int height , int mass ) {\n  long maxd = max ( length , max ( width , height ) ) , vol = 1L * length * width * height ;\n  bool isBulky = maxd >= 10000 || vol >= 1000000000 , isHeavy = mass >= 100 ;\n  if ( isBulky && isHeavy ) return \"Both\" ;\n  else if ( isBulky ) return \"Bulky\" ;\n  else if ( isHeavy ) return \"Heavy\" ;\n  else return \"Neither\" ;\n}\n",
        "reference_code": "string categorizeBox(int length, int width, int height, int mass) {\n        long long maxd = max(length, max(width, height)), vol = 1L * length * width * height;\n        bool isBulky = maxd >= 10000 || vol >= 1000000000, isHeavy = mass >= 100;\n        if (isBulky && isHeavy) {\n             return \"Both\";\n        } else if (isBulky) {\n            return \"Bulky\";\n        } else if (isHeavy) {\n            return \"Heavy\";\n        } else {\n            return \"Neither\";\n        }\n    }",
        "target_Lan": "cpp###categorizeBox.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <string>\n// TOFILL\nint main() {\n    cout << categorizeBox(10001, 50, 50, 150) << endl;\n    cout << categorizeBox(10001, 50, 50, 50) << endl;\n    cout << categorizeBox(10, 10, 10, 150) << endl;\n    cout << categorizeBox(10, 10, 10, 50) << endl;\n    cout << categorizeBox(10000, 10000, 10000, 100) << endl;\n}"
    },
    {
        "source_Lan": "java###maxKelements_Test.java",
        "source_code": "public static long maxKelements(int[] nums, int k) {\n        PriorityQueue<Integer> q = new PriorityQueue<Integer>((a, b) -> b - a);\n        for (int num : nums) {\n            q.offer(num);\n        }\n        long ans = 0;\n        for (int i = 0; i < k; ++i) {\n            int x = q.poll();\n            ans += x;\n            q.offer((x + 2) / 3);\n        }\n        return ans;\n    }",
        "trans_code": "public : long long maxKelements ( vector < int > & nums , int k ) {\n  priority_queue < int , vector < int > , greater < int >> q ( ( int * ) & nums [ 0 ] , ( int * ) & nums [ 0 ] + nums . size ( ) ) ;\n  for ( int num : nums ) q . push ( num ) ;\n  long long ans = 0 ;\n  for ( int i = 0 ;\n  i < k ;\n  ++ i ) {\n    int x = q . top ( ) ;\n    ans += x ;\n    q . pop ( ) ;\n  }\n  return ans ;\n}\n",
        "reference_code": "long long maxKelements(vector<int>& nums, int k) {\n        priority_queue<int> q(nums.begin(), nums.end());\n        long long ans = 0;\n        for (int _ = 0; _ < k; ++_) {\n            int x = q.top();\n            q.pop();\n            ans += x;\n            q.push((x + 2) / 3);\n        }\n        return ans;\n    }",
        "target_Lan": "cpp###maxKelements.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\nusing namespace std;\n// TOFILL\nint main() {\n    \n    vector<int> nums1 = {0, 0, 0};\n    int k1 = 3;\n    cout << maxKelements(nums1, k1) << endl;  \n\n    \n    vector<int> nums2 = {-5, 3, 2, -1, 4};\n    int k2 = 5;\n    cout << maxKelements(nums2, k2) << endl;  \n\n    \n    vector<int> nums3 = {1024, 1024, 1024};\n    int k3 = 3;\n    cout << maxKelements(nums3, k3) << endl;  \n\n    \n    vector<int> nums4 = {1000000};\n    int k4 = 1;\n    cout << maxKelements(nums4, k4) << endl;  \n\n    \n    vector<int> nums5 = {};\n    int k5 = 0;\n    cout << maxKelements(nums5, k5) << endl;  \n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###minimumOneBitOperations_Test.java",
        "source_code": "public static int minimumOneBitOperations(int n) {\n        int ans = 0;\n        int sign = 1;\n        for (int i = 29; i >= 0; --i) {\n            if ((n & (1 << i)) != 0) {\n                ans += sign * ((1 << (i + 1)) - 1);\n                sign = -sign;\n            }\n        }\n        return ans;\n    }",
        "trans_code": "public : int minimumOneBitOperations ( int n ) {\n  int ans = 0 ;\n  int sign = 1 ;\n  for ( int i = 29 ;\n  i >= 0 ;\n  -- i ) {\n    if ( ( n & ( 1 << i ) ) != 0 ) {\n      ans += sign * ( ( 1 << ( i + 1 ) ) - 1 ) ;\n      sign = - sign ;\n    }\n  }\n  return ans ;\n}\n",
        "reference_code": "int minimumOneBitOperations(int n) {\n        int ans = 0;\n        int sign = 1;\n        for (int i = 29; i >= 0; --i) {\n            if (n & (1 << i)) {\n                ans += sign * ((1 << (i + 1)) - 1);\n                sign = -sign;\n            }\n        }\n        return ans;\n    }",
        "target_Lan": "cpp###minimumOneBitOperations.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n// TOFILL\nint main() {\n    cout << minimumOneBitOperations(0) << endl;\n    cout << minimumOneBitOperations(1) << endl;\n    cout << minimumOneBitOperations(5) << endl;\n    cout << minimumOneBitOperations(1073741823) << endl;\n    cout << minimumOneBitOperations(-1) << endl;\n}"
    },
    {
        "source_Lan": "java###successfulPairs_Test.java",
        "source_code": "public static int[] successfulPairs(int[] spells, int[] potions, long success) {\n        int n = spells.length, m = potions.length;\n        int[] res = new int[n];\n        int[][] idx = new int[n][2];\n        for (int i = 0; i < n; ++i) {\n            idx[i][0] = spells[i];\n            idx[i][1] = i;\n        }\n        Arrays.sort(potions);\n        for (int i = 0, j = m - 1; i < j; ++i, --j) {\n            int temp = potions[i];\n            potions[i] = potions[j];\n            potions[j] = temp;\n        }\n        Arrays.sort(idx, (a, b) -> a[0] - b[0]);\n        for (int i = 0, j = 0; i < n; ++i) {\n            int p = idx[i][1];\n            int v = idx[i][0];\n            while (j < m && (long) potions[j] * v >= success) {\n                ++j;\n            }\n            res[p] = j;\n        }\n        return res;\n    }",
        "trans_code": "vector < int > successfulPairs ( vector < int > spells , vector < int > potions , uint32_t success ) {\n  int n = spells . size ( ) , m = potions . size ( ) ;\n  vector < int > res ;\n  vector < int > idx ;\n  for ( int i = 0 ;\n  i < n ;\n  ++ i ) {\n    idx . push_back ( spells [ i ] ) ;\n    idx . push_back ( i ) ;\n  }\n  sort ( potions . begin ( ) , potions . end ( ) ) ;\n  for ( int i = 0 , j = m - 1 ;\n  i < j ;\n  ++ i , -- j ) {\n    int temp = potions [ i ] ;\n    potions [ i ] = potions [ j ] ;\n    potions [ j ] = temp ;\n  }\n  sort ( idx . begin ( ) , idx . end ( ) , ( a , b ) -> first ) ;\n  for ( int i = 0 , j = 0 ;\n  i < n ;\n  ++ i ) {\n    int p = idx [ i ] ;\n    int v = idx [ i ] ;\n    while ( j < m && ( uint32_t ) potions [ j ] * v >= success ) ++ j ;\n    res . push_back ( p ) ;\n  }\n  return res ;\n}\n",
        "reference_code": "vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\n        vector<int> res(spells.size());\n        vector<int> idx(spells.size());\n        iota(idx.begin(), idx.end(), 0);\n        sort(idx.begin(), idx.end(), [&](int a, int b) {\n            return spells[a] < spells[b];\n        });\n        sort(potions.begin(), potions.end(), [](int a, int b) {\n            return a > b;\n        });\n        for (int i = 0, j = 0; i < spells.size(); ++i) {\n            int p = idx[i];\n            int v = spells[p];\n            while (j < potions.size() && (long long) potions[j] * v >= success) {\n                ++j;\n            }\n            res[p] = j;\n        }\n        return res;\n    }",
        "target_Lan": "cpp###successfulPairs.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n// TOFILL\nint main() {\n    vector<int> spells1 = {1, 2, 3};\n    vector<int> potions1 = {10, 20, 30};\n    long long success1 = 20;\n    vector<int> result1 = successfulPairs(spells1, potions1, success1);\n    for(int r : result1) cout << r << \" \";\n    cout << endl;\n\n    vector<int> spells2 = {1, 2, 3};\n    vector<int> potions2 = {0};\n    long long success2 = 1;\n    vector<int> result2 = successfulPairs(spells2, potions2, success2);\n    for(int r : result2) cout << r << \" \";\n    cout << endl;\n\n    vector<int> spells3 = {};\n    vector<int> potions3 = {1, 2, 3};\n    long long success3 = 5;\n    vector<int> result3 = successfulPairs(spells3, potions3, success3);\n    for(int r : result3) cout << r << \" \";\n    cout << endl;\n\n    vector<int> spells4 = {1000000, 2000000};\n    vector<int> potions4 = {1, 2};\n    long long success4 = 2000000;\n    vector<int> result4 = successfulPairs(spells4, potions4, success4);\n    for(int r : result4) cout << r << \" \";\n    cout << endl;\n\n    vector<int> spells5 = {5, 10, 15};\n    vector<int> potions5 = {5, 10, 15};\n    long long success5 = 75;\n    vector<int> result5 = successfulPairs(spells5, potions5, success5);\n    for(int r : result5) cout << r << \" \";\n    cout << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###countPairs_Test.java",
        "source_code": "public static int countPairs(List<Integer> nums, int target) {\n        int res = 0;\n        for (int i = 0; i < nums.size(); i++) {\n            for (int j = i + 1; j < nums.size(); j++) {\n                if (nums.get(i) + nums.get(j) < target) {\n                    res++;\n                }\n            }\n        }\n        return res;\n    }",
        "trans_code": "public : int countPairs ( vector < int > & nums , int target ) {\n  int res = 0 ;\n  for ( int i = 0 ;\n  i < nums . size ( ) ;\n  i ++ ) {\n    for ( int j = i + 1 ;\n    j < nums . size ( ) ;\n    j ++ ) {\n      if ( nums [ i ] + nums [ j ] < target ) res ++ ;\n    }\n  }\n  return res ;\n}\n",
        "reference_code": "int countPairs(vector<int>& nums, int target) {\n        int res = 0;\n        for (int i = 0; i < nums.size(); i++) {\n            for (int j = i + 1; j < nums.size(); j++) {\n                if (nums[i] + nums[j] < target) {\n                    res++;\n                }\n            }\n        }\n        return res;\n    }",
        "target_Lan": "cpp###countPairs.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    vector<int> nums1 = {};\n    int target1 = 5;\n    cout << countPairs(nums1, target1) << endl;\n\n    vector<int> nums2 = {1};\n    int target2 = 3;\n    cout << countPairs(nums2, target2) << endl;\n\n    vector<int> nums3 = {1, 2, 3};\n    int target3 = 6;\n    cout << countPairs(nums3, target3) << endl;\n\n    vector<int> nums4 = {1, 5, 8};\n    int target4 = 10;\n    cout << countPairs(nums4, target4) << endl;\n\n    vector<int> nums5 = {-1, -2, 3, 4};\n    int target5 = 2;\n    cout << countPairs(nums5, target5) << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###tupleSameProduct_Test.java",
        "source_code": "    public static int tupleSameProduct(int[] nums) {\n        int n = nums.length;\n        Map<Integer, Integer> cnt = new HashMap<>();\n        for (int i = 0; i < n; i++) {\n            for(int j = i + 1; j < n; j++) {\n                int key = nums[i] * nums[j];\n                cnt.put(key, cnt.getOrDefault(key, 0) + 1);\n            }\n        }\n        int ans = 0;\n        for (Integer v : cnt.values()) {\n            ans += v * (v - 1) * 4;\n        }\n        return ans;\n    }",
        "trans_code": "public : int tupleSameProduct ( vector < int > & nums ) {\n  int n = nums . size ( ) ;\n  map < int , int > cnt ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    for ( int j = i + 1 ;\n    j < n ;\n    j ++ ) {\n      int key = nums [ i ] * nums [ j ] ;\n      cnt [ key ] = cnt . count ( key ) + 1 ;\n    }\n  }\n  int ans = 0 ;\n  for ( auto v : cnt ) ans += v * ( v - 1 ) * 4 ;\n  return ans ;\n}\n",
        "reference_code": "int tupleSameProduct(vector<int>& nums) {\n        int n = nums.size();\n        int ans = 0;\n        unordered_map<int, int> cnt;\n        for (int i = 0; i < n; i++) {\n            for(int j = i + 1; j < n; j++) {\n                cnt[nums[i] * nums[j]]++;\n            }\n        }\n        for (auto &[k, v] : cnt) {\n            ans += v * (v - 1) * 4;\n        }\n        return ans;\n    }",
        "target_Lan": "cpp###tupleSameProduct.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n// TOFILL\nint main() {\n    vector<int> input1 = {};\n    vector<int> input2 = {1};\n    vector<int> input3 = {1, 2, 3, 4, 1, 2};\n    vector<int> input4 = {-1, -2, -3, -4, 1, 2};\n    vector<int> input5 = {10000, 20000, 30000};\n    \n    cout << tupleSameProduct(input1) << endl;\n    cout << tupleSameProduct(input2) << endl;\n    cout << tupleSameProduct(input3) << endl;\n    cout << tupleSameProduct(input4) << endl;\n    cout << tupleSameProduct(input5) << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###sumOfMultiples_Test.java",
        "source_code": "public static int sumOfMultiples(int n) {\n        int res = 0;\n        for (int i = 1; i <= n; i++) {\n            if (i % 3 == 0 || i % 5 == 0 || i % 7 == 0) {\n                res += i;\n            }\n        }\n        return res;\n    }",
        "trans_code": "public : int sumOfMultiples ( int n ) {\n  int res = 0 ;\n  for ( int i = 1 ;\n  i <= n ;\n  i ++ ) {\n    if ( i % 3 == 0 || i % 5 == 0 || i % 7 == 0 ) res += i ;\n  }\n  return res ;\n}\n",
        "reference_code": "int sumOfMultiples(int n) {\n        int res = 0;\n        for (int i = 1; i <= n; i++) {\n            if (i % 3 == 0 || i % 5 == 0 || i % 7 == 0) {\n                res += i;\n            }\n        }\n        return res;\n    }",
        "target_Lan": "cpp###sumOfMultiples.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n// TOFILL\nint main() {\n    cout << sumOfMultiples(0) << endl;\n    cout << sumOfMultiples(1) << endl;\n    cout << sumOfMultiples(3) << endl;\n    cout << sumOfMultiples(10) << endl;\n    cout << sumOfMultiples(100) << endl;\n}"
    },
    {
        "source_Lan": "java###topStudents_Test.java",
        "source_code": "public static List<Integer> topStudents(String[] positive_feedback, String[] negative_feedback, String[] report, int[] student_id, int k) {\n        Map<String, Integer> words = new HashMap<>();\n        for (String word : positive_feedback) {\n            words.put(word, 3);\n        }\n        for (String word : negative_feedback) {\n            words.put(word, -1);\n        }\n        int n = report.length;\n        int[] scores = new int[n];\n        int[][] A = new int[n][2];\n        for (int i = 0; i < n; i++) {\n            int score = 0;\n            for (String word : report[i].split(\" \")) {\n                score += words.getOrDefault(word, 0);\n            }\n            A[i] = new int[]{-score, student_id[i]};\n        }\n        Arrays.sort(A, (a, b) -> a[0] == b[0] ? a[1] - b[1] : a[0] - b[0]);\n        List<Integer> topK = new ArrayList<>();\n        for (int i = 0; i < k; i++) {\n            topK.add(A[i][1]);\n        }\n        return topK;\n    }",
        "trans_code": "public : vector < int > topStudents ( vector < string > & positive_feedback , vector < string > & negative_feedback , vector < string > & report , vector < int > & student_id , int k ) {\n  map < string , int > words ;\n  for ( auto word : positive_feedback ) words [ word ] = 3 ;\n  for ( auto word : negative_feedback ) words [ word ] = - 1 ;\n  int n = report . size ( ) ;\n  vector < int > scores ;\n  vector < vector < int >> A ( n , 0 ) ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    int score = 0 ;\n    for ( auto word : report [ i ] ) score += words . at ( word ) ;\n    A [ i ] . push_back ( {\n      - score , student_id [ i ] }\n      ) ;\n    }\n    sort ( A . begin ( ) , A . end ( ) , ( a , b ) -> second ) ;\n    vector < int > topK ;\n    for ( int i = 0 ;\n    i < k ;\n    i ++ ) topK . push_back ( A [ i ] . at ( 1 ) ) ;\n    return topK ;\n  }\n  ",
        "reference_code": "vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& student_id, int k) {\n        unordered_map<std::string, int> words;\n        for (const auto& word : positive_feedback) {\n            words[word] = 3;\n        }\n        for (const auto& word : negative_feedback) {\n            words[word] = -1;\n        }\n        vector<vector<int>> A;\n        for (int i = 0; i < report.size(); i++) {\n            stringstream ss; \n            string w;\n            int score = 0;\n            ss << report[i];\n            while (ss >> w) {\n                if (words.count(w)) {\n                    score += words[w];\n                }\n            }\n            A.push_back({-score, student_id[i]});\n        }\n        sort(A.begin(), A.end());\n        vector<int> top_k;\n        for (int i = 0; i < k; i++) {\n            top_k.push_back(A[i][1]);\n        }\n        return top_k;\n    }",
        "target_Lan": "cpp###topStudents.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <sstream>\n#include <algorithm>\n// TOFILL\nint main() {\n    vector<string> positive_feedback1 = {\"good\", \"excellent\", \"great\"};\n    vector<string> negative_feedback1 = {\"bad\", \"poor\"};\n    vector<string> report1 = {\"good work excellent\", \"bad performance\", \"great effort\", \"excellent but with some poor points\"};\n    vector<int> student_id1 = {1, 2, 3, 4};\n    int k1 = 2;\n    vector<int> result1 = topStudents(positive_feedback1, negative_feedback1, report1, student_id1, k1);\n    for(int id : result1) {\n        cout << id << \" \";\n    }\n    cout << endl;\n\n    vector<string> positive_feedback2 = {};\n    vector<string> negative_feedback2 = {};\n    vector<string> report2 = {};\n    vector<int> student_id2 = {};\n    int k2 = 0;\n    vector<int> result2 = topStudents(positive_feedback2, negative_feedback2, report2, student_id2, k2);\n    for(int id : result2) {\n        cout << id << \" \";\n    }\n    cout << endl;\n\n    vector<string> positive_feedback3 = {\"smart\", \"hardworking\"};\n    vector<string> negative_feedback3 = {\"lazy\"};\n    vector<string> report3 = {\"smart hardworking\", \"lazy lazy\"};\n    vector<int> student_id3 = {1, 2};\n    int k3 = 1;\n    vector<int> result3 = topStudents(positive_feedback3, negative_feedback3, report3, student_id3, k3);\n    for(int id : result3) {\n        cout << id << \" \";\n    }\n    cout << endl;\n\n    vector<string> positive_feedback4 = {\"amazing\"};\n    vector<string> negative_feedback4 = {\"awful\"};\n    vector<string> report4 = {\"amazing work\", \"awful results\", \"amazing effort\"};\n    vector<int> student_id4 = {1, 2, 3};\n    int k4 = 2;\n    vector<int> result4 = topStudents(positive_feedback4, negative_feedback4, report4, student_id4, k4);\n    for(int id : result4) {\n        cout << id << \" \";\n    }\n    cout << endl;\n\n    vector<string> positive_feedback5 = {\"fantastic\"};\n    vector<string> negative_feedback5 = {\"terrible\"};\n    vector<string> report5 = {\"fantastic performance\", \"terrible execution\", \"average effort\"};\n    vector<int> student_id5 = {1, 2, 3};\n    int k5 = 3;\n    vector<int> result5 = topStudents(positive_feedback5, negative_feedback5, report5, student_id5, k5);\n    for(int id : result5) {\n        cout << id << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###splitNum_Test.java",
        "source_code": "public static int splitNum(int num) {\n        char[] stnum = Integer.toString(num).toCharArray();\n        Arrays.sort(stnum);\n        int num1 = 0, num2 = 0;\n        for (int i = 0; i < stnum.length; ++i) {\n            if (i % 2 == 0) {\n                num1 = num1 * 10 + (stnum[i] - '0');\n            } else {\n                num2 = num2 * 10 + (stnum[i] - '0');\n            }\n        }\n        return num1 + num2;\n    }",
        "trans_code": "public : int splitNum ( int num ) {\n  string stnum = to_string ( num ) ;\n  sort ( stnum . begin ( ) , stnum . end ( ) ) ;\n  int num1 = 0 , num2 = 0 ;\n  for ( int i = 0 ;\n  i < stnum . size ( ) ;\n  ++ i ) {\n    if ( i % 2 == 0 ) num1 = num1 * 10 + ( stnum [ i ] - '0' ) ;\n    else num2 = num2 * 10 + ( stnum [ i ] - '0' ) ;\n  }\n  return num1 + num2 ;\n}\n",
        "reference_code": "int splitNum(int num) {\n        string stnum = to_string(num);\n        sort(stnum.begin(), stnum.end());\n        int num1 = 0, num2 = 0;\n        for (int i = 0; i < stnum.size(); ++i) {\n            if (i % 2 == 0) {\n                num1 = num1 * 10 + (stnum[i] - '0');\n            }\n            else {\n                num2 = num2 * 10 + (stnum[i] - '0');\n            }\n        }\n        return num1 + num2;\n    }",
        "target_Lan": "cpp###splitNum.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <string>\n#include <algorithm>\n// TOFILL\nint main() {\n    cout << splitNum(0) << endl;          \n    cout << splitNum(12345) << endl;     \n    cout << splitNum(-12345) << endl;    \n    cout << splitNum(999999999) << endl;  \n}"
    },
    {
        "source_Lan": "java###filterRestaurants_Test.java",
        "source_code": "public static List<Integer> filterRestaurants(int[][] restaurants, int veganFriendly, int maxPrice, int maxDistance) {\n        int n = restaurants.length;\n        List<int[]> filtered = new ArrayList<int[]>();\n        for (int i = 0; i < n; i++) {\n            if (restaurants[i][3] <= maxPrice && restaurants[i][4] <= maxDistance && !(veganFriendly == 1 && restaurants[i][2] == 0)) {\n                filtered.add(restaurants[i]);\n            }\n        }\n        Collections.sort(filtered, (a, b) -> {\n            if (a[1] != b[1]) {\n                return b[1] - a[1];\n            } else {\n                return b[0] - a[0];\n            }\n        });\n        List<Integer> res = new ArrayList<Integer>();\n        for (int[] v : filtered) {\n            res.add(v[0]);\n        }\n        return res;\n    }",
        "trans_code": "vector < int > filterRestaurants ( vector < vector < int >> restaurants , int veganFriendly , int maxPrice , int maxDistance ) {\n  int n = restaurants . size ( ) ;\n  vector < vector < int >> filtered ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    if ( restaurants [ i ] [ 3 ] <= maxPrice && restaurants [ i ] [ 4 ] <= maxDistance && ! ( veganFriendly == 1 && restaurants [ i ] [ 2 ] == 0 ) ) {\n      filtered . push_back ( restaurants [ i ] ) ;\n    }\n  }\n  sort ( filtered . begin ( ) , filtered . end ( ) , ( a , b ) ) ;\n  if ( a [ 1 ] != b [ 1 ] ) {\n    return b [ 1 ] - a [ 1 ] ;\n  }\n  else {\n    return b [ 0 ] - a [ 0 ] ;\n  }\n}\n",
        "reference_code": "vector<int> filterRestaurants(vector<vector<int>>& restaurants, int veganFriendly, int maxPrice, int maxDistance) {\n        int n = restaurants.size();\n        vector<vector<int>> filtered;\n        for (int i = 0; i < n; i++) {\n            if (restaurants[i][3] <= maxPrice && restaurants[i][4] <= maxDistance && !(veganFriendly && !restaurants[i][2])) {\n                filtered.push_back(restaurants[i]);\n            }\n        }\n        sort(filtered.begin(), filtered.end(), [](vector<int> &v1, vector<int> &v2) -> bool {\n            return v1[1] > v2[1] || (v1[1] == v2[1] && v1[0] > v2[0]);\n        });\n        vector<int> res;\n        for (auto &v : filtered) {\n            res.push_back(v[0]);\n        }\n        return res;\n    }",
        "target_Lan": "cpp###filterRestaurants.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <algorithm>\n// TOFILL\nint main() {\n    vector<vector<int>> restaurants1 = {};\n    vector<vector<int>> restaurants2 = {{1, 5, 1, 50, 5}, {2, 3, 1, 30, 10}};\n    vector<vector<int>> restaurants3 = {{1, 5, 0, 60, 6}, {2, 3, 1, 40, 4}, {3, 4, 0, 30, 3}};\n    vector<vector<int>> restaurants4 = {{1, 4, 1, 20, 5}, {2, 3, 0, 30, 10}, {3, 5, 1, 20, 5}};\n    vector<vector<int>> restaurants5 = {{1, 5, 1, 100, 10}, {2, 4, 0, 200, 20}, {3, 3, 1, 25, 2}};\n\n    \n    vector<int> result1 = filterRestaurants(restaurants1, 1, 100, 10);\n    for(int r : result1) cout << r << \" \"; \n    cout << endl;\n\n    \n    vector<int> result2 = filterRestaurants(restaurants2, 1, 40, 10);\n    for(int r : result2) cout << r << \" \"; \n    cout << endl;\n\n    \n    vector<int> result3 = filterRestaurants(restaurants3, 1, 50, 5);\n    for(int r : result3) cout << r << \" \"; \n    cout << endl;\n\n    \n    vector<int> result4 = filterRestaurants(restaurants4, 0, 30, 6);\n    for(int r : result4) cout << r << \" \"; \n    cout << endl;\n\n    \n    vector<int> result5 = filterRestaurants(restaurants5, 1, 150, 15);\n    for(int r : result5) cout << r << \" \"; \n    cout << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###passThePillow_Test.java",
        "source_code": "public static int passThePillow(int n, int time) {\n        time %= (n - 1) * 2;\n        return time < n ? time + 1 : n * 2 - time - 1;\n    }",
        "trans_code": "int passThePillow ( int n , int time ) {\n  time %= ( n - 1 ) * 2 ;\n  return time < n ? time + 1 : n * 2 - time - 1 ;\n}\n",
        "reference_code": "    int passThePillow(int n, int time) {\n        time %= (n - 1) * 2;\n        return time < n ? time + 1 : n * 2 - time - 1;\n    }",
        "target_Lan": "cpp###passThePillow.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n// TOFILL\nint main() {\n    cout << passThePillow(2, 0) << endl;\n    cout << passThePillow(3, 4) << endl;\n    cout << passThePillow(5, 5) << endl;\n    cout << passThePillow(4, 6) << endl;\n    cout << passThePillow(6, 20) << endl;\n}"
    },
    {
        "source_Lan": "java###collectTheCoins_Test.java",
        "source_code": "public static int collectTheCoins(int[] coins, int[][] edges) {\n        int n = coins.length;\n        List<Integer>[] g = new List[n];\n        for (int i = 0; i < n; ++i) {\n            g[i] = new ArrayList<Integer>();\n        }\n        int[] degree = new int[n];\n        for (int[] edge : edges) {\n            int x = edge[0], y = edge[1];\n            g[x].add(y);\n            g[y].add(x);\n            ++degree[x];\n            ++degree[y];\n        }\n        int rest = n;\n        \n        Queue<Integer> queue = new ArrayDeque<Integer>();\n        for (int i = 0; i < n; ++i) {\n            if (degree[i] == 1 && coins[i] == 0) {\n                queue.offer(i);\n            }\n        }\n        while (!queue.isEmpty()) {\n            int u = queue.poll();\n            --degree[u];\n            --rest;\n            for (int v : g[u]) {\n                --degree[v];\n                if (degree[v] == 1 && coins[v] == 0) {\n                    queue.offer(v);\n                }\n            }\n        }\n        \n        for (int x = 0; x < 2; ++x) {\n            queue = new ArrayDeque<Integer>();\n            for (int i = 0; i < n; ++i) {\n                if (degree[i] == 1) {\n                    queue.offer(i);\n                }\n            }\n            while (!queue.isEmpty()) {\n                int u = queue.poll();\n                --degree[u];\n                --rest;\n                for (int v : g[u]) {\n                    --degree[v];\n                }\n            }\n        }\n        return rest == 0 ? 0 : (rest - 1) * 2;\n    }",
        "trans_code": "public : int collectTheCoins ( vector < int > coins , vector < vector < int >> edges ) {\n  int n = coins . size ( ) ;\n  vector < vector < int >> g ;\n  for ( int i = 0 ;\n  i < n ;\n  ++ i ) g . push_back ( vector < int > ( ) ) ;\n  vector < int > degree ( n , 0 ) ;\n  for ( vector < int > :: iterator edge = edges . begin ( ) ;\n  edge != edges . end ( ) ;\n  ++ edge ) {\n    int x = * edge , y = * edge ;\n    g [ x ] . push_back ( y ) ;\n    g [ y ] . push_back ( x ) ;\n    ++ degree [ x ] ;\n    ++ degree [ y ] ;\n  }\n  int rest = n ;\n  queue < int > queue ;\n  for ( int i = 0 ;\n  i < n ;\n  ++ i ) {\n    if ( degree [ i ] == 1 && coins [ i ] == 0 ) queue . push ( i ) ;\n  }\n  while ( ! queue . empty ( ) ) {\n    int u = queue . front ( ) ;\n    -- degree [ u ] ;\n    -- rest ;\n    for ( int v : g [ u ] ) {\n      -- degree [ v ] ;\n      if ( degree [ v ] == 1 && coins [ v ] == 0 ) queue . push ( v ) ;\n    }\n  }\n  for ( int x = 0 ;\n  x < 2 ;\n  ++ x ) {\n    queue . clear ( ) ;\n    for ( int i = 0 ;\n    i < n ;\n    ++ i ) {\n      if ( degree [ i ] == 1 ) queue . push ( i ) ;\n    }\n    while ( ! queue . empty ( ) ) {\n      int u = queue . front ( ) ;\n      -- degree [ u ] ;\n      -- rest ;\n      for ( int v : g [ u ] ) {\n        -- degree [ v ] ;\n      }\n    }\n  }\n  return rest == 0 ? 0 : ( rest - 1 ) * 2 ;\n}\n",
        "reference_code": "int collectTheCoins(vector<int>& coins, vector<vector<int>>& edges) {\n        int n = coins.size();\n        vector<vector<int>> g(n);\n        vector<int> degree(n);\n        for (const auto& edge: edges) {\n            int x = edge[0], y = edge[1];\n            g[x].push_back(y);\n            g[y].push_back(x);\n            ++degree[x];\n            ++degree[y];\n        }\n        int rest = n;\n        {\n            \n            queue<int> q;\n            for (int i = 0; i < n; ++i) {\n                if (degree[i] == 1 && !coins[i]) {\n                    q.push(i);\n                }\n            }\n            while (!q.empty()) {\n                int u = q.front();\n                --degree[u];\n                q.pop();\n                --rest;\n                for (int v: g[u]) {\n                    --degree[v];\n                    if (degree[v] == 1 && !coins[v]) {\n                        q.push(v);\n                    }\n                }\n            }\n        }\n        {\n            \n            for (int _ = 0; _ < 2; ++_) {\n                queue<int> q;\n                for (int i = 0; i < n; ++i) {\n                    if (degree[i] == 1) {\n                        q.push(i);\n                    }\n                }\n                while (!q.empty()) {\n                    int u = q.front();\n                    --degree[u];\n                    q.pop();\n                    --rest;\n                    for (int v: g[u]) {\n                        --degree[v];\n                    }\n                }\n            }\n        }\n        return rest == 0 ? 0 : (rest - 1) * 2;\n    }",
        "target_Lan": "cpp###collectTheCoins.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <queue>\n// TOFILL\nint main() {\n    vector<int> coins1 = {};\n    vector<vector<int>> edges1 = {};\n    cout << collectTheCoins(coins1, edges1) << endl;\n\n    vector<int> coins2 = {1};\n    vector<vector<int>> edges2 = {};\n    cout << collectTheCoins(coins2, edges2) << endl;\n\n    vector<int> coins3 = {0, 0, 0};\n    vector<vector<int>> edges3 = {{0, 1}, {1, 2}};\n    cout << collectTheCoins(coins3, edges3) << endl;\n\n    vector<int> coins4 = {1, 1, 1};\n    vector<vector<int>> edges4 = {{0, 1}, {1, 2}};\n    cout << collectTheCoins(coins4, edges4) << endl;\n\n    vector<int> coins5 = {0, 1, 0};\n    vector<vector<int>> edges5 = {{0, 1}, {1, 2}};\n    cout << collectTheCoins(coins5, edges5) << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###minCapability_Test.java",
        "source_code": "public static int minCapability(int[] nums, int k) {\n        int lower = Arrays.stream(nums).min().getAsInt();\n        int upper = Arrays.stream(nums).max().getAsInt();\n        while (lower <= upper) {\n            int middle = (lower + upper) / 2;\n            int count = 0;\n            boolean visited = false;\n            for (int x : nums) {\n                if (x <= middle && !visited) {\n                    count++;\n                    visited = true;\n                } else {\n                    visited = false;\n                }\n            }\n            if (count >= k) {\n                upper = middle - 1;\n            } else {\n                lower = middle + 1;\n            }\n        }\n        return lower;\n    }",
        "trans_code": "public : int minCapability ( vector < int > & nums , int k ) {\n  int lower = std :: min ( nums . begin ( ) , nums . end ( ) ) ;\n  int upper = std :: max ( nums . begin ( ) , nums . end ( ) ) ;\n  while ( lower <= upper ) {\n    int middle = ( lower + upper ) / 2 ;\n    int count = 0 ;\n    bool visited = false ;\n    for ( int x : nums ) {\n      if ( x <= middle && ! visited ) {\n        count ++ ;\n        visited = true ;\n      }\n      else {\n        visited = false ;\n      }\n    }\n    if ( count >= k ) upper = middle - 1 ;\n    else lower = middle + 1 ;\n  }\n  return lower ;\n}\n",
        "reference_code": "int minCapability(vector<int>& nums, int k) {\n        int lower = *min_element(nums.begin(), nums.end());\n        int upper = *max_element(nums.begin(), nums.end());\n        while (lower <= upper) {\n            int middle = (lower + upper) / 2;\n            int count = 0;\n            bool visited = false;\n            for (int x : nums) {\n                if (x <= middle && !visited) {\n                    count++;\n                    visited = true;\n                } else {\n                    visited = false;\n                }\n            }\n            if (count >= k) {\n                upper = middle - 1;\n            } else {\n                lower = middle + 1;\n            }\n        }\n        return lower;\n    }",
        "target_Lan": "cpp###minCapability.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <algorithm>\n// TOFILL\nint main() {\n    vector<int> nums1 = {1, 2, 3, 4, 5};\n    vector<int> nums2 = {2, 6, 7, 3};\n    vector<int> nums3 = {5};\n    vector<int> nums4 = {1, 1, 1};\n    vector<int> nums5 = {4, 2, 5, 1, 3};\n    \n    cout << minCapability(nums1, 3) << endl;\n    cout << minCapability(nums2, 2) << endl;\n    cout << minCapability(nums3, 1) << endl;\n    cout << minCapability(nums4, 2) << endl;\n    cout << minCapability(nums5, 0) << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###distMoney_Test.java",
        "source_code": "public static int distMoney(int money, int children) {\n        if (money < children) {\n            return -1;\n        }\n        money -= children;\n        int cnt = Math.min(money / 7, children);\n        money -= cnt * 7;\n        children -= cnt;\n        if ((children == 0 && money > 0) || (children == 1 && money == 3)) {\n            cnt--;\n        }\n        return cnt;\n    }",
        "trans_code": "int dist_money ( int money , int children ) {\n  if ( money < children ) return - 1 ;\n  money -= children ;\n  int cnt = min ( money / 7 , children ) ;\n  money -= cnt * 7 ;\n  children -= cnt ;\n  if ( ( children == 0 && money > 0 ) || ( children == 1 && money == 3 ) ) cnt -- ;\n  return cnt ;\n}\n",
        "reference_code": "int distMoney(int money, int children) {\n        if (money < children) {\n            return -1;\n        }\n        money -= children;\n        int cnt = min(money / 7, children);\n        money -= cnt * 7;\n        children -= cnt;\n        if ((children == 0 && money > 0) || (children == 1 && money == 3)) {\n            cnt--;\n        }\n        return cnt;\n    }",
        "target_Lan": "cpp###distMoney.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n// TOFILL\nint main() {\n    cout << distMoney(3, 5) << endl;  \n    cout << distMoney(5, 5) << endl;  \n    cout << distMoney(10, 3) << endl; \n    cout << distMoney(10, 1) << endl; \n    cout << distMoney(14, 3) << endl; \n}"
    },
    {
        "source_Lan": "java###queensAttacktheKing_Test.java",
        "source_code": "public static List<List<Integer>> queensAttacktheKing(int[][] queens, int[] king) {\n        Set<Integer> queenPos = new HashSet<Integer>();\n        for (int[] queen : queens) {\n            int x = queen[0], y = queen[1];\n            queenPos.add(x * 8 + y);\n        }\n        List<List<Integer>> ans = new ArrayList<List<Integer>>();\n        for (int dx = -1; dx <= 1; ++dx) {\n            for (int dy = -1; dy <= 1; ++dy) {\n                if (dx == 0 && dy == 0) {\n                    continue;\n                }\n                int kx = king[0] + dx, ky = king[1] + dy;\n                while (kx >= 0 && kx < 8 && ky >= 0 && ky < 8) {\n                    int pos = kx * 8 + ky;\n                    if (queenPos.contains(pos)) {\n                        List<Integer> posList = new ArrayList<Integer>();\n                        posList.add(kx);\n                        posList.add(ky);\n                        ans.add(posList);\n                        break;\n                    }\n                    kx += dx;\n                    ky += dy;\n                }\n            }\n        }\n        return ans;\n    }",
        "trans_code": "public : vector < vector < int >> queensAttacktheKing ( vector < int > & queens , vector < int > & king ) {\n  set < int > queenPos ;\n  for ( auto & queen : queens ) {\n    int x = queen [ 0 ] , y = queen [ 1 ] ;\n    queenPos . insert ( x * 8 + y ) ;\n  }\n  vector < vector < int >> ans ;\n  for ( int dx = - 1 ;\n  dx <= 1 ;\n  ++ dx ) {\n    for ( int dy = - 1 ;\n    dy <= 1 ;\n    ++ dy ) {\n      if ( dx == 0 && dy == 0 ) continue ;\n      int kx = king [ 0 ] + dx , ky = king [ 1 ] + dy ;\n      while ( kx >= 0 && kx < 8 && ky >= 0 && ky < 8 ) {\n        int pos = kx * 8 + ky ;\n        if ( queenPos . count ( pos ) ) {\n          vector < int > posVec ;\n          posVec . push_back ( kx ) ;\n          posVec . push_back ( ky ) ;\n          ans . push_back ( posVec ) ;\n          break ;\n        }\n        kx += dx ;\n        ky += dy ;\n      }\n    }\n  }\n  return ans ;\n}\n",
        "reference_code": "vector<vector<int>> queensAttacktheKing(vector<vector<int>>& queens, vector<int>& king) {\n        unordered_set<int> queen_pos;\n        for (const auto& queen: queens) {\n            int x = queen[0], y = queen[1];\n            queen_pos.insert(x * 8 + y);\n        }\n        vector<vector<int>> ans;\n        for (int dx = -1; dx <= 1; ++dx) {\n            for (int dy = -1; dy <= 1; ++dy) {\n                if (dx == 0 && dy == 0) {\n                    continue;\n                }\n                int kx = king[0] + dx, ky = king[1] + dy;\n                while (kx >= 0 && kx < 8 && ky >= 0 && ky < 8) {\n                    int pos = kx * 8 + ky;\n                    if (queen_pos.count(pos)) {\n                        ans.push_back({kx, ky});\n                        break;\n                    }\n                    kx += dx;\n                    ky += dy;\n                }\n            }\n        }\n        return ans;\n    }",
        "target_Lan": "cpp###queensAttacktheKing.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <unordered_set>\n// TOFILL\nint main() {\n    vector<vector<int>> queens1 = {};\n    vector<int> king1 = {4, 4};\n    auto result1 = queensAttacktheKing(queens1, king1);\n    \n    vector<vector<int>> queens2 = {{0, 0}, {1, 1}, {2, 2}};\n    vector<int> king2 = {4, 4};\n    auto result2 = queensAttacktheKing(queens2, king2);\n    \n    vector<vector<int>> queens3 = {{0, 1}, {1, 0}, {2, 0}, {1, 2}};\n    vector<int> king3 = {0, 0};\n    auto result3 = queensAttacktheKing(queens3, king3);\n    \n    vector<vector<int>> queens4 = {{3, 3}, {3, 7}, {5, 5}};\n    vector<int> king4 = {4, 4};\n    auto result4 = queensAttacktheKing(queens4, king4);\n    \n    vector<vector<int>> queens5 = {{0, 2}, {0, 5}, {5, 0}, {0, 1}, {2, 0}};\n    vector<int> king5 = {0, 0};\n    auto result5 = queensAttacktheKing(queens5, king5);\n    \n    \n    for(auto& r : result1) cout << \"[\" << r[0] << \", \" << r[1] << \"] \";\n    cout << endl;\n\n    for(auto& r : result2) cout << \"[\" << r[0] << \", \" << r[1] << \"] \";\n    cout << endl;\n\n    for(auto& r : result3) cout << \"[\" << r[0] << \", \" << r[1] << \"] \";\n    cout << endl;\n\n    for(auto& r : result4) cout << \"[\" << r[0] << \", \" << r[1] << \"] \";\n    cout << endl;\n\n    for(auto& r : result5) cout << \"[\" << r[0] << \", \" << r[1] << \"] \";\n    cout << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###giveGem_Test.java",
        "source_code": "public static int giveGem(int[] gem, int[][] operations) {\n        for (int[] operation : operations) {\n            int x = operation[0], y = operation[1];\n            int number = gem[x] / 2;\n            gem[x] -= number;\n            gem[y] += number;\n        }\n        int mn = gem[0], mx = gem[0];\n        for (int number : gem) {\n            mn = Math.min(number, mn);\n            mx = Math.max(number, mx);\n        }\n        return mx - mn;\n    }",
        "trans_code": "int giveGem ( vector < int > gem , vector < vector < int >> & operations ) {\n  for ( vector < int > :: iterator operation = operations . begin ( ) ;\n  operation != operations . end ( ) ;\n  operation ++ ) {\n    int x = * operation , y = * operation ;\n    int number = gem [ x ] / 2 ;\n    gem [ x ] -= number ;\n    gem [ y ] += number ;\n  }\n  int mn = gem [ 0 ] , mx = gem [ 0 ] ;\n  for ( int number : gem ) {\n    mn = min ( number , mn ) ;\n    mx = max ( number , mx ) ;\n  }\n  return mx - mn ;\n}\n",
        "reference_code": "int giveGem(vector<int>& gem, vector<vector<int>>& operations) {\n        for (auto &operation : operations) {\n            int x = operation[0], y = operation[1];\n            int number = gem[x] / 2;\n            gem[x] -= number;\n            gem[y] += number;\n        }\n        int mn = *min_element(gem.begin(), gem.end());\n        int mx = *max_element(gem.begin(), gem.end());\n        return mx - mn;\n    }",
        "target_Lan": "cpp###giveGem.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n// TOFILL\nint main() {\n    \n    vector<int> gem1 = {0, 0, 0};\n    vector<vector<int>> operations1 = {{0, 1}, {1, 2}};\n    cout << giveGem(gem1, operations1) << endl;  \n\n    \n    vector<int> gem2 = {5, 5, 5};\n    vector<vector<int>> operations2 = {{0, 1}, {2, 1}};\n    cout << giveGem(gem2, operations2) << endl;  \n\n    \n    vector<int> gem3 = {10, 20, 30};\n    vector<vector<int>> operations3 = {{0, 1}, {1, 2}};\n    cout << giveGem(gem3, operations3) << endl;  \n\n    \n    vector<int> gem4 = {1, 2, 3};\n    vector<vector<int>> operations4 = {{0, 1}, {1, 0}, {2, 1}};\n    cout << giveGem(gem4, operations4) << endl;  \n\n    \n    vector<int> gem5 = {100, 200, 300};\n    vector<vector<int>> operations5 = {};\n    cout << giveGem(gem5, operations5) << endl;  \n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###checkValidGrid_Test.java",
        "source_code": "public static boolean checkValidGrid(int[][] grid) {\n        if (grid[0][0] != 0) {\n            return false;\n        }\n        int n = grid.length;\n        int[][] indices = new int[n * n][2];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                indices[grid[i][j]][0] = i;\n                indices[grid[i][j]][1] = j;\n            }\n        }\n        for (int i = 1; i < n * n; i++) {\n            int dx = Math.abs(indices[i][0] - indices[i - 1][0]);\n            int dy = Math.abs(indices[i][1] - indices[i - 1][1]);\n            if (dx * dy != 2) {\n                return false;\n            }\n        }\n        return true;\n    }",
        "trans_code": "bool checkValidGrid ( vector < vector < int >> & grid ) {\n  if ( grid [ 0 ] [ 0 ] != 0 ) {\n    return false ;\n  }\n  int n = grid . size ( ) ;\n  vector < vector < int >> indices ( n * n ) ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < n ;\n    j ++ ) {\n      indices [ grid [ i ] [ j ] ] . push_back ( i ) ;\n      indices [ grid [ i ] [ j ] ] . push_back ( j ) ;\n    }\n  }\n  for ( int i = 1 ;\n  i < n * n ;\n  i ++ ) {\n    int dx = abs ( indices [ i ] [ 0 ] - indices [ i - 1 ] [ 0 ] ) ;\n    int dy = abs ( indices [ i ] [ 1 ] - indices [ i - 1 ] [ 1 ] ) ;\n    if ( dx * dy != 2 ) {\n      return false ;\n    }\n  }\n  return true ;\n}\n",
        "reference_code": "bool checkValidGrid(vector<vector<int>>& grid) {\n        if (grid[0][0] != 0) {\n            return false;\n        }\n        int n = grid.size();\n        vector<array<int, 2>> indices(n * n);\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                indices[grid[i][j]] = {i, j};\n            }\n        }\n        for (int i = 1; i < indices.size(); i++) {\n            int dx = abs(indices[i][0] - indices[i - 1][0]);\n            int dy = abs(indices[i][1] - indices[i - 1][1]);\n            if (dx * dy != 2) {\n                return false;\n            }\n        }\n        return true;\n    }",
        "target_Lan": "cpp###checkValidGrid.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <array>\n// TOFILL\nint main() {\n    vector<vector<int>> grid1 = {{1, 0}, {2, 3}};\n    vector<vector<int>> grid2 = {{0, 1}, {3, 2}};\n    vector<vector<int>> grid3 = {{0}};\n    vector<vector<int>> grid4 = {{0, 3}, {1, 2}};\n\n    cout << checkValidGrid(grid1) << endl;\n    cout << checkValidGrid(grid2) << endl;\n    cout << checkValidGrid(grid3) << endl;\n    cout << checkValidGrid(grid4) << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###findTheArrayConcVal_Test.java",
        "source_code": "public static long findTheArrayConcVal(int[] nums) {\n        long ans = 0;\n        for (int i = 0, j = nums.length - 1; i <= j; i++, j--) {\n            if (i != j) {\n                ans += Integer.parseInt(Integer.toString(nums[i]) + Integer.toString(nums[j]));\n            } else {\n                ans += nums[i];\n            }\n        }\n        return ans;\n    }",
        "trans_code": "public : long long findTheArrayConcVal ( vector < int > & nums ) {\n  long long ans = 0 ;\n  for ( int i = 0 , j = nums . size ( ) - 1 ;\n  i <= j ;\n  i ++ , j -- ) {\n    if ( i != j ) ans += int ( to_string ( nums [ i ] ) + to_string ( nums [ j ] ) ) ;\n    else ans += nums [ i ] ;\n  }\n  return ans ;\n}\n",
        "reference_code": "long long findTheArrayConcVal(vector<int>& nums) {\n        long long ans = 0;\n        for (int i = 0, j = nums.size() - 1; i <= j; i++, j--) {\n            if (i != j) {\n                ans += stoi(to_string(nums[i]) + to_string(nums[j]));\n            } else {\n                ans += nums[i];\n            }\n        }\n        return ans;\n    }",
        "target_Lan": "cpp###findTheArrayConcVal.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <string>\n// TOFILL\nint main() {\n    vector<int> input1 = {};\n    vector<int> input2 = {5};\n    vector<int> input3 = {10, 25};\n    vector<int> input4 = {1, 2, 3};\n\n    cout << findTheArrayConcVal(input1) << endl;\n    cout << findTheArrayConcVal(input2) << endl;\n    cout << findTheArrayConcVal(input3) << endl;\n    cout << findTheArrayConcVal(input4) << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###findDelayedArrivalTime_Test.java",
        "source_code": "public static int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\n        return (arrivalTime + delayedTime) % 24;\n    }",
        "trans_code": "int findDelayedArrivalTime ( int arrivalTime , int delayedTime ) {\n  return ( arrivalTime + delayedTime ) % 24 ;\n}\n",
        "reference_code": "    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\n        return (arrivalTime + delayedTime) % 24;\n    }",
        "target_Lan": "cpp###findDelayedArrivalTime.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n// TOFILL\nint main() {\n    cout << findDelayedArrivalTime(0, 0) << endl;\n    cout << findDelayedArrivalTime(12, 15) << endl;\n    cout << findDelayedArrivalTime(23, 10) << endl;\n    cout << findDelayedArrivalTime(5, 20) << endl;\n    cout << findDelayedArrivalTime(10, 25) << endl;\n}"
    },
    {
        "source_Lan": "java###checkIfPrerequisite_Test.java",
        "source_code": "    public static List<Boolean> checkIfPrerequisite(int numCourses, int[][] prerequisites, int[][] queries) {\n        List<Integer>[] g = new List[numCourses];\n        for (int i = 0; i < numCourses; i++) {\n            g[i] = new ArrayList<Integer>();\n        }\n        int[] indgree = new int[numCourses];\n        boolean[][] isPre = new boolean[numCourses][numCourses];\n        for (int[] p : prerequisites) {\n            ++indgree[p[1]];\n            g[p[0]].add(p[1]);\n        }\n        Queue<Integer> queue = new ArrayDeque<Integer>();\n        for (int i = 0; i < numCourses; ++i) {\n            if (indgree[i] == 0) {\n                queue.offer(i);\n            }\n        }\n        while (!queue.isEmpty()) {\n            int cur = queue.poll();\n            for (int ne : g[cur]) {\n                isPre[cur][ne] = true;\n                for (int i = 0; i < numCourses; ++i) {\n                    isPre[i][ne] = isPre[i][ne] | isPre[i][cur];\n                }\n                --indgree[ne];\n                if (indgree[ne] == 0) {\n                    queue.offer(ne);\n                }\n            }\n        }\n        List<Boolean> res = new ArrayList<Boolean>();\n        for (int[] query : queries) {\n            res.add(isPre[query[0]][query[1]]);\n        }\n        return res;\n    }",
        "trans_code": "vector < bool > checkIfPrerequisite ( int numCourses , vector < vector < int >> & prerequisites , vector < vector < int >> & queries ) {\n  vector < int > g ;\n  for ( int i = 0 ;\n  i < numCourses ;\n  i ++ ) g . push_back ( i ) ;\n  vector < int > indgree ( numCourses , 0 ) ;\n  vector < bool > isPre ( numCourses , false ) ;\n  for ( auto p : prerequisites ) {\n    ++ indgree [ p [ 1 ] ] ;\n    g [ p [ 0 ] ] . push_back ( p [ 1 ] ) ;\n  }\n  queue < int > queue ;\n  for ( int i = 0 ;\n  i < numCourses ;\n  ++ i ) {\n    if ( indgree [ i ] == 0 ) queue . push ( i ) ;\n  }\n  while ( ! queue . empty ( ) ) {\n    int cur = queue . front ( ) ;\n    for ( int ne : g [ cur ] ) {\n      isPre [ cur ] [ ne ] = true ;\n      for ( int i = 0 ;\n      i < numCourses ;\n      ++ i ) isPre [ i ] [ ne ] = isPre [ i ] [ ne ] | isPre [ i ] [ cur ] ;\n      -- indgree [ ne ] ;\n      if ( indgree [ ne ] == 0 ) queue . push ( ne ) ;\n    }\n  }\n  vector < bool > res ;\n  for ( auto query : queries ) res . push_back ( isPre [ query [ 0 ] ] [ query [ 1 ] ] ) ;\n  return res ;\n}\n",
        "reference_code": "vector<bool> checkIfPrerequisite(int numCourses, vector<vector<int>>& prerequisites, vector<vector<int>>& queries) {\n        vector<vector<int>> g(numCourses);\n        vector<int> indgree(numCourses, 0);\n        vector<vector<bool>> isPre(numCourses, vector<bool>(numCourses, false));\n        for (auto& p : prerequisites) {\n            ++indgree[p[1]];\n            g[p[0]].push_back(p[1]);\n        }\n        queue<int> q;\n        for (int i = 0; i < numCourses; ++i) {\n            if (indgree[i] == 0) {\n                q.push(i);\n            }\n        }\n        while (!q.empty()) {\n            auto cur = q.front();\n            q.pop();\n            for (auto& ne : g[cur]) {\n                isPre[cur][ne] = true;\n                for (int i = 0; i < numCourses; ++i) {\n                    isPre[i][ne] = isPre[i][ne] | isPre[i][cur];\n                }\n                --indgree[ne];\n                if (indgree[ne] == 0) {\n                    q.push(ne);\n                }\n            }\n        }\n        vector<bool> res;\n        for (auto& query : queries) {\n            res.push_back(isPre[query[0]][query[1]]);\n        }\n        return res;\n    }",
        "target_Lan": "cpp###checkIfPrerequisite.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <queue>\n// TOFILL\nint main() {\n    vector<vector<int>> prerequisites1 = {};\n    vector<vector<int>> queries1 = {{0, 1}, {1, 2}, {0, 2}};\n    vector<bool> result1 = checkIfPrerequisite(3, prerequisites1, queries1);\n    for(bool r : result1) {\n        cout <<(r ? \"true\" : \"false\") << \" \";\n    }\n    cout << endl;\n\n    vector<vector<int>> prerequisites2 = {{0, 1}, {1, 2}};\n    vector<vector<int>> queries2 = {{0, 1}, {1, 0}, {0, 2}};\n    vector<bool> result2 = checkIfPrerequisite(3, prerequisites2, queries2);\n    for(bool r : result2) {\n        cout <<(r ? \"true\" : \"false\") << \" \";\n    }\n    cout << endl;\n\n    vector<vector<int>> prerequisites3 = {{0, 1}, {0, 2}, {1, 3}};\n    vector<vector<int>> queries3 = {{0, 3}, {1, 2}, {2, 3}};\n    vector<bool> result3 = checkIfPrerequisite(4, prerequisites3, queries3);\n    for(bool r : result3) {\n        cout <<(r ? \"true\" : \"false\") << \" \";\n    }\n    cout << endl;\n\n    vector<vector<int>> prerequisites4 = {{0, 1}};\n    vector<vector<int>> queries4 = {{0, 1}, {1, 0}, {0, 0}};\n    vector<bool> result4 = checkIfPrerequisite(2, prerequisites4, queries4);\n    for(bool r : result4) {\n        cout <<(r ? \"true\" : \"false\") << \" \";\n    }\n    cout << endl;\n\n    vector<vector<int>> prerequisites5 = {{0, 1}, {1, 2}, {2, 3}, {3, 4}};\n    vector<vector<int>> queries5 = {{0, 4}, {4, 0}, {1, 3}, {2, 1}};\n    vector<bool> result5 = checkIfPrerequisite(5, prerequisites5, queries5);\n    for(bool r : result5) {\n        cout <<(r ? \"true\" : \"false\") << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###minTrioDegree_Test.java",
        "source_code": "    public static int minTrioDegree(int n, int[][] edges) {\n        int[][] g = new int[n][n];\n        int[] degree = new int[n];\n        for (int[] edge : edges) {\n            int x = edge[0] - 1, y = edge[1] - 1;\n            g[x][y] = g[y][x] = 1;\n            ++degree[x];\n            ++degree[y];\n        }\n        int ans = Integer.MAX_VALUE;\n        for (int i = 0; i < n; ++i) {\n            for (int j = i + 1; j < n; ++j) {\n                if (g[i][j] == 1) {\n                    for (int k = j + 1; k < n; ++k) {\n                        if (g[i][k] == 1 && g[j][k] == 1) {\n                            ans = Math.min(ans, degree[i] + degree[j] + degree[k] - 6);\n                        }\n                    }\n                }\n            }\n        }\n        return ans == Integer.MAX_VALUE ? -1 : ans;\n    }",
        "trans_code": "public : int minTrioDegree ( int n , vector < vector < int >> & edges ) {\n  vector < vector < int >> g ( n , vector < int > ( n ) ) ;\n  vector < int > degree ( n , 0 ) ;\n  for ( auto edge : edges ) {\n    int x = edge . first - 1 , y = edge . second - 1 ;\n    g [ x ] [ y ] = g [ y ] [ x ] = 1 ;\n    ++ degree [ x ] ;\n    ++ degree [ y ] ;\n  }\n  int ans = INT_MAX ;\n  for ( int i = 0 ;\n  i < n ;\n  ++ i ) {\n    for ( int j = i + 1 ;\n    j < n ;\n    ++ j ) {\n      if ( g [ i ] [ j ] == 1 ) {\n        for ( int k = j + 1 ;\n        k < n ;\n        ++ k ) {\n          if ( g [ i ] [ k ] == 1 && g [ j ] [ k ] == 1 ) {\n            ans = min ( ans , degree [ i ] + degree [ j ] + degree [ k ] - 6 ) ;\n          }\n        }\n      }\n    }\n  }\n  return ans == INT_MAX ? - 1 : ans ;\n}\n",
        "reference_code": "int minTrioDegree(int n, vector<vector<int>>& edges) {\n        vector<vector<int>> g(n, vector<int>(n));\n        vector<int> degree(n);\n        for (auto&& edge: edges) {\n            int x = edge[0] - 1, y = edge[1] - 1;\n            g[x][y] = g[y][x] = 1;\n            ++degree[x];\n            ++degree[y];\n        }\n        int ans = INT_MAX;\n        for (int i = 0; i < n; ++i) {\n            for (int j = i + 1; j < n; ++j) {\n                if (g[i][j] == 1) {\n                    for (int k = j + 1; k < n; ++k) {\n                        if (g[i][k] == 1 && g[j][k] == 1) {\n                            ans = min(ans, degree[i] + degree[j] + degree[k] - 6);\n                        }\n                    }\n                }\n            }\n        }\n        return ans == INT_MAX ? -1 : ans;\n    }",
        "target_Lan": "cpp###minTrioDegree.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <limits.h>\n// TOFILL\nint main() {\n    vector<vector<int>> edges1 = {{1, 2}, {1, 3}};\n    cout << minTrioDegree(3, edges1) << endl;\n\n    vector<vector<int>> edges2 = {{1, 2}, {1, 3}, {2, 3}, {2, 4}, {3, 4}};\n    cout << minTrioDegree(4, edges2) << endl;\n\n    vector<vector<int>> edges3 = {{1, 2}, {1, 3}, {2, 3}, {3, 4}, {1, 4}};\n    cout << minTrioDegree(5, edges3) << endl;\n\n    vector<vector<int>> edges4 = {{1, 2}, {1, 3}, {1, 4}, {2, 3}, {2, 4}, {2, 5}, {3, 4}, {3, 5}, {4, 5}};\n    cout << minTrioDegree(6, edges4) << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###minTrioDegree_Test.java",
        "source_code": "public static int minTrioDegree(int n, int[][] edges) {\n        \n        Set<Integer>[] g = new Set[n];\n        for (int i = 0; i < n; ++i) {\n            g[i] = new HashSet<Integer>();\n        }\n        \n        List<Integer>[] h = new List[n];\n        for (int i = 0; i < n; ++i) {\n            h[i] = new ArrayList<Integer>();\n        }\n        int[] degree = new int[n];\n        for (int[] edge : edges) {\n            int x = edge[0] - 1, y = edge[1] - 1;\n            g[x].add(y);\n            g[y].add(x);\n            ++degree[x];\n            ++degree[y];\n        }\n        for (int[] edge : edges) {\n            int x = edge[0] - 1, y = edge[1] - 1;\n            if (degree[x] < degree[y] || (degree[x] == degree[y] && x < y)) {\n                h[x].add(y);\n            } else {\n                h[y].add(x);\n            }\n        }\n        int ans = Integer.MAX_VALUE;\n        for (int i = 0; i < n; ++i) {\n            for (int j : h[i]) {\n                for (int k : h[j]) {\n                    if (g[i].contains(k)) {\n                        ans = Math.min(ans, degree[i] + degree[j] + degree[k] - 6);\n                    }\n                }\n            }\n        }\n        return ans == Integer.MAX_VALUE ? -1 : ans;\n    }",
        "trans_code": "public : int minTrioDegree ( int n , vector < vector < int >> & edges ) {\n  set < int > g ;\n  for ( int i = 0 ;\n  i < n ;\n  ++ i ) g . insert ( i ) ;\n  vector < int > h ;\n  for ( int i = 0 ;\n  i < n ;\n  ++ i ) h . insert ( i ) ;\n  vector < int > degree ( n , 0 ) ;\n  for ( auto edge : edges ) {\n    int x = edge . first - 1 , y = edge . second - 1 ;\n    g [ x ] . insert ( y ) ;\n    g [ y ] . insert ( x ) ;\n    ++ degree [ x ] ;\n    ++ degree [ y ] ;\n  }\n  for ( auto edge : edges ) {\n    int x = edge . first - 1 , y = edge . second - 1 ;\n    if ( degree [ x ] < degree [ y ] || ( degree [ x ] == degree [ y ] && x < y ) ) h [ x ] . insert ( y ) ;\n    else h [ y ] . insert ( x ) ;\n  }\n  int ans = INT_MAX ;\n  for ( int i = 0 ;\n  i < n ;\n  ++ i ) {\n    for ( int j : h [ i ] ) {\n      for ( int k : h [ j ] ) {\n        if ( g [ i ] . count ( k ) ) ans = min ( ans , degree [ i ] + degree [ j ] + degree [ k ] - 6 ) ;\n      }\n    }\n  }\n  return ans == INT_MAX ? - 1 : ans ;\n}\n",
        "reference_code": "int minTrioDegree(int n, vector<vector<int>>& edges) {\n        \n        vector<unordered_set<int>> g(n);\n        \n        vector<vector<int>> h(n);\n        vector<int> degree(n);\n        for (auto&& edge: edges) {\n            int x = edge[0] - 1, y = edge[1] - 1;\n            g[x].insert(y);\n            g[y].insert(x);\n            ++degree[x];\n            ++degree[y];\n        }\n        for (auto&& edge: edges) {\n            int x = edge[0] - 1, y = edge[1] - 1;\n            if (degree[x] < degree[y] || (degree[x] == degree[y] && x < y)) {\n                h[x].push_back(y);\n            }\n            else {\n                h[y].push_back(x);\n            }\n        }\n        int ans = INT_MAX;\n        for (int i = 0; i < n; ++i) {\n            for (int j: h[i]) {\n                for (int k: h[j]) {\n                    if (g[i].count(k)) {\n                        ans = min(ans, degree[i] + degree[j] + degree[k] - 6);\n                    }\n                }\n            }\n        }\n        return ans == INT_MAX ? -1 : ans;\n    }",
        "target_Lan": "cpp###minTrioDegree.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_set>\n#include <climits>\nusing namespace std;\n// TOFILL\nint main() {\n    \n    vector<vector<int>> edges1 = {};\n    cout << minTrioDegree(1, edges1) << endl;  \n\n    \n    vector<vector<int>> edges2 = {{1, 2}, {2, 3}, {3, 1}};\n    cout << minTrioDegree(3, edges2) << endl;  \n\n    \n    vector<vector<int>> edges3 = {{1, 2}, {3, 4}};\n    cout << minTrioDegree(4, edges3) << endl;  \n\n    \n    vector<vector<int>> edges4 = {{1, 2}, {1, 3}, {2, 3}, {2, 4}, {3, 4}, {4, 5}};\n    cout << minTrioDegree(5, edges4) << endl;  \n\n    \n    vector<vector<int>> edges5 = {{1, 2}, {1, 3}, {1, 4}, {2, 4}, {2, 5}, {3, 5}, {4, 5}, {5, 6}};\n    cout << minTrioDegree(6, edges5) << endl;  \n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###minimumJumps_Test.java",
        "source_code": "public static int minimumJumps(int[] forbidden, int a, int b, int x) {\n        Queue<int[]> queue = new ArrayDeque<int[]>();\n        Set<Integer> visited = new HashSet<Integer>();\n        queue.offer(new int[]{0, 1, 0});\n        visited.add(0);\n        int lower = 0, upper = Math.max(Arrays.stream(forbidden).max().getAsInt() + a, x) + b;\n        Set<Integer> forbiddenSet = new HashSet<Integer>();\n        for (int position : forbidden) {\n            forbiddenSet.add(position);\n        }\n        while (!queue.isEmpty()) {\n            int[] arr = queue.poll();\n            int position = arr[0], direction = arr[1], step = arr[2];\n            if (position == x) {\n                return step;\n            }\n            int nextPosition = position + a;\n            int nextDirection = 1;\n            if (lower <= nextPosition && nextPosition <= upper && !visited.contains(nextPosition * nextDirection) && !forbiddenSet.contains(nextPosition)) {\n                visited.add(nextPosition * nextDirection);\n                queue.offer(new int[]{nextPosition, nextDirection, step + 1});\n            }\n            if (direction == 1) {\n                nextPosition = position - b;\n                nextDirection = -1;\n                if (lower <= nextPosition && nextPosition <= upper && !visited.contains(nextPosition * nextDirection) && !forbiddenSet.contains(nextPosition)) {\n                    visited.add(nextPosition * nextDirection);\n                    queue.offer(new int[]{nextPosition, nextDirection, step + 1});\n                }\n            }\n        }\n        return -1;\n    }",
        "trans_code": "public : int minimumJumps ( vector < int > forbidden , int a , int b , int x ) {\n  queue < vector < int >> queue ;\n  set < int > visited ;\n  queue . push ( {\n    0 , 1 , 0 }\n    ) ;\n    visited . push ( 0 ) ;\n    int lower = 0 , upper = max ( vector < int > ( forbidden ) . max ( ) . getAsInt ( ) + a , x ) + b ;\n    set < int > forbidden_set ;\n    for ( auto position : forbidden ) forbidden_set . insert ( position ) ;\n    while ( ! queue . empty ( ) ) {\n      vector < int > arr = queue . front ( ) ;\n      int position = arr [ 0 ] , direction = arr [ 1 ] , step = arr [ 2 ] ;\n      if ( position == x ) return step ;\n      int next_position = position + a ;\n      int next_direction = 1 ;\n      if ( lower <= next_position && next_position <= upper && ! visited . count ( next_position * next_direction ) && ! forbidden_set . count ( next_position ) ) {\n        visited . insert ( next_position * next_direction ) ;\n        queue . push ( {\n          next_position , next_direction , step + 1 }\n          ) ;\n        }\n        if ( direction == 1 ) {\n          next_position = position - b ;\n          next_direction = - 1 ;\n          if ( lower <= next_position && next_position <= upper && ! visited . count ( next_position * next_direction ) && ! forbidden_set . count ( next_position ) ) {\n            visited . insert ( next_position * next_direction ) ;\n            queue . push ( {\n              next_position , next_direction , step + 1 }\n              ) ;\n            }\n          }\n        }\n        return - 1 ;\n      }\n      ",
        "reference_code": "int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\n        queue<tuple<int, int, int>> q;\n        unordered_set<int> visited;\n        q.emplace(0, 1, 0);\n        visited.emplace(0);\n        int lower = 0, upper = max(*max_element(forbidden.begin(), forbidden.end()) + a, x) + b;\n        unordered_set<int> forbiddenSet(forbidden.begin(), forbidden.end());\n        while (!q.empty()) {\n            auto [position, direction, step] = q.front();\n            q.pop();\n            if (position == x) {\n                return step;\n            }\n            int nextPosition = position + a;\n            int nextDirection = 1;\n            if (lower <= nextPosition && nextPosition <= upper && !visited.count(nextPosition * nextDirection) && !forbiddenSet.count(nextPosition)) {\n                visited.emplace(nextPosition * nextDirection);\n                q.emplace(nextPosition, nextDirection, step + 1);\n            }\n            if (direction == 1) {\n                nextPosition = position - b;\n                nextDirection = -1;\n                if (lower <= nextPosition && nextPosition <= upper && !visited.count(nextPosition * nextDirection) && !forbiddenSet.count(nextPosition)) {\n                    visited.emplace(nextPosition * nextDirection);\n                    q.emplace(nextPosition, nextDirection, step + 1);\n                }\n            }\n        }\n        return -1;\n    }",
        "target_Lan": "cpp###minimumJumps.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <unordered_set>\n#include <queue>\n#include <tuple>\n#include <algorithm>\n// TOFILL\nint main() {\n    vector<int> forbidden1 = {1, 2, 3};\n    cout << minimumJumps(forbidden1, 3, 2, 7) << endl;\n\n    vector<int> forbidden2 = {4, 5};\n    cout << minimumJumps(forbidden2, 3, 1, 6) << endl;\n\n    vector<int> forbidden3 = {0};\n    cout << minimumJumps(forbidden3, 1, 1, 2) << endl;\n\n    vector<int> forbidden4 = {5};\n    cout << minimumJumps(forbidden4, 1, 1, 10) << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###numFactoredBinaryTrees_Test.java",
        "source_code": "public static int numFactoredBinaryTrees(int[] arr) {\n        Arrays.sort(arr);\n        int n = arr.length;\n        long[] dp = new long[n];\n        long res = 0, mod = 1000000007;\n        for (int i = 0; i < n; i++) {\n            dp[i] = 1;\n            for (int left = 0, right = i - 1; left <= right; left++) {\n                while (right >= left && (long) arr[left] * arr[right] > arr[i]) {\n                    right--;\n                }\n                if (right >= left && (long) arr[left] * arr[right] == arr[i]) {\n                    if (right != left) {\n                        dp[i] = (dp[i] + dp[left] * dp[right] * 2) % mod;\n                    } else {\n                        dp[i] = (dp[i] + dp[left] * dp[right]) % mod;\n                    }\n                }\n            }\n            res = (res + dp[i]) % mod;\n        }\n        return (int) res;\n    }",
        "trans_code": "public : int numFactoredBinaryTrees ( vector < int > arr ) {\n  sort ( arr . begin ( ) , arr . end ( ) ) ;\n  int n = arr . size ( ) ;\n  vector < long long > dp ( n , 0 ) ;\n  long long res = 0 , mod = 1000000007 ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    dp [ i ] = 1 ;\n    for ( int left = 0 , right = i - 1 ;\n    left <= right ;\n    left ++ ) {\n      while ( right >= left && ( long long ) arr [ left ] * arr [ right ] > arr [ i ] ) right -- ;\n      if ( right >= left && ( long long ) arr [ left ] * arr [ right ] == arr [ i ] ) {\n        if ( right != left ) dp [ i ] = ( dp [ i ] + dp [ left ] * dp [ right ] * 2 ) % mod ;\n        else dp [ i ] = ( dp [ i ] + dp [ left ] * dp [ right ] ) % mod ;\n      }\n    }\n    res = ( res + dp [ i ] ) % mod ;\n  }\n  return ( int ) res ;\n}\n",
        "reference_code": "int numFactoredBinaryTrees(vector<int>& arr) {\n        sort(arr.begin(), arr.end());\n        int n = arr.size();\n        vector<long long> dp(n);\n        long long res = 0, mod = 1e9 + 7;\n        for (int i = 0; i < n; i++) {\n            dp[i] = 1;\n            for (int left = 0, right = i - 1; left <= right; left++) {\n                while (right >= left && (long long)arr[left] * arr[right] > arr[i]) {\n                    right--;\n                }\n                if (right >= left && (long long)arr[left] * arr[right] == arr[i]) {\n                    if (right != left) {\n                        dp[i] = (dp[i] + dp[left] * dp[right] * 2) % mod;\n                    } else {\n                        dp[i] = (dp[i] + dp[left] * dp[right]) % mod;\n                    }\n                }\n            }\n            res = (res + dp[i]) % mod;\n        }\n        return res;\n    }",
        "target_Lan": "cpp###numFactoredBinaryTrees.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <algorithm>\n// TOFILL\nint main() {\n    vector<int> arr1 = {};\n    vector<int> arr2 = {1};\n    vector<int> arr3 = {2, 4};\n    vector<int> arr4 = {4, 6, 10, 15};\n    vector<int> arr5 = {1000000000, 500000000};\n\n    cout << numFactoredBinaryTrees(arr1) << endl; \n    cout << numFactoredBinaryTrees(arr2) << endl; \n    cout << numFactoredBinaryTrees(arr3) << endl; \n    cout << numFactoredBinaryTrees(arr4) << endl; \n    cout << numFactoredBinaryTrees(arr5) << endl; \n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###countPairs_Test.java",
        "source_code": "public static int[] countPairs(int n, int[][] edges, int[] queries) {\n        int[] degree = new int[n];\n        Map<Integer, Integer> cnt = new HashMap<Integer, Integer>();\n        for (int[] edge : edges) {\n            int x = edge[0] - 1, y = edge[1] - 1;\n            if (x > y) {\n                int temp = x;\n                x = y;\n                y = temp;\n            }\n            degree[x]++;\n            degree[y]++;\n            cnt.put(x * n + y, cnt.getOrDefault(x * n + y, 0) + 1);\n        }\n        int[] arr = Arrays.copyOf(degree, n);\n        int[] ans = new int[queries.length];\n        Arrays.sort(arr);\n        for (int k = 0; k < queries.length; k++) {\n            int bound = queries[k], total = 0;\n            for (int i = 0, j = n - 1; i < n; i++) {\n                while (j > i && arr[i] + arr[j] > bound) {\n                    j--;\n                }\n                total += n - 1 - Math.max(i, j);\n            }\n            for (Map.Entry<Integer, Integer> entry : cnt.entrySet()) {\n                int val = entry.getKey(), freq = entry.getValue();\n                int x = val / n, y = val % n;\n                if (degree[x] + degree[y] > bound && degree[x] + degree[y] - freq <= bound) {\n                    total--;\n                }\n            }\n            ans[k] = total;\n        }\n        return ans;\n    }",
        "trans_code": "public : vector < int > countPairs ( int n , vector < vector < int >> edges , vector < int > queries ) {\n  vector < int > degree ( n , 0 ) ;\n  map < int , int > cnt ;\n  for ( auto edge : edges ) {\n    int x = edge . first - 1 , y = edge . second - 1 ;\n    if ( x > y ) {\n      int temp = x ;\n      x = y ;\n      y = temp ;\n    }\n    degree [ x ] ++ ;\n    degree [ y ] ++ ;\n    cnt [ x * n + y ] = cnt . count ( x * n + y ) + 1 ;\n  }\n  vector < int > arr ( degree . begin ( ) , degree . end ( ) ) ;\n  vector < int > ans ( queries . begin ( ) , queries . end ( ) ) ;\n  sort ( arr . begin ( ) , arr . end ( ) ) ;\n  for ( int k = 0 ;\n  k < queries . size ( ) ;\n  k ++ ) {\n    int bound = queries [ k ] , total = 0 ;\n    for ( int i = 0 , j = n - 1 ;\n    i < n ;\n    i ++ ) {\n      while ( j > i && arr [ i ] + arr [ j ] > bound ) j -- ;\n      total += n - 1 - max ( i , j ) ;\n    }\n    for ( map < int , int > :: iterator it = cnt . begin ( ) ;\n    it != cnt . end ( ) ;\n    it ++ ) {\n      int val = it -> first , freq = it -> second ;\n      int x = val / n , y = val % n ;\n      if ( degree [ x ] + degree [ y ] > bound && degree [ x ] + degree [ y ] - freq <= bound ) total -- ;\n    }\n    ans [ k ] = total ;\n  }\n  return ans ;\n}\n",
        "reference_code": "vector<int> countPairs(int n, vector<vector<int>>& edges, vector<int>& queries) {\n        vector<int> degree(n);\n        unordered_map<int, int> cnt;\n        for (auto edge : edges) {\n            int x = edge[0] - 1, y = edge[1] - 1;\n            if (x > y) {\n                swap(x, y);\n            }\n            degree[x]++;\n            degree[y]++;\n            cnt[x * n + y]++;\n        }\n        vector<int> arr = degree;\n        vector<int> ans;\n        sort(arr.begin(), arr.end());\n        for (int bound : queries) {\n            int total = 0;\n            for (int i = 0, j = n - 1; i < n; i++) {\n                while (j > i && arr[i] + arr[j] > bound) {\n                    j--;\n                }\n                total += n - 1 - max(i, j);\n            }\n            for (auto &[val, freq] : cnt) {\n                int x = val / n;\n                int y = val % n;\n                if (degree[x] + degree[y] > bound && degree[x] + degree[y] - freq <= bound) {\n                    total--;\n                }\n            }\n            ans.emplace_back(total);\n        }\n        return ans;\n    }",
        "target_Lan": "cpp###countPairs.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <algorithm>\n// TOFILL\nint main() {\n    vector<vector<int>> edges1 = {};\n    vector<int> queries1 = {1, 2, 3};\n    vector<int> result1 = countPairs(5, edges1, queries1);\n    for(int res : result1) {\n        cout << res << \" \";\n    }\n    cout << endl;\n\n    vector<vector<int>> edges2 = {{1, 2}};\n    vector<int> queries2 = {1, 2, 3};\n    vector<int> result2 = countPairs(2, edges2, queries2);\n    for(int res : result2) {\n        cout << res << \" \";\n    }\n    cout << endl;\n\n    vector<vector<int>> edges3 = {{1, 2}, {2, 3}, {3, 4}, {4, 5}};\n    vector<int> queries3 = {2, 3, 7};\n    vector<int> result3 = countPairs(5, edges3, queries3);\n    for(int res : result3) {\n        cout << res << \" \";\n    }\n    cout << endl;\n\n    vector<vector<int>> edges4 = {{1, 2}, {3, 4}};\n    vector<int> queries4 = {1, 5, 10};\n    vector<int> result4 = countPairs(6, edges4, queries4);\n    for(int res : result4) {\n        cout << res << \" \";\n    }\n    cout << endl;\n\n    vector<vector<int>> edges5 = {{1, 2}, {1, 3}, {2, 3}, {3, 4}};\n    vector<int> queries5 = {0, 6, 4};\n    vector<int> result5 = countPairs(4, edges5, queries5);\n    for(int res : result5) {\n        cout << res << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###captureForts_Test.java",
        "source_code": "public static int captureForts(int[] forts) {\n        int n = forts.length;\n        int ans = 0, pre = -1;\n        for (int i = 0; i < n; i++) {\n            if (forts[i] == 1 || forts[i] == -1) {\n                if (pre >= 0 && forts[i] != forts[pre]) {\n                    ans = Math.max(ans, i - pre - 1);\n                }\n                pre = i;\n            }\n        }\n        return ans;\n    }",
        "trans_code": "public : int captureForts ( vector < int > forts ) {\n  int n = forts . size ( ) ;\n  int ans = 0 , pre = - 1 ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    if ( forts [ i ] == 1 || forts [ i ] == - 1 ) {\n      if ( pre >= 0 && forts [ i ] != forts [ pre ] ) ans = max ( ans , i - pre - 1 ) ;\n      pre = i ;\n    }\n  }\n  return ans ;\n}\n",
        "reference_code": "int captureForts(vector<int>& forts) {\n        int ans = 0, pre = -1;\n        for (int i = 0; i < forts.size(); i++) {\n            if (forts[i] == 1 || forts[i] == -1) {\n                if (pre >= 0 && forts[i] != forts[pre]) {\n                    ans = max(ans, i - pre - 1);\n                }\n                pre = i;\n            }\n        }\n        return ans;\n    }",
        "target_Lan": "cpp###captureForts.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <algorithm>\n// TOFILL\nint main() {\n    vector<int> forts1 = {0, 0, 0, 0, 0};\n    vector<int> forts2 = {1, 1, 1, 1, 1};\n    vector<int> forts3 = {1, 0, 0, -1};\n    vector<int> forts4 = {0, -1, 0, 1, 0};\n    vector<int> forts5 = {1};\n\n    cout << captureForts(forts1) << endl;\n    cout << captureForts(forts2) << endl;\n    cout << captureForts(forts3) << endl;\n    cout << captureForts(forts4) << endl;\n    cout << captureForts(forts5) << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###maxDistToClosest_Test.java",
        "source_code": "public static int maxDistToClosest(int[] seats) {\n        int res = 0;\n        int l = 0;\n        while (l < seats.length && seats[l] == 0) {\n            ++l;\n        }\n        res = Math.max(res, l);\n        while (l < seats.length) {\n            int r = l + 1;\n            while (r < seats.length && seats[r] == 0) {\n                ++r;\n            }\n            if (r == seats.length) {\n                res = Math.max(res, r - l - 1);\n            } else {\n                res = Math.max(res, (r - l) / 2);\n            }\n            l = r;\n        }\n        return res;\n    }",
        "trans_code": "public : int maxDistToClosest ( vector < int > & seats ) {\n  int res = 0 ;\n  int l = 0 ;\n  while ( l < seats . size ( ) && seats [ l ] == 0 ) ++ l ;\n  res = max ( res , l ) ;\n  while ( l < seats . size ( ) ) {\n    int r = l + 1 ;\n    while ( r < seats . size ( ) && seats [ r ] == 0 ) ++ r ;\n    if ( r == seats . size ( ) ) res = max ( res , r - l - 1 ) ;\n    else res = max ( res , ( r - l ) / 2 ) ;\n    l = r ;\n  }\n  return res ;\n}\n",
        "reference_code": "int maxDistToClosest(vector<int>& seats) {\n        int res = 0;\n        int l = 0;\n        while (l < seats.size() && seats[l] == 0) {\n            ++l;\n        }\n        res = max(res, l);\n        while (l < seats.size()) {\n            int r = l + 1;\n            while (r < seats.size() && seats[r] == 0) {\n                ++r;\n            }\n            if (r == seats.size()) {\n                res = max(res, r - l - 1);\n            } else {\n                res = max(res, (r - l) / 2);\n            }\n            l = r;\n        }\n        return res;\n    }",
        "target_Lan": "cpp###maxDistToClosest.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    vector<int> input1 = {1, 1, 1, 1};\n    vector<int> input2 = {0, 0, 0, 0};\n    vector<int> input3 = {0, 1, 0, 0, 1};\n    vector<int> input4 = {1, 0, 0, 0, 1};\n    vector<int> input5 = {1, 0, 0, 0, 0, 1, 0, 1};\n    \n    cout << maxDistToClosest(input1) << endl;\n    cout << maxDistToClosest(input2) << endl;\n    cout << maxDistToClosest(input3) << endl;\n    cout << maxDistToClosest(input4) << endl;\n    cout << maxDistToClosest(input5) << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###ways_Test.java",
        "source_code": "public static int ways(String[] pizza, int k) {\n        int m = pizza.length, n = pizza[0].length(), mod = 1_000_000_007;\n        int[][] apples = new int[m + 1][n + 1];\n        int[][][] dp = new int[k + 1][m + 1][n + 1];\n        \n        for (int i = m - 1; i >= 0; i--) {\n            for (int j = n - 1; j >= 0; j--) {\n                apples[i][j] = apples[i][j + 1] + apples[i + 1][j] - apples[i + 1][j + 1] + (pizza[i].charAt(j) == 'A' ? 1 : 0);\n                dp[1][i][j] = apples[i][j] > 0 ? 1 : 0;\n            }\n        }\n        for (int ki = 2; ki <= k; ki++) {\n            for (int i = 0; i < m; i++) {\n                for (int j = 0; j < n; j++) {\n                    \n                    for (int i2 = i + 1; i2 < m; i2++) {\n                        if (apples[i][j] > apples[i2][j]) {\n                            dp[ki][i][j] = (dp[ki][i][j] + dp[ki - 1][i2][j]) % mod;\n                        }\n                    }\n                    \n                    for (int j2 = j + 1; j2 < n; j2++) {\n                        if (apples[i][j] > apples[i][j2]) {\n                            dp[ki][i][j] = (dp[ki][i][j] + dp[ki - 1][i][j2]) % mod;\n                        }\n                    }\n                }\n            }\n        }\n        return dp[k][0][0];\n    }",
        "trans_code": "public : int ways ( vector < string > pizza , int k ) {\n  int m = pizza . size ( ) , n = pizza [ 0 ] . size ( ) , mod = 1 _000_000_007 ;\n  vector < vector < int >> apples ( m + 1 , vector < int > ( n + 1 , 0 ) ) ;\n  vector < vector < int >> dp ( k + 1 , vector < int > ( m + 1 , 0 ) ) ;\n  for ( int i = m - 1 ;\n  i >= 0 ;\n  i -- ) {\n    for ( int j = n - 1 ;\n    j >= 0 ;\n    j -- ) {\n      apples [ i ] [ j ] = apples [ i ] [ j + 1 ] + apples [ i + 1 ] [ j ] - apples [ i + 1 ] [ j + 1 ] + ( pizza [ i ] [ j ] == 'A' ? 1 : 0 ) ;\n      dp [ 1 ] [ i ] [ j ] = apples [ i ] [ j ] > 0 ? 1 : 0 ;\n    }\n  }\n  for ( int ki = 2 ;\n  ki <= k ;\n  ki ++ ) {\n    for ( int i = 0 ;\n    i < m ;\n    i ++ ) {\n      for ( int j = 0 ;\n      j < n ;\n      j ++ ) {\n        for ( int i2 = i + 1 ;\n        i2 < m ;\n        i2 ++ ) {\n          if ( apples [ i ] [ j ] > apples [ i2 ] [ j ] ) dp [ ki ] [ i ] [ j ] = ( dp [ ki ] [ i ] [ j ] + dp [ ki - 1 ] [ i2 ] [ j ] ) % mod ;\n        }\n        for ( int j2 = j + 1 ;\n        j2 < n ;\n        j2 ++ ) {\n          if ( apples [ i ] [ j ] > apples [ i ] [ j2 ] ) dp [ ki ] [ i ] [ j ] = ( dp [ ki ] [ i ] [ j ] + dp [ ki - 1 ] [ i ] [ j2 ] ) % mod ;\n        }\n      }\n    }\n  }\n  return dp [ k ] [ 0 ] ;\n}\n",
        "reference_code": "int ways(vector<string>& pizza, int k) {\n        int m = pizza.size(), n = pizza[0].size(), mod = 1e9 + 7;\n        vector<vector<int>> apples(m + 1, vector<int>(n + 1));\n        vector<vector<vector<int>>> dp(k + 1, vector<vector<int>>(m + 1, vector<int>(n + 1)));\n        \n        for (int i = m - 1; i >= 0; i--) {\n            for (int j = n - 1; j >= 0; j--) {\n                apples[i][j] = apples[i][j + 1] + apples[i + 1][j] - apples[i + 1][j + 1] + (pizza[i][j] == 'A');\n                dp[1][i][j] = apples[i][j] > 0;\n            }\n        }\n        for (int ki = 2; ki <= k; ki++) {\n            for (int i = 0; i < m; i++) {\n                for (int j = 0; j < n; j++) {\n                    \n                    for (int i2 = i + 1; i2 < m; i2++) {\n                        if (apples[i][j] > apples[i2][j]) {\n                            dp[ki][i][j] = (dp[ki][i][j] + dp[ki - 1][i2][j]) % mod;\n                        }\n                    }\n                    \n                    for (int j2 = j + 1; j2 < n; j2++) {\n                        if (apples[i][j] > apples[i][j2]) {\n                            dp[ki][i][j] = (dp[ki][i][j] + dp[ki - 1][i][j2]) % mod;\n                        }\n                    }\n                }\n            }\n        }\n        return dp[k][0][0];\n    }",
        "target_Lan": "cpp###ways.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <string>\n// TOFILL\nint main() {\n    vector<string> pizza = {\"AAB\", \"ABA\", \"BAA\"};\n    int k = 2;\n    cout << ways(pizza, k) << endl;\n}"
    },
    {
        "source_Lan": "java###findReplaceString_Test.java",
        "source_code": "public static String findReplaceString(String s, int[] indices, String[] sources, String[] targets) {\n        int n = s.length(), m = indices.length;\n        List<Integer> ops = new ArrayList<>();\n        for (int i = 0; i < m; i++) {\n            ops.add(i);\n        }\n        ops.sort((i, j) -> indices[i] - indices[j]);\n        StringBuilder ans = new StringBuilder();\n        int pt = 0;\n        for (int i = 0; i < n;) {\n            while (pt < m && indices[ops.get(pt)] < i) {\n                pt++;\n            }\n            boolean succeed = false;\n            while (pt < m && indices[ops.get(pt)] == i) {\n                if (s.substring(i, Math.min(i + sources[ops.get(pt)].length(), n)).equals(sources[ops.get(pt)])) {\n                    succeed = true;\n                    break;\n                }\n                pt++;\n            }\n            if (succeed) {\n                ans.append(targets[ops.get(pt)]);\n                i += sources[ops.get(pt)].length();\n            } else {\n                ans.append(s.charAt(i));\n                i++;\n            }\n        }\n        return ans.toString();\n    }",
        "trans_code": "public : string findReplaceString ( string s , vector < int > indices , vector < string > sources , vector < string > targets ) {\n  int n = s . size ( ) , m = indices . size ( ) ;\n  vector < int > ops ;\n  for ( int i = 0 ;\n  i < m ;\n  i ++ ) ops . push_back ( i ) ;\n  ops . sort ( ( int i , int j ) ) ;\n  string ans ;\n  int pt = 0 ;\n  for ( int i = 0 ;\n  i < n ;\n  ) {\n    while ( pt < m && indices [ ops [ pt ] ] < i ) pt ++ ;\n    bool succeed = false ;\n    while ( pt < m && indices [ ops [ pt ] ] == i ) {\n      if ( s . substr ( i , min ( i + sources [ ops [ pt ] ] . size ( ) , n ) ) == sources [ ops [ pt ] ] ) {\n        succeed = true ;\n        break ;\n      }\n      pt ++ ;\n    }\n    if ( succeed ) {\n      ans += targets [ ops [ pt ] ] ;\n      i += sources [ ops [ pt ] ] . size ( ) ;\n    }\n    else {\n      ans += s [ i ] ;\n      i ++ ;\n    }\n  }\n  return ans ;\n}\n",
        "reference_code": "string findReplaceString(string s, vector<int>& indices, vector<string>& sources, vector<string>& targets) {\n        int n = s.size(), m = indices.size();\n        vector<int> ops(m);\n        iota(ops.begin(), ops.end(), 0);\n        sort(ops.begin(), ops.end(), [&](int i, int j) { return indices[i] < indices[j]; });\n        string ans;\n        int pt = 0;\n        for (int i = 0; i < n;) {\n            while (pt < m && indices[ops[pt]] < i) {\n                ++pt;\n            }\n            bool succeed = false;\n            while (pt < m && indices[ops[pt]] == i) {\n                if (s.substr(i, sources[ops[pt]].size()) == sources[ops[pt]]) {\n                    succeed = true;\n                    break;\n                }\n                ++pt;\n            }\n            if (succeed) {\n                ans += targets[ops[pt]];\n                i += sources[ops[pt]].size();\n            }\n            else {\n                ans += s[i];\n                ++i;\n            }\n        }\n        return ans;\n    }",
        "target_Lan": "cpp###findReplaceString.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <numeric>\nusing namespace std;\n// TOFILL\nint main() {\n    \n    string s1 = \"ababc\";\n    vector<int> indices1 = {0, 2};\n    vector<string> sources1 = {\"ab\", \"c\"};\n    vector<string> targets1 = {\"xy\", \"z\"};\n    cout << findReplaceString(s1, indices1, sources1, targets1) << endl;  \n\n    \n    string s2 = \"abcdefg\";\n    vector<int> indices2 = {0, 2, 4};\n    vector<string> sources2 = {\"ab\", \"cd\", \"ef\"};\n    vector<string> targets2 = {\"1\", \"2\", \"3\"};\n    cout << findReplaceString(s2, indices2, sources2, targets2) << endl;  \n\n    \n    string s3 = \"hello world\";\n    vector<int> indices3 = {0, 6};\n    vector<string> sources3 = {\"hello\", \"world\"};\n    vector<string> targets3 = {\"hi\", \"everyone\"};\n    cout << findReplaceString(s3, indices3, sources3, targets3) << endl;  \n\n    \n    string s4 = \"x\";\n    vector<int> indices4 = {0};\n    vector<string> sources4 = {\"x\"};\n    vector<string> targets4 = {\"y\"};\n    cout << findReplaceString(s4, indices4, sources4, targets4) << endl;  \n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###circularGameLosers_Test.java",
        "source_code": "public static int[] circularGameLosers(int n, int k) {\n        boolean[] visit = new boolean[n];\n        for (int i = k, j = 0; !visit[j]; i += k) {\n            visit[j] = true;\n            j = (j + i) % n;\n        }\n        List<Integer> list = new ArrayList<Integer>();\n        for (int i = 0; i < n; i++) {\n            if (!visit[i]) {\n                list.add(i + 1);\n            }\n        }\n        int[] ans = new int[list.size()];\n        for (int i = 0; i < list.size(); i++) {\n            ans[i] = list.get(i);\n        }\n        return ans;\n    }",
        "trans_code": "public : vector < int > circularGameLosers ( int n , int k ) {\n  vector < bool > visit ( n , false ) ;\n  for ( int i = k , j = 0 ;\n  ! visit [ j ] ;\n  i += k ) {\n    visit [ j ] = true ;\n    j = ( j + i ) % n ;\n  }\n  vector < int > vec ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    if ( ! visit [ i ] ) vec . push_back ( i + 1 ) ;\n  }\n  vector < int > ans ;\n  for ( int i = 0 ;\n  i < vec . size ( ) ;\n  i ++ ) ans . push_back ( vec [ i ] ) ;\n  return ans ;\n}\n",
        "reference_code": "vector<int> circularGameLosers(int n, int k) {\n        vector<bool> visit(n, false);\n        for (int i = k, j = 0; !visit[j]; i += k) {\n            visit[j] = true;\n            j = (j + i) % n;\n        }\n        vector<int> ans;\n        for (int i = 0; i < n; i++) {\n            if (!visit[i]) {\n                ans.emplace_back(i + 1);\n            }\n        }\n        return ans;\n    }",
        "target_Lan": "cpp###circularGameLosers.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\nusing namespace std;\n// TOFILL\nint main() {\n    \n    int n1 = 5, k1 = 2;\n    vector<int> result1 = circularGameLosers(n1, k1);\n    for(int num : result1) {\n        cout << num << \" \";\n    }\n    cout << endl;  \n\n    \n    int n2 = 7, k2 = 3;\n    vector<int> result2 = circularGameLosers(n2, k2);\n    for(int num : result2) {\n        cout << num << \" \";\n    }\n    cout << endl;  \n\n    \n    int n3 = 10, k3 = 1;\n    vector<int> result3 = circularGameLosers(n3, k3);\n    for(int num : result3) {\n        cout << num << \" \";\n    }\n    cout << endl;  \n\n    \n    int n4 = 6, k4 = 4;\n    vector<int> result4 = circularGameLosers(n4, k4);\n    for(int num : result4) {\n        cout << num << \" \";\n    }\n    cout << endl;  \n\n    \n    int n5 = 8, k5 = 7;\n    vector<int> result5 = circularGameLosers(n5, k5);\n    for(int num : result5) {\n        cout << num << \" \";\n    }\n    cout << endl;  \n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###countSeniors_Test.java",
        "source_code": "public static int countSeniors(String[] details) {\n        int count = 0;\n        for (String info : details) {\n            if (Integer.parseInt(info.substring(11, 13)) > 60) {\n                count++;\n            }\n        }\n        return count;\n    }",
        "trans_code": "int CountSeniors ( const vector < string > & details ) {\n  int count = 0 ;\n  for ( auto info : details ) {\n    if ( atoi ( info . substr ( 11 , 13 ) . c_str ( ) ) > 60 ) count ++ ;\n  }\n  return count ;\n}\n",
        "reference_code": "int countSeniors(vector<string>& details) {\n        int count = 0;\n        for (string & info : details) {\n            if (stoi(info.substr(11, 2)) > 60) {\n                count++;\n            }\n        }\n        return count;\n    }",
        "target_Lan": "cpp###countSeniors.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <string>\n// TOFILL\nint main() {\n    vector<string> details = {};\n    cout << countSeniors(details) << endl;\n}"
    },
    {
        "source_Lan": "java###maxAbsoluteSum_Test.java",
        "source_code": "public static int maxAbsoluteSum(int[] nums) {\n        int positiveMax = 0, negativeMin = 0;\n        int positiveSum = 0, negativeSum = 0;\n        for (int num : nums) {\n            positiveSum += num;\n            positiveMax = Math.max(positiveMax, positiveSum);\n            positiveSum = Math.max(0, positiveSum);\n            negativeSum += num;\n            negativeMin = Math.min(negativeMin, negativeSum);\n            negativeSum = Math.min(0, negativeSum);\n        }\n        return Math.max(positiveMax, -negativeMin);\n    }",
        "trans_code": "public : int maxAbsoluteSum ( vector < int > & nums ) {\n  int positiveMax = 0 , negativeMin = 0 ;\n  int positiveSum = 0 , negativeSum = 0 ;\n  for ( int num : nums ) {\n    positiveSum += num ;\n    positiveMax = max ( positiveMax , positiveSum ) ;\n    positiveSum = max ( 0 , positiveSum ) ;\n    negativeSum += num ;\n    negativeMin = min ( negativeMin , negativeSum ) ;\n    negativeSum = min ( 0 , negativeSum ) ;\n  }\n  return max ( positiveMax , - negativeMin ) ;\n}\n",
        "reference_code": "int maxAbsoluteSum(vector<int>& nums) {\n        int positiveMax = 0, negativeMin = 0;\n        int positiveSum = 0, negativeSum = 0;\n        for (int num : nums) {\n            positiveSum += num;\n            positiveMax = max(positiveMax, positiveSum);\n            positiveSum = max(0, positiveSum);\n            negativeSum += num;\n            negativeMin = min(negativeMin, negativeSum);\n            negativeSum = min(0, negativeSum);\n        }\n        return max(positiveMax, -negativeMin);\n    }",
        "target_Lan": "cpp###maxAbsoluteSum.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <algorithm>\n// TOFILL\nint main() {\n    vector<int> test1 = {1, 2, 3, 4, 5};\n    vector<int> test2 = {-1, -2, -3, -4, -5};\n    vector<int> test3 = {1, -2, 3, -4, 5};\n    vector<int> test4 = {0, 0, 0, 0, 0};\n    vector<int> test5 = {};\n    \n    cout << maxAbsoluteSum(test1) << endl; \n    cout << maxAbsoluteSum(test2) << endl; \n    cout << maxAbsoluteSum(test3) << endl; \n    cout << maxAbsoluteSum(test4) << endl; \n    cout << maxAbsoluteSum(test5) << endl; \n}"
    },
    {
        "source_Lan": "java###minimumOperationsToMakeKPeriodic_Test.java",
        "source_code": "public static int minimumOperationsToMakeKPeriodic(String word, int k) {\n        int n = word.length(), res = Integer.MAX_VALUE;\n        HashMap<String, Integer> count = new HashMap<>();\n        for (int i = 0; i < n; i += k) {\n            String part = word.substring(i, i + k);\n            res = Math.min(res, n / k - count.merge(part, 1, Integer::sum));\n        }\n        return res;\n    }",
        "trans_code": "public : int minimumOperationsToMakeKPeriodic ( string word , int k ) {\n  int n = word . size ( ) , res = INT_MAX ;\n  unordered_map < string , int > count ;\n  for ( int i = 0 ;\n  i < n ;\n  i += k ) {\n    string part = word . substr ( i , k ) ;\n    res = min ( res , n / k - count . merge ( part , 1 , INT_MAX ) ) ;\n  }\n  return res ;\n}\n",
        "reference_code": "int minimumOperationsToMakeKPeriodic(string word, int k) {\n        int n = word.size(), res = INT_MAX;\n        unordered_map<string, int> count;\n        for (int i = 0; i < n; i += k) {\n            string &&part = word.substr(i, k);\n            count[part]++;\n            res = min(res, n / k - count[part]);\n        }\n        return res;\n    }",
        "target_Lan": "cpp###minimumOperationsToMakeKPeriodic.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <unordered_map>\n#include <string>\n#include <algorithm>\n#include <climits>\n// TOFILL\nint main() {\n    cout << minimumOperationsToMakeKPeriodic(\"\", 1) << endl;\n    cout << minimumOperationsToMakeKPeriodic(\"abcabcabc\", 3) << endl;\n    cout << minimumOperationsToMakeKPeriodic(\"abcd\", 2) << endl;\n    cout << minimumOperationsToMakeKPeriodic(\"aabbcc\", 2) << endl;\n}"
    },
    {
        "source_Lan": "java###maxScore_Test.java",
        "source_code": "public static int maxScore(List<List<Integer>> grid) {\n        int m = grid.size(), n = grid.get(0).size();\n        int[][] prerow = new int[m][n];\n        int[][] precol = new int[m][n];\n        int[][] f = new int[m][n];\n        for (int i = 0; i < m; ++i) {\n            Arrays.fill(f[i], Integer.MIN_VALUE);\n        }\n        int ans = Integer.MIN_VALUE;\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (i > 0) {\n                    f[i][j] = Math.max(f[i][j], grid.get(i).get(j) + precol[i - 1][j]);\n                }\n                if (j > 0) {\n                    f[i][j] = Math.max(f[i][j], grid.get(i).get(j) + prerow[i][j - 1]);\n                }\n                ans = Math.max(ans, f[i][j]);\n                prerow[i][j] = precol[i][j] = Math.max(f[i][j], 0) - grid.get(i).get(j);\n                if (i > 0) {\n                    precol[i][j] = Math.max(precol[i][j], precol[i - 1][j]);\n                }\n                if (j > 0) {\n                    prerow[i][j] = Math.max(prerow[i][j], prerow[i][j - 1]);\n                }\n            }\n        }\n        return ans;\n    }",
        "trans_code": "public : int maxScore ( vector < vector < int >> & grid ) {\n  int m = grid . size ( ) , n = grid [ 0 ] . size ( ) ;\n  vector < vector < int >> prerow ( m , vector < int > ( n , 0 ) ) ;\n  vector < vector < int >> precol ( m , vector < int > ( n , 0 ) ) ;\n  vector < vector < int >> f ( m , vector < int > ( n , 0 ) ) ;\n  for ( int i = 0 ;\n  i < m ;\n  ++ i ) std :: fill ( f . begin ( ) , f . end ( ) , INT_MAX ) ;\n  int ans = INT_MAX ;\n  for ( int i = 0 ;\n  i < m ;\n  ++ i ) {\n    for ( int j = 0 ;\n    j < n ;\n    ++ j ) {\n      if ( i > 0 ) f [ i ] [ j ] = max ( f [ i ] [ j ] , grid [ i ] [ j ] + precol [ i - 1 ] [ j ] ) ;\n      if ( j > 0 ) f [ i ] [ j ] = max ( f [ i ] [ j ] , grid [ i ] [ j ] + prerow [ i ] [ j - 1 ] ) ;\n      ans = max ( ans , f [ i ] [ j ] ) ;\n      prerow [ i ] [ j ] = precol [ i ] [ j ] = max ( f [ i ] [ j ] , 0 ) - grid [ i ] [ j ] ;\n      if ( i > 0 ) precol [ i ] [ j ] = max ( precol [ i ] [ j ] , precol [ i - 1 ] [ j ] ) ;\n      if ( j > 0 ) prerow [ i ] [ j ] = max ( prerow [ i ] [ j ] , prerow [ i ] [ j - 1 ] ) ;\n    }\n  }\n  return ans ;\n}\n",
        "reference_code": "int maxScore(vector<vector<int>>& grid) {\n        int m = grid.size(), n = grid[0].size();\n        vector<vector<int>> prerow(m, vector<int>(n));\n        vector<vector<int>> precol(m, vector<int>(n));\n        vector<vector<int>> f(m, vector<int>(n, INT_MIN));\n        int ans = INT_MIN;\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (i > 0) {\n                    f[i][j] = max(f[i][j], grid[i][j] + precol[i - 1][j]);\n                }\n                if (j > 0) {\n                    f[i][j] = max(f[i][j], grid[i][j] + prerow[i][j - 1]);\n                }\n                ans = max(ans, f[i][j]);\n                prerow[i][j] = precol[i][j] = max(f[i][j], 0) - grid[i][j];\n                if (i > 0) {\n                    precol[i][j] = max(precol[i][j], precol[i - 1][j]);\n                }\n                if (j > 0) {\n                    prerow[i][j] = max(prerow[i][j], prerow[i][j - 1]);\n                }\n            }\n        }\n        return ans;\n    }",
        "target_Lan": "cpp###maxScore.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <climits>\n// TOFILL\nint main() {\n    vector<vector<int>> grid1 = {{1}};\n    vector<vector<int>> grid2 = {{-1, -2, -3}, {-4, -5, -6}};\n    vector<vector<int>> grid3 = {{2147483647, 2147483647}, {2147483647, 2147483647}};\n    vector<vector<int>> grid4 = {{0, 1, 2}, {-1, -2, -3}};\n    vector<vector<int>> grid5 = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};\n    \n    cout << maxScore(grid1) << endl;\n    cout << maxScore(grid2) << endl;\n    cout << maxScore(grid3) << endl;\n    cout << maxScore(grid4) << endl;\n    cout << maxScore(grid5) << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###isArraySpecial_Test.java",
        "source_code": "public static boolean[] isArraySpecial(int[] nums, int[][] queries) {\n        int n = nums.length;\n        int[] dp = new int[n];\n        Arrays.fill(dp, 1);\n        for (int i = 1; i < n; i++) {\n            if (((nums[i] ^ nums[i - 1]) & 1) != 0) {\n                dp[i] = dp[i - 1] + 1;\n            }\n        }\n        boolean[] res = new boolean[queries.length];\n        for (int i = 0; i < queries.length; i++) {\n            int x = queries[i][0], y = queries[i][1];\n            res[i] = dp[y] >= y - x + 1;\n        }\n        return res;\n    }",
        "trans_code": "public : vector < bool > isArraySpecial ( vector < int > & nums , vector < vector < int >> & queries ) {\n  int n = nums . size ( ) ;\n  vector < int > dp ( n , 1 ) ;\n  memset ( dp . data ( ) , 0 , n * sizeof ( int ) ) ;\n  for ( int i = 1 ;\n  i < n ;\n  i ++ ) {\n    if ( ( ( nums [ i ] ^ nums [ i - 1 ] ) & 1 ) != 0 ) dp [ i ] = dp [ i - 1 ] + 1 ;\n  }\n  vector < bool > res ( queries . size ( ) , false ) ;\n  for ( int i = 0 ;\n  i < queries . size ( ) ;\n  i ++ ) {\n    int x = queries [ i ] [ 0 ] , y = queries [ i ] [ 1 ] ;\n    res [ i ] = dp [ y ] >= y - x + 1 ;\n  }\n  return res ;\n}\n",
        "reference_code": "vector<bool> isArraySpecial(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        vector<int> dp(n, 1);\n        for (int i = 1; i < n; i++) {\n            if ((nums[i] ^ nums[i - 1]) & 1) {\n                dp[i] = dp[i - 1] + 1;\n            }\n        }\n        vector<bool> res;\n        for (auto &q : queries) {\n            int x = q[0], y = q[1];\n            res.emplace_back(dp[y] >= y - x + 1);\n        }\n        return res;\n    }",
        "target_Lan": "cpp###isArraySpecial.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    vector<int> nums1 = {1, 2, 3, 4, 5};\n    vector<vector<int>> queries1 = {{0, 4}, {1, 3}, {2, 2}, {0, 2}, {2, 4}};\n    \n    vector<int> nums2 = {2, 4, 6, 8};\n    vector<vector<int>> queries2 = {{0, 1}, {1, 3}, {0, 3}};\n    \n    vector<int> nums3 = {1, 3, 5, 2, 4};\n    vector<vector<int>> queries3 = {{0, 4}, {1, 2}, {0, 3}, {1, 4}};\n    \n    vector<int> nums4 = {0, 0, 0, 0, 1};\n    vector<vector<int>> queries4 = {{0, 4}, {1, 2}, {2, 3}};\n    \n    vector<int> nums5 = {1, 0, 1, 0, 1};\n    vector<vector<int>> queries5 = {{0, 4}, {0, 0}, {4, 4}};\n    \n    auto result1 = isArraySpecial(nums1, queries1);\n    auto result2 = isArraySpecial(nums2, queries2);\n    auto result3 = isArraySpecial(nums3, queries3);\n    auto result4 = isArraySpecial(nums4, queries4);\n    auto result5 = isArraySpecial(nums5, queries5);\n    \n    for(bool res : result1) cout << res << \" \";\n    cout << endl;\n    \n    for(bool res : result2) cout << res << \" \";\n    cout << endl;\n    \n    for(bool res : result3) cout << res << \" \";\n    cout << endl;\n    \n    for(bool res : result4) cout << res << \" \";\n    cout << endl;\n    \n    for(bool res : result5) cout << res << \" \";\n    cout << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###leftmostBuildingQueries_Test.java",
        "source_code": "public static int[] leftmostBuildingQueries(int[] heights, int[][] queries) {\n        int n = heights.length;\n        int m = queries.length;\n        List<int[]>[] query = new List[n];\n        for (int i = 0; i < n; i++) {\n            query[i] = new ArrayList<int[]>();\n        }\n        int[] ans = new int[m];\n        List<Integer> st = new ArrayList<Integer>();\n        for (int i = 0; i < m; i++) {\n            int a = queries[i][0];\n            int b = queries[i][1];\n            if (a > b) {\n                int temp = a;\n                a = b;\n                b = temp;\n            }\n            if (a == b || heights[a] < heights[b]) {\n                ans[i] = b;\n                continue;\n            }\n            query[b].add(new int[]{i, heights[a]});\n        }\n        int top = -1;\n        for (int i = n - 1; i >= 0; i--) {\n            for (int j = 0; j < query[i].size(); j++) {\n                int q = query[i].get(j)[0];\n                int val = query[i].get(j)[1];\n                if (top == -1 || heights[st.get(0)] <= val) {\n                    ans[q] = -1;\n                    continue;\n                }\n                int l = 0, r = top;\n                while (l <= r) {\n                    int mid = (l + r) >> 1;\n                    if (heights[st.get(mid)] > val) {\n                        l = mid + 1;\n                    } else {\n                        r = mid - 1;\n                    }\n                }\n                ans[q] = st.get(r);\n            }\n            while (top >= 0 && heights[st.get(top)] <= heights[i]) {\n                st.remove(st.size() - 1);\n                top--;\n            }\n            st.add(i);\n            top++;\n        }\n        return ans;\n    }",
        "trans_code": "public : vector < vector < int >> leftmostBuildingQueries ( vector < int > heights , vector < vector < int >> queries ) {\n  int n = heights . size ( ) ;\n  int m = queries . size ( ) ;\n  vector < vector < int >> query ( n , vector < int > ( ) ) ;\n  vector < vector < int >> ans ( m , vector < int > ( ) ) ;\n  vector < int > st ;\n  for ( int i = 0 ;\n  i < m ;\n  i ++ ) {\n    int a = queries [ i ] [ 0 ] ;\n    int b = queries [ i ] [ 1 ] ;\n    if ( a > b ) {\n      int temp = a ;\n      a = b ;\n      b = temp ;\n    }\n    if ( a == b || heights [ a ] < heights [ b ] ) {\n      ans [ i ] = b ;\n      continue ;\n    }\n    query [ b ] . push_back ( {\n      i , heights [ a ] }\n      ) ;\n    }\n    int top = - 1 ;\n    for ( int i = n - 1 ;\n    i >= 0 ;\n    i -- ) {\n      for ( int j = 0 ;\n      j < query [ i ] . size ( ) ;\n      j ++ ) {\n        int q = query [ i ] [ j ] ;\n        int val = query [ i ] [ j ] ;\n        if ( top == - 1 || heights [ st [ 0 ] ] <= val ) {\n          ans [ q ] = - 1 ;\n          continue ;\n        }\n        int l = 0 , r = top ;\n        while ( l <= r ) {\n          int mid = ( l + r ) >> 1 ;\n          if ( heights [ st [ mid ] ] > val ) l = mid + 1 ;\n          else r = mid - 1 ;\n        }\n        ans [ q ] = st [ r ] ;\n      }\n      while ( top >= 0 && heights [ st [ top ] ] <= heights [ i ] ) {\n        st . erase ( st . end ( ) - 1 ) ;\n        top -- ;\n      }\n      st . push_back ( i ) ;\n      top ++ ;\n    }\n    return ans ;\n  }\n  ",
        "reference_code": "vector<int> leftmostBuildingQueries(vector<int>& heights, vector<vector<int>>& queries) {\n        int n = heights.size();\n        int m = queries.size();\n        vector<vector<pair<int, int>>> query(n);\n        vector<int> ans(m);\n        vector<int> st;\n        for (int i = 0; i < m; i++) {\n            int a = queries[i][0];\n            int b = queries[i][1];\n            if (a > b) swap(a, b);\n            if (a == b || heights[a] < heights[b]) {\n                ans[i] = b;\n                continue;\n            }\n            query[b].push_back(make_pair(i, heights[a]));\n        }\n        int top = -1;\n        for (int i = n - 1; i >= 0; i--) {\n            for (int j = 0; j < query[i].size(); j++) {\n                int q = query[i][j].first;\n                int val = query[i][j].second;\n                if (top == -1 || heights[st[0]] <= val) {\n                    ans[q] = -1;\n                    continue;\n                }\n                int l = 0, r = top;\n                while (l <= r) {\n                    int mid = (l + r) >> 1;\n                    if (heights[st[mid]] > val) {\n                        l = mid + 1;\n                    } else {\n                        r = mid - 1;\n                    }\n                }\n                ans[q] = st[r];\n            }\n            while (top >= 0 && heights[st[top]] <= heights[i]) {\n                st.pop_back();\n                top--;\n            }\n            st.push_back(i);\n            top++;\n        }\n        return ans;\n    }",
        "target_Lan": "cpp###leftmostBuildingQueries.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    vector<int> heights1 = {1, 2, 3, 4, 5};\n    vector<vector<int>> queries1 = {{0, 1}, {1, 4}, {4, 0}, {1, 1}, {2, 3}};\n    vector<int> result1 = leftmostBuildingQueries(heights1, queries1);\n    for(int res : result1) cout << res << \" \";\n    cout << endl;\n\n    vector<int> heights2 = {5, 1, 1, 1, 5};\n    vector<vector<int>> queries2 = {{0, 4}, {1, 2}, {2, 0}, {3, 1}, {4, 0}};\n    vector<int> result2 = leftmostBuildingQueries(heights2, queries2);\n    for(int res : result2) cout << res << \" \";\n    cout << endl;\n\n    vector<int> heights3 = {1};\n    vector<vector<int>> queries3 = {{0, 0}, {0, 0}};\n    vector<int> result3 = leftmostBuildingQueries(heights3, queries3);\n    for(int res : result3) cout << res << \" \";\n    cout << endl;\n\n    vector<int> heights4 = {3, 2, 4, 1};\n    vector<vector<int>> queries4 = {{0, 2}, {0, 1}, {3, 2}, {3, 3}, {2, 0}};\n    vector<int> result4 = leftmostBuildingQueries(heights4, queries4);\n    for(int res : result4) cout << res << \" \";\n    cout << endl;\n\n    vector<int> heights5 = {2, 2, 2, 2, 2};\n    vector<vector<int>> queries5 = {{0, 1}, {1, 2}, {2, 3}, {3, 4}, {0, 4}};\n    vector<int> result5 = leftmostBuildingQueries(heights5, queries5);\n    for(int res : result5) cout << res << \" \";\n    cout << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###isArraySpecial_Test.java",
        "source_code": "public static boolean isArraySpecial(int[] nums) {\n        int n = nums.length;\n        for (int i = 1; i < n; ++i) {\n            if (nums[i - 1] % 2 == nums[i] % 2) {\n                return false;\n            }\n        }\n        return true;\n    }",
        "trans_code": "public : bool isArraySpecial ( vector < int > & nums ) {\n  int n = nums . size ( ) ;\n  for ( int i = 1 ;\n  i < n ;\n  ++ i ) {\n    if ( nums [ i - 1 ] % 2 == nums [ i ] % 2 ) {\n      return false ;\n    }\n  }\n  return true ;\n}\n",
        "reference_code": "bool isArraySpecial(vector<int>& nums) {\n        int n = nums.size();\n        for (int i = 1; i < n; ++i) {\n            if (nums[i - 1] % 2 == nums[i] % 2) {\n                return false;\n            }\n        }\n        return true;\n    }",
        "target_Lan": "cpp###isArraySpecial.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    vector<int> nums1 = {};\n    vector<int> nums2 = {1};\n    vector<int> nums3 = {2, 3, 4};\n    vector<int> nums4 = {1, 2, 3, 4, 5};\n    vector<int> nums5 = {2, 4, 6, 8};\n\n    cout << isArraySpecial(nums1) << endl; \n    cout << isArraySpecial(nums2) << endl; \n    cout << isArraySpecial(nums3) << endl; \n    cout << isArraySpecial(nums4) << endl; \n    cout << isArraySpecial(nums5) << endl; \n}"
    },
    {
        "source_Lan": "java###countOfPairs_Test.java",
        "source_code": "public static int countOfPairs(int[] nums) {\n        final int MOD = (int)(1e9 + 7);\n        int m = nums.length;\n        int n = Arrays.stream(nums).max().getAsInt();\n        int[] f = new int[n + 1];\n        \n        for (int v = 0; v <= nums[0]; ++v) f[v] = 1;\n        List<Integer> preSums = new ArrayList<>();\n        \n        for (int i = 1; i <= m; ++i) {\n            \n            preSums.clear();\n            int preSum = 0;\n            for(int v : f){\n                preSum += v;\n                preSum %= MOD; \n                preSums.add(preSum);\n            }\n            \n            if (i == m) return preSums.get(preSums.size() - 1);\n            \n            for (int j = 0; j <= nums[i]; ++j) {\n                int ceil = Math.min(j, nums[i-1] - nums[i] + j);\n                if (ceil >= 0)\n                    f[j] = preSums.get(ceil);\n                else \n                    f[j] = 0;\n            }\n            for (int j = nums[i] + 1; j < f.length; ++j) {\n                f[j] = 0;\n            }\n        }\n        \n        return 0;\n    }",
        "trans_code": "public : int countOfPairs ( vector < int > & nums ) {\n  const int MOD = ( int ) ( 1e9 + 7 ) ;\n  int m = nums . size ( ) ;\n  int n = accumulate ( nums . begin ( ) , nums . end ( ) , 0 ) ;\n  vector < int > f ( n + 1 , 0 ) ;\n  for ( int v = 0 ;\n  v <= nums [ 0 ] ;\n  ++ v ) {\n    f [ v ] = 1 ;\n  }\n  vector < int > preSums ;\n  for ( int i = 1 ;\n  i <= m ;\n  ++ i ) {\n    preSums . clear ( ) ;\n    int preSum = 0 ;\n    for ( int v : f ) {\n      preSum += v ;\n      preSum %= MOD ;\n      preSums . push_back ( preSum ) ;\n    }\n    if ( i == m ) return preSums [ preSums . size ( ) - 1 ] ;\n    for ( int j = 0 ;\n    j <= nums [ i ] ;\n    ++ j ) {\n      int ceil = min ( j , nums [ i - 1 ] - nums [ i ] + j ) ;\n      if ( ceil >= 0 ) {\n        f [ j ] = preSums [ ceil ] ;\n      }\n      else {\n        f [ j ] = 0 ;\n      }\n    }\n    for ( int j = nums [ i ] + 1 ;\n    j < f . size ( ) ;\n    ++ j ) f [ j ] = 0 ;\n  }\n  return 0 ;\n}\n",
        "reference_code": "int countOfPairs(vector<int>& nums) {\n        const int MOD = 1e9 + 7;\n        int m = nums.size();\n        int n = *max_element(nums.begin(), nums.end());\n        vector<int> f(n + 1);\n        \n        for (int v = 0; v <= nums[0]; ++v)\n            f[v] = 1;\n        vector<int> preSums;\n        \n        for (int i = 1; i <= m; ++i) {\n            \n            preSums.clear();\n            int preSum = 0;\n            for(int v : f){\n                preSum += v;\n                preSum %= MOD; \n                preSums.push_back(preSum);\n            }\n            \n            if (i == m) return preSums.back();\n            \n            for (int j = 0; j <= nums[i]; ++j) {\n                int ceil = min(j, nums[i-1] - nums[i] + j);\n                if (ceil >= 0)\n                    f[j] = preSums[ceil];\n                else \n                    f[j] = 0;\n            }\n            for (int j = nums[i] + 1; j < f.size(); ++j) {\n                f[j] = 0;\n            }\n        }\n        \n        return 0;\n    }",
        "target_Lan": "cpp###countOfPairs.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <algorithm>\n// TOFILL\nint main() {\n    vector<int> input1 = {0};\n    vector<int> input2 = {1, 2, 3};\n    \n    cout << countOfPairs(input1) << endl;\n    cout << countOfPairs(input2) << endl;\n}"
    },
    {
        "source_Lan": "java###shortestDistanceAfterQueries_Test.java",
        "source_code": "public static int[] shortestDistanceAfterQueries(int n, int[][] queries) {\n        List<Integer>[] from = new ArrayList[n];\n        Arrays.setAll(from, i -> new ArrayList<>());\n        int[] f = new int[n];\n        for (int i = 1; i < n; i++) {\n            f[i] = i;\n        }\n        int[] ans = new int[queries.length];\n        for (int qi = 0; qi < queries.length; qi++) {\n            int l = queries[qi][0];\n            int r = queries[qi][1];\n            from[r].add(l);\n            if (f[l] + 1 < f[r]) {\n                f[r] = f[l] + 1;\n                for (int i = r + 1; i < n; i++) {\n                    f[i] = Math.min(f[i], f[i - 1] + 1);\n                    for (int j : from[i]) {\n                        f[i] = Math.min(f[i], f[j] + 1);\n                    }\n                }\n            }\n            ans[qi] = f[n - 1];\n        }\n        return ans;\n    }",
        "trans_code": "public : vector < int > shortestDistanceAfterQueries ( int n , vector < vector < int >> & queries ) {\n  vector < int > from ( n , 0 ) ;\n  sort ( from . begin ( ) , from . end ( ) ) ;\n  vector < int > f ( n , 0 ) ;\n  for ( int i = 1 ;\n  i < n ;\n  i ++ ) f [ i ] = i ;\n  vector < int > ans ( queries . size ( ) , 0 ) ;\n  for ( int qi = 0 ;\n  qi < queries . size ( ) ;\n  qi ++ ) {\n    int l = queries [ qi ] [ 0 ] ;\n    int r = queries [ qi ] [ 1 ] ;\n    from [ r ] . push_back ( l ) ;\n    if ( f [ l ] + 1 < f [ r ] ) {\n      f [ r ] = f [ l ] + 1 ;\n      for ( int i = r + 1 ;\n      i < n ;\n      i ++ ) {\n        f [ i ] = min ( f [ i ] , f [ i - 1 ] + 1 ) ;\n        for ( int j : from [ i ] ) f [ i ] = min ( f [ i ] , f [ j ] + 1 ) ;\n      }\n    }\n    ans [ qi ] = f [ n - 1 ] ;\n  }\n  return ans ;\n}\n",
        "reference_code": "vector<int> shortestDistanceAfterQueries(int n, vector<vector<int>>& queries) {\n        vector<vector<int>> from(n);\n        vector<int> f(n);\n        iota(f.begin(), f.end(), 0);\n        vector<int> ans(queries.size());\n        for (int qi = 0; qi < queries.size(); qi++) {\n            int l = queries[qi][0], r = queries[qi][1];\n            from[r].push_back(l);\n            if (f[l] + 1 < f[r]) {\n                f[r] = f[l] + 1;\n                for (int i = r + 1; i < n; i++) {\n                    f[i] = min(f[i], f[i - 1] + 1);\n                    for (int j : from[i]) {\n                        f[i] = min(f[i], f[j] + 1);\n                    }\n                }\n            }\n            ans[qi] = f[n - 1];\n        }\n        return ans;\n    }",
        "target_Lan": "cpp###shortestDistanceAfterQueries.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <numeric>\n// TOFILL\nint main() {\n    vector<vector<int>> queries1 = {{0, 0}};\n    vector<vector<int>> queries2 = {{0, 1}, {1, 2}, {2, 4}};\n    vector<vector<int>> queries3 = {{0, 4}, {4, 0}, {1, 3}};\n    vector<vector<int>> queries4 = {{0, 9}, {5, 9}, {1, 3}};\n    vector<vector<int>> queries5 = {{0, 99}, {1, 99}, {2, 99}, {3, 99}, {4, 99}, {5, 99}, {6, 99}, {7, 99}, \n                                      {8, 99}, {9, 99}, {10, 99}, {11, 99}, {12, 99}, {13, 99}, {14, 99}, \n                                      {15, 99}, {16, 99}, {17, 99}, {18, 99}, {19, 99}, {20, 99}, \n                                      {21, 99}, {22, 99}, {23, 99}, {24, 99}, {25, 99}, {26, 99}, \n                                      {27, 99}, {28, 99}, {29, 99}, {30, 99}, {31, 99}, {32, 99}, \n                                      {33, 99}, {34, 99}, {35, 99}, {36, 99}, {37, 99}, {38, 99}, \n                                      {39, 99}, {40, 99}, {41, 99}, {42, 99}, {43, 99}, {44, 99}, \n                                      {45, 99}, {46, 99}, {47, 99}, {48, 99}, {49, 99}, {50, 99}, \n                                      {51, 99}, {52, 99}, {53, 99}, {54, 99}, {55, 99}, {56, 99}, \n                                      {57, 99}, {58, 99}, {59, 99}, {60, 99}, {61, 99}, {62, 99}, \n                                      {63, 99}, {64, 99}, {65, 99}, {66, 99}, {67, 99}, {68, 99}, \n                                      {69, 99}, {70, 99}, {71, 99}, {72, 99}, {73, 99}, {74, 99}, \n                                      {75, 99}, {76, 99}, {77, 99}, {78, 99}, {79, 99}, {80, 99}, \n                                      {81, 99}, {82, 99}, {83, 99}, {84, 99}, {85, 99}, {86, 99}, \n                                      {87, 99}, {88, 99}, {89, 99}, {90, 99}, {91, 99}, {92, 99}, \n                                      {93, 99}, {94, 99}, {95, 99}, {96, 99}, {97, 99}, {98, 99}, \n                                      {99, 99}};\n    \n    vector<int> result1 = shortestDistanceAfterQueries(1, queries1);\n    vector<int> result2 = shortestDistanceAfterQueries(5, queries2);\n    vector<int> result3 = shortestDistanceAfterQueries(5, queries3);\n    vector<int> result4 = shortestDistanceAfterQueries(10, queries4);\n    vector<int> result5 = shortestDistanceAfterQueries(100, queries5);\n\n    for(int res : result1) cout << res << \" \";\n    cout << endl;\n    for(int res : result2) cout << res << \" \";\n    cout << endl;\n    for(int res : result3) cout << res << \" \";\n    cout << endl;\n    for(int res : result4) cout << res << \" \";\n    cout << endl;\n    for(int res : result5) cout << res << \" \";\n    cout << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###winningPlayerCount_Test.java",
        "source_code": "public static int winningPlayerCount(int n, int[][] pick) {\n        int[][] cnts = new int[n][11];\n        for (int[] p : pick) {\n            cnts[p[0]][p[1]]++;\n        }\n        int ans = 0;\n        for (int i = 0; i < n; i++) {\n            for (int c : cnts[i]) {\n                if (c > i) {\n                    ans++;\n                    break;\n                }\n            }\n        }\n        return ans;\n    }",
        "trans_code": "public : int winningPlayerCount ( int n , vector < vector < int >> pick ) {\n  vector < vector < int >> cnts ( n , vector < int > ( 11 , 0 ) ) ;\n  for ( auto p : pick ) cnts [ p [ 0 ] ] [ p [ 1 ] ] ++ ;\n  int ans = 0 ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    for ( auto c : cnts [ i ] ) {\n      if ( c > i ) {\n        ans ++ ;\n        break ;\n      }\n    }\n  }\n  return ans ;\n}\n",
        "reference_code": "int winningPlayerCount(int n, vector<vector<int>>& pick) {\n        vector<array<int, 11>> cnts(n);\n        for (auto& p : pick) {\n            cnts[p[0]][p[1]]++;\n        }\n        int ans = 0;\n        for (int i = 0; i < n; i++) {\n            for (int c : cnts[i]) {\n                if (c > i) {\n                    ans++;\n                    break;\n                }\n            }\n        }\n        return ans;\n    }",
        "target_Lan": "cpp###winningPlayerCount.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <array>\n// TOFILL\nint main() {\n    vector<vector<int>> pick1 = {};\n    cout << winningPlayerCount(0, pick1) << endl;\n\n    vector<vector<int>> pick2 = {{0, 1}, {1, 1}, {2, 2}};\n    cout << winningPlayerCount(3, pick2) << endl;\n\n    vector<vector<int>> pick3 = {{0, 0}, {0, 1}, {1, 1}, {2, 2}};\n    cout << winningPlayerCount(3, pick3) << endl;\n\n    vector<vector<int>> pick4 = {{0, 1}, {0, 2}, {1, 1}, {1, 3}, {2, 1}, {4, 2}};\n    cout << winningPlayerCount(5, pick4) << endl;\n\n    vector<vector<int>> pick5 = {{0, 1}, {1, 2}, {2, 3}, {3, 1}, {3, 5}};\n    cout << winningPlayerCount(4, pick5) << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###minFlips_Test.java",
        "source_code": "    public static int minFlips(int[][] grid) {\n        int m = grid.length;\n        int n = grid[0].length;\n        int diffRow = 0;\n        for (int[] row : grid) {\n            for (int j = 0; j < n / 2; j++) {\n                if (row[j] != row[n - 1 - j]) {\n                    diffRow++;\n                }\n            }\n        }\n        int diffCol = 0;\n        for (int j = 0; j < n; j++) {\n            for (int i = 0; i < m / 2; i++) {\n                if (grid[i][j] != grid[m - 1 - i][j]) {\n                    diffCol++;\n                }\n            }\n        }\n        return Math.min(diffRow, diffCol);\n    }",
        "trans_code": "public : int minFlips ( vector < vector < int >> & grid ) {\n  int m = grid . size ( ) ;\n  int n = grid [ 0 ] . size ( ) ;\n  int diffRow = 0 ;\n  for ( auto row : grid ) {\n    for ( int j = 0 ;\n    j < n / 2 ;\n    j ++ ) {\n      if ( row [ j ] != row [ n - 1 - j ] ) diffRow ++ ;\n    }\n  }\n  int diffCol = 0 ;\n  for ( int j = 0 ;\n  j < n ;\n  j ++ ) {\n    for ( int i = 0 ;\n    i < m / 2 ;\n    i ++ ) {\n      if ( grid [ i ] [ j ] != grid [ m - 1 - i ] [ j ] ) diffCol ++ ;\n    }\n  }\n  return min ( diffRow , diffCol ) ;\n}\n",
        "reference_code": "int minFlips(vector<vector<int>>& grid) {\n        int m = grid.size(), n = grid[0].size();\n        int diff_row = 0;\n        for (auto& row : grid) {\n            for (int j = 0; j < n / 2; j++) {\n                diff_row += row[j] != row[n - 1 - j];\n            }\n        }\n        int diff_col = 0;\n        for (int j = 0; j < n; j++) {\n            for (int i = 0; i < m / 2; i++) {\n                diff_col += grid[i][j] != grid[m - 1 - i][j];\n            }\n        }\n        return min(diff_row, diff_col);\n    }",
        "target_Lan": "cpp###minFlips.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <algorithm>\n// TOFILL\nint main() {\n    vector<vector<int>> grid1 = {{0, 0}, {0, 0}};\n    vector<vector<int>> grid2 = {{0, 1}, {0, 0}};\n    vector<vector<int>> grid3 = {{0, 1}, {0, 1}};\n    vector<vector<int>> grid4 = {{1, 0, 0}, {0, 1, 0}, {0, 0, 1}};\n    \n    cout << minFlips(grid1) << endl; \n    cout << minFlips(grid2) << endl; \n    cout << minFlips(grid3) << endl; \n    cout << minFlips(grid4) << endl; \n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###minFlips_Test.java",
        "source_code": "    public static int minFlips(int[][] a) {\n        int ans = 0;\n        int m = a.length;\n        int n = a[0].length;\n        for (int i = 0; i < m / 2; i++) {\n            for (int j = 0; j < n / 2; j++) {\n                int cnt1 = a[i][j] + a[i][n - 1 - j] + a[m - 1 - i][j] + a[m - 1 - i][n - 1 - j];\n                ans += Math.min(cnt1, 4 - cnt1); \n            }\n        }\n        if (m % 2 > 0 && n % 2 > 0) {\n            \n            ans += a[m / 2][n / 2];\n        }\n        int diff = 0, cnt1 = 0;\n        if (m % 2 > 0) {\n            \n            for (int j = 0; j < n / 2; j++) {\n                if (a[m / 2][j] != a[m / 2][n - 1 - j]) {\n                    diff++;\n                } else {\n                    cnt1 += a[m / 2][j] * 2;\n                }\n            }\n        }\n        if (n % 2 > 0) {\n            \n            for (int i = 0; i < m / 2; i++) {\n                if (a[i][n / 2] != a[m - 1 - i][n / 2]) {\n                    diff++;\n                } else {\n                    cnt1 += a[i][n / 2] * 2;\n                }\n            }\n        }\n        return ans + (diff > 0 ? diff : cnt1 % 4);\n    }",
        "trans_code": "public : int minFlips ( vector < vector < int >> & a ) {\n  int ans = 0 ;\n  int m = a . size ( ) ;\n  int n = a [ 0 ] . size ( ) ;\n  for ( int i = 0 ;\n  i < m / 2 ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < n / 2 ;\n    j ++ ) {\n      int cnt1 = a [ i ] [ j ] + a [ i ] [ n - 1 - j ] + a [ m - 1 - i ] [ j ] + a [ m - 1 - i ] [ n - 1 - j ] ;\n      ans += min ( cnt1 , 4 - cnt1 ) ;\n    }\n  }\n  if ( m % 2 > 0 && n % 2 > 0 ) ans += a [ m / 2 ] [ n / 2 ] ;\n  int diff = 0 , cnt1 = 0 ;\n  if ( m % 2 > 0 ) {\n    for ( int j = 0 ;\n    j < n / 2 ;\n    j ++ ) {\n      if ( a [ m / 2 ] [ j ] != a [ m / 2 ] [ n - 1 - j ] ) diff ++ ;\n      else cnt1 += a [ m / 2 ] [ j ] * 2 ;\n    }\n  }\n  if ( n % 2 > 0 ) {\n    for ( int i = 0 ;\n    i < m / 2 ;\n    i ++ ) {\n      if ( a [ i ] [ n / 2 ] != a [ m - 1 - i ] [ n / 2 ] ) diff ++ ;\n      else cnt1 += a [ i ] [ n / 2 ] * 2 ;\n    }\n  }\n  return ans + ( diff ? diff : cnt1 % 4 ) ;\n}\n",
        "reference_code": "int minFlips(vector<vector<int>>& a) {\n        int m = a.size(), n = a[0].size(), ans = 0;\n        for (int i = 0; i < m / 2; i++) {\n            for (int j = 0; j < n / 2; j++) {\n                int cnt1 = a[i][j] + a[i][n - 1 - j] + a[m - 1 - i][j] + a[m - 1 - i][n - 1 - j];\n                ans += min(cnt1, 4 - cnt1);  \n            }\n        }\n        if (m % 2 && n % 2) {\n            \n            ans += a[m / 2][n / 2];\n        }\n        int diff = 0, cnt1 = 0;\n        if (m % 2) {\n            \n            for (int j = 0; j < n / 2; j++) {\n                if (a[m / 2][j] != a[m / 2][n - 1 - j]) {\n                    diff++;\n                } else {\n                    cnt1 += a[m / 2][j] * 2;\n                }\n            }\n        }\n        if (n % 2) {\n            \n            for (int i = 0; i < m / 2; i++) {\n                if (a[i][n / 2] != a[m - 1 - i][n / 2]) {\n                    diff++;\n                } else {\n                    cnt1 += a[i][n / 2] * 2;\n                }\n            }\n        }\n        return ans + (diff ? diff : cnt1 % 4);\n    }",
        "target_Lan": "cpp###minFlips.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    vector<vector<int>> input1 = {{0}};\n    vector<vector<int>> input2 = {{1, 1}, {1, 0}};\n    vector<vector<int>> input3 = {{0, 1, 0}, {1, 1, 1}, {0, 0, 0}};\n    vector<vector<int>> input4 = {{1, 0}, {0, 1}, {1, 0}};\n    vector<vector<int>> input5 = {{1, 1, 1}, {0, 0, 0}, {1, 1, 1}};\n\n    cout << minFlips(input1) << endl;\n    cout << minFlips(input2) << endl;\n    cout << minFlips(input3) << endl;\n    cout << minFlips(input4) << endl;\n    cout << minFlips(input5) << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###canAliceWin_Test.java",
        "source_code": "public static boolean canAliceWin(int[] nums) {\n        int s = 0;\n        for (int x : nums) {\n            s += x < 10 ? x : -x;\n        }\n        return s != 0;\n    }",
        "trans_code": "public : bool canAliceWin ( vector < int > & nums ) {\n  int s = 0 ;\n  for ( auto x : nums ) s += x < 10 ? x : - x ;\n  return s != 0 ;\n}\n",
        "reference_code": "bool canAliceWin(vector<int>& nums) {\n        int s = 0;\n        for (int x : nums) {\n            s += x < 10 ? x : -x;\n        }\n        return s; \n    }",
        "target_Lan": "cpp###canAliceWin.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    vector<int> input1 = {};\n    vector<int> input2 = {1, 2, 3, 4};\n    vector<int> input3 = {10, 11, 12};\n    vector<int> input4 = {1, 5, 10, 20};\n    vector<int> input5 = {0, 9, 10, 100, -100};\n    \n    cout << canAliceWin(input1) << endl;\n    cout << canAliceWin(input2) << endl;\n    cout << canAliceWin(input3) << endl;\n    cout << canAliceWin(input4) << endl;\n    cout << canAliceWin(input5) << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###numberOfSubstrings_Test.java",
        "source_code": "public static int numberOfSubstrings(String S) {\n        char[] s = S.toCharArray();\n        int n = s.length;\n        int m = 0;\n        int[] a = new int[n + 1];\n        for (int i = 0; i < n; i++) {\n            if (s[i] == '0') {\n                a[m++] = i;\n            }\n        }\n        int tot1 = n - m;\n        a[m] = n; \n        int ans = 0;\n        int i = 0; \n        for (int left = 0; left < n; left++) {\n            if (s[left] == '1') {\n                ans += a[i] - left; \n            }\n            for (int k = i; k < m; k++) {\n                int cnt0 = k - i + 1;\n                if (cnt0 * cnt0 > tot1) {\n                    break;\n                }\n                int cnt1 = a[k] - left - (k - i);\n                ans += Math.max(a[k + 1] - a[k] - Math.max(cnt0 * cnt0 - cnt1, 0), 0);\n            }\n            if (s[left] == '0') {\n                i++; \n            }\n        }\n        return ans;\n    }",
        "trans_code": "public : int numberOfSubstrings ( string S ) {\n  char * s = S . c_str ( ) ;\n  int n = S . size ( ) ;\n  int m = 0 ;\n  int a [ n + 1 ] ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    if ( s [ i ] == '0' ) a [ m ++ ] = i ;\n  }\n  int tot1 = n - m ;\n  a [ m ] = n ;\n  int ans = 0 ;\n  int i = 0 ;\n  for ( int left = 0 ;\n  left < n ;\n  left ++ ) {\n    if ( s [ left ] == '1' ) ans += a [ i ] - left ;\n    for ( int k = i ;\n    k < m ;\n    k ++ ) {\n      int cnt0 = k - i + 1 ;\n      if ( cnt0 * cnt0 > tot1 ) break ;\n      int cnt1 = a [ k ] - left - ( k - i ) ;\n      ans += max ( a [ k + 1 ] - a [ k ] - max ( cnt0 * cnt0 - cnt1 , 0 ) , 0 ) ;\n    }\n    if ( s [ left ] == '0' ) i ++ ;\n  }\n  return ans ;\n}\n",
        "reference_code": "int numberOfSubstrings(string s) {\n        int n = s.length();\n        vector<int> a;\n        for (int i = 0; i < n; i++) {\n            if (s[i] == '0') {\n                a.push_back(i);\n            }\n        }\n        int tot1 = n - a.size();\n        a.push_back(n); \n        int ans = 0, i = 0; \n        for (int left = 0; left < n; left++) {\n            if (s[left] == '1') {\n                ans += a[i] - left; \n            }\n            for (int k = i; k < a.size() - 1; k++) {\n                int cnt0 = k - i + 1;\n                if (cnt0 * cnt0 > tot1) {\n                    break;\n                }\n                int cnt1 = a[k] - left - (k - i);\n                ans += max(a[k + 1] - a[k] - max(cnt0 * cnt0 - cnt1, 0), 0);\n            }\n            if (s[left] == '0') {\n                i++; \n            }\n        }\n        return ans;\n    }",
        "target_Lan": "cpp###numberOfSubstrings.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <string>\n// TOFILL\nint main() {\n    cout << numberOfSubstrings(\"\") << endl;\n    cout << numberOfSubstrings(\"00000\") << endl;\n    cout << numberOfSubstrings(\"11111\") << endl;\n    cout << numberOfSubstrings(\"010101\") << endl;\n    cout << numberOfSubstrings(\"110001\") << endl;\n}"
    },
    {
        "source_Lan": "java###mostFrequent_Test.java",
        "source_code": "public static int mostFrequent(int a[], int n)\n    {\n        HashMap<Integer, Integer> mp = new HashMap<>();\n        for(int i=0;i<n;i++)\n        {\n            if(mp.containsKey(a[i]))\n                mp.put(a[i], mp.get(a[i])+1);\n            else\n                mp.put(a[i],1);\n        }\n        int ans=-1,res=0;\n        for(Entry<Integer,Integer> val : mp.entrySet())\n            res=Math.max(res,val.getValue());\n        for(Entry<Integer,Integer> val : mp.entrySet())\n        {\n            if (val.getValue()==res&&val.getKey()>ans)\n                ans=val.getKey();\n        }\n        return ans;\n    }",
        "trans_code": "public : int mostFrequent ( int a [ ] , int n ) {\n  unordered_map < int , int > mp ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    if ( mp . count ( a [ i ] ) ) {\n      mp [ a [ i ] ] = mp [ a [ i ] ] + 1 ;\n    }\n    else {\n      mp [ a [ i ] ] = 1 ;\n    }\n  }\n  int ans = - 1 , res = 0 ;\n  for ( auto val : mp ) {\n    res = max ( res , val . second ) ;\n  }\n  for ( auto val : mp ) {\n    if ( val . second == res && val . first > ans ) {\n      ans = val . first ;\n    }\n  }\n  return ans ;\n}\n",
        "reference_code": "int mostFrequent(int n, vector<int> &a){\n    map<int,int> m;\n    for(int i:a)m[i]++;\n    int mx=0;\n    for(auto i:m)mx=max(mx,i.second);\n    int ans=-1;\n    for(auto i:m)if(mx==i.second)ans=i.first;\n    return ans;\n}",
        "target_Lan": "cpp###mostFrequent.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <map>\n// TOFILL\nint main() {\n    vector<int> input1; \n    cout << mostFrequent(0, input1) << endl;\n\n    vector<int> input2 = {1}; \n    cout << mostFrequent(1, input2) << endl;\n\n    vector<int> input3 = {1, 2, 3, 4}; \n    cout << mostFrequent(4, input3) << endl;\n\n    vector<int> input4 = {1, 2, 2, 3, 3, 3}; \n    cout << mostFrequent(6, input4) << endl;\n\n    vector<int> input5 = {0, -1, -1, -2, 0, 0}; \n    cout << mostFrequent(6, input5) << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###getMax_Test.java",
        "source_code": "public static int getMax(int x) {\n        \n        boolean flag = false;\n        int prev = -1;\n        int cnt = 0;\n        for (int i = 30; i >= 0; i--) {\n            if (cnt >= 2) break;\n            if (!flag && (x & (1 << i)) > 0) {\n                flag = true;\n                continue;\n            }\n            if (flag) {\n                if ((x & (1 << i)) == 0 && prev == -1) {\n                    prev = i;\n                    x |= (1 << i);\n                    cnt++;\n                }\n                if ((x & (1 << i)) == 0 && prev - i > 1) {\n                    x |= (1 << i);\n                    cnt++;\n                }\n            }\n        }\n        return x;\n    }",
        "trans_code": "int getMax ( int x ) {\n  bool flag = false ;\n  int prev = - 1 ;\n  int cnt = 0 ;\n  for ( int i = 30 ;\n  i >= 0 ;\n  i -- ) {\n    if ( cnt >= 2 ) break ;\n    if ( ! flag && ( x & ( 1 << i ) ) > 0 ) {\n      flag = true ;\n      continue ;\n    }\n    if ( flag ) {\n      if ( ( x & ( 1 << i ) ) == 0 && prev == - 1 ) {\n        prev = i ;\n        x |= ( 1 << i ) ;\n        cnt ++ ;\n      }\n      if ( ( x & ( 1 << i ) ) == 0 && prev - i > 1 ) {\n        x |= ( 1 << i ) ;\n        cnt ++ ;\n      }\n    }\n  }\n  return x ;\n}\n",
        "reference_code": "    int getMax(int x) {\n        \n        bool flag = false;\n        int prev = -1;\n        int cnt = 0;\n        for (int i = 30; i >= 0; i--) {\n            if (cnt >= 2)\n                break;\n            if (flag == false and (x & (1 << i)) > 0) {\n                flag = true;\n                continue;\n            }\n            if (flag) {\n                if ((x & (1 << i)) == 0 and prev == -1) {\n                    prev = i;\n                    x |= (1 << i);\n                    cnt++;\n                }\n                if ((x & (1 << i)) == 0 and prev - i > 1) {\n                    x |= (1 << i);\n                    cnt++;\n                }\n            }\n        }\n        return x;\n    }",
        "target_Lan": "cpp###getMax.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n// TOFILL\nint main() {\n    cout << getMax(0) << endl;\n    cout << getMax(5) << endl;\n    cout << getMax(1073741824) << endl;\n    cout << getMax(65535) << endl;\n    cout << getMax(2147483647) << endl;\n}"
    },
    {
        "source_Lan": "java###getCount_Test.java",
        "source_code": "    public static long getCount(int n, int[] arr, int a, int b) {\n        \n        int ans = 0;\n        for (int i = 0; i < n; i++) {\n            for (int j = i; j < n; j++) {\n                boolean flag = false;\n                for (int k = i; k <= j; k++) {\n                    for (int l = k + 1; l <= j; l++) {\n                        if (arr[k] + arr[l] < a || arr[k] + arr[l] > b) {\n                            flag = true;\n                        }\n                    }\n                }\n                if (!flag) ans++;\n            }\n        }\n        return ans;\n    }",
        "trans_code": "long long getCount ( int n , int * arr , int a , int b ) {\n  int ans = 0 ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    for ( int j = i ;\n    j < n ;\n    j ++ ) {\n      bool flag = false ;\n      for ( int k = i ;\n      k <= j ;\n      k ++ ) {\n        for ( int l = k + 1 ;\n        l <= j ;\n        l ++ ) {\n          if ( arr [ k ] + arr [ l ] < a || arr [ k ] + arr [ l ] > b ) flag = true ;\n        }\n      }\n      if ( ! flag ) ans ++ ;\n    }\n  }\n  return ans ;\n}\n",
        "reference_code": "long long getCount(int n, vector<int> &arr, int a, int b) {\n        \n        int ans=0;\n        for(int i=0;i<n;i++){\n            for(int j=i;j<n;j++){\n                bool flag=false;\n                for(int k=i;k<=j;k++){\n                    for(int l=k+1;l<=j;l++){\n                        if(arr[k]+arr[l]<a || arr[k]+arr[l]>b)\n                        flag=true;\n                    }\n                }\n                if(flag==false)  ans++;\n            }\n        }\n        return ans;\n    }",
        "target_Lan": "cpp###getCount.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    vector<int> arr1 = {1, 2, 3, 4, 5};\n    vector<int> arr2 = {2, 3, 5, 7, 11};\n    vector<int> arr3 = {5, 5, 5, 5};\n    vector<int> arr4 = {};\n    vector<int> arr5 = {-1, 2, -3, 4, 5};\n    \n    cout << getCount(5, arr1, 3, 10) << endl;\n    cout << getCount(5, arr2, 1, 10) << endl;\n    cout << getCount(4, arr3, 10, 20) << endl;\n    cout << getCount(0, arr4, 5, 15) << endl;\n    cout << getCount(5, arr5, -5, 8) << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###minSwaps_Test.java",
        "source_code": "public static int minSwaps(String S) {\n        int evenSum = 0, oddSum = 0;\n        int n = S.length();\n        \n        for (int i = 0; i < n; i++) {\n            if (i % 2 == 1)\n                oddSum += (S.charAt(i) == '1') ? 1 : 0;\n            else\n                evenSum += (S.charAt(i) == '1') ? 1 : 0;\n        }\n        \n        int difference = Math.abs(oddSum - evenSum);\n        \n        if (difference % 2 == 1) return -1;\n        \n        return difference / 2;\n    }",
        "trans_code": "public : int minSwaps ( string S ) {\n  int evenSum = 0 , oddSum = 0 ;\n  int n = S . size ( ) ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    if ( i % 2 == 1 ) {\n      oddSum += ( S [ i ] == '1' ) ? 1 : 0 ;\n    }\n    else {\n      evenSum += ( S [ i ] == '1' ) ? 1 : 0 ;\n    }\n  }\n  int difference = abs ( oddSum - evenSum ) ;\n  if ( difference % 2 == 1 ) return - 1 ;\n  return difference / 2 ;\n}\n",
        "reference_code": "int minSwaps(string S) {\n        int evenSum = 0, oddSum = 0;\n        int n = S.size();\n        \n        for (int i = 0; i < n; i++) {\n            if (i & 1)\n                oddSum += (S[i] == '1');\n            else\n                evenSum += (S[i] == '1');\n        }\n        \n        int difference = abs(oddSum - evenSum);\n        \n        if (difference & 1)\n            return -1;\n        \n        return difference / 2;\n    }",
        "target_Lan": "cpp###minSwaps.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <string>\n#include <cstdlib>\n// TOFILL\nint main() {\n    cout << minSwaps(\"\") << endl;        \n    cout << minSwaps(\"1010\") << endl;    \n    cout << minSwaps(\"1110\") << endl;    \n    cout << minSwaps(\"1100\") << endl;    \n    cout << minSwaps(\"010101\") << endl;  \n}"
    },
    {
        "source_Lan": "java###countUniques_Test.java",
        "source_code": "public static int countUniques(int[] a, int k, int l, int r) {\n        Set<Integer> set = new HashSet<>();\n        int dup = 0;\n        for(int i : a) if(!set.add(i)) dup++;\n        int unique = set.size();\n        for(int i = l ; i <= r ; i++)\n            if(k>0 && dup>0 && !set.contains(i)){\n                unique++; k--; dup--;\n            }\n        return unique;\n    }",
        "trans_code": "public : int countUniques ( vector < int > a , int k , int l , int r ) {\n  set < int > set ;\n  int dup = 0 ;\n  for ( int i : a ) if ( ! set . insert ( i ) . second ) dup ++ ;\n  int unique = set . size ( ) ;\n  for ( int i = l ;\n  i <= r ;\n  i ++ ) if ( k > 0 && dup > 0 && ! set . insert ( i ) . second ) {\n    unique ++ ;\n    k -- ;\n    dup -- ;\n  }\n  return unique ;\n}\n",
        "reference_code": "int countUniques(vector<int> a, int k, int l, int r) {\n        \n        unordered_set<int> set;\n        int dup = 0;\n        for (int i : a) {\n            if (!set.insert(i).second) {\n                dup++;\n            }\n        }\n        int unique = set.size();\n        for (int i = l; i <= r; i++) {\n            if (k > 0 && dup > 0 && set.find(i) == set.end()) {\n                unique++;\n                k--;\n                dup--;\n            }\n        }\n        return unique;\n    }",
        "target_Lan": "cpp###countUniques.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <unordered_set>\n// TOFILL\nint main() {\n    cout << countUniques({}, 2, 3, 5) << endl;\n    cout << countUniques({1, 2, 3}, 0, 1, 3) << endl;\n    cout << countUniques({1, 2, 2, 3, 3, 3}, 2, 1, 4) << endl;\n    cout << countUniques({5, 5, 5, 5}, 1, 0, 2) << endl;\n    cout << countUniques({1, 2, 3, 2, 1, 4}, 3, 1, 5) << endl;\n}"
    },
    {
        "source_Lan": "java###maxLength_Test.java",
        "source_code": "public static int maxLength(int N, int[] arr) {\n        int ans = 0;\n        for(int i = 0 ; i < N; i++){\n            int or = 0;\n            for(int j = i ; j < N; j++){\n                or = or | arr[j];\n                int x = Integer.bitCount(or);\n                if(x == Integer.toBinaryString(or).length()){\n                    ans = Math.max(ans , j - i + 1);\n                }\n            }\n        }\n        return ans;\n    }",
        "trans_code": "public : int maxLength ( int N , vector < int > arr ) {\n  int ans = 0 ;\n  for ( int i = 0 ;\n  i < N ;\n  i ++ ) {\n    int or = 0 ;\n    for ( int j = i ;\n    j < N ;\n    j ++ ) {\n      or = or | arr [ j ] ;\n      int x = int ( or ) ;\n      if ( x == int ( or ) ) ans = max ( ans , j - i + 1 ) ;\n    }\n  }\n  return ans ;\n}\n",
        "reference_code": "int maxLength(vector<int> arr) {\n        \n        int ans = 0;\n        int N = arr.size();\n        for (int i = 0; i < N; i++) {\n            int or_val = 0;\n            for (int j = i; j < N; j++) {\n                or_val = or_val | arr[j];\n                int x = __builtin_popcount(or_val);\n                if (x == (int)log2(or_val) + 1) {\n                    ans = max(ans, j - i + 1);\n                }\n            }\n        }\n        return ans;\n    }",
        "target_Lan": "cpp###maxLength.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n// TOFILL\nint main() {\n    cout << maxLength({}) << endl; \n    cout << maxLength({0, 0, 0, 0}) << endl; \n    cout << maxLength({1, 2, 3, 4}) << endl; \n    cout << maxLength({7, 7, 7, 7}) << endl; \n    cout << maxLength({15, 31, 63, 127}) << endl; \n}"
    },
    {
        "source_Lan": "java###firstWord_Test.java",
        "source_code": "public static String firstWord(int n, String[] dictionary) {\n        \n        Arrays.sort(dictionary);\n        Set<String> seenWords = new HashSet<>();\n        for (String word : dictionary) {\n            if (seenWords.contains(word)) {\n                return \"Invalid\";\n            }\n            seenWords.add(word);\n        }\n        return dictionary[0];\n    }",
        "trans_code": "public : string firstWord ( int n , vector < string > & dictionary ) {\n  sort ( dictionary . begin ( ) , dictionary . end ( ) ) ;\n  set < string > seenWords ;\n  for ( auto word : dictionary ) {\n    if ( seenWords . find ( word ) != seenWords . end ( ) ) {\n      return \"Invalid\" ;\n    }\n    seenWords . insert ( word ) ;\n  }\n  return dictionary [ 0 ] ;\n}\n",
        "reference_code": "string firstWord(int n, vector<string> &dictionary) {\n        \n        sort(dictionary.begin(), dictionary.end());\n        for(int i=0;i<n;i++) {\n            for(int j=i+1;j<n;j++) {\n                if(dictionary[i]==dictionary[j]){\n                    return \"Invalid\";\n                }\n            }\n        }\n        return dictionary[0];\n    }",
        "target_Lan": "cpp###firstWord.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n// TOFILL\nint main() {\n    vector<string> dict1 = {\"apple\"};\n    cout << firstWord(1, dict1) << endl;\n\n    vector<string> dict2 = {\"banana\", \"apple\", \"cherry\", \"dragonfruit\", \"elderberry\"};\n    cout << firstWord(5, dict2) << endl;\n\n    vector<string> dict3 = {\"grape\", \"apple\", \"grape\"};\n    cout << firstWord(3, dict3) << endl;\n\n    vector<string> dict4 = {\"kiwi\", \"banana\", \"Apple\", \"banana\"};\n    cout << firstWord(4, dict4) << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###longestSubarray_Test.java",
        "source_code": "public static int longestSubarray(int n, int[] arr) {\n        int ans = -1;\n        for (int i = 0; i < n; i++) {\n            int count = 0;\n            int sum = 0;\n            for (int j = i; j < n; j++) {\n                count++;\n                sum += arr[j];\n                if (count == sum) {\n                    ans = Math.max(ans, count);\n                }\n            }\n        }\n        return ans;\n    }",
        "trans_code": "public : int longestSubarray ( int n , vector < int > arr ) {\n  int ans = - 1 ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    int count = 0 ;\n    int sum = 0 ;\n    for ( int j = i ;\n    j < n ;\n    j ++ ) {\n      count ++ ;\n      sum += arr [ j ] ;\n      if ( count == sum ) ans = max ( ans , count ) ;\n    }\n  }\n  return ans ;\n}\n",
        "reference_code": "int longestSubarray(int n, vector<int> &arr) {\n        \n        int ans=-1;\n        for(int i=0;i<n;i++){\n            int count=0;\n            int sum=0;\n            for(int j=i;j<n;j++) {\n                count++;\n                sum += arr[j];\n                if(count == sum){\n                    ans = max(ans, count);\n                }\n            }\n        }\n        return ans;\n    }",
        "target_Lan": "cpp###longestSubarray.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    \n    vector<int> arr1 = {};\n    cout << longestSubarray(0, arr1) << endl;\n\n    \n    vector<int> arr2 = {1, 2, 3, 4, 5};\n    cout << longestSubarray(5, arr2) << endl;\n\n    \n    vector<int> arr3 = {0, 0, 0, 0};\n    cout << longestSubarray(4, arr3) << endl;\n\n    \n    vector<int> arr4 = {1, 1, 1, 1, 1, 5};\n    cout << longestSubarray(6, arr4) << endl;\n\n    \n    vector<int> arr5 = {5, 1, 1, 1, 1};\n    cout << longestSubarray(5, arr5) << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###minDifference_Test.java",
        "source_code": "public static int minDifference(int n, int[] arr, int x) {\n        int ans = n + 1;\n        for (int i = 0; i < n - 1; i++) {\n            for (int j = i + 1; j < n; j++) {\n                if ((arr[i] ^ arr[j]) <= x) {\n                    ans = Math.min(ans, j - i);\n                }\n            }\n        }\n        return (ans == n + 1) ? -1 : ans;\n    }",
        "trans_code": "public : int minDifference ( int n , int arr [ ] , int x ) {\n  int ans = n + 1 ;\n  for ( int i = 0 ;\n  i < n - 1 ;\n  i ++ ) {\n    for ( int j = i + 1 ;\n    j < n ;\n    j ++ ) {\n      if ( ( arr [ i ] ^ arr [ j ] ) <= x ) ans = min ( ans , j - i ) ;\n    }\n  }\n  return ( ans == n + 1 ) ? - 1 : ans ;\n}\n",
        "reference_code": "int minDifference(int n, vector<int> &arr, int x) {\n        \n        int ans=n+1;\n        for(int i=0;i<n-1;i++){\n            for(int j=i+1;j<n;j++){\n                if((arr[i]^arr[j]) <= x){\n                    ans = min(ans, j-i);\n                }\n            }\n        }\n        return (ans == n+1 ? -1 : ans);\n    }",
        "target_Lan": "cpp###minDifference.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <algorithm>\n// TOFILL\nint main() {\n    vector<int> arr1 = {3, 5, 6, 1};\n    cout << minDifference(4, arr1, 4) << endl;\n\n    vector<int> arr2 = {1, 2, 8, 4, 3};\n    cout << minDifference(5, arr2, 3) << endl;\n\n    vector<int> arr3 = {7, -2, 4};\n    cout << minDifference(3, arr3, 5) << endl;\n\n    vector<int> arr4 = {0, 0};\n    cout << minDifference(2, arr4, 0) << endl;\n\n    vector<int> arr5 = {1000000000};\n    cout << minDifference(1, arr5, 0) << endl;\n\n    return 0;\n}"
    },
    {
        "source_Lan": "java###reachAlice_Test.java",
        "source_code": "public static String reachAlice(int d, int x, int y, int k) {\n        int p = d / x;\n        int q = d / y;\n        q += k;\n        return (p <= q) ? \"Walk\" : \"Bike\";\n    }",
        "trans_code": "string reach_alice ( int d , int x , int y , int k ) {\n  int p = d / x ;\n  int q = d / y ;\n  q += k ;\n  return ( p <= q ) ? \"Walk\" : \"Bike\" ;\n}\n",
        "reference_code": "string reachAlice(int d, int x, int y, int k) {\n        int t1 = d / x;\n        int t2 = d / y + k;\n        if (t1 <= t2)\n            return \"Walk\";\n        return \"Bike\";\n    }",
        "target_Lan": "cpp###reachAlice.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <limits>\n// TOFILL\nint main() {\n    cout << reachAlice(0, 1, 1, 1) << endl;\n    cout << reachAlice(10, 2, 5, 0) << endl;\n    cout << reachAlice(10, 5, 2, 0) << endl;\n    cout << reachAlice(10, 5, 5, 0) << endl;\n    cout << reachAlice(numeric_limits<int>::max(), 1, 1, numeric_limits<int>::max()) << endl;\n}"
    },
    {
        "source_Lan": "java###removeOrder_Test.java",
        "source_code": "public static int[] removeOrder(int n, int[] arr, String str) {\n        Arrays.sort(arr);\n        int i = 0, j = n - 1;\n        int[] ans = new int[n];\n        int idx = 0;\n        for (char ch : str.toCharArray()) {\n            if (ch == '0')\n                ans[idx++] = arr[i++];\n            else\n                ans[idx++] = arr[j--];\n        }\n        return ans;\n    }",
        "trans_code": "public : vector < int > removeOrder ( int n , vector < int > arr , string str ) {\n  sort ( arr . begin ( ) , arr . end ( ) ) ;\n  int i = 0 , j = n - 1 ;\n  vector < int > ans ( n , 0 ) ;\n  int idx = 0 ;\n  for ( char ch : str ) {\n    if ( ch == '0' ) {\n      ans [ idx ++ ] = arr [ i ++ ] ;\n    }\n    else {\n      ans [ idx ++ ] = arr [ j -- ] ;\n    }\n  }\n  return ans ;\n}\n",
        "reference_code": "vector<int> removeOrder(int n, vector<int> &arr, string str) {\n        sort(arr.begin(), arr.end());\n        int i = 0, j = n - 1;\n        vector<int> ans(n);\n        for (int k = 0; k < n; k++) {\n            if (str[k] == '0')\n                ans[k] = arr[i++];\n            else\n                ans[k] = arr[j--];\n        }\n        return ans;\n    }",
        "target_Lan": "cpp###removeOrder.cpp",
        "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <algorithm>\n// TOFILL\nint main() {\n    vector<int> arr1 = {5, 3, 1, 4, 2};\n    string str1 = \"01010\";\n    vector<int> result1 = removeOrder(5, arr1, str1);\n    for(int x : result1) cout << x << \" \";\n    cout << endl;\n\n    vector<int> arr2 = {};\n    string str2 = \"\";\n    vector<int> result2 = removeOrder(0, arr2, str2);\n    for(int x : result2) cout << x << \" \";\n    cout << endl;\n\n    vector<int> arr3 = {7, 8, 9, 10};\n    string str3 = \"0000\";\n    vector<int> result3 = removeOrder(4, arr3, str3);\n    for(int x : result3) cout << x << \" \";\n    cout << endl;\n\n    vector<int> arr4 = {1, 2, 3};\n    string str4 = \"111\";\n    vector<int> result4 = removeOrder(3, arr4, str4);\n    for(int x : result4) cout << x << \" \";\n    cout << endl;\n\n    vector<int> arr5 = {6, 5, 4, 3, 2, 1};\n    string str5 = \"001100\";\n    vector<int> result5 = removeOrder(6, arr5, str5);\n    for(int x : result5) cout << x << \" \";\n    cout << endl;\n\n    return 0;\n}"
    }
]