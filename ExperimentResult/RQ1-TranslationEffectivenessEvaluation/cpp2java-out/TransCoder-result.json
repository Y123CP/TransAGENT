[{"source_Lan": "cpp###ANDequalOR.cpp", "source_code": "    long long ANDequalOR(int n, vector<int> arr) {\n        long long ans = 0;\n        for (int i = 0; i < n; i++) {\n            int pt = i;\n            long long ct = 0;\n            while (pt < n) {\n                if (arr[pt] == arr[i]) {\n                    pt++;\n                    ct++;\n                } else\n                    break;\n            }\n            ct *= (ct + 1);\n            ct /= 2;\n            ans += ct;\n            i = pt - 1;\n        }\n        return ans;\n    }", "trans_code": "public static long ANDequalOR ( int n , int [ ] arr ) {\n  long ans = 0 ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    int pt = i ;\n    long ct = 0 ;\n    while ( pt < n ) {\n      if ( arr [ pt ] == arr [ i ] ) {\n        pt ++ ;\n        ct ++ ;\n      }\n      else {\n        break ;\n      }\n    }\n    ct *= ( ct + 1 ) ;\n    ct /= 2 ;\n    ans += ct ;\n    i = pt - 1 ;\n  }\n  return ans ;\n}\n", "reference_code": "    public static long ANDequalOR(int n, int[] arr) {\n        long ans = 0;\n        int pre = 0;\n        long count = 0;\n        for (int i = 0; i < n; i++) {\n            if (arr[i] == arr[pre]) {\n                count++;\n            } else {\n                ans += (count * (count + 1)) / 2;\n                pre = i;\n                count = 1;\n            }\n        }\n        ans += (count * (count + 1)) / 2;\n        return ans;\n    }", "target_Lan": "java###ANDequalOR_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\n\npublic class ANDequalOR_Test {\n// TOFILL\npublic static void main(String[] args) {\n    int[] arr1 = {};\n    int[] arr2 = {1};\n    int[] arr3 = {1, 1};\n    int[] arr4 = {1, 2, 1};\n    int[] arr5 = {1, 1, 2, 2, 2};\n\n    System.out.println(ANDequalOR(0, arr1)); // Output: 0\n    System.out.println(ANDequalOR(1, arr2)); // Output: 1\n    System.out.println(ANDequalOR(2, arr3)); // Output: 3\n    System.out.println(ANDequalOR(3, arr4)); // Output: 4\n    System.out.println(ANDequalOR(5, arr5)); // Output: 10\n}\n}"}, {"source_Lan": "cpp###MinSize.cpp", "source_code": "    int MinSize(vector<int> A, int n) {\n        \n        \n        int curr = A[0];\n        int count = 1;\n        for (int i = 1; i < n; ++i) {\n            if (A[i] == curr) {\n                count += 1;\n            } else {\n                count -= 1;\n                if (count == 0) {\n                    curr = A[i];\n                    count = 1;\n                }\n            }\n        }\n        int max_f = 0;\n        for (int i = 0; i < n; i++)\n            if (curr == A[i])\n                max_f++;\n        if (max_f <= (n + 1) / 2) {\n            return n & 1;\n        } else {\n            return 2 * max_f - n;\n        }\n    }", "trans_code": "public static int MinSize ( int [ ] A , int n ) {\n  int curr = A [ 0 ] ;\n  int count = 1 ;\n  for ( int i = 1 ;\n  i < n ;\n  ++ i ) {\n    if ( A [ i ] == curr ) {\n      count += 1 ;\n    }\n    else {\n      count -= 1 ;\n      if ( count == 0 ) {\n        curr = A [ i ] ;\n        count = 1 ;\n      }\n    }\n  }\n  int max_f = 0 ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) if ( curr == A [ i ] ) max_f ++ ;\n  if ( max_f <= ( n + 1 ) / 2 ) return n & 1 ;\n  else return 2 * max_f - n ;\n}\n", "reference_code": "    public static int MinSize(int[] A,int n) {\n        \n        \n        int curr = A[0];\n        int count = 1;\n        for (int i = 1; i < n; ++i) {\n            if (A[i] == curr) {\n                count += 1;\n            } else {\n                count -= 1;\n                if (count == 0) {\n                    curr = A[i];\n                    count = 1;\n                }\n            }\n        }\n        int max_f = 0;\n        for (int i = 0; i < n; i++) {\n            if (curr == A[i]) {\n                max_f++;\n            }\n        }\n        if (max_f <= (n + 1) / 2) {\n            return n & 1;\n        } else {\n            return 2 * max_f - n;\n        }\n    }", "target_Lan": "java###MinSize_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.Arrays;\npublic class MinSize_Test {\n// TOFILL\n    public static void main(String[] args) {\n        System.out.println(MinSize(new int[]{1}, 1));\n        System.out.println(MinSize(new int[]{1,1,2,2,3,3,3,3}, 8));\n        System.out.println(MinSize(new int[]{1,2,3,4,5,6,7,8,9,10}, 10));\n        System.out.println(MinSize(new int[]{1,1,1,2,2,2,2,3,3,3}, 10));\n        System.out.println(MinSize(new int[]{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20}, 20));\n    }\n}"}, {"source_Lan": "cpp###timeTravel.cpp", "source_code": "    int timeTravel(int n, vector<int> &arr) {\n        int ans = 0;\n        for(int i = 1; i < n; i++)\n            ans += (arr[i] > arr[i - 1] ? 1 : (arr[i] < arr[i - 1] ? 2 : 0));\n        return ans;\n    }", "trans_code": "public static int timeTravel ( int n , int [ ] arr ) {\n  int ans = 0 ;\n  for ( int i = 1 ;\n  i < n ;\n  i ++ ) {\n    ans += ( arr [ i ] > arr [ i - 1 ] ? 1 : ( arr [ i ] < arr [ i - 1 ] ? 2 : 0 ) ) ;\n  }\n  return ans ;\n}\n", "reference_code": "    public static int timeTravel(int n, int[] arr) {\n        int ans = 0;\n        for(int i = 1; i < n; i++)\n            ans += (arr[i] > arr[i - 1] ? 1 : (arr[i] < arr[i - 1] ? 2 : 0));\n        return ans;\n    }", "target_Lan": "java###timeTravel_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\n\npublic class timeTravel_Test {\n// TOFILL\npublic static void main(String[] args) {\n    int[] arr1 = {};\n    System.out.println(timeTravel(0, arr1));\n\n    int[] arr2 = {10};\n    System.out.println(timeTravel(1, arr2));\n\n    int[] arr3 = {10, 20};\n    System.out.println(timeTravel(2, arr3));\n\n    int[] arr4 = {20, 10};\n    System.out.println(timeTravel(2, arr4));\n\n    int[] arr5 = {10, 10, 10};\n    System.out.println(timeTravel(3, arr5));\n}\n}"}, {"source_Lan": "cpp###lastFairyStanding.cpp", "source_code": "    int lastFairyStanding(int n, int k) {\n        \n        int i = 1, ans = 0;\n        while (i <= n)\n            ans = (ans + k) % i++;\n        return ans + 1;\n    }", "trans_code": "public static int lastFairyStanding ( int n , int k ) {\n  int i = 1 , ans = 0 ;\n  while ( i <= n ) {\n    ans = ( ans + k ) % i ++ ;\n  }\n  return ans + 1 ;\n}\n", "reference_code": "    public static int lastFairyStanding(int n, int k) {\n        int i = 1, ans = 0;\n        while (i <= n)\n            ans = (ans + k) % i++;\n        return ans + 1;\n    }", "target_Lan": "java###lastFairyStanding_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\n\npublic class lastFairyStanding_Test {\n// TOFILL\n    public static void main(String[] args) {\n        System.out.println(lastFairyStanding(0, 0));\n        System.out.println(lastFairyStanding((int)1e6, 1));\n        System.out.println(lastFairyStanding(-1, 5));\n        System.out.println(lastFairyStanding(10, 10));\n        System.out.println(lastFairyStanding(5, 1));\n    }\n}"}, {"source_Lan": "cpp###equality.cpp", "source_code": "    int equality(int A, int B) {\n        if (B<A) return 0;\n        if (A==B) return 1;\n        if (B%2==0) return 1;\n        return 0;\n    }", "trans_code": "public static int equality ( int A , int B ) {\n  if ( B < A ) return 0 ;\n  if ( A == B ) return 1 ;\n  if ( B % 2 == 0 ) return 1 ;\n  return 0 ;\n}\n", "reference_code": "    public static int equality(int A, int B) {\n        \n        if (B < A) return 0;\n        \n        if (A == B) return 1;\n        \n        if (B % 2 == 0) return 1;\n        \n        return 0;\n    }", "target_Lan": "java###equality_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\n\npublic class equality_Test {\n// TOFILL\n    public static void main(String[] args) {\n        System.out.println(equality(0, 0));\n        System.out.println(equality(100, 100));\n        System.out.println(equality(-1, -1));\n        System.out.println(equality(10, 11));\n        System.out.println(equality(5, 3));\n    }\n}"}, {"source_Lan": "cpp###isMagicArray.cpp", "source_code": "    bool isMagicArray(int n, vector<int> &arr) {\n        for (int i=1;i<n;i++){\n            if ((arr[i]%2==0 && arr[i-1]%2==0) || (arr[i]%2!=0 && arr[i-1]%2!=0)) return 0;\n        }\n        return 1;\n    }", "trans_code": "public static boolean isMagicArray ( int n , int [ ] arr ) {\n  for ( int i = 1 ;\n  i < n ;\n  i ++ ) {\n    if ( ( arr [ i ] % 2 == 0 && arr [ i - 1 ] % 2 == 0 ) || ( arr [ i ] % 2 != 0 && arr [ i - 1 ] % 2 != 0 ) ) {\n      return 0 ;\n    }\n  }\n  return 1 ;\n}\n", "reference_code": "    public static boolean isMagicArray(int n, int[] arr) {\n        \n        for (int i = 1; i < n; i++) {\n            \n            if ((arr[i] % 2 == 0 && arr[i - 1] % 2 == 0) || (arr[i] % 2 != 0 && arr[i - 1] % 2 != 0)) {\n                return false;\n            }\n        }\n        \n        return true;\n    }", "target_Lan": "java###isMagicArray_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\n\npublic class isMagicArray_Test {\n// TOFILL\n    public static void main(String[] args) {\n        System.out.println(isMagicArray(3, new int[]{1,2,3}));\n        System.out.println(isMagicArray(4, new int[]{2,4,6,8}));\n        System.out.println(isMagicArray(3, new int[]{1,1,1}));\n        System.out.println(isMagicArray(5, new int[]{2,4,1,3,5}));\n        System.out.println(isMagicArray(4, new int[]{1,2,3,4}));\n    }\n}"}, {"source_Lan": "cpp###smallestString.cpp", "source_code": "    string smallestString(int n, string s) {\n        string answer = s;\n        int odd = n%2;\n        if(n == 1){\n            return \"-1\";\n        }\n        for(int i = 0; i < (n/2); i ++){\n            if(s[i] != 'a'){\n                answer[i] = 'a';\n                return answer;\n            }\n        }\n        answer[answer.size() - 1] = 'b';\n        return answer;\n    }", "trans_code": "public static String smallestString ( int n , String s ) {\n  String answer = s ;\n  int odd = n % 2 ;\n  if ( n == 1 ) {\n    return \"-1\" ;\n  }\n  for ( int i = 0 ;\n  i < ( n / 2 ) ;\n  i ++ ) {\n    if ( s . charAt ( i ) != 'a' ) {\n      answer . charAt ( i ) = 'a' ;\n      return answer ;\n    }\n  }\n  answer . charAt ( answer . length ( ) - 1 ) = 'b' ;\n  return answer ;\n}\n", "reference_code": "    public static String smallestString(int n, String s) {\n        \n        StringBuilder answer = new StringBuilder(s);\n        int odd = n % 2; \n        if (n == 1) {\n            return \"-1\"; \n        }\n        for (int i = 0; i < n / 2; i++) {\n            if (s.charAt(i) != 'a') {\n                answer.setCharAt(i, 'a'); \n                return answer.toString(); \n            }\n        }\n        answer.setCharAt(answer.length() - 1, 'b'); \n        return answer.toString(); \n    }", "target_Lan": "java###smallestString_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\n\npublic class smallestString_Test {\n// TOFILL\npublic static void main(String[] args) {\n    System.out.println(smallestString(2, \"aa\"));\n    System.out.println(smallestString(3, \"baa\"));\n    System.out.println(smallestString(4, \"aaaa\"));\n    System.out.println(smallestString(5, \"baaaa\"));\n    System.out.println(smallestString(1, \"a\"));\n}\n}"}, {"source_Lan": "cpp###AreEqual.cpp", "source_code": "    bool AreEqual(string a, string b) {\n        int n = a.length();\n        bool flag = false;\n        for (int i = 0; i < n - 1; i++) {\n            if (a[i] == '0' && b[i + 1] == '1') {\n                if (a[i] == b[i] && a[i + 1] == b[i + 1]) {\n                    flag = true;\n                }\n            }\n        }\n        return flag;\n    }", "trans_code": "public static boolean areEqual ( String a , String b ) {\n  int n = a . length ( ) ;\n  boolean flag = false ;\n  for ( int i = 0 ;\n  i < n - 1 ;\n  i ++ ) {\n    if ( a . charAt ( i ) == '0' && b . charAt ( i + 1 ) == '1' ) {\n      if ( a . charAt ( i ) == b . charAt ( i ) && a . charAt ( i + 1 ) == b . charAt ( i + 1 ) ) {\n        flag = true ;\n      }\n    }\n  }\n  return flag ;\n}\n", "reference_code": "    public static boolean AreEqual(String a, String b) {\n        int n = a.length();\n        boolean flag = false;\n        for (int i = 0; i < n - 1; i++) {\n            if (a.charAt(i) == '0' && b.charAt(i + 1) == '1') {\n                if (a.charAt(i) == b.charAt(i) && a.charAt(i + 1) == b.charAt(i + 1)) {\n                    flag = true;\n                }\n            }\n        }\n        return flag;\n    }", "target_Lan": "java###AreEqual_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\n\npublic class AreEqual_Test {\n// TOFILL\npublic static void main(String[] args) {\n    System.out.println(AreEqual(\"01\", \"10\"));\n    System.out.println(AreEqual(\"101\", \"010\"));\n    System.out.println(AreEqual(\"0000\", \"0000\"));\n    System.out.println(AreEqual(\"1111\", \"1111\"));\n    System.out.println(AreEqual(\"\", \"\"));\n}\n}"}, {"source_Lan": "cpp###matrixConundrum.cpp", "source_code": "    bool matrixConundrum(int n, int m, vector<string> &mat) {\n        string play = \"play\";\n        int fnd = 0;\n        for (int i = 0; i < m; ++i) {\n            bool check = false;\n            for (int j = 0; j < n; ++j) {\n                if (mat[j][i] == play[fnd]) {\n                    check = true;\n                }\n            }\n            if (check) {\n                ++fnd;\n                if (fnd == 4) {\n                    break;\n                }\n            }\n        }\n        if (fnd == 4)\n            return true;\n        return false;\n    }", "trans_code": "public static boolean matrixConundrum ( int n , int m , String [ ] [ ] mat ) {\n  String play = \"play\" ;\n  int fnd = 0 ;\n  for ( int i = 0 ;\n  i < m ;\n  ++ i ) {\n    boolean check = false ;\n    for ( int j = 0 ;\n    j < n ;\n    ++ j ) {\n      if ( mat [ j ] [ i ] . equals ( play . charAt ( fnd ) ) ) check = true ;\n    }\n    if ( check ) {\n      ++ fnd ;\n      if ( fnd == 4 ) break ;\n    }\n  }\n  if ( fnd == 4 ) return true ;\n  return false ;\n}\n", "reference_code": "    public static boolean matrixConundrum(int n, int m, List<String> mat) {\n        String play = \"play\";\n        int fnd = 0;\n        for (int i = 0; i < m; ++i) {\n            boolean check = false;\n            for (int j = 0; j < n; ++j) {\n                if (mat.get(j).charAt(i) == play.charAt(fnd)) {\n                    check = true;\n                }\n            }\n            if (check) {\n                ++fnd;\n                if (fnd == 4) {\n                    break;\n                }\n            }\n        }\n        return fnd == 4;\n    }", "target_Lan": "java###matrixConundrum_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.Arrays;\nimport java.util.List;\npublic class matrixConundrum_Test {\n// TOFILL\n    public static void main(String[] args) {\n        System.out.println(matrixConundrum(4, 5, Arrays.asList(\"play\", \"yolo\", \"plop\", \"loll\")));\n        System.out.println(matrixConundrum(2, 2, Arrays.asList(\"opo\", \"poo\")));\n        System.out.println(matrixConundrum(3, 3, Arrays.asList(\"lay\", \"lop\", \"lol\")));\n        System.out.println(matrixConundrum(4, 4, Arrays.asList(\"layy\", \"lopp\", \"loll\", \"lopi\")));\n        System.out.println(matrixConundrum(5, 5, Arrays.asList(\"play\", \"yolo\", \"plop\", \"loll\", \"play\")));\n    }\n}"}, {"source_Lan": "cpp###isPossible.cpp", "source_code": "    string isPossible(int a, int b, int c) {\n        \n        if ((a + b) > c && (a + c) > b && (b + c) > a)\n            return \"YES\";\n        else\n            return \"NO\";\n    }", "trans_code": "public static String isPossible ( int a , int b , int c ) {\n  if ( ( a + b ) > c && ( a + c ) > b && ( b + c ) > a ) {\n    return \"YES\" ;\n  }\n  else {\n    return \"NO\" ;\n  }\n}\n", "reference_code": "    public static String isPossible(int a, int b, int c) {\n        \n        if ((a + b) > c && (a + c) > b && (b + c) > a)\n            return \"YES\";\n        else\n            return \"NO\";\n    }", "target_Lan": "java###isPossible_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\n\npublic class isPossible_Test {\n// TOFILL\npublic static void main(String[] args) {\n    System.out.println(isPossible(1, 2, 3));\n    System.out.println(isPossible(3, 4, 8));\n    System.out.println(isPossible(5, 10, 7));\n    System.out.println(isPossible(7, 14, 20));\n    System.out.println(isPossible(9, 18, 22));\n}\n}"}, {"source_Lan": "cpp###geeklandElections.cpp", "source_code": "    bool geeklandElections(int n, int k, string &s) {\n        int votes = 0;\n        for (int i = 0; i < n; i++)\n            votes += (s[i] == '1');\n        return (votes + k) > (n - (votes + k));\n    }", "trans_code": "public static boolean geeklandElections ( int n , int k , String s ) {\n  int votes = 0 ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    votes += ( s . charAt ( i ) == '1' ) ;\n  }\n  return ( votes + k ) > ( n - ( votes + k ) ) ;\n}\n", "reference_code": "    public static boolean geeklandElections(int n, int k, String s) {\n        int votes = 0;\n        for (int i = 0; i < n; i++)\n            if (s.charAt(i) == '1') votes++;\n        return (votes + k) > (n - (votes + k));\n    }", "target_Lan": "java###geeklandElections_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.*;\npublic class geeklandElections_Test {\n// TOFILL\n    public static void main(String[] args) {\n        System.out.println(geeklandElections(5, 1, \"11001\"));\n        System.out.println(geeklandElections(6, 2, \"101010\"));\n        System.out.println(geeklandElections(7, 0, \"0000000\"));\n        System.out.println(geeklandElections(8, 3, \"11110000\"));\n        System.out.println(geeklandElections(9, 1, \"100100100\"));\n    }\n}"}, {"source_Lan": "cpp###totalCount.cpp", "source_code": "    int totalCount(int n, string s) {\n        int answer = 0;\n        int mod = 1e9 + 7;\n        char now = s[0];\n        for(int i = 0; i < n; i ++){\n            if(s[i] == now){\n                answer += n - i;\n                answer %= mod;\n            }\n        }\n        return answer;\n    }", "trans_code": "public static int totalCount ( int n , String s ) {\n  int answer = 0 ;\n  int mod = 1e9 + 7 ;\n  char now = s . charAt ( 0 ) ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    if ( s . charAt ( i ) == now ) {\n      answer += n - i ;\n      answer %= mod ;\n    }\n  }\n  return answer ;\n}\n", "reference_code": "    public static int totalCount(int n, String s) {\n        int ans = 0, mod = (int)(1e9 + 7);\n        for(int i = 0; i < s.length(); i++){\n            if(s.charAt(i) == s.charAt(0))\n                ans = (ans + s.length() - i) % mod;\n        }\n        return ans;\n    }", "target_Lan": "java###totalCount_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.*;\npublic class totalCount_Test {\n// TOFILL\n    public static void main(String[] args) {\n        System.out.println(totalCount(0, \"\"));\n        System.out.println(totalCount(1, \"a\"));\n        System.out.println(totalCount(2, \"aa\"));\n        System.out.println(totalCount(3, \"aba\"));\n        System.out.println(totalCount(4, \"abba\"));\n    }\n}"}, {"source_Lan": "cpp###isFriend.cpp", "source_code": "    string isFriend(int n, int x, int y, vector<int> &arr) {\n        for (auto j:arr){\n            if (x+j==y) return \"yes\";\n        }\n        return \"no\";\n    }", "trans_code": "public static String isFriend ( int n , int x , int y , int [ ] arr ) {\n  for ( int j : arr ) {\n    if ( x + j == y ) return \"yes\" ;\n  }\n  return \"no\" ;\n}\n", "reference_code": "    public static String isFriend(int n, int x, int y, int[] arr) {\n        for(int e : arr)\n            if(x + e == y)\n                return \"yes\";\n        return \"no\";\n    }", "target_Lan": "java###isFriend_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.Arrays;\npublic class isFriend_Test {\n// TOFILL\n    public static void main(String[] args) {\n        int[] arr1 = {10, 10, 10, 10, 10};\n        int[] arr2 = {1, 2, 3, 4};\n        int[] arr3 = {0, 0, 0};\n        int[] arr4 = {-10, 10};\n        int[] arr5 = {100};\n        \n        System.out.println(isFriend(5, 10, 20, arr1));\n        System.out.println(isFriend(4, 5, 15, arr2));\n        System.out.println(isFriend(3, 0, 0, arr3));\n        System.out.println(isFriend(2, -5, 5, arr4));\n        System.out.println(isFriend(1, 100, 200, arr5));\n    }\n}"}, {"source_Lan": "cpp###minimizeArr.cpp", "source_code": "    int minimizeArr(int n, vector<int>&arr){\n        int mi=INT_MAX;\n        for (auto j:arr) mi=min(mi,j);\n        int ct=0;\n        for (auto j:arr){\n            if (j==mi)ct+=1;\n        }\n        if (ct==1) return 1;\n        for (auto j:arr){\n            if (j%mi!=0) return 1;\n        }\n        return ceil((float)ct / 2);\n    }", "trans_code": "public static int minimizeArr ( int n , int [ ] arr ) {\n  int mi = Integer . MAX_VALUE ;\n  for ( int j : arr ) {\n    mi = Math . min ( mi , j ) ;\n  }\n  int ct = 0 ;\n  for ( int j : arr ) {\n    if ( j == mi ) {\n      ct += 1 ;\n    }\n  }\n  if ( ct == 1 ) {\n    return 1 ;\n  }\n  for ( int j : arr ) {\n    if ( j % mi != 0 ) {\n      return 1 ;\n    }\n  }\n  return Math . ceil ( ( float ) ct / 2 ) ;\n}\n", "reference_code": "    public static int minimizeArr(int n, int[] arr) {\n        \n        int mi = Arrays.stream(arr).min().getAsInt();\n        int ct = 0;\n        \n        for (int j : arr) {\n            if (j == mi) ct++;\n        }\n        \n        if (ct == 1) return 1;\n        \n        for (int j : arr) {\n            if (j % mi != 0) return 1;\n        }\n        \n        return (int)Math.ceil((float)ct / 2);\n    }", "target_Lan": "java###minimizeArr_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.Arrays;\npublic class minimizeArr_Test {\n// TOFILL\n    public static void main(String[] args) {\n        System.out.println(minimizeArr(3, new int[]{2, 4, 8}));\n        System.out.println(minimizeArr(4, new int[]{5, 10, 15, 20}));\n        System.out.println(minimizeArr(2, new int[]{10, 10}));\n        System.out.println(minimizeArr(3, new int[]{1, 2, 3}));\n        System.out.println(minimizeArr(4, new int[]{1, 1, 1, 1}));\n    }\n}"}, {"source_Lan": "cpp###minJumps2.cpp", "source_code": "    int minJumps2(int n, vector<int> &arr) {\n        vector<int> right_greater(n, n);\n        vector<int> right_lesser(n, n);\n        stack<int> st;\n        for (int i = 0; i < n; i++) {\n            while (!st.empty() && arr[st.top()] < arr[i]) {\n                right_greater[st.top()] = i;\n                st.pop();\n            }\n            st.push(i);\n        }\n        stack<int> st1;\n        st = st1;\n        for (int i = 0; i < n; i++) {\n            while (!st.empty() && arr[st.top()] > arr[i]) {\n                right_lesser[st.top()] = i;\n                st.pop();\n            }\n            st.push(i);\n        }\n        deque<pair<int, int>> queue;\n        queue.push_back(make_pair(0, 0));\n        vector<int> visited(n, 0);\n        while (!queue.empty()) {\n            pair<int, int> p = queue.front();\n            queue.pop_front();\n            int idx = p.first;\n            int d = p.second;\n            if (visited[idx] == 1) {\n                continue;\n            }\n            visited[idx] = 1;\n            if (idx == n - 1) {\n                return d;\n            }\n            int temp = idx + 1;\n            if (arr[temp] > arr[idx]) {\n                while (temp != n && arr[temp] > arr[idx]) {\n                    queue.push_back(make_pair(temp, d + 1));\n                    temp = right_lesser[temp];\n                }\n                if (temp != n) {\n                    queue.push_back(make_pair(temp, d + 1));\n                }\n            } else {\n                while (temp != n && arr[temp] < arr[idx]) {\n                    queue.push_back(make_pair(temp, d + 1));\n                    temp = right_greater[temp];\n                }\n                if (temp != n) {\n                    queue.push_back(make_pair(temp, d + 1));\n                }\n            }\n        }\n        return -1;\n    }", "trans_code": "public static int minJumps2 ( int n , int [ ] arr ) {\n  int [ ] rightGreater = new int [ n ] ;\n  int [ ] rightLesser = new int [ n ] ;\n  Stack < Integer > st = new Stack < Integer > ( ) ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    while ( ! st . isEmpty ( ) && arr [ st . pop ( ) ] < arr [ i ] ) {\n      rightGreater [ st . pop ( ) ] = i ;\n      st . pop ( ) ;\n    }\n    st . push ( i ) ;\n  }\n  Stack < Integer > st1 = new Stack < Integer > ( ) ;\n  st = st1 ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    while ( ! st . isEmpty ( ) && arr [ st . pop ( ) ] > arr [ i ] ) {\n      rightLesser [ st . pop ( ) ] = i ;\n      st . pop ( ) ;\n    }\n    st . push ( i ) ;\n  }\n  Deque < Pair < Integer , Integer >> queue = new ArrayDeque < Pair < Integer , Integer >> ( ) ;\n  queue . push ( new Pair < Integer , Integer > ( 0 , 0 ) ) ;\n  int [ ] visited = new int [ n ] ;\n  while ( ! queue . isEmpty ( ) ) {\n    Pair < Integer , Integer > p = queue . peek ( ) ;\n    queue . pop ( ) ;\n    int idx = p . getFirst ( ) ;\n    int d = p . getSecond ( ) ;\n    if ( visited [ idx ] == 1 ) {\n      continue ;\n    }\n    visited [ idx ] = 1 ;\n    if ( idx == n - 1 ) {\n      return d ;\n    }\n    int temp = idx + 1 ;\n    if ( arr [ temp ] > arr [ idx ] ) {\n      while ( temp != n && arr [ temp ] > arr [ idx ] ) {\n        queue . push ( new Pair < Integer , Integer > ( temp , d + 1 ) ) ;\n        temp = rightLesser [ temp ] ;\n      }\n      if ( temp != n ) {\n        queue . push ( new Pair < Integer , Integer > ( temp , d + 1 ) ) ;\n      }\n    }\n    else {\n      while ( temp != n && arr [ temp ] < arr [ idx ] ) {\n        queue . push ( new Pair < Integer , Integer > ( temp , d + 1 ) ) ;\n        temp = rightGreater [ temp ] ;\n      }\n      if ( temp != n ) {\n        queue . push ( new Pair < Integer , Integer > ( temp , d + 1 ) ) ;\n        ", "reference_code": "    public static int minJumps2(int n, int[] arr) {\n        int[] rightGreater = new int[n];\n        int[] rightLesser = new int[n];\n        Arrays.fill(rightGreater, n);\n        Arrays.fill(rightLesser, n);\n        \n        Deque<Integer> stack = new ArrayDeque<>();\n        for (int i = 0; i < n; i++) {\n            while (!stack.isEmpty() && arr[stack.peek()] < arr[i]) {\n                rightGreater[stack.peek()] = i;\n                stack.pop();\n            }\n            stack.push(i);\n        }\n        \n        stack.clear();\n        for (int i = 0; i < n; i++) {\n            while (!stack.isEmpty() && arr[stack.peek()] > arr[i]) {\n                rightLesser[stack.peek()] = i;\n                stack.pop();\n            }\n            stack.push(i);\n        }\n        Deque<int[]> queue = new ArrayDeque<>();\n        queue.offer(new int[]{0, 0});\n        boolean[] visited = new boolean[n];\n        while (!queue.isEmpty()) {\n            int[] p = queue.poll();\n            int idx = p[0];\n            int d = p[1];\n            if (visited[idx]) {\n                continue;\n            }\n            visited[idx] = true;\n            if (idx == n - 1) {\n                return d;\n            }\n            int temp = idx + 1;\n            if (arr[temp] > arr[idx]) {\n                while (temp < n && arr[temp] > arr[idx]) {\n                    queue.offer(new int[]{temp, d + 1});\n                    temp = rightLesser[temp];\n                }\n                if (temp < n) {\n                    queue.offer(new int[]{temp, d + 1});\n                }\n            } else {\n                while (temp < n && arr[temp] < arr[idx]) {\n                    queue.offer(new int[]{temp, d + 1});\n                    temp = rightGreater[temp];\n                }\n                if (temp < n) {\n                    queue.offer(new int[]{temp, d + 1});\n                }\n            }\n        }\n        return -1;\n    }", "target_Lan": "java###minJumps2_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.Arrays;\npublic class minJumps2_Test {\n// TOFILL\n    public static void main(String[] args) {\n        int[] arr1 = {1, 2, 3, 4, 5};\n        int[] arr2 = {5, 4, 3, 2, 1};\n        int[] arr3 = {1, 1, 1, 1, 1};\n        int[] arr4 = {1, 3, 5, 7, 9};\n        int[] arr5 = {9, 7, 5, 3, 1};\n        \n        System.out.println(minJumps2(5, arr1)); // input1\n        System.out.println(minJumps2(5, arr2)); // input2\n        System.out.println(minJumps2(5, arr3)); // input3\n        System.out.println(minJumps2(5, arr4)); // input4\n        System.out.println(minJumps2(5, arr5)); // input5\n    }\n}"}, {"source_Lan": "cpp###geekTasks.cpp", "source_code": "    long long geekTasks(int n, int m, int q, vector<vector<int>> &tasks) {\n        long long int total = 0;\n        long long int a,b, minA, minB;\n        for(long long int i=0; i<q; i++)\n        {\n            a = tasks[i][0];\n            b = tasks[i][1];\n            a += 1;\n            b += 1;\n            if(i==0){\n                minA=a;\n                minB=b;\n            }\n            if(a<minA){\n                minA=a;\n            }\n            if(b<minB){\n                minB=b;\n            }\n        }\n        vector<int> col(n, 0);\n        for(auto i : tasks){\n            long long int x = i[1] + 1;\n            col[i[0]] = max((long long int)col[i[0]], x);\n        }\n        long long int maxi = 0;\n        for(int i = n - 1; i >= 0; i--){\n            maxi = max(maxi, (long long int)col[i]);\n            total += maxi;\n        }\n        long long int cellsWithMaxValue = minA*minB;\n        total -= cellsWithMaxValue;\n        return total;\n    }", "trans_code": "public static long geekTasks ( int n , int m , int q , int [ ] [ ] tasks ) {\n  long total = 0 ;\n  long a , b , minA , minB ;\n  for ( long i = 0 ;\n  i < q ;\n  i ++ ) {\n    a = tasks [ i ] [ 0 ] ;\n    b = tasks [ i ] [ 1 ] ;\n    a += 1 ;\n    b += 1 ;\n    if ( i == 0 ) {\n      minA = a ;\n      minB = b ;\n    }\n    if ( a < minA ) minA = a ;\n    if ( b < minB ) minB = b ;\n  }\n  int [ ] col = new int [ n ] ;\n  for ( int i = 0 ;\n  i < tasks . length ;\n  i ++ ) {\n    long x = tasks [ i ] [ 1 ] + 1 ;\n    col [ i ] = Math . max ( ( long ) col [ i ] , x ) ;\n  }\n  long maxi = 0 ;\n  for ( int i = n - 1 ;\n  i >= 0 ;\n  i -- ) {\n    maxi = Math . max ( maxi , ( long ) col [ i ] ) ;\n    total += maxi ;\n  }\n  long cellsWithMaxValue = minA * minB ;\n  total -= cellsWithMaxValue ;\n  return total ;\n}\n", "reference_code": "    public static long geekTasks(int n, int m, int q, int[][] tasks) {\n        long total = 0;\n        long minA = Long.MAX_VALUE, minB = Long.MAX_VALUE;\n        \n        for (int i = 0; i < q; i++) {\n            int a = tasks[i][0] + 1;\n            int b = tasks[i][1] + 1;\n            minA = Math.min(minA, a);\n            minB = Math.min(minB, b);\n        }\n        int[] col = new int[n]; \n        \n        for (int[] task : tasks) {\n            int x = task[1] + 1;\n            col[task[0]] = Math.max(col[task[0]], x);\n        }\n        long maxColValue = 0;\n        \n        for (int i = n - 1; i >= 0; i--) {\n            maxColValue = Math.max(maxColValue, col[i]);\n            total += maxColValue;\n        }\n        long cellsWithMaxValue = minA * minB;\n        \n        return total - cellsWithMaxValue;\n    }", "target_Lan": "java###geekTasks_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\n\npublic class geekTasks_Test {\n// TOFILL\npublic static void main(String[] args) {\n    System.out.println(geekTasks(3, 3, 3, new int[][]{{0,0},{0,1},{0,2}}));\n    System.out.println(geekTasks(5, 5, 5, new int[][]{{0,0},{1,1},{2,2},{3,3},{4,4}}));\n    System.out.println(geekTasks(2, 2, 2, new int[][]{{0,0},{1,1}}));\n    System.out.println(geekTasks(4, 4, 4, new int[][]{{0,0},{1,1},{2,2},{3,3}}));\n    System.out.println(geekTasks(6, 6, 6, new int[][]{{0,0},{1,1},{2,2},{3,3},{4,4},{5,5}}));\n}\n}"}, {"source_Lan": "cpp###majorityWins.cpp", "source_code": "    int majorityWins(int arr[], int n, int x, int y) {\n        int count_x = 0;\n        int count_y = 0;\n        \n        \n        for (int i = 0; i < n; i++) {\n            if (arr[i] == x) count_x++;\n            if (arr[i] == y) count_y++;\n        }\n        \n        if (count_x > count_y)\n            \n            return x;\n        else if (count_y > count_x)\n            \n            return y;\n        \n        else\n            return x < y ? x : y;\n    }", "trans_code": "public static int majorityWins ( int arr [ ] , int n , int x , int y ) {\n  int count_x = 0 ;\n  int count_y = 0 ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    if ( arr [ i ] == x ) {\n      count_x ++ ;\n    }\n    if ( arr [ i ] == y ) {\n      count_y ++ ;\n    }\n  }\n  if ( count_x > count_y ) {\n    return x ;\n  }\n  else if ( count_y > count_x ) {\n    return y ;\n  }\n  else {\n    return x < y ? x : y ;\n  }\n}\n", "reference_code": "    public static int majorityWins(int arr[], int n, int x, int y) {\n        int count_x = 0;\n        int count_y = 0;\n        \n        \n        for (int i = 0; i < n; i++) {\n            if (arr[i] == x) count_x++;\n            if (arr[i] == y) count_y++;\n        }\n        \n        if (count_x > count_y)\n            \n            return x;\n        else if (count_y > count_x)\n            \n            return y;\n        \n        else if (x < y)\n            return x;\n        else\n            return y;\n    }", "target_Lan": "java###majorityWins_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.Arrays;\npublic class majorityWins_Test {\n// TOFILL\n    public static void main(String[] args) {\n        System.out.println(majorityWins(new int[]{1,2,3,4,5,6}, 6, 2, 5));\n        System.out.println(majorityWins(new int[]{5,5,5,4,4,4,3,3,3}, 9, 5, 3));\n        System.out.println(majorityWins(new int[]{1,1,1,1,2,2,2,2}, 8, 1, 2));\n        System.out.println(majorityWins(new int[]{10,20,30,40,50}, 5, 10, 20));\n        System.out.println(majorityWins(new int[]{1,1,2,2,2,3,3,3,3,4,4,4,4}, 13, 2, 4));\n    }\n}"}, {"source_Lan": "cpp###minJumps.cpp", "source_code": "    int minJumps(int n, vector<int> &arr) {\n        map<int, int> m;\n        int ans = n - 1;\n        for (int i = n - 1; i >= 0; i--) {\n            if (m.count(arr[i])) {\n                ans = min(ans, n - (m[arr[i]] - i));\n            } else {\n                m[arr[i]] = i;\n            }\n        }\n        return ans;\n    }", "trans_code": "public static int minJumps ( int n , int [ ] arr ) {\n  Map < Integer , Integer > m = new HashMap < Integer , Integer > ( ) ;\n  int ans = n - 1 ;\n  for ( int i = n - 1 ;\n  i >= 0 ;\n  i -- ) {\n    if ( m . containsKey ( arr [ i ] ) ) ans = Math . min ( ans , n - ( m . get ( arr [ i ] ) - i ) ) ;\n    else m . put ( arr [ i ] , i ) ;\n  }\n  return ans ;\n}\n", "reference_code": "    public static int minJumps(int n, int[] arr) {\n        \n        \n        HashMap<Integer, Integer> m = new HashMap<Integer, Integer>();\n        \n        int ans = n - 1;\n        \n        for (int i = n - 1; i >= 0; i--) {\n            \n            if (m.containsKey(arr[i])) {\n                \n                \n                ans = Math.min(ans, n - (m.get(arr[i]) - i));\n            } else {\n                \n                m.put(arr[i], i);\n            }\n        }\n        \n        return ans;\n    }", "target_Lan": "java###minJumps_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.HashMap;\npublic class minJumps_Test {\n// TOFILL\n    public static void main(String[] args) {\n        int[] arr1 = {1, 2, 3};\n        System.out.println(minJumps(3, arr1));\n\n        int[] arr2 = {3, 2, 1, 4};\n        System.out.println(minJumps(4, arr2));\n\n        int[] arr3 = {1, 1, 1, 1, 1};\n        System.out.println(minJumps(5, arr3));\n\n        int[] arr4 = {1};\n        System.out.println(minJumps(1, arr4));\n\n        int[] arr5 = {2, 2};\n        System.out.println(minJumps(2, arr5));\n    }\n}"}, {"source_Lan": "cpp###areaOfMaxDiagonal.cpp", "source_code": "    int areaOfMaxDiagonal(vector<vector<int>> &dimensions) {\n        int ans = 0, max_l = 0;\n        for (auto &d: dimensions) {\n            int x = d[0], y = d[1];\n            int l = x * x + y * y;\n            if (l > max_l || (l == max_l && x * y > ans)) {\n                max_l = l;\n                ans = x * y;\n            }\n        }\n        return ans;\n    }", "trans_code": "public static int areaOfMaxDiagonal ( int [ ] [ ] dimensions ) {\n  int ans = 0 , max_l = 0 ;\n  for ( int [ ] d : dimensions ) {\n    int x = d [ 0 ] , y = d [ 1 ] ;\n    int l = x * x + y * y ;\n    if ( l > max_l || ( l == max_l && x * y > ans ) ) {\n      max_l = l ;\n      ans = x * y ;\n    }\n  }\n  return ans ;\n}\n", "reference_code": "    public static int areaOfMaxDiagonal(int[][] dimensions) {\n        int ans = 0, maxL = 0;\n        for (int[] d : dimensions) {\n            int x = d[0], y = d[1];\n            int l = x * x + y * y;\n            if (l > maxL || (l == maxL && x * y > ans)) {\n                maxL = l;\n                ans = x * y;\n            }\n        }\n        return ans;\n    }", "target_Lan": "java###areaOfMaxDiagonal_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.Arrays;\npublic class areaOfMaxDiagonal_Test {\n// TOFILL\n    public static void main(String[] args) {\n        System.out.println(areaOfMaxDiagonal(new int[][]{{1,1},{2,2},{3,3},{4,4},{5,5}}));\n        System.out.println(areaOfMaxDiagonal(new int[][]{{1,1},{2,2},{3,3},{4,4},{50,50}}));\n        System.out.println(areaOfMaxDiagonal(new int[][]{{1,1},{2,2},{3,3},{4,4},{0,0}}));\n        System.out.println(areaOfMaxDiagonal(new int[][]{{1,1},{2,2},{3,3},{4,4},{-1,-1}}));\n        System.out.println(areaOfMaxDiagonal(new int[][]{{1,1},{2,2},{3,3},{4,4},{-100,-100}}));\n    }\n}"}, {"source_Lan": "cpp###maximumSetSize.cpp", "source_code": "    int maximumSetSize(vector<int> &nums1, vector<int> &nums2) {\n        unordered_set<int> set1(nums1.begin(), nums1.end());\n        unordered_set<int> set2(nums2.begin(), nums2.end());\n        int common = 0;\n        for (int x : set1) {\n            common += set2.count(x);\n        }\n        int n1 = set1.size();\n        int n2 = set2.size();\n        int ans = n1 + n2 - common;\n        int m = nums1.size() / 2;\n        if (n1 > m) {\n            int mn = min(n1 - m, common);\n            ans -= n1 - mn - m;\n            common -= mn;\n        }\n        if (n2 > m) {\n            n2 -= min(n2 - m, common);\n            ans -= n2 - m;\n        }\n        return ans;\n    }", "trans_code": "public static int maximumSetSize ( int [ ] nums1 , int [ ] nums2 ) {\n  TreeSet < Integer > set1 = new TreeSet < Integer > ( Arrays . asList ( nums1 ) ) ;\n  TreeSet < Integer > set2 = new TreeSet < Integer > ( Arrays . asList ( nums2 ) ) ;\n  int common = 0 ;\n  for ( Integer x : set1 ) common += set2 . contains ( x ) ? 1 : 0 ;\n  int n1 = set1 . size ( ) ;\n  int n2 = set2 . size ( ) ;\n  int ans = n1 + n2 - common ;\n  int m = nums1 . length / 2 ;\n  if ( n1 > m ) {\n    int mn = Math . min ( n1 - m , common ) ;\n    ans -= n1 - mn - m ;\n    common -= mn ;\n  }\n  if ( n2 > m ) {\n    n2 -= Math . min ( n2 - m , common ) ;\n    ans -= n2 - m ;\n  }\n  return ans ;\n}\n", "reference_code": "    public static int maximumSetSize(int[] nums1, int[] nums2) {\n        Set<Integer> set1 = new HashSet<>();\n        for (int x : nums1) {\n            set1.add(x);\n        }\n        Set<Integer> set2 = new HashSet<>();\n        for (int x : nums2) {\n            set2.add(x);\n        }\n        int common = 0;\n        for (int x : set1) {\n            if (set2.contains(x)) {\n                common++;\n            }\n        }\n        int n1 = set1.size();\n        int n2 = set2.size();\n        int ans = n1 + n2 - common;\n        int m = nums1.length / 2;\n        if (n1 > m) {\n            int mn = Math.min(n1 - m, common);\n            ans -= n1 - mn - m;\n            common -= mn;\n        }\n        if (n2 > m) {\n            n2 -= Math.min(n2 - m, common);\n            ans -= n2 - m;\n        }\n        return ans;\n    }", "target_Lan": "java###maximumSetSize_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.*;\npublic class maximumSetSize_Test {\n// TOFILL\n    public static void main(String[] args) {\n        int[] nums1 = {1,2,3,4,5};\n        int[] nums2 = {2,3,4,5,6};\n        System.out.println(maximumSetSize(nums1, nums2));\n\n        int[] nums3 = {1,1,1,1,1};\n        int[] nums4 = {1,1,1,1,1};\n        System.out.println(maximumSetSize(nums3, nums4));\n\n        int[] nums5 = {1,2,3,4,5,6,7,8,9,10};\n        int[] nums6 = {11,12,13,14,15};\n        System.out.println(maximumSetSize(nums5, nums6));\n\n        int[] nums7 = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};\n        int[] nums8 = {16,17,18,19,20};\n        System.out.println(maximumSetSize(nums7, nums8));\n\n        int[] nums9 = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25};\n        int[] nums10 = {26,27,28,29,30};\n        System.out.println(maximumSetSize(nums9, nums10));\n    }\n}"}, {"source_Lan": "cpp###countKeyChanges.cpp", "source_code": "    int countKeyChanges(string s) {\n        int ans = 0;\n        for (int i = 1; i < s.length(); i++) {\n            ans += (s[i - 1] & 31) != (s[i] & 31);\n        }\n        return ans;\n    }", "trans_code": "public static int countKeyChanges ( String s ) {\n  int ans = 0 ;\n  for ( int i = 1 ;\n  i < s . length ( ) ;\n  i ++ ) ans += ( s . charAt ( i - 1 ) & 31 ) != ( s . charAt ( i ) & 31 ) ;\n  return ans ;\n}\n", "reference_code": "    public static int countKeyChanges(String s) {\n        int ans = 0;\n        for (int i = 1; i < s.length(); i++) {\n            if ((s.charAt(i - 1) & 31) != (s.charAt(i) & 31)) {\n                ans++;\n            }\n        }\n        return ans;\n    }", "target_Lan": "java###countKeyChanges_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\n\npublic class countKeyChanges_Test {\n// TOFILL\n    public static void main(String[] args) {\n        System.out.println(countKeyChanges(\"a\"));\n        System.out.println(countKeyChanges(\"aaa\"));\n        System.out.println(countKeyChanges(\"abc\"));\n        System.out.println(countKeyChanges(\"ABC\"));\n        System.out.println(countKeyChanges(\"AabBcC\"));\n    }\n}"}, {"source_Lan": "cpp###minOrAfterOperations.cpp", "source_code": "    int minOrAfterOperations(vector<int> &nums, int k) {\n        int ans = 0, mask = 0;\n        for (int b = 29; b >= 0; b--) {\n            mask |= 1 << b;\n            int cnt = 0, and_res = -1; \n            for (int x : nums) {\n                and_res &= x & mask;\n                if (and_res) {\n                    cnt++; \n                } else {\n                    and_res = -1; \n                }\n            }\n            if (cnt > k) {\n                ans |= 1 << b; \n                mask ^= 1 << b; \n            }\n        }\n        return ans;\n    }", "trans_code": "public static int minOrAfterOperations ( int [ ] nums , int k ) {\n  int ans = 0 , mask = 0 ;\n  for ( int b = 29 ;\n  b >= 0 ;\n  b -- ) {\n    mask |= 1 << b ;\n    int cnt = 0 , and_res = - 1 ;\n    for ( int x : nums ) {\n      and_res &= x & mask ;\n      if ( and_res > 0 ) cnt ++ ;\n      else and_res = - 1 ;\n    }\n    if ( cnt > k ) {\n      ans |= 1 << b ;\n      mask ^= 1 << b ;\n    }\n  }\n  return ans ;\n}\n", "reference_code": "    public static int minOrAfterOperations(int[] nums, int k) {\n        int ans = 0;\n        int mask = 0;\n        for (int b = 29; b >= 0; b--) {\n            mask |= 1 << b;\n            int cnt = 0; \n            int and = -1; \n            for (int x : nums) {\n                and &= x & mask;\n                if (and != 0) {\n                    cnt++; \n                } else {\n                    and = -1; \n                }\n            }\n            if (cnt > k) {\n                ans |= 1 << b; \n                mask ^= 1 << b; \n            }\n        }\n        return ans;\n    }", "target_Lan": "java###minOrAfterOperations_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.Arrays;\npublic class minOrAfterOperations_Test {\n// TOFILL\n    public static void main(String[] args) {\n        System.out.println(minOrAfterOperations(new int[]{1, 2, 3, 4, 5}, 2));\n        System.out.println(minOrAfterOperations(new int[]{2, 4, 6, 8, 10}, 3));\n        System.out.println(minOrAfterOperations(new int[]{1, 1, 1, 1, 1}, 1));\n        System.out.println(minOrAfterOperations(new int[]{10, 20, 30, 40, 50}, 5));\n        System.out.println(minOrAfterOperations(new int[]{1, 3, 5, 7, 9}, 0));\n    }\n}"}, {"source_Lan": "cpp###resultArray.cpp", "source_code": "    vector<int> resultArray(vector<int> &nums) {\n        vector<int> a{nums[0]}, b{nums[1]};\n        for (int i = 2; i < nums.size(); i++) {\n            (a.back() > b.back() ? a : b).push_back(nums[i]);\n        }\n        a.insert(a.end(), b.begin(), b.end());\n        return a;\n    }", "trans_code": "public static int [ ] resultArray ( int [ ] nums ) {\n  int [ ] a = new int [ nums . length ] , b = new int [ nums . length ] ;\n  for ( int i = 2 ;\n  i < nums . length ;\n  i ++ ) {\n    ( a [ i ] > b [ i ] ? a : b ) [ i ] = nums [ i ] ;\n  }\n  a [ 0 ] = nums [ 0 ] ;\n  a [ 1 ] = nums [ 1 ] ;\n  a [ 2 ] = nums [ 2 ] ;\n  a [ 3 ] = nums [ 3 ] ;\n  a [ 4 ] = nums [ 4 ] ;\n  a [ 5 ] = nums [ 5 ] ;\n  a [ 6 ] = nums [ 6 ] ;\n  a [ 7 ] = nums [ 7 ] ;\n  a [ 8 ] = nums [ 8 ] ;\n  a [ 9 ] = nums [ 9 ] ;\n  a [ 10 ] = nums [ 10 ] ;\n  a [ 11 ] = nums [ 11 ] ;\n  a [ 12 ] = nums [ 12 ] ;\n  a [ 13 ] = nums [ 13 ] ;\n  a [ 14 ] = nums [ 14 ] ;\n  a [ 15 ] = nums [ 15 ] ;\n  a [ 16 ] = nums [ 16 ] ;\n  a [ 17 ] = nums [ 17 ] ;\n  a [ 18 ] = nums [ 18 ] ;\n  a [ 19 ] = nums [ 19 ] ;\n  a [ 20 ] = nums [ 20 ] ;\n  a [ 21 ] = nums [ 21 ] ;\n  a [ 22 ] = nums [ 22 ] ;\n  a [ 23 ] = nums [ 23 ] ;\n  a [ 24 ] = nums [ 24 ] ;\n  a [ 25 ] = nums [ 25 ]", "reference_code": "    public static int[] resultArray(int[] nums) {\n        int n = nums.length;\n        List<Integer> a = new ArrayList<>();\n        List<Integer> b = new ArrayList<>();\n        a.add(nums[0]);\n        b.add(nums[1]);\n        for (int i = 2; i < n; i++) {\n            if (a.get(a.size() - 1) > b.get(b.size() - 1)) {\n                a.add(nums[i]);\n            } else {\n                b.add(nums[i]);\n            }\n        }\n        a.addAll(b);\n        for (int i = 0; i < n; i++) {\n            nums[i] = a.get(i);\n        }\n        return nums;\n    }", "target_Lan": "java###resultArray_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.Arrays;\npublic class resultArray_Test {\n// TOFILL\n    public static void main(String[] args) {\n        System.out.println(Arrays.toString(resultArray(new int[]{1, 2})));\n        System.out.println(Arrays.toString(resultArray(new int[]{2, 1})));\n        System.out.println(Arrays.toString(resultArray(new int[]{1, 1})));\n        System.out.println(Arrays.toString(resultArray(new int[]{2, 2, 1, 1})));\n        System.out.println(Arrays.toString(resultArray(new int[]{1, 2, 3, 4, 5})));\n    }\n}"}, {"source_Lan": "cpp###countSubmatrices.cpp", "source_code": "    int countSubmatrices(vector<vector<int>> &grid, int k) {\n        int ans = 0, m = grid.size(), n = grid[0].size();\n        vector<vector<int>> sum(m + 1, vector<int>(n + 1));\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                sum[i + 1][j + 1] = sum[i + 1][j] + sum[i][j + 1] - sum[i][j] + grid[i][j];\n                ans += sum[i + 1][j + 1] <= k;\n            }\n        }\n        return ans;\n    }", "trans_code": "public static int countSubmatrices ( int [ ] [ ] grid , int k ) {\n  int ans = 0 , m = grid . length , n = grid [ 0 ] . length ;\n  int [ ] [ ] sum = new int [ m + 1 ] [ n + 1 ] ;\n  for ( int i = 0 ;\n  i < m ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < n ;\n    j ++ ) {\n      sum [ i + 1 ] [ j + 1 ] = sum [ i + 1 ] [ j ] + sum [ i ] [ j + 1 ] - sum [ i ] [ j ] + grid [ i ] [ j ] ;\n      ans += sum [ i + 1 ] [ j + 1 ] <= k ;\n    }\n  }\n  return ans ;\n}\n", "reference_code": "    public static int countSubmatrices(int[][] grid, int k) {\n        int ans = 0;\n        int m = grid.length;\n        int n = grid[0].length;\n        int[][] sum = new int[m + 1][n + 1];\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                sum[i + 1][j + 1] = sum[i + 1][j] + sum[i][j + 1] - sum[i][j] + grid[i][j];\n                if (sum[i + 1][j + 1] <= k) {\n                    ans++;\n                }\n            }\n        }\n        return ans;\n    }", "target_Lan": "java###countSubmatrices_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.Arrays;\npublic class countSubmatrices_Test {\n// TOFILL\n    public static void main(String[] args) {\n        int[][] input1 = {{1,0,1},{1,1,0},{0,1,1}};\n        int[][] input2 = {{1,1,1},{1,1,1},{1,1,1}};\n        int[][] input3 = {{1,0,1,0},{0,1,0,1},{1,0,1,0}};\n        int[][] input4 = {{1,0,0,1},{0,1,1,0},{0,1,1,0}};\n        int[][] input5 = {{0,0,0,0},{0,0,0,0},{0,0,0,0}};\n        System.out.println(countSubmatrices(input1, 2));\n        System.out.println(countSubmatrices(input2, 3));\n        System.out.println(countSubmatrices(input3, 3));\n        System.out.println(countSubmatrices(input4, 2));\n        System.out.println(countSubmatrices(input5, 0));\n    }\n}"}, {"source_Lan": "cpp###isSubstringPresent.cpp", "source_code": "    bool isSubstringPresent(string s) {\n        bool vis[26][26]{};\n        for (int i = 1; i < s.length(); i++) {\n            int x = s[i - 1] - 'a', y = s[i] - 'a';\n            vis[x][y] = true;\n            if (vis[y][x]) {\n                return true;\n            }\n        }\n        return false;\n    }", "trans_code": "public static boolean isSubstringPresent ( String s ) {\n  boolean [ ] [ ] vis = new boolean [ 26 ] [ 26 ] ;\n  for ( int i = 1 ;\n  i < s . length ( ) ;\n  i ++ ) {\n    int x = s . charAt ( i - 1 ) - 'a' , y = s . charAt ( i ) - 'a' ;\n    vis [ x ] [ y ] = true ;\n    if ( vis [ y ] [ x ] ) {\n      return true ;\n    }\n  }\n  return false ;\n}\n", "reference_code": "    public static boolean isSubstringPresent(String S) {\n        char[] s = S.toCharArray();\n        boolean[][] vis = new boolean[26][26];\n        for (int i = 1; i < s.length; i++) {\n            int x = s[i - 1] - 'a';\n            int y = s[i] - 'a';\n            vis[x][y] = true;\n            if (vis[y][x]) {\n                return true;\n            }\n        }\n        return false;\n    }", "target_Lan": "java###isSubstringPresent_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\n\npublic class isSubstringPresent_Test {\n// TOFILL\npublic static void main(String[] args) {\n    System.out.println(isSubstringPresent(\"abcdefghijklmnopqrstuvwxyz\"));\n    System.out.println(isSubstringPresent(\"abcabcabcabcabcabcabcabcabc\"));\n    System.out.println(isSubstringPresent(\"aabbccddeeffgghhiijjkkllmmnnooppqqrrssttuuvvwwxxyyzz\"));\n    System.out.println(isSubstringPresent(\"zabcdefghijklmnopqrstuvwxy\"));\n    System.out.println(isSubstringPresent(\"abcdefghijklmnopqrstuvwxyz\"));\n}\n}"}, {"source_Lan": "cpp###maximumLengthSubstring.cpp", "source_code": "    int maximumLengthSubstring(string s) {\n        int ans = 0, left = 0, cnt[26]{};\n        for (int i = 0; i < s.length(); i++) {\n            int b = s[i] - 'a';\n            cnt[b]++;\n            while (cnt[b] > 2) {\n                cnt[s[left++] - 'a']--;\n            }\n            ans = max(ans, i - left + 1);\n        }\n        return ans;\n    }", "trans_code": "public static int maximumLengthSubstring ( String s ) {\n  int ans = 0 , left = 0 , cnt [ 26 ] = {\n  }\n  ;\n  for ( int i = 0 ;\n  i < s . length ( ) ;\n  i ++ ) {\n    int b = s . charAt ( i ) - 'a' ;\n    cnt [ b ] ++ ;\n    while ( cnt [ b ] > 2 ) cnt [ s . charAt ( left ++ ) - 'a' ] -- ;\n    ans = Math . max ( ans , i - left + 1 ) ;\n  }\n  return ans ;\n}\n", "reference_code": "    public static int maximumLengthSubstring(String S) {\n        char[] s = S.toCharArray();\n        int ans = 0;\n        int left = 0;\n        int[] cnt = new int[26];\n        for (int i = 0; i < s.length; i++) {\n            int b = s[i] - 'a';\n            cnt[b]++;\n            while (cnt[b] > 2) {\n                cnt[s[left++] - 'a']--;\n            }\n            ans = Math.max(ans, i - left + 1);\n        }\n        return ans;\n    }", "target_Lan": "java###maximumLengthSubstring_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.*;\npublic class maximumLengthSubstring_Test {\n// TOFILL\n    public static void main(String[] args) {\n        System.out.println(maximumLengthSubstring(\"abcabcbb\"));\n        System.out.println(maximumLengthSubstring(\"bbbbb\"));\n        System.out.println(maximumLengthSubstring(\"pwwkew\"));\n        System.out.println(maximumLengthSubstring(\"abcdabcd\"));\n        System.out.println(maximumLengthSubstring(\"abcdabcde\"));\n    }\n}"}, {"source_Lan": "cpp###maxBottlesDrunk.cpp", "source_code": "    int maxBottlesDrunk(int numBottles, int numExchange) {\n        int ans = numBottles; \n        while (numBottles >= numExchange) { \n            ans++; \n            numBottles += 1 - numExchange++;\n        }\n        return ans;\n    }", "trans_code": "public static int maxBottlesDrunk ( int numBottles , int numExchange ) {\n  int ans = numBottles ;\n  while ( numBottles >= numExchange ) {\n    ans ++ ;\n    numBottles += 1 - numExchange ++ ;\n  }\n  return ans ;\n}\n", "reference_code": "    public static int maxBottlesDrunk(int numBottles, int numExchange) {\n        int ans = numBottles; \n        while (numBottles >= numExchange) { \n            ans++; \n            numBottles += 1 - numExchange++;\n        }\n        return ans;\n    }", "target_Lan": "java###maxBottlesDrunk_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\n\npublic class maxBottlesDrunk_Test {\n// TOFILL\npublic static void main(String[] args) {\n    System.out.println(maxBottlesDrunk(0, 0));\n    System.out.println(maxBottlesDrunk(10, 3));\n    System.out.println(maxBottlesDrunk(15, 5));\n    System.out.println(maxBottlesDrunk(20, 10));\n    System.out.println(maxBottlesDrunk(1, 2));\n}\n}"}, {"source_Lan": "cpp###longestMonotonicSubarray.cpp", "source_code": "    int longestMonotonicSubarray(vector<int> &a) {\n        int ans = 1;\n        int i = 0, n = a.size();\n        while (i < n - 1) {\n            if (a[i + 1] == a[i]) {\n                i++; \n                continue;\n            }\n            int i0 = i; \n            bool inc = a[i + 1] > a[i]; \n            i += 2; \n            while (i < n && a[i] != a[i - 1] && (a[i] > a[i - 1]) == inc) {\n                i++;\n            }\n            \n            ans = max(ans, i - i0);\n            i--;\n        }\n        return ans;\n    }", "trans_code": "public static int longestMonotonicSubarray ( int [ ] a ) {\n  int ans = 1 ;\n  int i = 0 , n = a . length ;\n  while ( i < n - 1 ) {\n    if ( a [ i + 1 ] == a [ i ] ) {\n      i ++ ;\n      continue ;\n    }\n    int i0 = i ;\n    boolean inc = a [ i + 1 ] > a [ i ] ;\n    i += 2 ;\n    while ( i < n && a [ i ] != a [ i - 1 ] && ( a [ i ] > a [ i - 1 ] ) == inc ) {\n      i ++ ;\n    }\n    ans = Math . max ( ans , i - i0 ) ;\n    i -- ;\n  }\n  return ans ;\n}\n", "reference_code": "    public static int longestMonotonicSubarray(int[] a) {\n        int ans = 1;\n        int i = 0, n = a.length;\n        while (i < n - 1) {\n            if (a[i + 1] == a[i]) {\n                i++; \n                continue;\n            }\n            int i0 = i; \n            boolean inc = a[i + 1] > a[i]; \n            i += 2; \n            while (i < n && a[i] != a[i - 1] && (a[i] > a[i - 1]) == inc) {\n                i++;\n            }\n            \n            ans = Math.max(ans, i - i0);\n            i--;\n        }\n        return ans;\n    }", "target_Lan": "java###longestMonotonicSubarray_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.Arrays;\npublic class longestMonotonicSubarray_Test {\n// TOFILL\n    public static void main(String[] args) {\n        System.out.println(longestMonotonicSubarray(new int[]{1, 2, 2, 3, 4, 5}));\n        System.out.println(longestMonotonicSubarray(new int[]{5, 4, 3, 2, 1}));\n        System.out.println(longestMonotonicSubarray(new int[]{1, 1, 1, 1, 1, 1}));\n        System.out.println(longestMonotonicSubarray(new int[]{1, 2, 3, 4, 5, 6}));\n        System.out.println(longestMonotonicSubarray(new int[]{6, 5, 4, 3, 2, 1}));\n    }\n}"}, {"source_Lan": "cpp###getSmallestString.cpp", "source_code": "    string getSmallestString(string s, int k) {\n        for (int i = 0; i < s.length(); i++) {\n            int dis = min(s[i] - 'a', 'z' - s[i] + 1);\n            if (dis > k) {\n                s[i] -= k;\n                break;\n            }\n            s[i] = 'a';\n            k -= dis;\n        }\n        return s;\n    }", "trans_code": "public static String getSmallestString ( String s , int k ) {\n  for ( int i = 0 ;\n  i < s . length ( ) ;\n  i ++ ) {\n    int dis = Math . min ( s . charAt ( i ) - 'a' , 'z' - s . charAt ( i ) + 1 ) ;\n    if ( dis > k ) {\n      s . charAt ( i ) - = k ;\n      break ;\n    }\n    s . charAt ( i ) = 'a' ;\n    k -= dis ;\n  }\n  return s ;\n}\n", "reference_code": "    public static String getSmallestString(String s, int k) {\n        char[] t = s.toCharArray();\n        for (int i = 0; i < t.length; i++) {\n            int dis = Math.min(t[i] - 'a', 'z' - t[i] + 1);\n            if (dis > k) {\n                t[i] -= k;\n                break;\n            }\n            t[i] = 'a';\n            k -= dis;\n        }\n        return new String(t);\n    }", "target_Lan": "java###getSmallestString_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\n\npublic class getSmallestString_Test {\n// TOFILL\npublic static void main(String[] args) {\n    System.out.println(getSmallestString(\"abc\", 2));\n    System.out.println(getSmallestString(\"xyz\", 3));\n    System.out.println(getSmallestString(\"aaa\", 1));\n    System.out.println(getSmallestString(\"zzz\", 2));\n    System.out.println(getSmallestString(\"xyz\", 5));\n}\n}"}, {"source_Lan": "cpp###sumDigitDifferences.cpp", "source_code": "    long long sumDigitDifferences(vector<int>& nums) {\n        long long ans = 0;\n        vector<array<int, 10>> cnt(to_string(nums[0]).length());\n        for (int k = 0; k < nums.size(); k++) {\n            int x = nums[k];\n            for (int i = 0; x; x /= 10, i++) {\n                int d = x % 10;\n                ans += k - cnt[i][d]++;\n            }\n        }\n        return ans;\n    }", "trans_code": "public static long sumDigitDifferences ( int [ ] nums ) {\n  long ans = 0 ;\n  int [ ] [ ] cnt = new int [ nums . length ] [ nums . length ] ;\n  for ( int k = 0 ;\n  k < nums . length ;\n  k ++ ) {\n    int x = nums [ k ] ;\n    for ( int i = 0 ;\n    x ;\n    x /= 10 , i ++ ) {\n      int d = x % 10 ;\n      ans += k - cnt [ i ] [ d ] ++ ;\n    }\n  }\n  return ans ;\n}\n", "reference_code": "    public static long sumDigitDifferences(int[] nums) {\n        long ans = 0;\n        int[][] cnt = new int[Integer.toString(nums[0]).length()][10];\n        for (int k = 0; k < nums.length; k++) {\n            int x = nums[k];\n            for (int i = 0; x > 0; x /= 10, i++) {\n                int d = x % 10;\n                ans += k - cnt[i][d]++;\n            }\n        }\n        return ans;\n    }", "target_Lan": "java###sumDigitDifferences_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\n\npublic class sumDigitDifferences_Test {\n// TOFILL\npublic static void main(String[] args) {\n    System.out.println(sumDigitDifferences(new int[]{1, 2, 3, 4, 5}));\n    System.out.println(sumDigitDifferences(new int[]{10, 20, 30, 40, 50}));\n    System.out.println(sumDigitDifferences(new int[]{100, 200, 300, 400, 500}));\n    System.out.println(sumDigitDifferences(new int[]{1000, 2000, 3000, 4000, 5000}));\n    System.out.println(sumDigitDifferences(new int[]{10000, 20000, 30000, 40000, 50000}));\n}\n}"}, {"source_Lan": "cpp###compressedString.cpp", "source_code": "    string compressedString(string word) {\n        string t;\n        int i0 = -1;\n        for (int i = 0; i < word.length(); i++) {\n            char c = word[i];\n            if (i + 1 == word.length() || c != word[i + 1]) {\n                int k = i - i0;\n                for (int j = 0; j < k / 9; j++) {\n                    t += '9';\n                    t += c;\n                }\n                if (k % 9) {\n                    t += '0' + (k % 9);\n                    t += c;\n                }\n                i0 = i;\n            }\n        }\n        return t;\n    }", "trans_code": "public static String compressedString ( String word ) {\n  StringBuilder t = new StringBuilder ( ) ;\n  int i0 = - 1 ;\n  for ( int i = 0 ;\n  i < word . length ( ) ;\n  i ++ ) {\n    char c = word . charAt ( i ) ;\n    if ( i + 1 == word . length ( ) || c != word . charAt ( i + 1 ) ) {\n      int k = i - i0 ;\n      for ( int j = 0 ;\n      j < k / 9 ;\n      j ++ ) {\n        t . append ( '9' ) ;\n        t . append ( c ) ;\n      }\n      if ( k % 9 ) {\n        t . append ( '0' + ( k % 9 ) ) ;\n        t . append ( c ) ;\n      }\n      i0 = i ;\n    }\n  }\n  return t . toString ( ) ;\n}\n", "reference_code": "    public static String compressedString(String word) {\n        StringBuilder t = new StringBuilder();\n        char[] s = word.toCharArray();\n        int i0 = -1;\n        for (int i = 0; i < s.length; i++) {\n            char c = s[i];\n            if (i + 1 == s.length || c != s[i + 1]) {\n                int k = i - i0;\n                for (int j = 0; j < k / 9; j++) {\n                    t.append('9').append(c);\n                }\n                if (k % 9 > 0) {\n                    t.append((char) ('0' + (k % 9))).append(c);\n                }\n                i0 = i;\n            }\n        }\n        return t.toString();\n    }", "target_Lan": "java###compressedString_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.*;\npublic class compressedString_Test {\n// TOFILL\n    public static void main(String[] args) {\n        System.out.println(compressedString(\"a\"));\n        System.out.println(compressedString(\"aaa\"));\n        System.out.println(compressedString(\"bbb\"));\n        System.out.println(compressedString(\"abcabcabc\"));\n        System.out.println(compressedString(\"aaaaaaaaaa\"));\n    }\n}"}, {"source_Lan": "cpp###numberOfChild.cpp", "source_code": "   int numberOfChild(int n, int k) {\n       int a = k / (n - 1), b = k % (n - 1);\n       return (a & 1) == 0 ? b : n - 1 - b;\n   }", "trans_code": "public static int numberOfChild ( int n , int k ) {\n  int a = k / ( n - 1 ) , b = k % ( n - 1 ) ;\n  return ( a & 1 ) == 0 ? b : n - 1 - b ;\n}\n", "reference_code": "    public static int numberOfChild(int n, int k) {\n        int ans=0;\n        for(int neg=-1;k!=0;k--){\n            if(ans==0||ans==n-1){neg*=-1;}\n            ans+=neg;\n        }\n        return ans;\n    }", "target_Lan": "java###numberOfChild_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\n\npublic class numberOfChild_Test {\n// TOFILL\npublic static void main(String[] args) {\n    System.out.println(numberOfChild(2, 1));\n    System.out.println(numberOfChild(10, 1));\n    System.out.println(numberOfChild(1000, 999));\n    System.out.println(numberOfChild(5, 2));\n    System.out.println(numberOfChild(10, 9));\n}\n}"}, {"source_Lan": "cpp###countCompleteDayPairs.cpp", "source_code": "    long long countCompleteDayPairs(vector<int> &hours) {\n        long long ans = 0;\n        int cnt[24]{};\n        for (int t : hours) {\n            \n            \n            ans += cnt[(24 - t % 24) % 24];\n            cnt[t % 24]++;\n        }\n        return ans;\n    }", "trans_code": "public static long countCompleteDayPairs ( int [ ] hours ) {\n  long ans = 0 ;\n  int [ ] cnt = new int [ 24 ] ;\n  for ( int t : hours ) {\n    ans += cnt [ ( 24 - t % 24 ) % 24 ] ;\n    cnt [ t % 24 ] ++ ;\n  }\n  return ans ;\n}\n", "reference_code": "    public static long countCompleteDayPairs(int[] hours) {\n        long ans = 0;\n        int[] cnt = new int[24];\n        for (int t : hours) {\n            \n            \n            ans += cnt[(24 - t % 24) % 24];\n            cnt[t % 24]++;\n        }\n        return ans;\n    }", "target_Lan": "java###countCompleteDayPairs_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\n\npublic class countCompleteDayPairs_Test {\n// TOFILL\npublic static void main(String[] args) {\n    System.out.println(countCompleteDayPairs(new int[]{0}));\n    System.out.println(countCompleteDayPairs(new int[]{12}));\n    System.out.println(countCompleteDayPairs(new int[]{24}));\n    System.out.println(countCompleteDayPairs(new int[]{25, 30}));\n    System.out.println(countCompleteDayPairs(new int[]{0, 24, 30}));\n}\n}"}, {"source_Lan": "cpp###minimumArea.cpp", "source_code": "    int minimumArea(vector<vector<int>>& grid) {\n        int left = grid[0].size(), right = 0, top = grid.size(), bottom = 0;\n        for (int i = 0; i < grid.size(); i++) {\n            for (int j = 0; j < grid[i].size(); j++) {\n                if (grid[i][j]) {\n                    left = min(left, j);\n                    right = max(right, j);\n                    top = min(top, i);\n                    bottom = i;\n                }\n            }\n        }\n        return (right - left + 1) * (bottom - top + 1);\n    }", "trans_code": "public static int minimumArea ( int [ ] [ ] grid ) {\n  int left = grid [ 0 ] . length , right = 0 , top = grid . length , bottom = 0 ;\n  for ( int i = 0 ;\n  i < grid . length ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < grid [ i ] . length ;\n    j ++ ) {\n      if ( grid [ i ] [ j ] ) {\n        left = Math . min ( left , j ) ;\n        right = Math . max ( right , j ) ;\n        top = Math . min ( top , i ) ;\n        bottom = i ;\n      }\n    }\n  }\n  return ( right - left + 1 ) * ( bottom - top + 1 ) ;\n}\n", "reference_code": "    public static int minimumArea(int[][] grid) {\n        int left = grid[0].length;\n        int right = 0;\n        int top = grid.length;\n        int bottom = 0;\n        for (int i = 0; i < grid.length; i++) {\n            for (int j = 0; j < grid[i].length; j++) {\n                if (grid[i][j] == 1) {\n                    left = Math.min(left, j);\n                    right = Math.max(right, j);\n                    top = Math.min(top, i);\n                    bottom = i;\n                }\n            }\n        }\n        return (right - left + 1) * (bottom - top + 1);\n    }", "target_Lan": "java###minimumArea_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.Arrays;\npublic class minimumArea_Test {\n// TOFILL\n    public static void main(String[] args) {\n        int[][] grid1 = {{1,0,1,0,1},{0,0,0,0,0},{1,0,1,0,1}};\n        int[][] grid2 = {{1,1,1,1,1},{1,1,1,1,1},{1,1,1,1,1}};\n        int[][] grid3 = {{0,0,0,0,0},{0,0,0,0,0},{0,0,0,0,0}};\n        int[][] grid4 = {{1,0,0,0,1},{0,0,0,0,0},{1,0,0,0,1}};\n        int[][] grid5 = {{0,1,1,1,0},{1,1,1,1,1},{0,1,1,1,0}};\n\n        System.out.println(minimumArea(grid1));\n        System.out.println(minimumArea(grid2));\n        System.out.println(minimumArea(grid3));\n        System.out.println(minimumArea(grid4));\n        System.out.println(minimumArea(grid5));\n    }\n}"}, {"source_Lan": "cpp###maximumLength.cpp", "source_code": "    int maximumLength(vector<int>& nums, int k) {\n        int ans = 0;\n        vector<vector<int>> f(k, vector<int>(k));\n        for (int x : nums) {\n            x %= k;\n            for (int y = 0; y < k; y++) {\n                f[y][x] = f[x][y] + 1;\n                ans = max(ans, f[y][x]);\n            }\n        }\n        return ans;\n    }", "trans_code": "public static int maximumLength ( int [ ] [ ] nums , int k ) {\n  int ans = 0 ;\n  int [ ] [ ] f = new int [ k ] [ k ] ;\n  for ( int x : nums ) {\n    x %= k ;\n    for ( int y = 0 ;\n    y < k ;\n    y ++ ) {\n      f [ y ] [ x ] = f [ x ] [ y ] + 1 ;\n      ans = Math . max ( ans , f [ y ] [ x ] ) ;\n    }\n  }\n  return ans ;\n}\n", "reference_code": "    public static int maximumLength(int[] nums, int k) {\n        int ans = 0;\n        int[][] f = new int[k][k];\n        for (int x : nums) {\n            x %= k;\n            for (int y = 0; y < k; y++) {\n                f[y][x] = f[x][y] + 1;\n                ans = Math.max(ans, f[y][x]);\n            }\n        }\n        return ans;\n    }", "target_Lan": "java###maximumLength_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.Arrays;\npublic class maximumLength_Test {\n// TOFILL\n    public static void main(String[] args) {\n        int[] input1 = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n        int[] input2 = {2, 4, 6, 8, 10, 12, 14, 16, 18, 20};\n        int[] input3 = {3, 6, 9, 12, 15, 18, 21, 24, 27, 30};\n        int[] input4 = {4, 8, 12, 16, 20, 24, 28, 32, 36, 40};\n        int[] input5 = {5, 10, 15, 20, 25, 30, 35, 40, 45, 50};\n        int k1 = 1;\n        int k2 = 2;\n        int k3 = 3;\n        int k4 = 4;\n        int k5 = 5;\n        System.out.println(maximumLength(input1, k1));\n        System.out.println(maximumLength(input2, k2));\n        System.out.println(maximumLength(input3, k3));\n        System.out.println(maximumLength(input4, k4));\n        System.out.println(maximumLength(input5, k5));\n    }\n}"}, {"source_Lan": "cpp###triangleType.cpp", "source_code": "    string triangleType(vector<int> &nums) {\n        sort(nums.begin(), nums.end());\n        int x = nums[0], y = nums[1], z = nums[2];\n        if (x + y <= z) { \n            return \"none\";\n        }\n        if (x == z) { \n            return \"equilateral\";\n        }\n        if (x == y || y == z) {\n            return \"isosceles\";\n        }\n        return \"scalene\";\n    }", "trans_code": "public static String triangleType ( int [ ] nums ) {\n  Arrays . sort ( nums ) ;\n  int x = nums [ 0 ] , y = nums [ 1 ] , z = nums [ 2 ] ;\n  if ( x + y <= z ) {\n    return \"none\" ;\n  }\n  if ( x == z ) {\n    return \"equilateral\" ;\n  }\n  if ( x == y || y == z ) {\n    return \"isosceles\" ;\n  }\n  return \"scalene\" ;\n}\n", "reference_code": "    public static String triangleType(int[] nums) {\n        Arrays.sort(nums);\n        int x = nums[0];\n        int y = nums[1];\n        int z = nums[2];\n        if (x + y <= z) { \n            return \"none\";\n        }\n        if (x == z) { \n            return \"equilateral\";\n        }\n        if (x == y || y == z) {\n            return \"isosceles\";\n        }\n        return \"scalene\";\n    }", "target_Lan": "java###triangleType_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.Arrays;\npublic class triangleType_Test {\n// TOFILL\n    public static void main(String[] args) {\n        System.out.println(triangleType(new int[]{3, 3, 3}));\n        System.out.println(triangleType(new int[]{3, 4, 5}));\n        System.out.println(triangleType(new int[]{3, 3, 4}));\n        System.out.println(triangleType(new int[]{3, 4, 7}));\n        System.out.println(triangleType(new int[]{2, 2, 3}));\n    }\n}"}, {"source_Lan": "cpp###sumOfPower.cpp", "source_code": "    int sumOfPower(vector<int> &nums, int k) {\n        const int MOD = 1'000'000'007;\n        int n = nums.size();\n        vector<vector<int>> f(k + 1, vector<int>(n + 1));\n        f[0][0] = 1;\n        for (int i = 0; i < n; i++) {\n            for (int j = k; j >= nums[i]; j--) {\n                for (int c = i + 1; c > 0; c--) {\n                    f[j][c] = (f[j][c] + f[j - nums[i]][c - 1]) % MOD;\n                }\n            }\n        }\n        int ans = 0;\n        int pow2 = 1;\n        for (int i = n; i > 0; i--) {\n            ans = (ans + (long long) f[k][i] * pow2) % MOD;\n            pow2 = pow2 * 2 % MOD;\n        }\n        return ans;\n    }", "trans_code": "public static int sumOfPower ( int [ ] nums , int k ) {\n  final int MOD = 1 '000' 000 '007' ;\n  int n = nums . length ;\n  int [ ] [ ] f = new int [ k + 1 ] [ n + 1 ] ;\n  f [ 0 ] [ 0 ] = 1 ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    for ( int j = k ;\n    j >= nums [ i ] ;\n    j -- ) {\n      for ( int c = i + 1 ;\n      c > 0 ;\n      c -- ) {\n        f [ j ] [ c ] = ( f [ j ] [ c ] + f [ j - nums [ i ] ] [ c - 1 ] ) % MOD ;\n      }\n    }\n  }\n  int ans = 0 ;\n  int pow2 = 1 ;\n  for ( int i = n ;\n  i > 0 ;\n  i -- ) {\n    ans = ( ans + ( long ) f [ k ] [ i ] * pow2 ) % MOD ;\n    pow2 = pow2 * 2 % MOD ;\n  }\n  return ans ;\n}\n", "reference_code": "    public static int sumOfPower(int[] nums, int k) {\n        final int MOD = 1_000_000_007;\n        int n = nums.length;\n        int[][] f = new int[k + 1][n + 1];\n        f[0][0] = 1;\n        for (int i = 0; i < n; i++) {\n            for (int j = k; j >= nums[i]; j--) {\n                for (int c = i + 1; c > 0; c--) {\n                    f[j][c] = (f[j][c] + f[j - nums[i]][c - 1]) % MOD;\n                }\n            }\n        }\n        long ans = 0;\n        int pow2 = 1;\n        for (int i = n; i > 0; i--) {\n            ans = (ans + (long) f[k][i] * pow2) % MOD;\n            pow2 = pow2 * 2 % MOD;\n        }\n        return (int) ans;\n    }", "target_Lan": "java###sumOfPower_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.Arrays;\npublic class sumOfPower_Test {\n// TOFILL\n    public static void main(String[] args) {\n        System.out.println(sumOfPower(new int[]{1, 2, 3}, 5));\n        System.out.println(sumOfPower(new int[]{4, 5, 6, 7}, 8));\n        System.out.println(sumOfPower(new int[]{10, 20, 30}, 0));\n        System.out.println(sumOfPower(new int[]{0, 0, 0}, 10));\n        System.out.println(sumOfPower(new int[]{100, 1000, 10000}, 100000));\n    }\n}"}, {"source_Lan": "cpp###scoreOfString.cpp", "source_code": "    int scoreOfString(string s) {\n        int ans = 0;\n        for (int i = 1; i < s.length(); i++) {\n            ans += abs(s[i] - s[i - 1]);\n        }\n        return ans;\n    }", "trans_code": "public static int scoreOfString ( String s ) {\n  int ans = 0 ;\n  for ( int i = 1 ;\n  i < s . length ( ) ;\n  i ++ ) ans += Math . abs ( s . charAt ( i ) - s . charAt ( i - 1 ) ) ;\n  return ans ;\n}\n", "reference_code": "    public static int scoreOfString(String S) {\n        char[] s = S.toCharArray();\n        int ans = 0;\n        for (int i = 1; i < s.length; i++) {\n            ans += Math.abs(s[i] - s[i - 1]);\n        }\n        return ans;\n    }", "target_Lan": "java###scoreOfString_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.Arrays;\npublic class scoreOfString_Test {\n// TOFILL\n    public static void main(String[] args) {\n        System.out.println(scoreOfString(\"abc\"));\n        System.out.println(scoreOfString(\"aaa\"));\n        System.out.println(scoreOfString(\"abcd\"));\n        System.out.println(scoreOfString(\"xyz\"));\n        System.out.println(scoreOfString(\"cba\"));\n    }\n}"}, {"source_Lan": "cpp###satisfiesConditions.cpp", "source_code": "    bool satisfiesConditions(vector<vector<int>>& grid) {\n        for (int i = 0; i < grid.size(); i++) {\n            for (int j = 0; j < grid[i].size(); j++) {\n                if (j && grid[i][j] == grid[i][j - 1] || i && grid[i][j] != grid[i - 1][j]) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }", "trans_code": "public static boolean satisfiesConditions ( int [ ] [ ] grid ) {\n  for ( int i = 0 ;\n  i < grid . length ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < grid [ i ] . length ;\n    j ++ ) {\n      if ( j > 0 && grid [ i ] [ j ] == grid [ i ] [ j - 1 ] || i > 0 && grid [ i ] [ j ] != grid [ i - 1 ] [ j ] ) {\n        return false ;\n      }\n    }\n  }\n  return true ;\n}\n", "reference_code": "    public static boolean satisfiesConditions(int[][] grid) {\n        for (int i = 0; i < grid.length; i++) {\n            for (int j = 0; j < grid[i].length; j++) {\n                if (j > 0 && grid[i][j] == grid[i][j - 1] || i > 0 && grid[i][j] != grid[i - 1][j]) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }", "target_Lan": "java###satisfiesConditions_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\n\npublic class satisfiesConditions_Test {\n// TOFILL\npublic static void main(String[] args) {\n    int[][] input1 = {{1, 1, 1}, {1, 1, 1}, {1, 1, 1}};\n    System.out.println(satisfiesConditions(input1));\n\n    int[][] input2 = {{1, 2, 1}, {2, 2, 2}, {1, 2, 1}};\n    System.out.println(satisfiesConditions(input2));\n\n    int[][] input3 = {{1, 1, 1}, {2, 2, 2}, {3, 3, 3}};\n    System.out.println(satisfiesConditions(input3));\n\n    int[][] input4 = {{1, 2, 3}, {2, 2, 3}, {3, 3, 3}};\n    System.out.println(satisfiesConditions(input4));\n\n    int[][] input5 = {{1, 2, 3}, {2, 3, 3}, {3, 3, 4}};\n    System.out.println(satisfiesConditions(input5));\n}\n}"}, {"source_Lan": "cpp###minOperations.cpp", "source_code": "    int minOperations(vector<int>& nums) {\n        int n = nums.size();\n        int ans = 0;\n        for (int i = 0; i < n - 2; i++) {\n            if (nums[i] == 0) {\n                nums[i + 1] ^= 1;\n                nums[i + 2] ^= 1;\n                ans++;\n            }\n        }\n        return nums[n - 2] && nums[n - 1] ? ans : -1;\n    }", "trans_code": "public static int minOperations ( int [ ] nums ) {\n  int n = nums . length ;\n  int ans = 0 ;\n  for ( int i = 0 ;\n  i < n - 2 ;\n  i ++ ) {\n    if ( nums [ i ] == 0 ) {\n      nums [ i + 1 ] ^= 1 ;\n      nums [ i + 2 ] ^= 1 ;\n      ans ++ ;\n    }\n  }\n  return nums [ n - 2 ] && nums [ n - 1 ] ? ans : - 1 ;\n}\n", "reference_code": "    public static int minOperations(int[] nums) {\n        int n = nums.length;\n        int ans = 0;\n        for (int i = 0; i < n - 2; i++) {\n            if (nums[i] == 0) {\n                nums[i + 1] ^= 1;\n                nums[i + 2] ^= 1;\n                ans++;\n            }\n        }\n        return nums[n - 2] != 0 && nums[n - 1] != 0 ? ans : -1;\n    }", "target_Lan": "java###minOperations_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\n\npublic class minOperations_Test {\n// TOFILL\npublic static void main(String[] args) {\n    int[] nums1 = {0, 0, 0, 0};\n    int[] nums2 = {1, 1, 1, 1};\n    int[] nums3 = {0, 1, 0, 1};\n    int[] nums4 = {1, 0, 1, 0};\n    int[] nums5 = {0, 0, 0, 1, 0, 0};\n\n    System.out.println(minOperations(nums1));\n    System.out.println(minOperations(nums2));\n    System.out.println(minOperations(nums3));\n    System.out.println(minOperations(nums4));\n    System.out.println(minOperations(nums5));\n}\n}"}, {"source_Lan": "cpp###countAlternatingSubarrays.cpp", "source_code": "    long long countAlternatingSubarrays(vector<int>& nums) {\n        long long res = 0, cur = 0;\n        int pre = -1;\n        for (int a : nums) {\n            cur = (pre != a) ? cur + 1 : 1;\n            pre = a;\n            res += cur;\n        }\n        return res;\n    }", "trans_code": "public static long countAlternatingSubarrays ( int [ ] nums ) {\n  long res = 0 , cur = 0 ;\n  int pre = - 1 ;\n  for ( int a : nums ) {\n    cur = ( pre != a ) ? cur + 1 : 1 ;\n    pre = a ;\n    res += cur ;\n  }\n  return res ;\n}\n", "reference_code": "    public static long countAlternatingSubarrays(int[] nums) {\n        long res = 0, cur = 0;\n        int pre = -1;\n        for (int a : nums) {\n            cur = (pre != a) ? cur + 1 : 1;\n            pre = a;\n            res += cur;\n        }\n        return res;\n    }", "target_Lan": "java###countAlternatingSubarrays_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.Arrays;\npublic class countAlternatingSubarrays_Test {\n// TOFILL\n    public static void main(String[] args) {\n        System.out.println(countAlternatingSubarrays(new int[]{1,2,3,4,5}));\n        System.out.println(countAlternatingSubarrays(new int[]{1,1,1,1,1}));\n        System.out.println(countAlternatingSubarrays(new int[]{1,2,3,2,1}));\n        System.out.println(countAlternatingSubarrays(new int[]{1,3,2,4,6,5}));\n        System.out.println(countAlternatingSubarrays(new int[]{2,2,2,2,2,2}));\n    }\n}"}, {"source_Lan": "cpp###modifiedMatrix.cpp", "source_code": "    vector<vector<int>> modifiedMatrix(vector<vector<int>>& matrix) {\n        int n = matrix.size();\n        int m = matrix[0].size();\n        for (int j = 0; j < m; j++) {\n            int zd = -1;\n            for (int i = 0; i < n; i++) {\n                zd = max(zd, matrix[i][j]);\n            }\n            for (int i = 0; i < n; i++) {\n                if (matrix[i][j] == -1) {\n                    matrix[i][j] = zd;\n                }\n            }\n        }\n        return matrix;\n    }", "trans_code": "public static int [ ] [ ] modifiedMatrix ( int [ ] [ ] matrix ) {\n  int n = matrix . length ;\n  int m = matrix [ 0 ] . length ;\n  for ( int j = 0 ;\n  j < m ;\n  j ++ ) {\n    int zd = - 1 ;\n    for ( int i = 0 ;\n    i < n ;\n    i ++ ) zd = Math . max ( zd , matrix [ i ] [ j ] ) ;\n    for ( int i = 0 ;\n    i < n ;\n    i ++ ) {\n      if ( matrix [ i ] [ j ] == - 1 ) matrix [ i ] [ j ] = zd ;\n    }\n  }\n  return matrix ;\n}\n", "reference_code": "    public static int[][] modifiedMatrix(int[][] matrix) {\n        int n = matrix.length; \n        int m = matrix[0].length; \n        for (int j = 0; j < m; j++) {\n            int zd = -1; \n            for (int i = 0; i < n; i++) {\n                zd = Math.max(zd, matrix[i][j]); \n            }\n            for (int i = 0; i < n; i++) {\n                if (matrix[i][j] == -1) {\n                    matrix[i][j] = zd; \n                }\n            }\n        }\n        return matrix; \n    }", "target_Lan": "java###modifiedMatrix_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.Arrays;\npublic class modifiedMatrix_Test {\n// TOFILL\n    public static void main(String[] args) {\n        int[][] matrix1 = {{1,2,3},{4,-1,6},{7,8,9}};\n        int[][] matrix2 = {{10,20,30},{40,-1,60},{70,80,90}};\n        int[][] matrix3 = {{-1,2,-3},{4,-1,-6},{-7,8,9}};\n        int[][] matrix4 = {{0,0,0},{0,-1,0},{0,0,0}};\n        int[][] matrix5 = {{1,-1,1},{-1,1,-1},{1,-1,1}};\n        \n        System.out.println(Arrays.deepToString(modifiedMatrix(matrix1)));\n        System.out.println(Arrays.deepToString(modifiedMatrix(matrix2)));\n        System.out.println(Arrays.deepToString(modifiedMatrix(matrix3)));\n        System.out.println(Arrays.deepToString(modifiedMatrix(matrix4)));\n        System.out.println(Arrays.deepToString(modifiedMatrix(matrix5)));\n    }\n}"}, {"source_Lan": "cpp###accountBalanceAfterPurchase.cpp", "source_code": "    int accountBalanceAfterPurchase(int purchaseAmount) {\n        int r = purchaseAmount % 10;\n        if (r < 5) {\n            purchaseAmount -= r;\n        } else {\n            purchaseAmount += 10 - r;\n        }\n        return 100 - purchaseAmount;\n    }", "trans_code": "public static int accountBalanceAfterPurchase ( int purchaseAmount ) {\n  int r = purchaseAmount % 10 ;\n  if ( r < 5 ) purchaseAmount -= r ;\n  else purchaseAmount += 10 - r ;\n  return 100 - purchaseAmount ;\n}\n", "reference_code": "    public static int accountBalanceAfterPurchase(int purchaseAmount) {\n        int r = purchaseAmount % 10;\n        if (r < 5) {\n            purchaseAmount -= r;\n        } else {\n            purchaseAmount += 10 - r;\n        }\n        return 100 - purchaseAmount;\n    }", "target_Lan": "java###accountBalanceAfterPurchase_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\n\npublic class accountBalanceAfterPurchase_Test {\n// TOFILL\npublic static void main(String[] args) {\n    System.out.println(accountBalanceAfterPurchase(0));\n    System.out.println(accountBalanceAfterPurchase(10));\n    System.out.println(accountBalanceAfterPurchase(5));\n    System.out.println(accountBalanceAfterPurchase(15));\n    System.out.println(accountBalanceAfterPurchase(17));\n}\n}"}, {"source_Lan": "cpp###maxOperations.cpp", "source_code": "    int maxOperations(vector<int>& nums) {\n        int n = nums.size(), t = 0;\n        for (int i = 1; i < n; i += 2) {\n            if (nums[i] + nums[i - 1] != nums[1] + nums[0]) {\n                break;\n            }\n            t++;\n        }\n        return t;\n    }", "trans_code": "public static int maxOperations ( int [ ] nums ) {\n  int n = nums . length , t = 0 ;\n  for ( int i = 1 ;\n  i < n ;\n  i += 2 ) {\n    if ( nums [ i ] + nums [ i - 1 ] != nums [ 1 ] + nums [ 0 ] ) {\n      break ;\n    }\n    t ++ ;\n  }\n  return t ;\n}\n", "reference_code": "    public static int maxOperations(int[] nums) {\n        int n = nums.length, t = 0;\n        for (int i = 1; i < n; i += 2) {\n            if (nums[i] + nums[i - 1] != nums[1] + nums[0]) {\n                break;\n            }\n            t++;\n        }\n        return t;\n    }", "target_Lan": "java###maxOperations_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.Arrays;\npublic class maxOperations_Test {\n// TOFILL\n    public static void main(String[] args) {\n        System.out.println(maxOperations(new int[]{1, 2, 3, 4}));\n        System.out.println(maxOperations(new int[]{2, 2, 2, 2}));\n        System.out.println(maxOperations(new int[]{1, 3, 5, 7}));\n        System.out.println(maxOperations(new int[]{10, 20, 30, 40}));\n        System.out.println(maxOperations(new int[]{5, 10, 15, 20}));\n    }\n}"}, {"source_Lan": "cpp###minimumSteps.cpp", "source_code": "    long long minimumSteps(string s) {\n        long long ans = 0;\n        int sum = 0;\n        for (int i = 0; i < s.size(); i++) {\n            if (s[i] == '1') {\n                sum++;\n            } else {\n                ans += sum;\n            }\n        }\n        return ans;\n    }", "trans_code": "public static long minimumSteps ( String s ) {\n  long ans = 0 ;\n  int sum = 0 ;\n  for ( int i = 0 ;\n  i < s . length ( ) ;\n  i ++ ) {\n    if ( s . charAt ( i ) == '1' ) sum ++ ;\n    else ans += sum ;\n  }\n  return ans ;\n}\n", "reference_code": "    public static long minimumSteps(String s) {\n        long ans = 0;\n        int sum = 0;\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == '1') {\n                sum++;\n            } else {\n                ans += sum;\n            }\n        }\n        return ans;\n    }", "target_Lan": "java###minimumSteps_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\n\npublic class minimumSteps_Test {\n// TOFILL\npublic static void main(String[] args) {\n    System.out.println(minimumSteps(\"0\"));\n    System.out.println(minimumSteps(\"1010101\"));\n    System.out.println(minimumSteps(\"1111111111\"));\n    System.out.println(minimumSteps(\"0000000000\"));\n    System.out.println(minimumSteps(\"1010101010\"));\n}\n}"}, {"source_Lan": "cpp###findMissingAndRepeatedValues.cpp", "source_code": "    vector<int> findMissingAndRepeatedValues(vector<vector<int>>& grid) {\n        int n = grid.size();\n        vector<int> count(n * n + 1);\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                count[grid[i][j]]++;\n            }\n        }\n        vector<int> res(2);\n        for (int i = 1; i <= n * n; i++) {\n            if (count[i] == 2) {\n                res[0] = i;\n            }\n            if (count[i] == 0) {\n                res[1] = i;\n            }\n        }\n        return res;\n    }", "trans_code": "public static int [ ] findMissingAndRepeatedValues ( int [ ] [ ] grid ) {\n  int n = grid . length ;\n  int [ ] count = new int [ n * n + 1 ] ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < n ;\n    j ++ ) {\n      count [ grid [ i ] [ j ] ] ++ ;\n    }\n  }\n  int [ ] res = new int [ 2 ] ;\n  for ( int i = 1 ;\n  i <= n * n ;\n  i ++ ) {\n    if ( count [ i ] == 2 ) res [ 0 ] = i ;\n    if ( count [ i ] == 0 ) res [ 1 ] = i ;\n  }\n  return res ;\n}\n", "reference_code": "    public static int[] findMissingAndRepeatedValues(int[][] grid) {\n        int n = grid.length;\n        int[] count = new int[n * n + 1];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                count[grid[i][j]]++;\n            }\n        }\n        int[] res = new int[2];\n        for (int i = 1; i <= n * n; i++) {\n            if (count[i] == 2) {\n                res[0] = i;\n            }\n            if (count[i] == 0) {\n                res[1] = i;\n            }\n        }\n        return res;\n    }", "target_Lan": "java###findMissingAndRepeatedValues_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.Arrays;\npublic class findMissingAndRepeatedValues_Test {\n// TOFILL\n    public static void main(String[] args) {\n        int[][] grid1 = {{1,2,3},{4,5,6},{7,8,9}};\n        int[][] grid2 = {{1,2,3},{1,4,5},{6,7,8}};\n        int[][] grid3 = {{1,2,3},{4,5,6},{8,9,7}};\n        int[][] grid4 = {{1,2,3},{4,5,6},{7,9,8}};\n        int[][] grid5 = {{2,3,4},{5,6,7},{8,9,1}};\n\n        System.out.println(Arrays.toString(findMissingAndRepeatedValues(grid1)));\n        System.out.println(Arrays.toString(findMissingAndRepeatedValues(grid2)));\n        System.out.println(Arrays.toString(findMissingAndRepeatedValues(grid3)));\n        System.out.println(Arrays.toString(findMissingAndRepeatedValues(grid4)));\n        System.out.println(Arrays.toString(findMissingAndRepeatedValues(grid5)));\n    }\n}"}, {"source_Lan": "cpp###distributeCandies2.cpp", "source_code": "    long long distributeCandies2(int n, int limit) {\n        long long ans = 0;\n        for (int i = 0; i <= min(limit, n); i++) {\n            if (n - i > 2 * limit) {\n                continue;\n            }\n            ans += min(n - i, limit) - max(0, n - i - limit) + 1;\n        }\n        return ans;\n    }", "trans_code": "public static long distributeCandies2 ( int n , int limit ) {\n  long ans = 0 ;\n  for ( int i = 0 ;\n  i <= Math . min ( limit , n ) ;\n  i ++ ) {\n    if ( n - i > 2 * limit ) {\n      continue ;\n    }\n    ans += Math . min ( n - i , limit ) - Math . max ( 0 , n - i - limit ) + 1 ;\n  }\n  return ans ;\n}\n", "reference_code": "    public static long distributeCandies2(int n, int limit) {\n        long ans = 0;\n        for (int i = 0; i <= Math.min(limit, n); i++) {\n            if (n - i > 2 * limit) {\n                continue;\n            }\n            ans += Math.min(n - i, limit) - Math.max(0, n - i - limit) + 1;\n        }\n        return ans;\n    }", "target_Lan": "java###distributeCandies2_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\n\npublic class distributeCandies2_Test {\n// TOFILL\npublic static void main(String[] args) {\n    System.out.println(distributeCandies2(1, 1));\n    System.out.println(distributeCandies2(2, 1));\n    System.out.println(distributeCandies2(2, 2));\n    System.out.println(distributeCandies2(3, 2));\n    System.out.println(distributeCandies2(5, 5));\n}\n}"}, {"source_Lan": "cpp###distributeCandies.cpp", "source_code": "    int distributeCandies(int n, int limit) {\n        int ans = 0;\n        for (int i = 0; i <= limit; i++) {\n            for (int j = 0; j <= limit; j++) {\n                if (i + j > n) {\n                    break;\n                }\n                if (n - i - j <= limit) {\n                    ans++;\n                }\n            }\n        }\n        return ans;\n    }", "trans_code": "public static int distributeCandies ( int n , int limit ) {\n  int ans = 0 ;\n  for ( int i = 0 ;\n  i <= limit ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j <= limit ;\n    j ++ ) {\n      if ( i + j > n ) {\n        break ;\n      }\n      if ( n - i - j <= limit ) {\n        ans ++ ;\n      }\n    }\n  }\n  return ans ;\n}\n", "reference_code": "    public static int distributeCandies(int n, int limit) {\n        int ans = 0;\n        for (int i = 0; i <= limit; i++) {\n            for (int j = 0; j <= limit; j++) {\n                if (i + j > n) {\n                    break;\n                }\n                if (n - i - j <= limit) {\n                    ans++;\n                }\n            }\n        }\n        return ans;\n    }", "target_Lan": "java###distributeCandies_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\n\npublic class distributeCandies_Test {\n// TOFILL\npublic static void main(String[] args) {\n    System.out.println(distributeCandies(0, 0));\n    System.out.println(distributeCandies(10, 3));\n    System.out.println(distributeCandies(15, 10));\n    System.out.println(distributeCandies(20, 5));\n    System.out.println(distributeCandies(25, 15));\n}\n}"}, {"source_Lan": "cpp###findIndices.cpp", "source_code": "    vector<int> findIndices(vector<int>& nums, int indexDifference, int valueDifference) {\n        for (int i = 0; i < nums.size(); i++) {\n            for (int j = i; j < nums.size(); j++) {\n                if (j - i >= indexDifference && abs(nums[j] - nums[i]) >= valueDifference) {\n                    return {i, j};\n                }\n            }\n        }\n        return {-1, -1};\n    }", "trans_code": "public static int [ ] findIndices ( int [ ] nums , int indexDifference , int valueDifference ) {\n  for ( int i = 0 ;\n  i < nums . length ;\n  i ++ ) {\n    for ( int j = i ;\n    j < nums . length ;\n    j ++ ) {\n      if ( j - i >= indexDifference && Math . abs ( nums [ j ] - nums [ i ] ) >= valueDifference ) {\n        return new int [ ] {\n          i , j }\n          ;\n        }\n      }\n    }\n    return new int [ ] {\n      - 1 , - 1 }\n      ;\n    }\n    ", "reference_code": "    public static int[] findIndices(int[] nums, int indexDifference, int valueDifference) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i; j < nums.length; j++) {\n                if (j - i >= indexDifference && Math.abs(nums[j] - nums[i]) >= valueDifference) {\n                    return new int[]{i, j};\n                }\n            }\n        }\n        return new int[]{-1, -1};\n    }", "target_Lan": "java###findIndices_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.Arrays;\npublic class findIndices_Test {\n// TOFILL\n    public static void main(String[] args) {\n        System.out.println(Arrays.toString(findIndices(new int[]{1,2,3,4,5}, 2, 2)));\n        System.out.println(Arrays.toString(findIndices(new int[]{1,1,1,1,1}, 1, 0)));\n        System.out.println(Arrays.toString(findIndices(new int[]{1,2,3,2,1}, 2, 1)));\n        System.out.println(Arrays.toString(findIndices(new int[]{1,2,3,4,5}, 1, 0)));\n        System.out.println(Arrays.toString(findIndices(new int[]{5,4,3,2,1}, 4, 4)));\n    }\n}"}, {"source_Lan": "cpp###theMaximumAchievableX.cpp", "source_code": "    int theMaximumAchievableX(int num, int t) {\n        return num + 2 * t;\n    }", "trans_code": "public static int theMaximumAchievableX ( int num , int t ) {\n  return num + 2 * t ;\n}\n", "reference_code": "    public static int theMaximumAchievableX(int num, int t) {\n        return num + 2 * t;\n    }", "target_Lan": "java###theMaximumAchievableX_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\n\npublic class theMaximumAchievableX_Test {\n// TOFILL\npublic static void main(String[] args) {\n    System.out.println(theMaximumAchievableX(0, 0));\n    System.out.println(theMaximumAchievableX(1000000, 0));\n    System.out.println(theMaximumAchievableX(0, 1000000));\n    System.out.println(theMaximumAchievableX(1000000, 1000000));\n    System.out.println(theMaximumAchievableX(-1000000, 0));\n}\n}"}, {"source_Lan": "cpp###numberOfEmployeesWhoMetTarget.cpp", "source_code": "    int numberOfEmployeesWhoMetTarget(vector<int>& hours, int target) {\n        int ans = 0;\n        for (int i = 0; i < hours.size(); i++) {\n            if (hours[i] >= target) {\n                ans++;\n            }\n        }\n        return ans;\n    }", "trans_code": "public static int numberOfEmployeesWhoMetTarget ( int [ ] hours , int target ) {\n  int ans = 0 ;\n  for ( int i = 0 ;\n  i < hours . length ;\n  i ++ ) {\n    if ( hours [ i ] >= target ) ans ++ ;\n  }\n  return ans ;\n}\n", "reference_code": "    public static int numberOfEmployeesWhoMetTarget(int[] hours, int target) {\n        int ans = 0;\n        for (int i = 0; i < hours.length; i++) {\n            if (hours[i] >= target) {\n                ans++;\n            }\n        }\n        return ans;\n    }", "target_Lan": "java###numberOfEmployeesWhoMetTarget_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\n\npublic class numberOfEmployeesWhoMetTarget_Test {\n// TOFILL\npublic static void main(String[] args) {\n    System.out.println(numberOfEmployeesWhoMetTarget(new int[]{0, 1, 2, 3, 4}, 2));\n    System.out.println(numberOfEmployeesWhoMetTarget(new int[]{5, 5, 5, 5, 5}, 5));\n    System.out.println(numberOfEmployeesWhoMetTarget(new int[]{1, 2, 3, 4, 5}, 1));\n    System.out.println(numberOfEmployeesWhoMetTarget(new int[]{10, 20, 30, 40, 50}, 30));\n    System.out.println(numberOfEmployeesWhoMetTarget(new int[]{100, 200, 300, 400, 500}, 600));\n}\n}"}, {"source_Lan": "cpp###distanceTraveled.cpp", "source_code": "    int distanceTraveled(int mainTank, int additionalTank) {\n        int ans = 0;\n        while (mainTank >= 5) {\n            mainTank -= 5;\n            ans += 50;\n            if (additionalTank > 0) {\n                additionalTank--;\n                mainTank++;\n            }\n        }\n        return ans + mainTank * 10;\n    }", "trans_code": "public static int distanceTraveled ( int mainTank , int additionalTank ) {\n  int ans = 0 ;\n  while ( mainTank >= 5 ) {\n    mainTank -= 5 ;\n    ans += 50 ;\n    if ( additionalTank > 0 ) {\n      additionalTank -- ;\n      mainTank ++ ;\n    }\n  }\n  return ans + mainTank * 10 ;\n}\n", "reference_code": "    public static int distanceTraveled(int mainTank, int additionalTank) {\n        int ans = 0;\n        while (mainTank >= 5) {\n            mainTank -= 5;\n            ans += 50;\n            if (additionalTank > 0) {\n                additionalTank--;\n                mainTank++;\n            }\n        }\n        return ans + mainTank * 10;\n    }", "target_Lan": "java###distanceTraveled_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\n\npublic class distanceTraveled_Test {\n// TOFILL\n    public static void main(String[] args) {\n        System.out.println(distanceTraveled(10, 2));\n        System.out.println(distanceTraveled(20, 3));\n        System.out.println(distanceTraveled(0, 0));\n        System.out.println(distanceTraveled(100, 10));\n        System.out.println(distanceTraveled(10, 0));\n    }\n}"}, {"source_Lan": "cpp###maximumBinaryString.cpp", "source_code": "    string maximumBinaryString(string binary) {\n        int n = binary.size();\n        int j = 0;\n        for (int i = 0; i < n; i++) {\n            if (binary[i] == '0') {\n                while (j <= i || (j < n && binary[j] == '1')) {\n                    j++;\n                }\n                if (j < n) {\n                    binary[j] = '1';\n                    binary[i] = '1';\n                    binary[i + 1] = '0';\n                }\n            }\n        }\n        return binary;\n    }", "trans_code": "public static String maximumBinaryString ( String binary ) {\n  int n = binary . length ( ) ;\n  int j = 0 ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    if ( binary . charAt ( i ) == '0' ) {\n      while ( j <= i || ( j < n && binary . charAt ( j ) == '1' ) ) j ++ ;\n      if ( j < n ) {\n        binary . setCharAt ( j , '1' ) ;\n        binary . setCharAt ( i , '1' ) ;\n        binary . setCharAt ( i + 1 , '0' ) ;\n      }\n    }\n  }\n  return binary ;\n}\n", "reference_code": "    public static String maximumBinaryString(String binary) {\n        int n = binary.length();\n        char[] s = binary.toCharArray();\n        int j = 0;\n        for (int i = 0; i < n; i++) {\n            if (s[i] == '0') {\n                while (j <= i || (j < n && s[j] == '1')) {\n                    j++;\n                }\n                if (j < n) {\n                    s[j] = '1';\n                    s[i] = '1';\n                    s[i + 1] = '0';\n                }\n            }\n        }\n        return new String(s);\n    }", "target_Lan": "java###maximumBinaryString_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.*;\npublic class maximumBinaryString_Test {\n// TOFILL\n    public static void main(String[] args) {\n        System.out.println(maximumBinaryString(\"110101\"));\n        System.out.println(maximumBinaryString(\"000000\"));\n        System.out.println(maximumBinaryString(\"111111\"));\n        System.out.println(maximumBinaryString(\"010101\"));\n        System.out.println(maximumBinaryString(\"101010\"));\n    }\n}"}, {"source_Lan": "cpp###findChampion.cpp", "source_code": "    int findChampion(int n, vector<vector<int>>& edges) {\n        vector<int> degree(n);\n        for (auto e : edges) {\n            degree[e[1]]++;\n        }\n        int champion = -1;\n        for (int i = 0; i < n; i++) {\n            if (degree[i] == 0) {\n                if (champion == -1) {\n                    champion = i;\n                } else {\n                    return -1;\n                }\n            }\n        }\n        return champion;\n    }", "trans_code": "public static int findChampion ( int n , List < List < Integer >> edges ) {\n  int [ ] degree = new int [ n ] ;\n  for ( List < Integer > e : edges ) degree [ e . get ( 1 ) ] ++ ;\n  int champion = - 1 ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    if ( degree [ i ] == 0 ) {\n      if ( champion == - 1 ) champion = i ;\n      else return - 1 ;\n    }\n  }\n  return champion ;\n}\n", "reference_code": "    public static int findChampion(int n, int[][] edges) {\n        int[] degree = new int[n];\n        for (int[] e : edges) {\n            degree[e[1]]++;\n        }\n        int champion = -1;\n        for (int i = 0; i < n; i++) {\n            if (degree[i] == 0) {\n                if (champion == -1) {\n                    champion = i;\n                } else {\n                    return -1;\n                }\n            }\n        }\n        return champion;\n    }", "target_Lan": "java###findChampion_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\n\npublic class findChampion_Test {\n// TOFILL\npublic static void main(String[] args) {\n    System.out.println(findChampion(0, new int[][]{}));\n    System.out.println(findChampion(1, new int[][]{}));\n    System.out.println(findChampion(2, new int[][]{{0,1}}));\n    System.out.println(findChampion(2, new int[][]{{1,0}}));\n    System.out.println(findChampion(3, new int[][]{{0,1}, {1,2}}));\n    System.out.println(findChampion(3, new int[][]{{0,1}, {0,2}}));\n    System.out.println(findChampion(3, new int[][]{{0,1}, {1,2}, {2,0}}));\n    System.out.println(findChampion(3, new int[][]{{0,1}, {1,2}, {2,1}}));\n    System.out.println(findChampion(4, new int[][]{{0,1}, {1,2}, {2,3}, {3,1}}));\n    System.out.println(findChampion(4, new int[][]{{0,1}, {1,2}, {2,3}, {3,2}}));\n}\n}"}, {"source_Lan": "cpp###firstDayBeenInAllRooms.cpp", "source_code": "    int firstDayBeenInAllRooms(vector<int>& nextVisit) {\n        int mod = 1e9 + 7;\n        int len = nextVisit.size();\n        vector<int> dp(len);\n        dp[0] = 2; \n        for (int i = 1; i < len; i++) {\n            int to = nextVisit[i];\n            dp[i] = 2 + dp[i - 1];\n            if (to != 0) {\n                dp[i] = (dp[i] - dp[to - 1] + mod) % mod; \n            }\n            dp[i] = (dp[i] + dp[i - 1]) % mod;\n        }\n        return dp[len - 2]; \n    }", "trans_code": "public static int firstDayBeenInAllRooms ( int [ ] nextVisit ) {\n  int mod = 1e9 + 7 ;\n  int len = nextVisit . length ;\n  int [ ] dp = new int [ len ] ;\n  dp [ 0 ] = 2 ;\n  for ( int i = 1 ;\n  i < len ;\n  i ++ ) {\n    int to = nextVisit [ i ] ;\n    dp [ i ] = 2 + dp [ i - 1 ] ;\n    if ( to != 0 ) dp [ i ] = ( dp [ i ] - dp [ to - 1 ] + mod ) % mod ;\n    dp [ i ] = ( dp [ i ] + dp [ i - 1 ] ) % mod ;\n  }\n  return dp [ len - 2 ] ;\n}\n", "reference_code": "    public static int firstDayBeenInAllRooms(int[] nextVisit) {\n        int mod = 1000000007;\n        int len = nextVisit.length;\n        int[] dp = new int[len];\n        dp[0] = 2; \n        for (int i = 1; i < len; i++) {\n            int to = nextVisit[i];\n            dp[i] = 2 + dp[i - 1];\n            if (to != 0) {\n                dp[i] = (dp[i] - dp[to - 1] + mod) % mod; \n            }\n            dp[i] = (dp[i] + dp[i - 1]) % mod;\n        }\n        return dp[len - 2]; \n    }", "target_Lan": "java###firstDayBeenInAllRooms_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\n\npublic class firstDayBeenInAllRooms_Test {\n// TOFILL\npublic static void main(String[] args) {\n    System.out.println(firstDayBeenInAllRooms(new int[]{1, 0, 0, 0, 0}));\n    System.out.println(firstDayBeenInAllRooms(new int[]{0, 1, 2, 3, 4}));\n    System.out.println(firstDayBeenInAllRooms(new int[]{4, 3, 2, 1, 0}));\n    System.out.println(firstDayBeenInAllRooms(new int[]{0, 0, 0, 0, 0}));\n}\n}"}, {"source_Lan": "cpp###maxArrayValue.cpp", "source_code": "    long long maxArrayValue(vector<int>& nums) {\n        long long sum = nums.back();\n        for (int i = nums.size() - 2; i >= 0; i--) {\n            sum = nums[i] <= sum ? nums[i] + sum : nums[i];\n        }\n        return sum;\n    }", "trans_code": "public static long maxArrayValue ( int [ ] nums ) {\n  long sum = nums [ nums . length - 1 ] ;\n  for ( int i = nums . length - 2 ;\n  i >= 0 ;\n  i -- ) sum = nums [ i ] <= sum ? nums [ i ] + sum : nums [ i ] ;\n  return sum ;\n}\n", "reference_code": "    public static long maxArrayValue(int[] nums) {\n        long sum = nums[nums.length - 1];\n        for (int i = nums.length - 2; i >= 0; i--) {\n            sum = nums[i] <= sum ? nums[i] + sum : nums[i];\n        }\n        return sum;\n    }", "target_Lan": "java###maxArrayValue_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.Arrays;\npublic class maxArrayValue_Test {\n// TOFILL\n    public static void main(String[] args) {\n        System.out.println(maxArrayValue(new int[] {0}));\n        System.out.println(maxArrayValue(new int[] {1, 2, 3, 4, 5}));\n        System.out.println(maxArrayValue(new int[] {-1, -2, -3, -4, -5}));\n        System.out.println(maxArrayValue(new int[] {10, 20, 30, 40, 50}));\n        System.out.println(maxArrayValue(new int[] {5, 10, 15, 20, 25}));\n    }\n}"}, {"source_Lan": "cpp###divisibilityArray.cpp", "source_code": "    vector<int> divisibilityArray(string word, int m) {\n        vector<int> res;\n        long long cur = 0;\n        for (char& c : word) {\n            cur = (cur * 10 + (c - '0')) % m;\n            res.push_back(cur == 0 ? 1 : 0);\n        }\n        return res;\n    }", "trans_code": "public static int [ ] divisibilityArray ( String word , int m ) {\n  int [ ] res = new int [ word . length ( ) ] ;\n  long cur = 0 ;\n  for ( char c : word . toCharArray ( ) ) {\n    cur = ( cur * 10 + ( c - '0' ) ) % m ;\n    res [ cur ] = cur == 0 ? 1 : 0 ;\n  }\n  return res ;\n}\n", "reference_code": "    public static int[] divisibilityArray(String word, int m) {\n        int[] res = new int[word.length()];\n        long cur = 0;\n        for (int i = 0; i < word.length(); i++) {\n            char c = word.charAt(i);\n            cur = (cur * 10 + (c - '0')) % m;\n            res[i] = (cur == 0) ? 1 : 0;\n        }\n        return res;\n    }", "target_Lan": "java###divisibilityArray_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.Arrays;\npublic class divisibilityArray_Test {\n// TOFILL\n    public static void main(String[] args) {\n        System.out.println(Arrays.toString(divisibilityArray(\"123456789\", 1)));\n        System.out.println(Arrays.toString(divisibilityArray(\"101010\", 2)));\n        System.out.println(Arrays.toString(divisibilityArray(\"2468\", 3)));\n        System.out.println(Arrays.toString(divisibilityArray(\"13579\", 5)));\n        System.out.println(Arrays.toString(divisibilityArray(\"1234567890123456789\", 19)));\n    }\n}"}, {"source_Lan": "cpp###findKOr.cpp", "source_code": "    int findKOr(vector<int>& nums, int k) {\n        int ans = 0;\n        for (int i = 0; i < 31; ++i) {\n            int cnt = 0;\n            for (int num: nums) {\n                if ((num >> i) & 1) {\n                    ++cnt;\n                }\n            }\n            if (cnt >= k) {\n                ans |= 1 << i;\n            }\n        }\n        return ans;\n    }", "trans_code": "public static int findKOr ( int [ ] nums , int k ) {\n  int ans = 0 ;\n  for ( int i = 0 ;\n  i < 31 ;\n  ++ i ) {\n    int cnt = 0 ;\n    for ( int num : nums ) {\n      if ( ( num >> i ) & 1 ) ++ cnt ;\n    }\n    if ( cnt >= k ) ans |= 1 << i ;\n  }\n  return ans ;\n}\n", "reference_code": "    public static int findKOr(int[] nums, int k) {\n        int ans = 0;\n        for (int i = 0; i < 31; ++i) {\n            int cnt = 0;\n            for (int num : nums) {\n                if (((num >> i) & 1) != 0) {\n                    ++cnt;\n                }\n            }\n            if (cnt >= k) {\n                ans |= 1 << i;\n            }\n        }\n        return ans;\n    }", "target_Lan": "java###findKOr_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.Arrays;\npublic class findKOr_Test {\n// TOFILL\n    public static void main(String[] args) {\n        System.out.println(findKOr(new int[]{}, 0));\n        System.out.println(findKOr(new int[]{1,2,3,4,5}, 2));\n        System.out.println(findKOr(new int[]{1,1,1,1,1}, 3));\n        System.out.println(findKOr(new int[]{10,20,30,40,50}, 1));\n        System.out.println(findKOr(new int[]{100,200,300,400,500}, 5));\n    }\n}"}, {"source_Lan": "cpp###minIncrements.cpp", "source_code": "    int minIncrements(int n, vector<int>& cost) {\n        int ans = 0;\n        for (int i = n - 2; i > 0; i -= 2) {\n            ans += abs(cost[i] - cost[i + 1]);\n            \n            cost[i / 2] += max(cost[i], cost[i + 1]);\n        }\n        return ans;\n    }", "trans_code": "public static int minIncrements ( int n , int [ ] cost ) {\n  int ans = 0 ;\n  for ( int i = n - 2 ;\n  i > 0 ;\n  i -= 2 ) {\n    ans += Math . abs ( cost [ i ] - cost [ i + 1 ] ) ;\n    cost [ i / 2 ] += Math . max ( cost [ i ] , cost [ i + 1 ] ) ;\n  }\n  return ans ;\n}\n", "reference_code": "    public static int minIncrements(int n, int[] cost) {\n        int ans = 0;\n        for (int i = n - 2; i > 0; i -= 2) {\n            ans += Math.abs(cost[i] - cost[i + 1]);\n            \n            cost[i / 2] += Math.max(cost[i], cost[i + 1]);\n        }\n        return ans;\n    }", "target_Lan": "java###minIncrements_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\n\npublic class minIncrements_Test {\n// TOFILL\n    public static void main(String[] args) {\n        int[] cost1 = {};\n        int[] cost2 = {1};\n        int[] cost3 = {1,2};\n        int[] cost4 = {1,2,3};\n        int[] cost5 = {1,2,3,4};\n\n        System.out.println(minIncrements(0, cost1));\n        System.out.println(minIncrements(1, cost2));\n        System.out.println(minIncrements(2, cost3));\n        System.out.println(minIncrements(3, cost4));\n        System.out.println(minIncrements(4, cost5));\n    }\n}"}, {"source_Lan": "cpp###maxNumberOfAlloys.cpp", "source_code": "    int maxNumberOfAlloys(int n, int k, int budget, vector<vector<int>>& composition, vector<int>& stock, vector<int>& cost) {\n        int left = 1, right = 2e8, ans = 0;\n        while (left <= right) {\n            int mid = (left + right) / 2;\n            bool valid = false;\n            for (int i = 0; i < k; ++i) {\n                long long spend = 0;\n                for (int j = 0; j < n; ++j) {\n                    spend += max(static_cast<long long>(composition[i][j]) * mid - stock[j], 0LL) * cost[j];\n                }\n                if (spend <= budget) {\n                    valid = true;\n                    break;\n                }\n            }\n            if (valid) {\n                ans = mid;\n                left = mid + 1;\n            }\n            else {\n                right = mid - 1;\n            }\n        }\n        return ans;\n    }", "trans_code": "public static int maxNumberOfAlloys ( int n , int k , int budget , int [ ] [ ] composition , int [ ] stock , int [ ] cost ) {\n  int left = 1 , right = 2e8 , ans = 0 ;\n  while ( left <= right ) {\n    int mid = ( left + right ) / 2 ;\n    boolean valid = false ;\n    for ( int i = 0 ;\n    i < k ;\n    ++ i ) {\n      long spend = 0 ;\n      for ( int j = 0 ;\n      j < n ;\n      ++ j ) {\n        spend += Math . max ( Long . numberOfLeadingZeros ( composition [ i ] [ j ] ) * mid - stock [ j ] , 0L L ) * cost [ j ] ;\n      }\n      if ( spend <= budget ) {\n        valid = true ;\n        break ;\n      }\n    }\n    if ( valid ) {\n      ans = mid ;\n      left = mid + 1 ;\n    }\n    else {\n      right = mid - 1 ;\n    }\n  }\n  return ans ;\n}\n", "reference_code": "    public static int maxNumberOfAlloys(int n, int k, int budget, List<List<Integer>> composition, List<Integer> stock, List<Integer> cost) {\n        int left = 1, right = 200000000, ans = 0;\n        while (left <= right) {\n            int mid = (left + right) / 2;\n            boolean valid = false;\n            for (int i = 0; i < k; ++i) {\n                long spend = 0;\n                for (int j = 0; j < n; ++j) {\n                    spend += Math.max((long) composition.get(i).get(j) * mid - stock.get(j), 0) * cost.get(j);\n                }\n                if (spend <= budget) {\n                    valid = true;\n                    break;\n                }\n            }\n            if (valid) {\n                ans = mid;\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n        return ans;\n    }", "target_Lan": "java###maxNumberOfAlloys_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.*;\npublic class maxNumberOfAlloys_Test {\n// TOFILL\n    public static void main(String[] args) {\n        List<List<Integer>> composition1 = Arrays.asList(Arrays.asList(3, 2, 1), Arrays.asList(2, 1, 3));\n        List<Integer> stock1 = Arrays.asList(5, 5, 5);\n        List<Integer> cost1 = Arrays.asList(10, 20, 30);\n        System.out.println(maxNumberOfAlloys(3, 2, 1000, composition1, stock1, cost1));\n\n        List<List<Integer>> composition2 = Arrays.asList(Arrays.asList(2, 1), Arrays.asList(1, 2));\n        List<Integer> stock2 = Arrays.asList(10, 10);\n        List<Integer> cost2 = Arrays.asList(100, 200);\n        System.out.println(maxNumberOfAlloys(2, 2, 500, composition2, stock2, cost2));\n\n        List<List<Integer>> composition3 = Arrays.asList(Arrays.asList(1));\n        List<Integer> stock3 = Arrays.asList(5);\n        List<Integer> cost3 = Arrays.asList(10);\n        System.out.println(maxNumberOfAlloys(1, 1, 100, composition3, stock3, cost3));\n\n        List<List<Integer>> composition4 = Arrays.asList(Arrays.asList(1, 2, 3), Arrays.asList(3, 2, 1), Arrays.asList(2, 3, 1));\n        List<Integer> stock4 = Arrays.asList(10, 10, 10);\n        List<Integer> cost4 = Arrays.asList(100, 200, 300);\n        System.out.println(maxNumberOfAlloys(3, 3, 2000, composition4, stock4, cost4));\n\n        List<List<Integer>> composition5 = Arrays.asList(Arrays.asList(3, 2, 1), Arrays.asList(2, 3, 1), Arrays.asList(1, 2, 3));\n        List<Integer> stock5 = Arrays.asList(20, 20, 20);\n        List<Integer> cost5 = Arrays.asList(100, 200, 300);\n        System.out.println(maxNumberOfAlloys(3, 3, 3000, composition5, stock5, cost5));\n    }\n}"}, {"source_Lan": "cpp###maximumSumOfHeights.cpp", "source_code": "    long long maximumSumOfHeights(vector<int>& maxHeights) {\n        int n = maxHeights.size();\n        long long res = 0;\n        for (int i = 0; i < n; i++) {\n            int pre = maxHeights[i];\n            long long sum = pre;\n            for (int j = i - 1; j >= 0; j--) {\n                pre = min(pre, maxHeights[j]);\n                sum += pre;\n            }\n            int suf = maxHeights[i];\n            for (int j = i + 1; j < n; j++) {\n                suf = min(suf, maxHeights[j]);\n                sum += suf;\n            }\n            res = max(res, sum);\n        }\n        return res;\n    }", "trans_code": "public static long maximumSumOfHeights ( int [ ] maxHeights ) {\n  int n = maxHeights . length ;\n  long res = 0 ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    int pre = maxHeights [ i ] ;\n    long sum = pre ;\n    for ( int j = i - 1 ;\n    j >= 0 ;\n    j -- ) {\n      pre = Math . min ( pre , maxHeights [ j ] ) ;\n      sum += pre ;\n    }\n    int suf = maxHeights [ i ] ;\n    for ( int j = i + 1 ;\n    j < n ;\n    j ++ ) {\n      suf = Math . min ( suf , maxHeights [ j ] ) ;\n      sum += suf ;\n    }\n    res = Math . max ( res , sum ) ;\n  }\n  return res ;\n}\n", "reference_code": "    public static long maximumSumOfHeights(List<Integer> maxHeights) {\n        int n = maxHeights.size();\n        long res = 0;\n        for (int i = 0; i < n; i++) {\n            int pre = maxHeights.get(i);\n            long sum = pre;\n            for (int j = i - 1; j >= 0; j--) {\n                pre = Math.min(pre, maxHeights.get(j));\n                sum += pre;\n            }\n            int suf = maxHeights.get(i);\n            for (int j = i + 1; j < n; j++) {\n                suf = Math.min(suf, maxHeights.get(j));\n                sum += suf;\n            }\n            res = Math.max(res, sum);\n        }\n        return res;\n    }", "target_Lan": "java###maximumSumOfHeights_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.*;\npublic class maximumSumOfHeights_Test {\n// TOFILL\n    public static void main(String[] args) {\n        System.out.println(maximumSumOfHeights(Arrays.asList(1, 2, 3, 4, 5)));\n        System.out.println(maximumSumOfHeights(Arrays.asList(10, 20, 30, 40, 50)));\n        System.out.println(maximumSumOfHeights(Arrays.asList(100, 200, 300, 400, 500)));\n        System.out.println(maximumSumOfHeights(Arrays.asList(1000, 2000, 3000, 4000, 5000)));\n        System.out.println(maximumSumOfHeights(Arrays.asList(10000, 20000, 30000, 40000, 50000)));\n    }\n}"}, {"source_Lan": "cpp###alternatingSubarray.cpp", "source_code": "    int alternatingSubarray(vector<int>& nums) {\n        int res = -1;\n        int n = nums.size();\n        for (int firstIndex = 0; firstIndex < n; firstIndex++) {\n            for (int i = firstIndex + 1; i < n; i++) {\n                int length = i - firstIndex + 1;\n                if (nums[i] - nums[firstIndex] == (length - 1) % 2) {\n                    res = max(res, length);\n                } else {\n                    break;\n                }\n            }\n        }\n        return res;\n    }", "trans_code": "public static int alternatingSubarray ( int [ ] nums ) {\n  int res = - 1 ;\n  int n = nums . length ;\n  for ( int firstIndex = 0 ;\n  firstIndex < n ;\n  firstIndex ++ ) {\n    for ( int i = firstIndex + 1 ;\n    i < n ;\n    i ++ ) {\n      int length = i - firstIndex + 1 ;\n      if ( nums [ i ] - nums [ firstIndex ] == ( length - 1 ) % 2 ) {\n        res = Math . max ( res , length ) ;\n      }\n      else {\n        break ;\n      }\n    }\n  }\n  return res ;\n}\n", "reference_code": "    public static int alternatingSubarray(int[] nums) {\n        int res = -1;\n        int n = nums.length;\n        for (int firstIndex = 0; firstIndex < n; firstIndex++) {\n            for (int i = firstIndex + 1; i < n; i++) {\n                int length = i - firstIndex + 1;\n                if (nums[i] - nums[firstIndex] == (length - 1) % 2) {\n                    res = Math.max(res, length);\n                } else {\n                    break;\n                }\n            }\n        }\n        return res;\n    }", "target_Lan": "java###alternatingSubarray_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.Arrays;\npublic class alternatingSubarray_Test {\n// TOFILL\n    public static void main(String[] args) {\n        System.out.println(alternatingSubarray(new int[]{1,2,3,4,5,6,7,8,9,10})); // input1\n        System.out.println(alternatingSubarray(new int[]{1,3,5,7,9})); // input2\n        System.out.println(alternatingSubarray(new int[]{2,4,6,8,10})); // input3\n        System.out.println(alternatingSubarray(new int[]{1,2,4,3,5,6})); // input4\n        System.out.println(alternatingSubarray(new int[]{10,9,8,7,6,5,4,3,2,1})); // input5\n    }\n}"}, {"source_Lan": "cpp###maximumRows.cpp", "source_code": "    int maximumRows(vector<vector<int>>& matrix, int numSelect) {\n        int m = matrix.size();\n        int n = matrix[0].size();\n        vector<int> mask(m, 0);\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++){\n                mask[i] += matrix[i][j] << (n - j - 1);\n            }\n        }\n        int res = 0;\n        int cur = 0;\n        int limit = (1 << n);\n        while ((++cur) < limit) {\n            if (__builtin_popcount(cur) != numSelect) {\n                continue;\n            }\n            int t = 0;\n            for (int j = 0; j < m; j++) {\n                if ((mask[j] & cur) == mask[j]) {\n                    ++t;\n                }\n            }\n            res = max(res, t);\n        }\n        return res;\n    }", "trans_code": "public static int maximumRows ( int [ ] [ ] matrix , int numSelect ) {\n  int m = matrix . length ;\n  int n = matrix [ 0 ] . length ;\n  int [ ] mask = new int [ m ] ;\n  for ( int i = 0 ;\n  i < m ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < n ;\n    j ++ ) {\n      mask [ i ] += matrix [ i ] [ j ] << ( n - j - 1 ) ;\n    }\n  }\n  int res = 0 ;\n  int cur = 0 ;\n  int limit = ( 1 << n ) ;\n  while ( ( ++ cur ) < limit ) {\n    if ( __builtin_popcount ( cur ) != numSelect ) {\n      continue ;\n    }\n    int t = 0 ;\n    for ( int j = 0 ;\n    j < m ;\n    j ++ ) {\n      if ( ( mask [ j ] & cur ) == mask [ j ] ) {\n        t ++ ;\n      }\n    }\n    res = Math . max ( res , t ) ;\n  }\n  return res ;\n}\n", "reference_code": "    public static int maximumRows(int[][] matrix, int numSelect) {\n        int m = matrix.length;\n        int n = matrix[0].length;\n        int[] mask = new int[m];\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++){\n                mask[i] += matrix[i][j] << (n - j - 1);\n            }\n        }\n        int res = 0;\n        int cur = 0;\n        int limit = (1 << n);\n        while (++cur < limit) {\n            if (Integer.bitCount(cur) != numSelect) {\n                continue;\n            }\n            int t = 0;\n            for (int j = 0; j < m; j++) {\n                if ((mask[j] & cur) == mask[j]) {\n                    ++t;\n                }\n            }\n            res = Math.max(res, t);\n        }\n        return res;\n    }", "target_Lan": "java###maximumRows_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.Arrays;\npublic class maximumRows_Test {\n// TOFILL\n    public static void main(String[] args) {\n        int[][] matrix1 = {{1,0,0,1,0},{0,0,1,1,0},{1,0,0,1,0},{0,0,0,0,0}};\n        int[][] matrix2 = {{1,1,1,1,1},{1,0,1,0,1},{1,1,1,1,1},{1,0,1,0,1}};\n        int[][] matrix3 = {{0,0,0,0,0},{0,0,0,0,0},{0,0,0,0,0},{0,0,0,0,0}};\n        int[][] matrix4 = {{1,1,1,1,1},{1,1,1,1,1},{1,1,1,1,1},{1,1,1,1,1}};\n        int[][] matrix5 = {{1,0,1,0,1},{0,1,0,1,0},{1,0,1,0,1},{0,1,0,1,0}};\n\n        System.out.println(maximumRows(matrix1, 2));\n        System.out.println(maximumRows(matrix2, 3));\n        System.out.println(maximumRows(matrix3, 2));\n        System.out.println(maximumRows(matrix4, 5));\n        System.out.println(maximumRows(matrix5, 4));\n    }\n}"}, {"source_Lan": "cpp###findEnemies.cpp", "source_code": "    vector<vector<int>> findEnemies(int n, int m, int k, vector<int> &col, vector<int> &count) {\n        vector<vector<int>> answer(n, vector<int>(m, -1));\n        int curr = 0;\n        int ind = 0;\n        while(curr < k && ind < n){\n            int total = count[ind];\n            while(total--){\n                answer[ind][col[curr]] = curr;\n                curr += 1;\n            }\n            ind += 1;\n        }\n        return answer;\n    }", "trans_code": "public static int [ ] [ ] findEnemies ( int n , int m , int k , int [ ] col , int [ ] count ) {\n  int [ ] [ ] answer = new int [ n ] [ m ] ;\n  int curr = 0 ;\n  int ind = 0 ;\n  while ( curr < k && ind < n ) {\n    int total = count [ ind ] ;\n    while ( total -- > 0 ) {\n      answer [ ind ] [ col [ curr ] ] = curr ;\n      curr += 1 ;\n    }\n    ind += 1 ;\n  }\n  return answer ;\n}\n", "reference_code": "    public static ArrayList<ArrayList<Integer>> findEnemies(int n, int m, int k, int[] col, int[] count) {\n        ArrayList<ArrayList<Integer>> answer = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            ArrayList<Integer> row = new ArrayList<>();\n            for (int j = 0; j < m; j++) {\n                row.add(-1);\n            }\n            answer.add(row);\n        }\n        int curr = 0;\n        int ind = 0;\n        while (curr < k && ind < n) {\n            int total = count[ind];\n            while (total-- > 0) {\n                answer.get(ind).set(col[curr], curr);\n                curr += 1;\n            }\n            ind += 1;\n        }\n        return answer;\n    }", "target_Lan": "java###findEnemies_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.ArrayList;\npublic class findEnemies_Test {\n// TOFILL\n    public static void main(String[] args) {\n        System.out.println(findEnemies(0, 0, 0, new int[]{}, new int[]{}));\n        System.out.println(findEnemies(1, 1, 1, new int[]{0}, new int[]{1}));\n        System.out.println(findEnemies(2, 2, 2, new int[]{0, 1}, new int[]{1, 1}));\n        System.out.println(findEnemies(3, 3, 3, new int[]{0, 1, 2}, new int[]{1, 1, 1}));\n        System.out.println(findEnemies(4, 4, 4, new int[]{0, 1, 2, 3}, new int[]{1, 1, 1, 1}));\n    }\n}"}, {"source_Lan": "cpp###maxPoints.cpp", "source_code": "    long long maxPoints(int n, vector<vector<int>> &arr) {\n        long long dp[200001] = {};\n        for (int i = n - 1; i >= 0; --i){\n            dp[i] = max(arr[i][0] + dp[arr[i][1] + i + 1], dp[i + 1]);\n}\n        return dp[0];\n    }", "trans_code": "public static long maxPoints ( int n , int [ ] [ ] arr ) {\n  long [ ] dp = new long [ 200001 ] ;\n  for ( int i = n - 1 ;\n  i >= 0 ;\n  i -- ) dp [ i ] = Math . max ( arr [ i ] [ 0 ] + dp [ arr [ i ] [ 1 ] + i + 1 ] , dp [ i + 1 ] ) ;\n  return dp [ 0 ] ;\n}\n", "reference_code": "    public static long maxPoints(int n, int[][] arr) {\n        long[] dp = new long[200001];\n        for (int i = n - 1; i >= 0; --i){\n            dp[i] = Math.max(arr[i][0] + dp[arr[i][1] + i + 1], dp[i + 1]);\n}\n        return dp[0];\n    }", "target_Lan": "java###maxPoints_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.Arrays;\npublic class maxPoints_Test {\n// TOFILL\n    public static void main(String[] args) {\n        System.out.println(maxPoints(0, new int[][]{}));\n        System.out.println(maxPoints(1, new int[][]{{1,0}}));\n        System.out.println(maxPoints(2, new int[][]{{1,0},{2,0}}));\n        System.out.println(maxPoints(3, new int[][]{{1,0},{2,0},{3,0}}));\n        System.out.println(maxPoints(4, new int[][]{{1,0},{2,0},{3,0},{4,0}}));\n    }\n}"}, {"source_Lan": "cpp###countOperations.cpp", "source_code": "    int countOperations(string s) {\n        const int mod = 1000000007;\n        int ans = 0;\n        int count_b = 0;\n        for (int i = s.length() - 1; i >= 0; --i) {\n            if (s[i] == 'b')\n                count_b = (count_b + 1) % mod;\n            else {\n                ans = (ans + count_b) % mod;\n                count_b = (count_b + count_b) % mod;\n            }\n        }\n        return ans;\n    }", "trans_code": "public static int countOperations ( String s ) {\n  final int mod = 1000000007 ;\n  int ans = 0 ;\n  int count_b = 0 ;\n  for ( int i = s . length ( ) - 1 ;\n  i >= 0 ;\n  i -- ) {\n    if ( s . charAt ( i ) == 'b' ) {\n      count_b = ( count_b + 1 ) % mod ;\n    }\n    else {\n      ans = ( ans + count_b ) % mod ;\n      count_b = ( count_b + count_b ) % mod ;\n    }\n  }\n  return ans ;\n}\n", "reference_code": "    public static int countOperations(String s) {\n        final int mod = 1000000007;\n        int ans = 0;\n        int count_b = 0;\n        for (int i = s.length() - 1; i >= 0; --i) {\n            if (s.charAt(i) == 'b') {\n                count_b = (count_b + 1) % mod;\n            } else {\n                ans = (ans + count_b) % mod;\n                count_b = (count_b + count_b) % mod;\n            }\n        }\n        return ans;\n    }", "target_Lan": "java###countOperations_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\n\npublic class countOperations_Test {\n// TOFILL\npublic static void main(String[] args) {\n    System.out.println(countOperations(\"ab\"));\n    System.out.println(countOperations(\"bbbb\"));\n    System.out.println(countOperations(\"aaa\"));\n    System.out.println(countOperations(\"baab\"));\n    System.out.println(countOperations(\"babab\"));\n}\n}"}, {"source_Lan": "cpp###maximumStrongIndices.cpp", "source_code": "    int maximumStrongIndices(int n, int x, int y, vector<int> &a, vector<int> &b) {\n        int j = 0, ans = 0;\n        for (int i = 0; i < n; i++) {\n            while (j < n && b[j] < a[i] - x)\n                j++;\n            if (j < n && b[j] <= a[i] + y) {\n                ans++;\n                j++;\n            }\n        }\n        return ans;\n    }", "trans_code": "public static int maximumStrongIndices ( int n , int x , int y , int [ ] a , int [ ] b ) {\n  int j = 0 , ans = 0 ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    while ( j < n && b [ j ] < a [ i ] - x ) {\n      j ++ ;\n    }\n    if ( j < n && b [ j ] <= a [ i ] + y ) {\n      ans ++ ;\n      j ++ ;\n    }\n  }\n  return ans ;\n}\n", "reference_code": "    public static int maximumStrongIndices(int n, int x, int y, int[] a, int[] b) {\n        int j = 0, ans = 0;\n        for (int i = 0; i < n; i++) {\n            while (j < n && b[j] < a[i] - x) {\n                j++;\n            }\n            if (j < n && b[j] <= a[i] + y) {\n                ans++;\n                j++;\n            }\n        }\n        return ans;\n    }", "target_Lan": "java###maximumStrongIndices_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.Arrays;\npublic class maximumStrongIndices_Test {\n// TOFILL\n    public static void main(String[] args) {\n        System.out.println(maximumStrongIndices(5, 2, 3, new int[]{1,2,3,4,5}, new int[]{0,1,2,3,4}));\n        System.out.println(maximumStrongIndices(5, 1, 1, new int[]{1,2,3,4,5}, new int[]{2,3,4,5,6}));\n        System.out.println(maximumStrongIndices(5, 0, 0, new int[]{1,2,3,4,5}, new int[]{1,2,3,4,5}));\n        System.out.println(maximumStrongIndices(5, 1, 1, new int[]{1,3,5,7,9}, new int[]{2,4,6,8,10}));\n        System.out.println(maximumStrongIndices(5, 1, 1, new int[]{2,4,6,8,10}, new int[]{1,3,5,7,9}));\n    }\n}"}, {"source_Lan": "cpp###minimumPushes.cpp", "source_code": "    int minimumPushes(string &word) {\n        int n = word.length();\n        int k = n / 8;\n        return (k * 4 + n % 8) * (k + 1);\n    }", "trans_code": "public static int minimumPushes ( String word ) {\n  int n = word . length ( ) ;\n  int k = n / 8 ;\n  return ( k * 4 + n % 8 ) * ( k + 1 ) ;\n}\n", "reference_code": "    public static int minimumPushes(String word) {\n        int n = word.length();\n        int k = n / 8;\n        return (k * 4 + n % 8) * (k + 1);\n    }", "target_Lan": "java###minimumPushes_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\n\npublic class minimumPushes_Test {\n// TOFILL\npublic static void main(String[] args) {\n    System.out.println(minimumPushes(\"a\"));\n    System.out.println(minimumPushes(\"abcdefgh\"));\n    System.out.println(minimumPushes(\"abcdefghijklmnop\"));\n    System.out.println(minimumPushes(\"abcdefghijklmnopqrstuvwxyz\"));\n    System.out.println(minimumPushes(\"abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz\"));\n}\n}"}, {"source_Lan": "cpp###minimumOperationsToWriteY.cpp", "source_code": "    int minimumOperationsToWriteY(vector<vector<int>> &grid) {\n        int cnt1[3]{}, cnt2[3]{};\n        int n = grid.size();\n        int m = n / 2;\n        for (int i = 0; i < m; i++) {\n            cnt1[grid[i][i]]++;\n            cnt1[grid[i][n - 1 - i]]++;\n            for (int j = 0; j < n; j++) {\n                if (j != i && j != n - 1 - i) {\n                    cnt2[grid[i][j]]++;\n                }\n            }\n        }\n        for (int i = m; i < n; i++) {\n            cnt1[grid[i][m]]++;\n            for (int j = 0; j < n; j++) {\n                if (j != m) {\n                    cnt2[grid[i][j]]++;\n                }\n            }\n        }\n        int max_not_change = 0;\n        for (int i = 0; i < 3; i++) {\n            for (int j = 0; j < 3; j++) {\n                if (i != j) {\n                    max_not_change = max(max_not_change, cnt1[i] + cnt2[j]);\n                }\n            }\n        }\n        return n * n - max_not_change;\n    }", "trans_code": "public static int minimumOperationsToWriteY ( int [ ] [ ] grid ) {\n  int [ ] cnt1 = new int [ 3 ] , cnt2 = new int [ 3 ] ;\n  int n = grid . length ;\n  int m = n / 2 ;\n  for ( int i = 0 ;\n  i < m ;\n  i ++ ) {\n    cnt1 [ grid [ i ] [ i ] ] ++ ;\n    cnt1 [ grid [ i ] [ n - 1 - i ] ] ++ ;\n    for ( int j = 0 ;\n    j < n ;\n    j ++ ) {\n      if ( j != i && j != n - 1 - i ) cnt2 [ grid [ i ] [ j ] ] ++ ;\n    }\n  }\n  for ( int i = m ;\n  i < n ;\n  i ++ ) {\n    cnt1 [ grid [ i ] [ m ] ] ++ ;\n    for ( int j = 0 ;\n    j < n ;\n    j ++ ) {\n      if ( j != m ) cnt2 [ grid [ i ] [ j ] ] ++ ;\n    }\n  }\n  int maxNotChange = 0 ;\n  for ( int i = 0 ;\n  i < 3 ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < 3 ;\n    j ++ ) {\n      if ( i != j ) maxNotChange = Math . max ( maxNotChange , cnt1 [ i ] + cnt2 [ j ] ) ;\n    }\n  }\n  return n * n - maxNotChange ;\n}\n", "reference_code": "    public static int minimumOperationsToWriteY(int[][] grid) {\n        int[] cnt1 = new int[3];\n        int[] cnt2 = new int[3];\n        int n = grid.length;\n        int m = n / 2;\n        for (int i = 0; i < m; i++) {\n            cnt1[grid[i][i]]++;\n            cnt1[grid[i][n - 1 - i]]++;\n            for (int j = 0; j < n; j++) {\n                if (j != i && j != n - 1 - i) {\n                    cnt2[grid[i][j]]++;\n                }\n            }\n        }\n        for (int i = m; i < n; i++) {\n            cnt1[grid[i][m]]++;\n            for (int j = 0; j < n; j++) {\n                if (j != m) {\n                    cnt2[grid[i][j]]++;\n                }\n            }\n        }\n        int maxNotChange = 0;\n        for (int i = 0; i < 3; i++) {\n            for (int j = 0; j < 3; j++) {\n                if (i != j) {\n                    maxNotChange = Math.max(maxNotChange, cnt1[i] + cnt2[j]);\n                }\n            }\n        }\n        return n * n - maxNotChange;\n    }", "target_Lan": "java###minimumOperationsToWriteY_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.Arrays;\npublic class minimumOperationsToWriteY_Test {\n// TOFILL\n    public static void main(String[] args) {\n        int[][] grid1 = {{0, 1, 2}, {1, 2, 0}, {2, 0, 1}};\n        int[][] grid2 = {{0, 0, 0}, {0, 0, 0}, {0, 0, 0}};\n        int[][] grid3 = {{1, 1, 1}, {1, 1, 1}, {1, 1, 1}};\n        int[][] grid4 = {{2, 2, 2}, {2, 2, 2}, {2, 2, 2}};\n        int[][] grid5 = {{0, 1, 2}, {0, 1, 2}, {0, 1, 2}};\n\n        System.out.println(minimumOperationsToWriteY(grid1));\n        System.out.println(minimumOperationsToWriteY(grid2));\n        System.out.println(minimumOperationsToWriteY(grid3));\n        System.out.println(minimumOperationsToWriteY(grid4));\n        System.out.println(minimumOperationsToWriteY(grid5));\n    }\n}"}, {"source_Lan": "cpp###isArraySpecial.cpp", "source_code": "    bool isArraySpecial(vector<int>& nums) {\n        for (int i = 1; i < nums.size(); i++) {\n            if (nums[i - 1] % 2 == nums[i] % 2) {\n                return false;\n            }\n        }\n        return true;\n    }", "trans_code": "public static boolean isArraySpecial ( int [ ] nums ) {\n  for ( int i = 1 ;\n  i < nums . length ;\n  i ++ ) {\n    if ( nums [ i - 1 ] % 2 == nums [ i ] % 2 ) {\n      return false ;\n    }\n  }\n  return true ;\n}\n", "reference_code": "    public static boolean isArraySpecial(int[] nums) {\n        for (int i = 1; i < nums.length; i++) {\n            if (nums[i - 1] % 2 == nums[i] % 2) {\n                return false;\n            }\n        }\n        return true;\n    }", "target_Lan": "java###isArraySpecial_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.Arrays;\npublic class isArraySpecial_Test {\n// TOFILL\n    public static void main(String[] args) {\n        System.out.println(isArraySpecial(new int[]{1, 2, 3, 4, 5}));\n        System.out.println(isArraySpecial(new int[]{2, 4, 6, 8, 10}));\n        System.out.println(isArraySpecial(new int[]{1, 3, 5, 7, 9}));\n        System.out.println(isArraySpecial(new int[]{2, 3, 5, 7, 11}));\n        System.out.println(isArraySpecial(new int[]{1, 1, 1, 1, 1}));\n    }\n}"}, {"source_Lan": "cpp###sumOfEncryptedInt.cpp", "source_code": "    int sumOfEncryptedInt(vector<int> &nums) {\n        int ans = 0;\n        for (int x: nums) {\n            int mx = 0, base = 0;\n            for (; x; x /= 10) {\n                mx = max(mx, x % 10);\n                base = base * 10 + 1;\n            }\n            ans += mx * base;\n        }\n        return ans;\n    }", "trans_code": "public static int sumOfEncryptedInt ( int [ ] nums ) {\n  int ans = 0 ;\n  for ( int x : nums ) {\n    int mx = 0 , base = 0 ;\n    for ( ;\n    x ;\n    x /= 10 ) {\n      mx = Math . max ( mx , x % 10 ) ;\n      base = base * 10 + 1 ;\n    }\n    ans += mx * base ;\n  }\n  return ans ;\n}\n", "reference_code": "    public static int sumOfEncryptedInt(int[] nums) {\n        int ans = 0;\n        for (int x : nums) {\n            int mx = 0;\n            int base = 0;\n            for (; x > 0; x /= 10) {\n                mx = Math.max(mx, x % 10);\n                base = base * 10 + 1;\n            }\n            ans += mx * base;\n        }\n        return ans;\n    }", "target_Lan": "java###sumOfEncryptedInt_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.Arrays;\npublic class sumOfEncryptedInt_Test {\n// TOFILL\n    public static void main(String[] args) {\n        System.out.println(sumOfEncryptedInt(new int[]{0}));\n        System.out.println(sumOfEncryptedInt(new int[]{1, 2, 3, 4, 5}));\n        System.out.println(sumOfEncryptedInt(new int[]{-1, -2, -3, -4, -5}));\n        System.out.println(sumOfEncryptedInt(new int[]{100, 200, 300, 400, 500}));\n        System.out.println(sumOfEncryptedInt(new int[]{123, 456, 789}));\n    }\n}"}, {"source_Lan": "cpp###countTestedDevices.cpp", "source_code": "    int countTestedDevices(vector<int>& batteryPercentages) {\n        int n = batteryPercentages.size();\n        int need = 0;\n        for (int i = 0; i < n; i++) {\n            if (batteryPercentages[i] > 0) {\n                need++;\n                for (int j = i + 1; j < n; j++) {\n                    batteryPercentages[j] = max(batteryPercentages[j] - 1, 0);\n                }\n            }\n        }\n        return need;\n    }", "trans_code": "public static int countTestedDevices ( int [ ] batteryPercentages ) {\n  int n = batteryPercentages . length ;\n  int need = 0 ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    if ( batteryPercentages [ i ] > 0 ) {\n      need ++ ;\n      for ( int j = i + 1 ;\n      j < n ;\n      j ++ ) {\n        batteryPercentages [ j ] = Math . max ( batteryPercentages [ j ] - 1 , 0 ) ;\n      }\n    }\n  }\n  return need ;\n}\n", "reference_code": "    public static int countTestedDevices(int[] batteryPercentages) {\n        int n = batteryPercentages.length;\n        int need = 0;\n        for (int i = 0; i < n; i++) {\n            if (batteryPercentages[i] > 0) {\n                need++;\n                for (int j = i + 1; j < n; j++) {\n                    batteryPercentages[j] = Math.max(batteryPercentages[j] - 1, 0);\n                }\n            }\n        }\n        return need;\n    }", "target_Lan": "java###countTestedDevices_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\n\npublic class countTestedDevices_Test {\n// TOFILL\npublic static void main(String[] args) {\n    System.out.println(countTestedDevices(new int[]{100, 90, 80, 70, 60, 50}));\n    System.out.println(countTestedDevices(new int[]{0, 0, 0, 0, 0, 0}));\n    System.out.println(countTestedDevices(new int[]{100, 100, 100, 100, 100, 100}));\n    System.out.println(countTestedDevices(new int[]{10, 20, 30, 40, 50, 60}));\n    System.out.println(countTestedDevices(new int[]{100, 100, 100, 100, 100, 0}));\n}\n}"}, {"source_Lan": "cpp###frequency.cpp", "source_code": "    vector<int> frequency(int n, vector<int> &a){\n        vector<int>ans(n);\n        unordered_map<int,int>mp;\n        for(int i=n-1;i>-1;i--)\n        {\n            mp[a[i]]++;\n            ans[i]=mp[a[i]];\n        }\n        return ans;\n    }", "trans_code": "public static int [ ] frequency ( int n , int [ ] a ) {\n  int [ ] ans = new int [ n ] ;\n  HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ;\n  for ( int i = n - 1 ;\n  i > - 1 ;\n  i -- ) {\n    mp . put ( a [ i ] , i ) ;\n    ans [ i ] = mp . get ( a [ i ] ) ;\n  }\n  return ans ;\n}\n", "reference_code": "    public static int[] frequency(int n,int a[]) {\n        HashMap<Integer,Integer> hm=new HashMap<>();\n        int ans[]=new int[n];\n        for(int i:a){\n            hm.put(i,hm.getOrDefault(i,0)+1);\n        }\n        for(int i=0;i<n;i++){\n            ans[i]=hm.get(a[i]);\n            hm.put(a[i],hm.get(a[i])-1);\n        }\n        return ans;\n    }", "target_Lan": "java###frequency_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.Arrays;\npublic class frequency_Test {\n// TOFILL\n    public static void main(String[] args) {\n        System.out.println(Arrays.toString(frequency(0, new int[]{})));\n        System.out.println(Arrays.toString(frequency(1, new int[]{1})));\n        System.out.println(Arrays.toString(frequency(2, new int[]{1, 2})));\n        System.out.println(Arrays.toString(frequency(3, new int[]{1, 1, 2})));\n        System.out.println(Arrays.toString(frequency(4, new int[]{1, 2, 3, 4})));\n    }\n}"}, {"source_Lan": "cpp###findGoodPairs.cpp", "source_code": "    long long findGoodPairs(vector<int> a, int n, int k) {\n        map<int, int > ma;\n        long long ans = 0;\n        for (int i = k; i < n; i++) {\n            ma[a[i - k]]++;\n            ans += ma[a[i]];\n        }\n        return ans;\n    }", "trans_code": "public static long findGoodPairs ( int [ ] a , int n , int k ) {\n  Map < Integer , Integer > ma = new HashMap < Integer , Integer > ( ) ;\n  long ans = 0 ;\n  for ( int i = k ;\n  i < n ;\n  i ++ ) {\n    ma . put ( a [ i - k ] , i ) ;\n    ans += ma . get ( a [ i ] ) ;\n  }\n  return ans ;\n}\n", "reference_code": "    static long findGoodPairs(int a[], int n, int k){\n        \n        long ans = 0;\n        Map<Integer, Integer> hm = new HashMap<>();\n        for(int i = k; i < n; i++){\n            hm.put(a[i - k], hm.getOrDefault(a[i - k], 0) + 1);\n            ans += hm.getOrDefault(a[i], 0);\n        }\n        return ans;\n    }", "target_Lan": "java###findGoodPairs_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.HashMap;\nimport java.util.Map;\npublic class findGoodPairs_Test {\n// TOFILL\n    public static void main(String[] args) {\n        int[] a1 = {1,2,3,4,5};\n        int n1 = 5;\n        int k1 = 2;\n        System.out.println(findGoodPairs(a1, n1, k1));\n\n        int[] a2 = {1,1,1,1,1};\n        int n2 = 5;\n        int k2 = 1;\n        System.out.println(findGoodPairs(a2, n2, k2));\n\n        int[] a3 = {1,2,3,4,5,6,7,8,9,10};\n        int n3 = 10;\n        int k3 = 3;\n        System.out.println(findGoodPairs(a3, n3, k3));\n\n        int[] a4 = {10,20,30,40,50};\n        int n4 = 5;\n        int k4 = 1;\n        System.out.println(findGoodPairs(a4, n4, k4));\n\n        int[] a5 = {5,10,15,20,25};\n        int n5 = 5;\n        int k5 = 2;\n        System.out.println(findGoodPairs(a5, n5, k5));\n    }\n}"}, {"source_Lan": "cpp###collectingCoins.cpp", "source_code": "    int collectingCoins(int N, std::vector<std::vector<int>>& Coins)\n    {\n        \n        \n        unordered_map<int, int> hor,ver,diaa,diab;\n        int m = 0;\n        \n        for (auto& el : Coins)\n        {\n            \n            int a = el[0];\n            int b = el[1];\n            \n            \n            hor[a]++;\n            ver[b]++;\n            diaa[a + b]++;\n            diab[a - b]++;\n            \n            m = max(m, hor[a]);\n            m = max(m, ver[b]);\n            m = max(m, diaa[a + b]);\n            m = max(m, diab[a - b]);\n        }\n        \n        return m;\n    }", "trans_code": "public static int collectingCoins ( int N , List < List < Integer >> Coins ) {\n  HashMap < Integer , Integer > hor = new HashMap < Integer , Integer > ( ) , ver = new HashMap < Integer , Integer > ( ) , diaa = new HashMap < Integer , Integer > ( ) , diab = new HashMap < Integer , Integer > ( ) ;\n  int m = 0 ;\n  for ( List < Integer > el : Coins ) {\n    int a = el . get ( 0 ) ;\n    int b = el . get ( 1 ) ;\n    hor . put ( a , 1 ) ;\n    ver . put ( b , 1 ) ;\n    diaa . put ( a + b , 1 ) ;\n    diab . put ( a - b , 1 ) ;\n    m = Math . max ( m , hor . get ( a ) ) ;\n    m = Math . max ( m , ver . get ( b ) ) ;\n    m = Math . max ( m , diaa . get ( a + b ) ) ;\n    m = Math . max ( m , diab . get ( a - b ) ) ;\n  }\n  return m ;\n}\n", "reference_code": "    public static int collectingCoins(int N, int[][] Coins) {\n        Map<Integer, Integer> hor = new HashMap<>(); \n        Map<Integer, Integer> ver = new HashMap<>(); \n        Map<Integer, Integer> diaa = new HashMap<>(); \n        Map<Integer, Integer> diab = new HashMap<>(); \n        int m = 0; \n            \n            for (int[] el : Coins) {\n                int a = el[0], b = el[1];\n                hor.put(a, hor.getOrDefault(a, 0) + 1); \n                ver.put(b, ver.getOrDefault(b, 0) + 1); \n                diaa.put(a + b, diaa.getOrDefault(a + b, 0) + 1); \n                diab.put(a - b, diab.getOrDefault(a - b, 0) + 1); \n                \n                m = Math.max(m, hor.get(a));\n                m = Math.max(m, ver.get(b));\n                m = Math.max(m, diaa.get(a + b));\n                m = Math.max(m, diab.get(a - b));\n            }\n            return m; \n    }", "target_Lan": "java###collectingCoins_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.*;\npublic class collectingCoins_Test {\n// TOFILL\n    public static void main(String[] args) {\n        System.out.println(collectingCoins(0, new int[][]{}));\n        System.out.println(collectingCoins(1, new int[][]{{1,2}}));\n        System.out.println(collectingCoins(2, new int[][]{{1,2},{2,3}}));\n        System.out.println(collectingCoins(3, new int[][]{{1,2},{2,3},{3,4}}));\n        System.out.println(collectingCoins(4, new int[][]{{1,2},{2,3},{3,4},{4,5}}));\n    }\n}"}, {"source_Lan": "cpp###trafficLights.cpp", "source_code": "    string trafficLights(int n, int q, vector<vector<int>>& queries) {\n        \n        vector<int> darr(n + 1, 0);\n        for (vector<int>& Q : queries) {\n            int a = Q[0];\n            int b = Q[1];\n            darr[a - 1]++;\n            darr[b]--;\n        }\n        partial_sum(darr.begin(), darr.end(), darr.begin());\n        string result = \"\";\n        for (int i = 0; i < n; i++) {\n            int X = darr[i] % 3;\n            if (X == 0)\n                result += \"R\";\n            else if (X == 1)\n                result += \"Y\";\n            else if (X == 2)\n                result += \"G\";\n        }\n        return result;\n    }", "trans_code": "public static String trafficLights ( int n , int q , List < List < Integer >> queries ) {\n  int [ ] darr = new int [ n + 1 ] ;\n  for ( List < Integer > Q : queries ) {\n    int a = Q . get ( 0 ) ;\n    int b = Q . get ( 1 ) ;\n    darr [ a - 1 ] ++ ;\n    darr [ b ] -- ;\n  }\n  partial_sum ( darr ) ;\n  String result = \"\" ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    int X = darr [ i ] % 3 ;\n    if ( X == 0 ) {\n      result += \"R\" ;\n    }\n    else if ( X == 1 ) {\n      result += \"Y\" ;\n    }\n    else if ( X == 2 ) {\n      result += \"G\" ;\n    }\n  }\n  return result ;\n}\n", "reference_code": "    public static String trafficLights(int n, int q, int[][] queries) {\n        int[] darr = new int[n + 1];\n        for (int[] Q : queries) {\n            int a = Q[0];\n            int b = Q[1];\n            darr[a - 1]++;\n            darr[b]--;\n        }\n        Arrays.parallelPrefix(darr, (A, B) -> A + B);\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < n; i++) {\n            int X = darr[i] % 3;\n            if (X == 0)\n                sb.append(\"R\");\n            else if (X == 1)\n                sb.append(\"Y\");\n            else if (X == 2)\n                sb.append(\"G\");\n        }\n        return sb.toString();\n    }", "target_Lan": "java###trafficLights_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.Arrays;\npublic class trafficLights_Test {\n// TOFILL\n    public static void main(String[] args) {\n        int[][] queries1 = {{1, 2}, {2, 3}};\n        System.out.println(trafficLights(3, 2, queries1));\n\n        int[][] queries2 = {{1, 2}, {2, 3}, {3, 4}};\n        System.out.println(trafficLights(4, 3, queries2));\n\n        int[][] queries3 = {{1, 2}, {2, 3}, {3, 4}, {4, 5}};\n        System.out.println(trafficLights(5, 4, queries3));\n\n        int[][] queries4 = {{1, 2}, {2, 3}, {3, 4}, {4, 5}, {5, 6}};\n        System.out.println(trafficLights(6, 5, queries4));\n\n        int[][] queries5 = {{1, 2}, {2, 3}, {3, 4}, {4, 5}, {5, 6}, {6, 7}};\n        System.out.println(trafficLights(7, 6, queries5));\n    }\n}"}, {"source_Lan": "cpp###BeautifulBits.cpp", "source_code": "    vector<int> BeautifulBits(int n, vector<int> &arr, int q,\n                              vector<vector<int> > &queries) {\n        vector<vector<long long> > pref(n + 1, vector<long long>(32, 0));\n        for (int i = 1; i <= n; i++) {\n            for (int j = 0; j < 32; j++) {\n                pref[i][j] = pref[i - 1][j] + ((arr[i - 1] >> j) & 1);\n            }\n        }\n        vector<int> ans(q, 0);\n        for (int i = 0; i < q; i++) {\n            for (int j = 0; j < 32; j++) {\n                if (pref[queries[i][1]][j] - pref[queries[i][0] - 1][j] != 0) {\n                    ans[i] += 1 << j;\n                }\n            }\n        }\n        return ans;\n    }", "trans_code": "public static int [ ] BeautifulBits ( int n , int [ ] arr , int q , int [ ] [ ] queries ) {\n  long [ ] [ ] pref = new long [ n + 1 ] [ 32 ] ;\n  for ( int i = 1 ;\n  i <= n ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < 32 ;\n    j ++ ) {\n      pref [ i ] [ j ] = pref [ i - 1 ] [ j ] + ( ( arr [ i - 1 ] >> j ) & 1 ) ;\n    }\n  }\n  int [ ] ans = new int [ q ] ;\n  for ( int i = 0 ;\n  i < q ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < 32 ;\n    j ++ ) {\n      if ( pref [ queries [ i ] [ 1 ] ] [ j ] - pref [ queries [ i ] [ 0 ] - 1 ] [ j ] != 0 ) ans [ i ] += 1 << j ;\n    }\n  }\n  return ans ;\n}\n", "reference_code": "    public static ArrayList<Integer> BeautifulBits(int n, int[] arr, int q,\n                                                   int[][] queries) {\n        long[][] pref = new long[n + 1][32];\n        for (int i = 1; i <= n; i++) {\n            for (int j = 0; j < 32; j++) {\n                pref[i][j] = pref[i - 1][j] + ((arr[i - 1] >> j) & 1);\n            }\n        }\n        ArrayList<Integer> ans = new ArrayList<>(Collections.nCopies(q, 0));\n        for (int i = 0; i < q; i++) {\n            for (int j = 0; j < 32; j++) {\n                if (pref[queries[i][1]][j] - pref[queries[i][0] - 1][j] != 0) {\n                    ans.set(i, ans.get(i) + (1 << j));\n                }\n            }\n        }\n        return ans;\n    }", "target_Lan": "java###BeautifulBits_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.ArrayList;\nimport java.util.Arrays;\npublic class BeautifulBits_Test {\n// TOFILL\n    public static void main(String[] args) {\n        System.out.println(BeautifulBits(5, new int[]{1, 2, 3, 4, 5}, 2, new int[][]{{1, 3}, {2, 4}}));\n        System.out.println(BeautifulBits(10, new int[]{10, 20, 30, 40, 50, 60, 70, 80, 90, 100}, 3, new int[][]{{1, 5}, {6, 10}, {3, 8}}));\n        System.out.println(BeautifulBits(0, new int[]{}, 0, new int[][]{}));\n        System.out.println(BeautifulBits(1, new int[]{1}, 1, new int[][]{{1, 1}}));\n        System.out.println(BeautifulBits(2, new int[]{1, 2}, 1, new int[][]{{1, 2}}));\n    }\n}"}, {"source_Lan": "cpp###ForYou.cpp", "source_code": "    long long ForYou(int n, vector<int> &arr, int m, vector<vector<int> > &order)\n    {\n        vector<int> diff(n+1,0);\n        for(auto it:order)\n        {\n            diff[it[0]-1]++;\n            diff[it[1]]--;\n        }\n        for(int i=1;i<=n;i++)\n        {\n            diff[i] += diff[i-1];\n        }\n        diff.pop_back();\n        sort(diff.begin(),diff.end());\n        sort(arr.begin(),arr.end());\n        long long ans=0;\n        int mod = 1e9+7;\n        for(int i=0;i<n;i++)\n        {\n            ans += (1ll * diff[i]) * (1ll * arr[i]);\n            ans%=mod;\n        }\n        return ans;\n    }", "trans_code": "public static long ForYou ( int n , int [ ] arr , int m , List < List < Integer >> order ) {\n  int [ ] diff = new int [ n + 1 ] ;\n  for ( List < Integer > it : order ) {\n    diff [ it . get ( 0 ) - 1 ] ++ ;\n    diff [ it . get ( 1 ) ] -- ;\n  }\n  for ( int i = 1 ;\n  i <= n ;\n  i ++ ) diff [ i ] += diff [ i - 1 ] ;\n  diff [ n ] -- ;\n  Arrays . sort ( diff ) ;\n  Arrays . sort ( arr ) ;\n  long ans = 0 ;\n  int mod = 1e9 + 7 ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    ans += ( 1l l * diff [ i ] ) * ( 1l l * arr [ i ] ) ;\n    ans %= mod ;\n  }\n  return ans ;\n}\n", "reference_code": "    public static long ForYou(int n, int[] arr, int m, int[][] order) {\n        \n        int[] diff = new int[n + 1];\n        \n        for (int[] it : order) {\n            diff[it[0] - 1]++;\n            diff[it[1]]--;\n        }\n        \n        for (int i = 1; i <= n; i++) {\n            diff[i] += diff[i - 1];\n        }\n        \n        diff = Arrays.copyOf(diff, n);\n        Arrays.sort(diff);\n        \n        Arrays.sort(arr);\n        long ans = 0;\n        int mod = (int)1e9 + 7;\n        \n        for (int i = 0; i < n; i++) {\n            ans += ((long)diff[i]) * ((long)arr[i]);\n            ans %= mod;\n        }\n        return ans;\n    }", "target_Lan": "java###ForYou_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.Arrays;\npublic class ForYou_Test {\n// TOFILL\n    public static void main(String[] args) {\n        System.out.println(ForYou(5, new int[]{1, 2, 3, 4, 5}, 3, new int[][]{{1, 3}, {2, 4}, {1, 5}}));\n        System.out.println(ForYou(10, new int[]{10, 9, 8, 7, 6, 5, 4, 3, 2, 1}, 5, new int[][]{{1, 10}, {2, 9}, {3, 8}, {4, 7}, {5, 6}}));\n        System.out.println(ForYou(0, new int[]{}, 0, new int[][]{}));\n        System.out.println(ForYou(1, new int[]{100}, 1, new int[][]{{1, 1}}));\n        System.out.println(ForYou(2, new int[]{10, 20}, 2, new int[][]{{1, 1}, {2, 2}}));\n    }\n}"}, {"source_Lan": "cpp###validStrings.cpp", "source_code": "    int validStrings(int n, int k, vector<string> &arr) {\n        int tot=0;\n        for (auto j:arr){\n            int c=0;\n            for (auto q:j){\n                if (q=='a'||q=='e'||q=='i'||q=='o'||q=='u') c+=1;\n            }\n            if (c==k) tot+=1;\n        }\n        return tot;\n    }", "trans_code": "public static int validStrings ( int n , int k , String [ ] arr ) {\n  int tot = 0 ;\n  for ( String j : arr ) {\n    int c = 0 ;\n    for ( char q : j ) {\n      if ( q == 'a' || q == 'e' || q == 'i' || q == 'o' || q == 'u' ) {\n        c += 1 ;\n      }\n    }\n    if ( c == k ) {\n      tot += 1 ;\n    }\n  }\n  return tot ;\n}\n", "reference_code": "    public static int validStrings(int n, int k, String[] arr) \n    {\n        int totalValid = 0;\n        for (String str : arr) {\n            int vowelCount = 0;\n            for (char ch : str.toCharArray()) {\n                if (\"aeiou\".indexOf(ch) >= 0) {\n                    vowelCount++;\n                }\n            }\n            if (vowelCount == k) {\n                totalValid++;\n            }\n        }\n        return totalValid;\n    }", "target_Lan": "java###validStrings_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\n\npublic class validStrings_Test {\n// TOFILL\npublic static void main(String[] args) {\n    System.out.println(validStrings(0, 0, new String[]{}));\n    System.out.println(validStrings(1, 1, new String[]{\"a\"}));\n    System.out.println(validStrings(2, 2, new String[]{\"ae\", \"io\"}));\n    System.out.println(validStrings(3, 1, new String[]{\"a\", \"e\", \"i\"}));\n    System.out.println(validStrings(4, 2, new String[]{\"ae\", \"io\", \"u\", \"oiea\"}));\n}\n}"}, {"source_Lan": "cpp###maximumBattalions.cpp", "source_code": "    int maximumBattalions(int N, vector<string> &names) {\n        unordered_map<string, int> m;\n        for(int i = 0; i < N; i++){\n            m[names[i]] = i;\n        }\n        int answer = 0;\n        int maxi = 0;\n        int ind = 0;\n        for(auto i : names){\n            maxi = max(maxi, m[i]);\n            if(maxi == ind){\n                answer += 1;\n            }\n            ind += 1;\n        }\n        return answer;\n    }", "trans_code": "public static int maximumBattalions ( int N , String [ ] names ) {\n  HashMap < String , Integer > m = new HashMap < String , Integer > ( ) ;\n  for ( int i = 0 ;\n  i < N ;\n  i ++ ) m . put ( names [ i ] , i ) ;\n  int answer = 0 ;\n  int maxi = 0 ;\n  int ind = 0 ;\n  for ( String i : names ) {\n    maxi = Math . max ( maxi , m . get ( i ) ) ;\n    if ( maxi == ind ) answer += 1 ;\n    ind += 1 ;\n  }\n  return answer ;\n}\n", "reference_code": "    public static int maximumBattalions(int N, String[] names) \n    {\n        Map<String, Integer> nameIndexMap = new HashMap<>();\n        for (int i = 0; i < N; i++) \n        {\n            nameIndexMap.put(names[i], i);\n        }\n        int answer = 0;\n        int maxi = 0;\n        int ind = 0;\n        for (String name : names) \n        {\n            maxi = Math.max(maxi, nameIndexMap.get(name));\n            if (maxi == ind) \n            {\n                answer++;\n            }\n            ind++;\n        }\n        return answer;\n    }", "target_Lan": "java###maximumBattalions_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.HashMap;\nimport java.util.Map;\npublic class maximumBattalions_Test {\n// TOFILL\n    public static void main(String[] args) {\n        System.out.println(maximumBattalions(0, new String[]{}));\n        System.out.println(maximumBattalions(1, new String[]{\"John\"}));\n        System.out.println(maximumBattalions(2, new String[]{\"John\", \"John\"}));\n        System.out.println(maximumBattalions(3, new String[]{\"John\", \"Doe\", \"John\"}));\n        System.out.println(maximumBattalions(4, new String[]{\"John\", \"Doe\", \"John\", \"Doe\"}));\n    }\n}"}, {"source_Lan": "cpp###MaximumEnergy.cpp", "source_code": "    int MaximumEnergy(int N, vector<int> &E, int K, vector<int> &P) {\n        \n        sort(P.begin(),P.end());\n        long long mod = 1e9+7;\n        vector<int> ps(N+1);\n        long long ans = 0;\n        long long s = 0;\n        for(int i=0;i<N;i++){\n            s+=E[i];\n            s%=mod;\n            ps[i+1] = s;\n        }\n        for(int i=0;i<K/2;i++){\n            long long a = ps[P[i]];\n            long long b = ps[P[K-i-1]+1];\n            ans+=(b-a+mod);\n            ans%=mod;\n        }\n        return ans;\n    }", "trans_code": "public static int MaximumEnergy ( int N , int [ ] E , int K , int [ ] P ) {\n  Arrays . sort ( P ) ;\n  long mod = 1e9 + 7 ;\n  int [ ] ps = new int [ N + 1 ] ;\n  int ans = 0 ;\n  long s = 0 ;\n  for ( int i = 0 ;\n  i < N ;\n  i ++ ) {\n    s += E [ i ] ;\n    s %= mod ;\n    ps [ i + 1 ] = s ;\n  }\n  for ( int i = 0 ;\n  i < K / 2 ;\n  i ++ ) {\n    long a = ps [ P [ i ] ] ;\n    long b = ps [ P [ K - i - 1 ] + 1 ] ;\n    ans += ( b - a + mod ) ;\n    ans %= mod ;\n  }\n  return ans ;\n}\n", "reference_code": "    public static int MaximumEnergy(int N, int[] E, int K, int[] P) \n    {\n        Arrays.sort(P);\n        long mod = 1000000007;\n        long[] ps = new long[N + 1];\n        long ans = 0;\n        long s = 0;\n        for (int i = 0; i < N; i++) \n        {\n            s += E[i];\n            s %= mod;\n            ps[i + 1] =  s;\n        }\n        for (int i = 0; i < K / 2; i++) {\n            long a = ps[P[i]];\n            long b = ps[P[K - i - 1] + 1];\n            ans += (b - a + mod) % mod;\n            ans %= mod;\n        }\n        return (int) ans;\n    }", "target_Lan": "java###MaximumEnergy_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.Arrays;\npublic class MaximumEnergy_Test {\n// TOFILL\n    public static void main(String[] args) {\n        System.out.println(MaximumEnergy(5, new int[]{1,2,3,4,5}, 2, new int[]{0,1}));\n        System.out.println(MaximumEnergy(10, new int[]{10,20,30,40,50,60,70,80,90,100}, 5, new int[]{0,2,4,6,8}));\n        System.out.println(MaximumEnergy(7, new int[]{1,3,5,7,9,11,13}, 3, new int[]{0,1,2}));\n        System.out.println(MaximumEnergy(4, new int[]{2,4,6,8}, 4, new int[]{0,1,2,3}));\n        System.out.println(MaximumEnergy(6, new int[]{1,2,3,4,5,6}, 6, new int[]{0,1,2,3,4,5}));\n    }\n}"}, {"source_Lan": "cpp###minimumDis.cpp", "source_code": "    int minimumDis(int N, vector<int> X) {\n        sort(X.begin(), X.end());\n        return X[(N - 1) / 2];\n    }", "trans_code": "public static int minimumDis ( int N , int [ ] X ) {\n  Arrays . sort ( X ) ;\n  return X [ ( N - 1 ) / 2 ] ;\n}\n", "reference_code": "    public static int minimumDis(int N, int[] X) {\n        Arrays.sort(X);\n        return X[(N - 1) / 2];\n    }", "target_Lan": "java###minimumDis_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.Arrays;\npublic class minimumDis_Test {\n// TOFILL\n    public static void main(String[] args) {\n        System.out.println(minimumDis(1, new int[]{1}));\n        System.out.println(minimumDis(2, new int[]{1,2}));\n        System.out.println(minimumDis(3, new int[]{1,2,3}));\n        System.out.println(minimumDis(4, new int[]{1,2,3,4}));\n    }\n}"}, {"source_Lan": "cpp###maxAlternatingSubstring.cpp", "source_code": "    long long maxAlternatingSubstring(int N, string S) {\n        vector<long long> diff;\n        for (int i = 0; i < N;) {\n            int j = i + 1;\n            while (j < N && S[j] != S[j - 1])\n                j++;\n            diff.push_back(j - i);\n            i = j;\n        }\n        diff.push_back(0);\n        long long ans_before = 0;\n        for (long long x : diff) {\n            ans_before += ((x * (x + 1)) / 2);\n        }\n        long long ans = 0;\n        for (int i = 0; i < diff.size() - 1; ++i) {\n            long long a = diff[i];\n            long long b = diff[i + 1];\n            long long currAns = ans_before - ((a * (a + 1)) / 2) - ((b * (b + 1)) / 2) +\n                                ((a + b + 1) * (a + b + 2)) / 2;\n            ans = max(ans, currAns);\n        }\n        return ans;\n    }", "trans_code": "public static long maxAlternatingSubstring ( int N , String S ) {\n  long [ ] diff = new long [ N ] ;\n  for ( int i = 0 ;\n  i < N ;\n  ) {\n    int j = i + 1 ;\n    while ( j < N && S . charAt ( j ) != S . charAt ( j - 1 ) ) {\n      j ++ ;\n    }\n    diff [ j - i ] = j ;\n    i = j ;\n  }\n  diff [ N - 1 ] = 0 ;\n  long ansBefore = 0 ;\n  for ( long x : diff ) ansBefore += ( ( x * ( x + 1 ) ) / 2 ) ;\n  long ans = 0 ;\n  for ( int i = 0 ;\n  i < diff . length - 1 ;\n  ++ i ) {\n    long a = diff [ i ] ;\n    long b = diff [ i + 1 ] ;\n    long currAns = ansBefore - ( ( a * ( a + 1 ) ) / 2 ) - ( ( b * ( b + 1 ) ) / 2 ) + ( ( a + b + 1 ) * ( a + b + 2 ) ) / 2 ;\n    ans = Math . max ( ans , currAns ) ;\n  }\n  return ans ;\n}\n", "reference_code": "    public static long maxAlternatingSubstring(int N, String S) {\n        List<Integer> diff = new ArrayList<>();\n        for (int i = 0; i < N;) {\n            int j = i + 1;\n            while (j < N && S.charAt(j) != S.charAt(j - 1)) j++;\n            diff.add(j - i);\n            i = j;\n        }\n        diff.add(0);\n        long ans_before = 0;\n        for (int x : diff) {\n            ans_before += ((x * 1L * (x + 1)) / 2);\n        }\n        long ans = 0;\n        for (int i = 0; i < diff.size() - 1; i++) {\n            long a = diff.get(i);\n            long b = diff.get(i + 1);\n            long currAns = ans_before - ((a * (a + 1)) / 2) - ((b * (b + 1)) / 2) +\n                           ((a + b + 1) * (a + b + 2)) / 2;\n            ans = Math.max(ans, currAns);\n        }\n        return ans;\n    }", "target_Lan": "java###maxAlternatingSubstring_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.*;\npublic class maxAlternatingSubstring_Test {\n// TOFILL\n    public static void main(String[] args) {\n        System.out.println(maxAlternatingSubstring(0, \"\"));\n        System.out.println(maxAlternatingSubstring(1, \"1\"));\n        System.out.println(maxAlternatingSubstring(2, \"11\"));\n        System.out.println(maxAlternatingSubstring(3, \"101\"));\n        System.out.println(maxAlternatingSubstring(5, \"10101\"));\n    }\n}"}, {"source_Lan": "cpp###countSuperPalindrome.cpp", "source_code": "    int countSuperPalindrome(int l, int r) {\n        int count = 0;\n        \n        int start = static_cast<int>(ceil(sqrt(l)));\n        \n        while (start * start <= r) {\n            \n            int square = start * start;\n            string s = to_string(square);\n            \n            if (s == string(s.rbegin(), s.rend())) {\n                count++;\n            }\n            start++;\n        }\n        return count;\n    }", "trans_code": "public static int countSuperPalindrome ( int l , int r ) {\n  int count = 0 ;\n  int start = ( int ) Math . ceil ( Math . sqrt ( l ) ) ;\n  while ( start * start <= r ) {\n    int square = start * start ;\n    String s = Integer . toString ( square ) ;\n    if ( s . equals ( String . valueOf ( s . charAt ( s . length ( ) - 1 ) ) ) ) count ++ ;\n    start ++ ;\n  }\n  return count ;\n}\n", "reference_code": "    public static int countSuperPalindrome(int l, int r) {\n        int count = 0;\n        \n        int start = (int)Math.ceil(Math.sqrt(l));\n        \n        while (start * start <= r) {\n            \n            int square = start * start;\n            String s = Integer.toString(square);\n            \n            if (s.equals(new StringBuilder(s).reverse().toString())) {\n                count++;\n            }\n            start++;\n        }\n        return count;\n    }", "target_Lan": "java###countSuperPalindrome_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\n\npublic class countSuperPalindrome_Test {\n// TOFILL\npublic static void main(String[] args) {\n    System.out.println(countSuperPalindrome(0, 10));\n    System.out.println(countSuperPalindrome(100, 1000));\n    System.out.println(countSuperPalindrome(1000, 10000));\n    System.out.println(countSuperPalindrome(10000, 100000));\n    System.out.println(countSuperPalindrome(100000, 1000000));\n}\n}"}, {"source_Lan": "cpp###candyShop2.cpp", "source_code": "    int candyShop2(int n, vector<int> &candies) {\n        int answer = 0;\n        unordered_map<int, int> m;\n        for(auto i : candies){\n            if(m.find(i) == m.end()){\n                answer += i;\n                m[i] = 1;\n            }\n        }\n        return answer;\n    }", "trans_code": "public static int candyShop2 ( int n , int [ ] candies ) {\n  int answer = 0 ;\n  HashMap < Integer , Integer > m = new HashMap < > ( ) ;\n  for ( int i : candies ) {\n    if ( m . containsKey ( i ) == false ) {\n      answer += i ;\n      m . put ( i , 1 ) ;\n    }\n  }\n  return answer ;\n}\n", "reference_code": "    public static int candyShop2(int n, int[] candies) {\n        int ans = 0;\n        Set<Integer> hs = new HashSet<>();\n        for(int x : candies)\n            if(hs.add(x))\n                ans += x;\n        return ans;\n    }", "target_Lan": "java###candyShop2_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.HashSet;\nimport java.util.Set;\npublic class candyShop2_Test {\n// TOFILL\n    public static void main(String[] args) {\n        System.out.println(candyShop2(0, new int[]{}));\n        System.out.println(candyShop2(1, new int[]{1}));\n        System.out.println(candyShop2(2, new int[]{1, 1}));\n        System.out.println(candyShop2(3, new int[]{1, 2, 3}));\n        System.out.println(candyShop2(4, new int[]{2, 2, 2, 2}));\n    }\n}"}, {"source_Lan": "cpp###candyShop.cpp", "source_code": "    int candyShop(int n, vector<int> &candies) {\n        int answer = INT_MAX;\n        unordered_map<int, int> m;\n        for(auto i : candies){\n            m[i] += 1;\n        }\n        int k = m.size();\n        m.clear();\n        int l = 0, r = 0;\n        int total = 0;\n        while(r < n){\n            m[candies[r]] += 1;\n            total += candies[r];\n            while(m[candies[l]] > 1){\n                m[candies[l]] -= 1;\n                total -= candies[l];\n                l += 1;\n            }\n            if(m.size() == k){\n                answer = min(answer, total);\n            }\n            r += 1;\n        }\n        return answer;\n    }", "trans_code": "public static int candyShop ( int n , int [ ] candies ) {\n  int answer = Integer . MAX_VALUE ;\n  HashMap < Integer , Integer > m = new HashMap < Integer , Integer > ( ) ;\n  for ( Integer i : candies ) m . put ( i , 1 ) ;\n  int k = m . size ( ) ;\n  m . clear ( ) ;\n  int l = 0 , r = 0 ;\n  int total = 0 ;\n  while ( r < n ) {\n    m . put ( candies [ r ] , 1 ) ;\n    total += candies [ r ] ;\n    while ( m . get ( candies [ l ] ) > 1 ) {\n      m . put ( candies [ l ] , 1 ) ;\n      total -= candies [ l ] ;\n      l += 1 ;\n    }\n    if ( m . size ( ) == k ) answer = Math . min ( answer , total ) ;\n    r += 1 ;\n  }\n  return answer ;\n}\n", "reference_code": "    public static int candyShop(int n, int candies[]) {\n        int ans = Integer.MAX_VALUE;\n        int sum = 0;\n        int low = 0, high = 0;\n        Set<Integer> hs = new HashSet<>();\n        for(int x : candies)\n            hs.add(x);\n        Map<Integer, Integer> hm = new HashMap<>();\n        while(high < n){\n            hm.put(candies[high], hm.getOrDefault(candies[high], 0) + 1);\n            sum += candies[high++];\n            while(low < high && hm.get(candies[low]) > 1){\n                hm.put(candies[low], hm.get(candies[low]) - 1);\n                sum -= candies[low++];\n            }\n            if(hm.size() == hs.size())\n                ans = Math.min(ans, sum);\n        }\n        return ans;\n    }", "target_Lan": "java###candyShop_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.*;\npublic class candyShop_Test {\n// TOFILL\n    public static void main(String[] args) {\n        int[] candies1 = {1,2,3,4,5};\n        System.out.println(candyShop(5, candies1));\n\n        int[] candies2 = {1,1,1,1,1,1,1,1,1,1};\n        System.out.println(candyShop(10, candies2));\n\n        int[] candies3 = {1,2,3};\n        System.out.println(candyShop(3, candies3));\n\n        int[] candies4 = {1,2,3,1,2,3,1};\n        System.out.println(candyShop(7, candies4));\n\n        int[] candies5 = {1,2,1,2};\n        System.out.println(candyShop(4, candies5));\n    }\n}"}, {"source_Lan": "cpp###numOfWays.cpp", "source_code": "    long numOfWays(int n)\n    {\n        if(n%2) return 0;\n        long k = (n-1)/2;\n        k/=2;\n        k*=6;\n        return k;\n    }", "trans_code": "public static long numOfWays ( int n ) {\n  if ( n % 2 ) return 0 ;\n  long k = ( n - 1 ) / 2 ;\n  k /= 2 ;\n  k *= 6 ;\n  return k ;\n}\n", "reference_code": "    public static long numOfWays(int n) {\n        if(n%2==1)\n            return 0;\n        long k = (long)((n-1)/2);\n        k/=2;\n        k*=6;\n        return k;\n    }", "target_Lan": "java###numOfWays_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.*;\npublic class numOfWays_Test {\n// TOFILL\n    public static void main(String[] args) {\n        System.out.println(numOfWays(0));\n        System.out.println(numOfWays(1));\n        System.out.println(numOfWays(2));\n        System.out.println(numOfWays(10));\n        System.out.println(numOfWays(100));\n    }\n}"}, {"source_Lan": "cpp###minOPs.cpp", "source_code": "    int minOPs(int n, vector<int> &A)\n    {\n        map<int,int> m;\n        for(auto it:A) m[it]++;\n        vector<int> v;\n        for(auto it:m) v.push_back(it.second);\n        sort(v.begin(),v.end());\n        int sum=0;\n        for(int i=v.size()-1;i>=0;i--)\n        {\n          sum+=v[i];\n          if(sum>(n/2)) return v.size()-1-i;\n        }\n    }", "trans_code": "public static int minOPs ( int n , int [ ] A ) {\n  Map < Integer , Integer > m = new HashMap < Integer , Integer > ( ) ;\n  for ( Integer it : A ) {\n    m . put ( it , ++ n ) ;\n  }\n  List < Integer > list = new ArrayList < Integer > ( ) ;\n  for ( Integer it : m . keySet ( ) ) {\n    list . add ( it ) ;\n  }\n  Collections . sort ( list ) ;\n  int sum = 0 ;\n  for ( int i = list . size ( ) - 1 ;\n  i >= 0 ;\n  i -- ) {\n    sum += list . get ( i ) ;\n    if ( sum > ( n / 2 ) ) {\n      return list . size ( ) - 1 - i ;\n    }\n  }\n  return 0 ;\n}\n", "reference_code": "    public static int minOPs(int n, int[] A) {\n        Map<Integer, Integer> m = new HashMap<>();\n        for (int it : A) {\n            m.put(it, m.getOrDefault(it, 0) + 1);\n        }\n        int[] v = new int[m.size()];\n        int index = 0;\n        for (int value : m.values()) {\n            v[index++] = value;\n        }\n        Arrays.sort(v);\n        int sum = 0;\n        for (int i = v.length - 1; i >= 0; i--) {\n            sum += v[i];\n            if (sum > (n / 2)) {\n                return v.length - 1 - i;\n            }\n        }\n        return 0; \n    }", "target_Lan": "java###minOPs_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.*;\npublic class minOPs_Test {\n// TOFILL\n    public static void main(String[] args) {\n        int[] A1 = {1, 2, 3, 4, 5};\n        System.out.println(minOPs(5, A1));\n\n        int[] A2 = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1};\n        System.out.println(minOPs(10, A2));\n\n        int[] A3 = {1, 2, 3, 4, 5, 6, 7};\n        System.out.println(minOPs(7, A3));\n\n        int[] A4 = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15};\n        System.out.println(minOPs(15, A4));\n\n        int[] A5 = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n        System.out.println(minOPs(10, A5));\n    }\n}"}, {"source_Lan": "cpp###consecutiveVal.cpp", "source_code": "    string consecutiveVal(int n, vector<int> &a) {\n        \n        string result = \"\";\n        unordered_map<int, bool> mp;\n        for (int i = 0; i < n; i++) {\n            mp[a[i]] = true;\n        }\n        for (int i = 0; i < n; i++) {\n            if (mp[a[i] - 1] == true || mp[a[i] + 1] == true) {\n                result += '1';\n            } else\n                result += '0';\n        }\n        return result;\n    }", "trans_code": "public static String consecutiveVal ( int n , int [ ] a ) {\n  String result = \"\" ;\n  HashMap < Integer , Boolean > mp = new HashMap < Integer , Boolean > ( ) ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) mp . put ( a [ i ] , true ) ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    if ( mp . get ( a [ i ] - 1 ) == true || mp . get ( a [ i ] + 1 ) == true ) result += '1' ;\n    else result += '0' ;\n  }\n  return result ;\n}\n", "reference_code": "    public static String consecutiveVal(int n, List<Integer> a) {\n        StringBuilder result = new StringBuilder();\n        Map<Integer, Boolean> mp = new HashMap<>();\n        for (int i = 0; i < n; i++) {\n            mp.put(a.get(i), true);\n        }\n        for (int i = 0; i < n; i++) {\n            if (Boolean.TRUE.equals(mp.get(a.get(i) - 1)) ||\n                Boolean.TRUE.equals(mp.get(a.get(i) + 1))) {\n                result.append('1');\n            } else {\n                result.append('0');\n            }\n        }\n        return result.toString();\n    }", "target_Lan": "java###consecutiveVal_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.*;\npublic class consecutiveVal_Test {\n// TOFILL\n    public static void main(String[] args) {\n        System.out.println(consecutiveVal(5, Arrays.asList(1, 2, 3, 4, 5)));\n        System.out.println(consecutiveVal(5, Arrays.asList(5, 4, 3, 2, 1)));\n        System.out.println(consecutiveVal(5, Arrays.asList(1, 3, 5, 7, 9)));\n        System.out.println(consecutiveVal(5, Arrays.asList(2, 4, 6, 8, 10)));\n        System.out.println(consecutiveVal(5, Arrays.asList(1, 1, 1, 1, 1)));\n    }\n}"}, {"source_Lan": "cpp###chocolateDistribution.cpp", "source_code": "    int chocolateDistribution(int N, int M, vector<int> &arr, vector<int> &brr) {\n        sort(arr.begin(), arr.end());\n        sort(brr.begin(), brr.end());\n        int ans = 0;\n        int i = 0, j = 0;\n        while (i < N && j < M) {\n            if (arr[i] <= brr[j]) {\n                ans++;\n                i++;\n                j++;\n            } else {\n                j++;\n            }\n        }\n        return ans;\n    }", "trans_code": "public static int chocolateDistribution ( int N , int M , int [ ] arr , int [ ] brr ) {\n  Arrays . sort ( arr ) ;\n  Arrays . sort ( brr ) ;\n  int ans = 0 ;\n  int i = 0 , j = 0 ;\n  while ( i < N && j < M ) {\n    if ( arr [ i ] <= brr [ j ] ) {\n      ans ++ ;\n      i ++ ;\n      j ++ ;\n    }\n    else {\n      j ++ ;\n    }\n  }\n  return ans ;\n}\n", "reference_code": "    public static int chocolateDistribution(int N, int M, int[] arr, int[] brr) {\n        Arrays.sort(arr);\n        Arrays.sort(brr);\n        int ans = 0;\n        int i = 0, j = 0;\n        while (i < N && j < M) {\n            if (arr[i] <= brr[j]) {\n                ans++;\n                i++;\n                j++;\n            } else {\n                j++;\n            }\n        }\n        return ans;\n    }", "target_Lan": "java###chocolateDistribution_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.Arrays;\npublic class chocolateDistribution_Test {\n// TOFILL\n    public static void main(String[] args) {\n        int[] arr1 = {1, 2, 3, 4, 5};\n        int[] brr1 = {1, 2, 3, 4, 5};\n        System.out.println(chocolateDistribution(5, 5, arr1, brr1));\n\n        int[] arr2 = {1, 2, 3, 4, 5};\n        int[] brr2 = {6, 7, 8, 9, 10};\n        System.out.println(chocolateDistribution(5, 5, arr2, brr2));\n\n        int[] arr3 = {6, 7, 8, 9, 10};\n        int[] brr3 = {1, 2, 3, 4, 5};\n        System.out.println(chocolateDistribution(5, 5, arr3, brr3));\n\n        int[] arr4 = {1, 3, 5, 7, 9};\n        int[] brr4 = {2, 4, 6, 8, 10};\n        System.out.println(chocolateDistribution(5, 5, arr4, brr4));\n\n        int[] arr5 = {2, 4, 6, 8, 10};\n        int[] brr5 = {1, 3, 5, 7, 9};\n        System.out.println(chocolateDistribution(5, 5, arr5, brr5));\n    }\n}"}, {"source_Lan": "cpp###minElements.cpp", "source_code": "    int minElements(int n, int m, vector<int> &arr1, vector<int> &arr2) {\n        long long s=0;\n        for (auto j:arr1) s+=j;\n        sort(arr2.begin(),arr2.end());\n        long long cur=0;\n        int ans=0;\n        for (int i=m-1;i>=0;i--){\n            cur+=arr2[i];\n            ans+=1;\n            if (cur>=s)break;\n        }\n        if (cur>=s) return ans;\n        return -1;\n    }", "trans_code": "public static int minElements ( int n , int m , int [ ] arr1 , int [ ] arr2 ) {\n  long s = 0 ;\n  for ( int j : arr1 ) {\n    s += j ;\n  }\n  Arrays . sort ( arr2 ) ;\n  long cur = 0 ;\n  int ans = 0 ;\n  for ( int i = m - 1 ;\n  i >= 0 ;\n  i -- ) {\n    cur += arr2 [ i ] ;\n    ans += 1 ;\n    if ( cur >= s ) {\n      break ;\n    }\n  }\n  if ( cur >= s ) {\n    return ans ;\n  }\n  return - 1 ;\n}\n", "reference_code": "    public static int minElements(int n, int m, int[] arr1, int[] arr2) {\n        long sum = 0;\n        \n        for (int num : arr1) {\n            sum += num;\n        }\n        Arrays.sort(arr2); \n        long currentSum = 0;\n        int count = 0;\n        \n        for (int i = m - 1; i >= 0; i--) {\n            currentSum += arr2[i];\n            count++;\n            \n            if (currentSum >= sum) {\n                break;\n            }\n        }\n        \n        return currentSum >= sum ? count : -1;\n    }", "target_Lan": "java###minElements_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.Arrays;\npublic class minElements_Test {\n// TOFILL\n    public static void main(String[] args) {\n        System.out.println(minElements(5, 5, new int[]{1, 2, 3, 4, 5}, new int[]{5, 4, 3, 2, 1}));\n        System.out.println(minElements(5, 5, new int[]{1, 1, 1, 1, 1}, new int[]{1, 1, 1, 1, 1}));\n        System.out.println(minElements(5, 5, new int[]{1, 2, 3, 4, 5}, new int[]{1, 1, 1, 1, 1}));\n        System.out.println(minElements(5, 5, new int[]{5, 4, 3, 2, 1}, new int[]{5, 4, 3, 2, 1}));\n        System.out.println(minElements(5, 5, new int[]{1, 2, 3, 4, 5}, new int[]{1, 2, 3, 4, 5}));\n    }\n}"}, {"source_Lan": "cpp###maxScoreSubseq.cpp", "source_code": "    int maxScoreSubseq(int n, vector<int> &arr) {\n        unordered_map<int,int>mp;\n        int ma=INT_MIN;\n        for (int i=0;i<n;i++){\n            if (arr[i]>=0)mp[arr[i]-i]+=arr[i];\n            ma=max(ma,arr[i]);\n        }\n        int ele=INT_MIN;\n        for (auto j:mp) ele=max(ele,j.second);\n        return max(ele,ma);\n    }", "trans_code": "public static int maxScoreSubseq ( int n , int [ ] arr ) {\n  HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ;\n  int ma = Integer . MIN_VALUE ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    if ( arr [ i ] >= 0 ) {\n      mp . put ( arr [ i ] - i , arr [ i ] ) ;\n    }\n    ma = Math . max ( ma , arr [ i ] ) ;\n  }\n  int ele = Integer . MIN_VALUE ;\n  for ( Entry < Integer , Integer > j : mp . entrySet ( ) ) {\n    ele = Math . max ( ele , j . getValue ( ) ) ;\n  }\n  return Math . max ( ele , ma ) ;\n}\n", "reference_code": "    public static int maxScoreSubseq(int n, int[] arr) {\n        \n        \n        HashMap<Integer, Integer> map = new HashMap<>();\n        \n        int ma = Integer.MIN_VALUE;\n        \n        for(int i = 0; i < n; i++) {\n            \n            if(arr[i] >= 0) \n                map.put(arr[i] - i, map.getOrDefault(arr[i] - i, 0) + arr[i]);\n            \n            ma = Math.max(ma, arr[i]);\n        }\n        \n        int ele = Integer.MIN_VALUE;\n        \n        for(int j : map.values()){\n            ele = Math.max(ele, j);\n}\n        \n        return Math.max(ele, ma);\n    }", "target_Lan": "java###maxScoreSubseq_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.HashMap;\npublic class maxScoreSubseq_Test {\n// TOFILL\n    public static void main(String[] args) {\n        System.out.println(maxScoreSubseq(0, new int[]{}));\n        System.out.println(maxScoreSubseq(1, new int[]{1}));\n        System.out.println(maxScoreSubseq(2, new int[]{-1, 2}));\n        System.out.println(maxScoreSubseq(3, new int[]{3, -2, 1}));\n        System.out.println(maxScoreSubseq(4, new int[]{4, -3, 2, -1}));\n    }\n}"}, {"source_Lan": "cpp###canTrade.cpp", "source_code": "    vector<int> canTrade(int n, vector<int>& beautifulness, int q,\n                         vector<vector<int>>& queries) {\n        int prev = beautifulness[0];\n        beautifulness[0] = 0;\n        for (int i = 1; i < n; i++) {\n            int curr = beautifulness[i];\n            if (beautifulness[i] == prev)\n                beautifulness[i] = beautifulness[i - 1];\n            else\n                beautifulness[i] = i;\n            prev = curr;\n        }\n        vector<int> ans(q);\n        for (int i = 0; i < q; i++) {\n            int u = queries[i][0], v = queries[i][1];\n            u--;\n            v--;\n            if (beautifulness[v] <= u)\n                ans[i] = 1;\n        }\n        return ans;\n    }", "trans_code": "public static int [ ] canTrade ( int n , int [ ] beautifulness , int q , int [ ] [ ] queries ) {\n  int prev = beautifulness [ 0 ] ;\n  beautifulness [ 0 ] = 0 ;\n  for ( int i = 1 ;\n  i < n ;\n  i ++ ) {\n    int curr = beautifulness [ i ] ;\n    if ( beautifulness [ i ] == prev ) {\n      beautifulness [ i ] = beautifulness [ i - 1 ] ;\n    }\n    else {\n      beautifulness [ i ] = i ;\n    }\n    prev = curr ;\n  }\n  int [ ] ans = new int [ q ] ;\n  for ( int i = 0 ;\n  i < q ;\n  i ++ ) {\n    int u = queries [ i ] [ 0 ] , v = queries [ i ] [ 1 ] ;\n    u -- ;\n    v -- ;\n    if ( beautifulness [ v ] <= u ) {\n      ans [ i ] = 1 ;\n    }\n  }\n  return ans ;\n}\n", "reference_code": "    public static int[] canTrade(int n, int[] beautifulness, int q, int[][] queries) {\n        int prev = beautifulness[0];\n        beautifulness[0] = 0;\n        for (int i = 1; i < n; i++) {\n            int curr = beautifulness[i];\n            if (beautifulness[i] == prev) {\n                beautifulness[i] = beautifulness[i - 1];\n            } else {\n                beautifulness[i] = i;\n            }\n            prev = curr;\n        }\n        int[] ans = new int[q];\n        for (int i = 0; i < q; i++) {\n            int u = queries[i][0] - 1, v = queries[i][1] - 1;\n            ans[i] = beautifulness[v] <= u ? 1 : 0;\n        }\n        return ans;\n    }", "target_Lan": "java###canTrade_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.Arrays;\npublic class canTrade_Test {\n// TOFILL\n    public static void main(String[] args) {\n        int[] result1 = canTrade(5, new int[]{1, 2, 3, 4, 5}, 3, new int[][]{{1, 2}, {2, 3}, {3, 4}});\n        System.out.println(Arrays.toString(result1));\n\n        int[] result2 = canTrade(10, new int[]{10, 9, 8, 7, 6, 5, 4, 3, 2, 1}, 5, new int[][]{{1, 10}, {2, 9}, {3, 8}, {4, 7}, {5, 6}});\n        System.out.println(Arrays.toString(result2));\n\n\n        int[] result4 = canTrade(1, new int[]{1}, 1, new int[][]{{1, 1}});\n        System.out.println(Arrays.toString(result4));\n\n        int[] result5 = canTrade(2, new int[]{1, 2}, 2, new int[][]{{1, 1}, {2, 2}});\n        System.out.println(Arrays.toString(result5));\n    }\n}"}, {"source_Lan": "cpp###maxFrequencyElements.cpp", "source_code": "    int maxFrequencyElements(vector<int> &nums) {\n        int ans = 0, maxCnt = 0;\n        unordered_map<int, int> cnt;\n        for (int x : nums) {\n            int c = ++cnt[x];\n            if (c > maxCnt) {\n                maxCnt = ans = c;\n            } else if (c == maxCnt) {\n                ans += c;\n            }\n        }\n        return ans;\n    }", "trans_code": "public static int maxFrequencyElements ( int [ ] nums ) {\n  int ans = 0 , maxCnt = 0 ;\n  HashMap < Integer , Integer > cnt = new HashMap < Integer , Integer > ( ) ;\n  for ( int x : nums ) {\n    int c = ++ cnt . get ( x ) ;\n    if ( c > maxCnt ) maxCnt = ans = c ;\n    else if ( c == maxCnt ) ans += c ;\n  }\n  return ans ;\n}\n", "reference_code": "    public static int maxFrequencyElements(int[] nums) {\n        int ans = 0, maxCnt = 0;\n        Map<Integer, Integer> cnt = new HashMap<>();\n        for (int x : nums) {\n            int c = cnt.merge(x, 1, Integer::sum);\n            if (c > maxCnt) {\n                maxCnt = ans = c;\n            } else if (c == maxCnt) {\n                ans += c;\n            }\n        }\n        return ans;\n    }", "target_Lan": "java###maxFrequencyElements_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.HashMap;\nimport java.util.Map;\npublic class maxFrequencyElements_Test {\n// TOFILL\n    public static void main(String[] args) {\n        System.out.println(maxFrequencyElements(new int[]{1, 2, 2, 3, 3, 3}));\n        System.out.println(maxFrequencyElements(new int[]{1, 1, 1, 2, 2, 3, 3}));\n        System.out.println(maxFrequencyElements(new int[]{1, 2, 3, 4, 5, 6}));\n        System.out.println(maxFrequencyElements(new int[]{1, 1, 1, 1, 1, 1}));\n        System.out.println(maxFrequencyElements(new int[]{1, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4}));\n    }\n}"}, {"source_Lan": "cpp###minimumOperationsToMakeKPeriodic.cpp", "source_code": "    int minimumOperationsToMakeKPeriodic(string word, int k) {\n        int n = word.size(), mx = 0;\n        unordered_map<string, int> cnt;\n        for (int i = k; i <= n; i += k) {\n            mx = max(mx, ++cnt[word.substr(i - k, k)]);\n        }\n        return n / k - mx;\n    }", "trans_code": "public static int minimumOperationsToMakeKPeriodic ( String word , int k ) {\n  int n = word . length ( ) , mx = 0 ;\n  HashMap < String , Integer > cnt = new HashMap < String , Integer > ( ) ;\n  for ( int i = k ;\n  i <= n ;\n  i += k ) mx = Math . max ( mx , ++ cnt . get ( word . substring ( i - k , k ) ) ) ;\n  return n / k - mx ;\n}\n", "reference_code": "    public static int minimumOperationsToMakeKPeriodic(String word, int k) {\n        int n = word.length();\n        int mx = 0;\n        HashMap<String, Integer> cnt = new HashMap<>();\n        for (int i = k; i <= n; i += k) {\n            String sub = word.substring(i - k, i);\n            int c = cnt.merge(sub, 1, Integer::sum); \n            mx = Math.max(mx, c);\n        }\n        return n / k - mx;\n    }", "target_Lan": "java###minimumOperationsToMakeKPeriodic_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.HashMap;\npublic class minimumOperationsToMakeKPeriodic_Test {\n// TOFILL\n    public static void main(String[] args) {\n        System.out.println(minimumOperationsToMakeKPeriodic(\"abcabcabcabc\", 3));\n        System.out.println(minimumOperationsToMakeKPeriodic(\"aaaaa\", 1));\n        System.out.println(minimumOperationsToMakeKPeriodic(\"abcabcabcabc\", 4));\n        System.out.println(minimumOperationsToMakeKPeriodic(\"abcabcabcabc\", 6));\n        System.out.println(minimumOperationsToMakeKPeriodic(\"abcabcabcabc\", 12));\n    }\n}"}, {"source_Lan": "cpp###minimumCost.cpp", "source_code": "    int minimumCost(vector<int> &nums) {\n        sort(nums.begin() + 1, nums.end());\n        return accumulate(nums.begin(), nums.begin() + 3, 0);\n    }", "trans_code": "public static int minimumCost ( int [ ] nums ) {\n  Arrays . sort ( nums ) ;\n  return sum ( nums ) ;\n}\n", "reference_code": "    public static int minimumCost(int[] nums) {\n        Arrays.sort(nums, 1, nums.length);\n        return nums[0] + nums[1] + nums[2];\n    }", "target_Lan": "java###minimumCost_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.Arrays;\npublic class minimumCost_Test {\n// TOFILL\n    public static void main(String[] args) {\n        System.out.println(minimumCost(new int[]{1,2,3,4,5}));\n        System.out.println(minimumCost(new int[]{5,4,3,2,1}));\n        System.out.println(minimumCost(new int[]{1,1,1,1,1}));\n        System.out.println(minimumCost(new int[]{10,20,30,40,50}));\n        System.out.println(minimumCost(new int[]{5,5,5,5,5}));\n    }\n}"}, {"source_Lan": "cpp###maximumSubarraySum.cpp", "source_code": "    long long maximumSubarraySum(vector<int> &nums, int k) {\n        long long ans = LLONG_MIN, sum = 0;\n        unordered_map<int, long long> min_s;\n        for (int x: nums) {\n            auto it = min_s.find(x + k);\n            if (it != min_s.end()) {\n                ans = max(ans, sum + x - it->second);\n            }\n            it = min_s.find(x - k);\n            if (it != min_s.end()) {\n                ans = max(ans, sum + x - it->second);\n            }\n            it = min_s.find(x);\n            if (it == min_s.end() || sum < it->second) {\n                min_s[x] = sum;\n            }\n            sum += x;\n        }\n        return ans == LLONG_MIN ? 0 : ans;\n    }", "trans_code": "public static long maximumSubarraySum ( int [ ] nums , int k ) {\n  long ans = LLONG_MIN , sum = 0 ;\n  HashMap < Integer , Long > min_s = new HashMap < Integer , Long > ( ) ;\n  for ( int x : nums ) {\n    Integer key = min_s . get ( x + k ) ;\n    if ( key != null ) ans = Math . max ( ans , sum + x - key ) ;\n    key = min_s . get ( x - k ) ;\n    if ( key != null ) ans = Math . max ( ans , sum + x - key ) ;\n    key = min_s . get ( x ) ;\n    if ( key == null || sum < key ) min_s . put ( x , sum ) ;\n    sum += x ;\n  }\n  return ans == LLONG_MIN ? 0 : ans ;\n}\n", "reference_code": "    public static long maximumSubarraySum(int[] nums, int k) {\n        long ans = Long.MIN_VALUE;\n        long sum = 0;\n        Map<Integer, Long> minS = new HashMap<>();\n        for (int x : nums) {\n            long s1 = minS.getOrDefault(x - k, Long.MAX_VALUE / 2);\n            long s2 = minS.getOrDefault(x + k, Long.MAX_VALUE / 2);\n            ans = Math.max(ans, sum + x - Math.min(s1, s2));\n            minS.merge(x, sum, Math::min);\n            sum += x;\n        }\n        return ans > Long.MIN_VALUE / 4 ? ans : 0;\n    }", "target_Lan": "java###maximumSubarraySum_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.HashMap;\nimport java.util.Map;\npublic class maximumSubarraySum_Test {\n// TOFILL\n    public static void main(String[] args) {\n        int[] nums1 = {1, 2, 3, 4, 5};\n        int k1 = 1;\n        System.out.println(maximumSubarraySum(nums1, k1));\n\n        int[] nums2 = {1, 2, 3, 4, 5};\n        int k2 = 2;\n        System.out.println(maximumSubarraySum(nums2, k2));\n\n        int[] nums3 = {1, 2, 3, 4, 5};\n        int k3 = 3;\n        System.out.println(maximumSubarraySum(nums3, k3));\n\n        int[] nums4 = {1, 2, 3, 4, 5};\n        int k4 = 4;\n        System.out.println(maximumSubarraySum(nums4, k4));\n\n        int[] nums5 = {1, 2, 3, 4, 5};\n        int k5 = 5;\n        System.out.println(maximumSubarraySum(nums5, k5));\n    }\n}"}, {"source_Lan": "cpp###minimumLevels.cpp", "source_code": "    int minimumLevels(vector<int> &possible) {\n        \n        int n = possible.size();\n        int s = accumulate(possible.begin(), possible.end(), 0) * 2 - n;\n        int pre = 0;\n        for (int i = 0; i < n - 1; i++) {\n            pre += possible[i] ? 2 : -2;\n            if (pre > s) {\n                return i + 1;\n            }\n        }\n        return -1;\n    }", "trans_code": "public static int minimumLevels ( int [ ] possible ) {\n  int n = possible . length ;\n  int s = Arrays . binarySearch ( possible , 0 , n ) * 2 - n ;\n  int pre = 0 ;\n  for ( int i = 0 ;\n  i < n - 1 ;\n  i ++ ) {\n    pre += possible [ i ] ? 2 : - 2 ;\n    if ( pre > s ) {\n      return i + 1 ;\n    }\n  }\n  return - 1 ;\n}\n", "reference_code": "    public static int minimumLevels(int[] possible) {\n        \n        int n = possible.length;\n        int s = 0;\n        for (int x : possible) {\n            s += x;\n        }\n        s = s * 2 - n;\n        int pre = 0;\n        for (int i = 0; i < n - 1; i++) {\n            pre += possible[i] == 1 ? 2 : -2;\n            if (pre > s) {\n                return i + 1;\n            }\n        }\n        return -1;\n    }", "target_Lan": "java###minimumLevels_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.Arrays;\npublic class minimumLevels_Test {\n// TOFILL\n    public static void main(String[] args) {\n        System.out.println(minimumLevels(new int[]{1, 0, 1, 0, 1}));\n        System.out.println(minimumLevels(new int[]{1, 1, 1, 1, 1}));\n        System.out.println(minimumLevels(new int[]{0, 0, 0, 0, 0}));\n        System.out.println(minimumLevels(new int[]{1, 1, 1, 0, 0}));\n        System.out.println(minimumLevels(new int[]{0, 1, 0, 1, 0}));\n    }\n}"}, {"source_Lan": "cpp###minimumDistance.cpp", "source_code": "    int minimumDistance(vector<vector<int>>& points) {\n        multiset<int> sx, sy;\n        for (auto & p : points) {\n            sx.emplace(p[0] - p[1]);\n            sy.emplace(p[0] + p[1]);\n        }\n        int res = INT_MAX;\n        for (auto &p : points) {\n            sx.erase(sx.find(p[0] - p[1]));\n            sy.erase(sy.find(p[0] + p[1]));\n            res = min(res, max(*sx.rbegin() - *sx.begin(), *sy.rbegin() - *sy.begin()));\n            sx.emplace(p[0] - p[1]);\n            sy.emplace(p[0] + p[1]);\n        }\n        return res;\n    }", "trans_code": "public static int minimumDistance ( List < List < Integer >> points ) {\n  Multiset < Integer > sx = LinkedHashMultiset . create ( ) , sy = LinkedHashMultiset . create ( ) ;\n  for ( List < Integer > p : points ) {\n    sx . add ( p . get ( 0 ) - p . get ( 1 ) ) ;\n    sy . add ( p . get ( 0 ) + p . get ( 1 ) ) ;\n  }\n  int res = Integer . MAX_VALUE ;\n  for ( List < Integer > p : points ) {\n    sx . remove ( p . get ( 0 ) - p . get ( 1 ) ) ;\n    sy . remove ( p . get ( 0 ) + p . get ( 1 ) ) ;\n    res = Math . min ( res , Math . max ( sx . size ( ) - sx . getCount ( ) , sy . size ( ) - sy . getCount ( ) ) ) ;\n    sx . add ( p . get ( 0 ) - p . get ( 1 ) ) ;\n    sy . add ( p . get ( 0 ) + p . get ( 1 ) ) ;\n  }\n  return res ;\n}\n", "reference_code": "    public static int minimumDistance(int[][] points) {\n        TreeMap<Integer, Integer> sx = new TreeMap<Integer, Integer>();\n        TreeMap<Integer, Integer> sy = new TreeMap<Integer, Integer>();\n        for (int[] p : points) {\n            sx.put(p[0] - p[1], sx.getOrDefault(p[0] - p[1], 0) + 1);\n            sy.put(p[0] + p[1], sy.getOrDefault(p[0] + p[1], 0) + 1);\n        }\n        int res = Integer.MAX_VALUE;\n        for (int[] p : points) {\n            sx.put(p[0] - p[1], sx.get(p[0] - p[1]) - 1);\n            if (sx.get(p[0] - p[1]) == 0) {\n                sx.remove(p[0] - p[1]);\n            }\n            sy.put(p[0] + p[1], sy.get(p[0] + p[1]) - 1);\n            if (sy.get(p[0] + p[1]) == 0) {\n                sy.remove(p[0] + p[1]);\n            }\n            res = Math.min(res, Math.max(sx.lastKey() - sx.firstKey(), sy.lastKey() - sy.firstKey()));\n            sx.put(p[0] - p[1], sx.getOrDefault(p[0] - p[1], 0) + 1);\n            sy.put(p[0] + p[1], sy.getOrDefault(p[0] + p[1], 0) + 1);\n        }\n        return res;\n    }", "target_Lan": "java###minimumDistance_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.TreeMap;\npublic class minimumDistance_Test {\n// TOFILL\n    public static void main(String[] args) {\n        int[][] points1 = {{0,0},{1,1},{2,2}};\n        int[][] points2 = {{0,0},{1,2},{2,3}};\n        int[][] points3 = {{0,0},{1,1},{2,3}};\n        int[][] points4 = {{0,0},{1,1},{2,4}};\n        int[][] points5 = {{0,0},{1,1},{2,5}};\n\n        System.out.println(minimumDistance(points1));\n        System.out.println(minimumDistance(points2));\n        System.out.println(minimumDistance(points3));\n        System.out.println(minimumDistance(points4));\n        System.out.println(minimumDistance(points5));\n    }\n}"}, {"source_Lan": "cpp###goodSubsetofBinaryMatrix.cpp", "source_code": "    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid) {\n        vector<int> ans;\n        unordered_map<int, int> mp;\n        int m = grid.size();\n        int n = grid[0].size();\n        for (int j = 0; j < m; j++) {\n            int st = 0;\n            for (int i = 0; i < n; i++) {\n                st |= (grid[j][i] << i);\n            }\n            mp[st] = j;\n        }\n        if (mp.count(0)) {\n            ans.push_back(mp[0]);\n            return ans;\n        }\n        for (auto [x, i]: mp) {\n            for (auto [y, j]: mp) {\n                if (!(x & y)) {\n                    return {min(i, j), max(i, j)};\n                }\n            }\n        }\n        return ans;\n    }", "trans_code": "public static int [ ] goodSubsetofBinaryMatrix ( int [ ] [ ] grid ) {\n  int [ ] ans = new int [ grid . length ] ;\n  HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ;\n  int m = grid . length ;\n  int n = grid [ 0 ] . length ;\n  for ( int j = 0 ;\n  j < m ;\n  j ++ ) {\n    int st = 0 ;\n    for ( int i = 0 ;\n    i < n ;\n    i ++ ) st |= ( grid [ j ] [ i ] << i ) ;\n    mp . put ( st , j ) ;\n  }\n  if ( mp . containsKey ( 0 ) ) {\n    ans [ 0 ] = mp . get ( 0 ) ;\n    return ans ;\n  }\n  for ( Integer x : mp . keySet ( ) ) {\n    for ( Integer y : mp . get ( x ) ) {\n      if ( ! ( x & y ) ) {\n        return new int [ ] {\n          min ( i , j ) , max ( i , j ) }\n          ;\n        }\n      }\n    }\n    return ans ;\n  }\n  ", "reference_code": "    public static List<Integer> goodSubsetofBinaryMatrix(int[][] grid) {\n        List<Integer> ans = new ArrayList<Integer>();\n        Map<Integer, Integer> mp = new HashMap<Integer, Integer>();\n        int m = grid.length;\n        int n = grid[0].length;\n        for (int j = 0; j < m; j++) {\n            int st = 0;\n            for (int i = 0; i < n; i++) {\n                st |= (grid[j][i] << i);\n            }\n            mp.put(st, j);\n        }\n        if (mp.containsKey(0)) {\n            ans.add(mp.get(0));\n            return ans;\n        }\n        for (Map.Entry<Integer, Integer> entry1 : mp.entrySet()) {\n            int x = entry1.getKey(), i = entry1.getValue();\n            for (Map.Entry<Integer, Integer> entry2 : mp.entrySet()) {\n                int y = entry2.getKey(), j = entry2.getValue();\n                if ((x & y) == 0) {\n                    List<Integer> list = new ArrayList<Integer>();\n                    list.add(Math.min(i, j));\n                    list.add(Math.max(i, j));\n                    return list;\n                }\n            }\n        }\n        return ans;\n    }", "target_Lan": "java###goodSubsetofBinaryMatrix_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.*;\npublic class goodSubsetofBinaryMatrix_Test {\n// TOFILL\n    public static void main(String[] args) {\n        int[][] grid1 = {{0,0,0,0,0},{0,0,0,0,0},{0,0,0,0,0},{0,0,0,0,0},{0,0,0,0,0}};\n        System.out.println(goodSubsetofBinaryMatrix(grid1));\n\n        int[][] grid2 = {{1,1,1,1,1},{1,1,1,1,1},{1,1,1,1,1},{1,1,1,1,1},{1,1,1,1,1}};\n        System.out.println(goodSubsetofBinaryMatrix(grid2));\n\n        int[][] grid3 = {{1,0,1,0,1},{0,1,0,1,0},{1,0,1,0,1},{0,1,0,1,0},{1,0,1,0,1}};\n        System.out.println(goodSubsetofBinaryMatrix(grid3));\n\n        int[][] grid4 = {{1,1,1,1,1},{0,0,0,0,0},{1,1,1,1,1},{0,0,0,0,0},{1,1,1,1,1}};\n        System.out.println(goodSubsetofBinaryMatrix(grid4));\n\n        int[][] grid5 = {{0,1,0,1,0},{1,0,1,0,1},{0,1,0,1,0},{1,0,1,0,1},{0,1,0,1,0}};\n        System.out.println(goodSubsetofBinaryMatrix(grid5));\n    }\n}"}, {"source_Lan": "cpp###findMaximumElegance.cpp", "source_code": "    long long findMaximumElegance(vector<vector<int>>& items, int k) {\n        sort(items.begin(), items.end(), [&](const vector<int> &item1, const vector<int> &item2) -> bool {\n            return item1[0] > item2[0];\n        });\n        unordered_set<int> categorySet;\n        long long res = 0, profit = 0;\n        stack<int> st;\n        for (int i = 0; i < items.size(); i++) {\n            if (i < k) {\n                profit += items[i][0];\n                if (categorySet.count(items[i][1]) == 0) {\n                    categorySet.insert(items[i][1]);\n                } else {\n                    st.push(items[i][0]);\n                }\n            } else if (categorySet.count(items[i][1]) == 0 && !st.empty()) {\n                profit += items[i][0] - st.top();\n                st.pop();\n                categorySet.insert(items[i][1]);\n            }\n            res = max(res, (long long)(profit + categorySet.size() * categorySet.size()));\n        }\n        return res;\n    }", "trans_code": "public static long findMaximumElegance ( int [ ] [ ] items , int k ) {\n  Arrays . sort ( items , new Comparator < int [ ] > ( ) {\n    @ Override public int compare ( int [ ] item1 , int [ ] item2 ) throws Exception {\n      return item1 [ 0 ] . compareTo ( item2 [ 0 ] ) ;\n    }\n  }\n  ) ;\n  HashSet < Integer > categorySet = new HashSet < Integer > ( ) ;\n  long res = 0 , profit = 0 ;\n  Stack < Integer > st = new Stack < Integer > ( ) ;\n  for ( int i = 0 ;\n  i < items . length ;\n  i ++ ) {\n    if ( i < k ) {\n      profit += items [ i ] [ 0 ] ;\n      if ( categorySet . contains ( items [ i ] [ 1 ] ) ) categorySet . add ( items [ i ] [ 1 ] ) ;\n      else st . push ( items [ i ] [ 0 ] ) ;\n    }\n    else if ( categorySet . contains ( items [ i ] [ 1 ] ) && ! st . isEmpty ( ) ) {\n      profit += items [ i ] [ 0 ] - st . pop ( ) ;\n      st . pop ( ) ;\n      categorySet . add ( items [ i ] [ 1 ] ) ;\n    }\n    res = Math . max ( res , ( long ) ( profit + categorySet . size ( ) * categorySet . size ( ) ) ) ;\n  }\n  return res ;\n}\n", "reference_code": "    public static long findMaximumElegance(int[][] items, int k) {\n        Arrays.sort(items, (item0, item1) -> item1[0] - item0[0]);\n        var categorySet = new HashSet<Integer>();\n        long profit = 0, res = 0;\n        var st = new ArrayDeque<Integer>();\n        for (int i = 0; i < items.length; i++) {\n            if (i < k) {\n                profit += items[i][0];\n                if (!categorySet.add(items[i][1])) {\n                    st.push(items[i][0]);\n                }\n            } else if (!st.isEmpty() && categorySet.add(items[i][1])) {\n                profit += items[i][0] - st.pop();\n            }\n            res = Math.max(res, profit + (long)categorySet.size() * categorySet.size());\n        }\n        return res;\n    }", "target_Lan": "java###findMaximumElegance_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.*;\npublic class findMaximumElegance_Test {\n// TOFILL\n    public static void main(String[] args) {\n        int[][] items1 = {{1,2},{3,4},{5,6},{7,8},{9,10}};\n        int[][] items2 = {{10,1},{9,2},{8,3},{7,4},{6,5}};\n        int[][] items3 = {{1,1},{2,2},{3,3},{4,4},{5,5}};\n        int[][] items4 = {{1,1},{2,2},{3,3},{4,4},{5,5}};\n        int[][] items5 = {{1,1},{2,2},{3,3},{4,4},{5,5}};\n\n        System.out.println(findMaximumElegance(items1, 3));\n        System.out.println(findMaximumElegance(items2, 2));\n        System.out.println(findMaximumElegance(items3, 1));\n        System.out.println(findMaximumElegance(items4, 0));\n        System.out.println(findMaximumElegance(items5, 6));\n    }\n}"}, {"source_Lan": "cpp###maximumBeauty.cpp", "source_code": "    int maximumBeauty(vector<int>& nums, int k) {\n        int res = 0, n = nums.size();\n        sort(nums.begin(), nums.end());\n        for (int i = 0, j = 0; i < n; i++) {\n            while (nums[i] - 2 * k > nums[j]) {\n                j++;\n            }\n            res = max(res, i - j + 1);\n        }\n        return res;\n    }", "trans_code": "public static int maximumBeauty ( int [ ] nums , int k ) {\n  int res = 0 , n = nums . length ;\n  Arrays . sort ( nums ) ;\n  for ( int i = 0 , j = 0 ;\n  i < n ;\n  i ++ ) {\n    while ( nums [ i ] - 2 * k > nums [ j ] ) j ++ ;\n    res = Math . max ( res , i - j + 1 ) ;\n  }\n  return res ;\n}\n", "reference_code": "    public static int maximumBeauty(int[] nums, int k) {\n        int res = 0, n = nums.length;\n        Arrays.sort(nums);\n        for (int i = 0, j = 0; i < n; i++) {\n            while (nums[i] - 2 * k > nums[j]) {\n                j++;\n            }\n            res = Math.max(res, i - j + 1);\n        }\n        return res;\n    }", "target_Lan": "java###maximumBeauty_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.Arrays;\npublic class maximumBeauty_Test {\n// TOFILL\n    public static void main(String[] args) {\n        System.out.println(maximumBeauty(new int[]{1,2,3,4,5}, 1));\n        System.out.println(maximumBeauty(new int[]{5,4,3,2,1}, 2));\n        System.out.println(maximumBeauty(new int[]{1,1,1,1,1}, 0));\n        System.out.println(maximumBeauty(new int[]{10,20,30,40,50}, 5));\n        System.out.println(maximumBeauty(new int[]{1,2,3,4,5,6,7,8,9,10}, 3));\n    }\n}"}, {"source_Lan": "cpp###maxScore.cpp", "source_code": "    long long maxScore(vector<int>& nums, int x) {\n        long long res = nums[0];\n        vector<long long> dp(2, INT_MIN);\n        dp[nums[0] % 2] = nums[0];\n        for (int i = 1; i < nums.size(); i++) {\n            int parity = nums[i] % 2;\n            long long cur = max(dp[parity] + nums[i], dp[1 - parity] - x + nums[i]);\n            res = max(res, cur);\n            dp[parity] = max(dp[parity], cur);\n        }\n        return res;\n    }", "trans_code": "public static long maxScore ( int [ ] nums , int x ) {\n  long res = nums [ 0 ] ;\n  long [ ] dp = new long [ 2 ] ;\n  dp [ nums [ 0 ] % 2 ] = nums [ 0 ] ;\n  for ( int i = 1 ;\n  i < nums . length ;\n  i ++ ) {\n    int parity = nums [ i ] % 2 ;\n    long cur = Math . max ( dp [ parity ] + nums [ i ] , dp [ 1 - parity ] - x + nums [ i ] ) ;\n    res = Math . max ( res , cur ) ;\n    dp [ parity ] = Math . max ( dp [ parity ] , cur ) ;\n  }\n  return res ;\n}\n", "reference_code": "    public static long maxScore(int[] nums, int x) {\n        long res = nums[0];\n        long[] dp = {Integer.MIN_VALUE, Integer.MIN_VALUE};\n        dp[nums[0] % 2] = nums[0];\n        for (int i = 1; i < nums.length; i++) {\n            int parity = (int) (nums[i] % 2);\n            long cur = Math.max(dp[parity] + nums[i], dp[1 - parity] - x + nums[i]);\n            res = Math.max(res, cur);\n            dp[parity] = Math.max(dp[parity], cur);\n        }\n        return res;\n    }", "target_Lan": "java###maxScore_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.Arrays;\npublic class maxScore_Test {\n// TOFILL\n    public static void main(String[] args) {\n        System.out.println(maxScore(new int[]{1,2,3,4,5}, 2));\n        System.out.println(maxScore(new int[]{10,20,30,40,50}, 10));\n        System.out.println(maxScore(new int[]{100,200,300,400,500}, 50));\n        System.out.println(maxScore(new int[]{1000,2000,3000,4000,5000}, 250));\n        System.out.println(maxScore(new int[]{10000,20000,30000,40000,50000}, 1250));\n    }\n}"}, {"source_Lan": "cpp###findMinimumTime.cpp", "source_code": "    int findMinimumTime(vector<vector<int>>& tasks) {\n        int n = tasks.size();\n        sort(tasks.begin(), tasks.end(), [&](const vector<int> &t1, const vector<int> &t2) -> bool {\n            return t1[1] < t2[1];\n        });\n        vector<int> run(tasks[n - 1][1] + 1);\n        int res = 0;\n        for (int i = 0; i < n; i++) {\n            int start = tasks[i][0], end = tasks[i][1], duration = tasks[i][2];\n            duration -= accumulate(run.begin() + start, run.begin() + end + 1, 0);\n            res += max(duration, 0);\n            for (int j = end; j >= 0 && duration > 0; j--) {\n                if (run[j] == 0) {\n                    duration--;\n                    run[j] = 1;\n                }\n            }\n        }\n        return res;\n    }", "trans_code": "public static int findMinimumTime ( int [ ] [ ] tasks ) {\n  int n = tasks . length ;\n  Arrays . sort ( tasks , new Comparator < int [ ] > ( ) {\n    @ Override public int compare ( int [ ] t1 , int [ ] t2 ) throws Exception {\n      return t1 [ 1 ] - t2 [ 1 ] ;\n    }\n  }\n  ) ;\n  int [ ] run = new int [ tasks [ n - 1 ] . length + 1 ] ;\n  int res = 0 ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    int start = tasks [ i ] [ 0 ] , end = tasks [ i ] [ 1 ] , duration = tasks [ i ] [ 2 ] ;\n    duration -= Arrays . binarySearch ( run , start , end + 1 ) ;\n    res += Math . max ( duration , 0 ) ;\n    for ( int j = end ;\n    j >= 0 && duration > 0 ;\n    j -- ) {\n      if ( run [ j ] == 0 ) {\n        duration -- ;\n        run [ j ] = 1 ;\n      }\n    }\n  }\n  return res ;\n}\n", "reference_code": "    public static int findMinimumTime(int[][] tasks) {\n        int n = tasks.length;\n        Arrays.sort(tasks, (a, b) -> a[1] - b[1]);\n        int[] run = new int[tasks[n - 1][1] + 1];\n        int res = 0;\n        for (int i = 0; i < n; i++) {\n            int start = tasks[i][0], end = tasks[i][1], duration = tasks[i][2];\n            for (int j = start; j <= end; j++) {\n                duration -= run[j];\n            }\n            res += Math.max(duration, 0);\n            for (int j = end; j >= 0 && duration > 0; j--) {\n                if (run[j] == 0) {\n                    duration--;\n                    run[j] = 1;\n                }\n            }\n        }\n        return res;\n    }", "target_Lan": "java###findMinimumTime_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.Arrays;\npublic class findMinimumTime_Test {\n// TOFILL\n    public static void main(String[] args) {\n        int[][] tasks1 = {{1,3,2},{2,5,3},{5,6,2}};\n        int[][] tasks2 = {{1,3,2},{2,5,3},{5,6,2},{7,9,1}};\n        int[][] tasks3 = {{1,3,2},{2,5,3},{5,6,2},{7,9,1},{10,12,2}};\n        int[][] tasks4 = {{1,3,2},{2,5,3},{5,6,2},{7,9,1},{10,12,2},{13,15,1}};\n        int[][] tasks5 = {{1,3,2},{2,5,3},{5,6,2},{7,9,1},{10,12,2},{13,15,1},{16,18,2}};\n\n        System.out.println(findMinimumTime(tasks1));\n        System.out.println(findMinimumTime(tasks2));\n        System.out.println(findMinimumTime(tasks3));\n        System.out.println(findMinimumTime(tasks4));\n        System.out.println(findMinimumTime(tasks5));\n    }\n}"}, {"source_Lan": "cpp###totalCost.cpp", "source_code": "    long long totalCost(vector<int>& costs, int k, int candidates) {\n        int n = costs.size();\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> q;\n        int left = candidates - 1, right = n - candidates;\n        if (left + 1 < right) {\n            for (int i = 0; i <= left; ++i) {\n                q.emplace(costs[i], i);\n            }\n            for (int i = right; i < n; ++i) {\n                q.emplace(costs[i], i);\n            }\n        }\n        else {\n            for (int i = 0; i < n; ++i) {\n                q.emplace(costs[i], i);\n            }\n        }\n        long long ans = 0;\n        for (int _ = 0; _ < k; ++_) {\n            auto [cost, id] = q.top();\n            q.pop();\n            ans += cost;\n            if (left + 1 < right) {\n                if (id <= left) {\n                    ++left;\n                    q.emplace(costs[left], left);\n                }\n                else {\n                    --right;\n                    q.emplace(costs[right], right);\n                }\n            }\n        }\n        return ans;\n    }", "trans_code": "public static long totalCost ( int [ ] costs , int k , int candidates ) {\n  int n = costs . length ;\n  PriorityQueue < Pair < Integer , Integer >> q = new PriorityQueue < Pair < Integer , Integer >> ( ) ;\n  int left = candidates - 1 , right = n - candidates ;\n  if ( left + 1 < right ) {\n    for ( int i = 0 ;\n    i <= left ;\n    ++ i ) q . add ( costs [ i ] ) ;\n    for ( int i = right ;\n    i < n ;\n    ++ i ) q . add ( costs [ i ] ) ;\n  }\n  else {\n    for ( int i = 0 ;\n    i < n ;\n    ++ i ) q . add ( costs [ i ] ) ;\n  }\n  long ans = 0 ;\n  for ( int _ = 0 ;\n  _ < k ;\n  ++ _ ) {\n    Pair < Integer , Integer > [ ] cost = q . toArray ( new Pair [ k ] ) ;\n    q . poll ( ) ;\n    ans += cost [ 0 ] . first ;\n    if ( left + 1 < right ) {\n      if ( id <= left ) {\n        ++ left ;\n        q . add ( costs [ left ] ) ;\n      }\n      else {\n        -- right ;\n        q . add ( costs [ right ] ) ;\n      }\n    }\n  }\n  return ans ;\n}\n", "reference_code": "    public static long totalCost(int[] costs, int k, int candidates) {\n        int n = costs.length;\n        PriorityQueue<int[]> pq = new PriorityQueue<int[]>((a, b) -> a[0] != b[0] ? a[0] - b[0] : a[1] - b[1]);\n        int left = candidates - 1, right = n - candidates;\n        if (left + 1 < right) {\n            for (int i = 0; i <= left; ++i) {\n                pq.offer(new int[]{costs[i], i});\n            }\n            for (int i = right; i < n; ++i) {\n                pq.offer(new int[]{costs[i], i});\n            }\n        } else {\n            for (int i = 0; i < n; ++i) {\n                pq.offer(new int[]{costs[i], i});\n            }\n        }\n        long ans = 0;\n        for (int i = 0; i < k; ++i) {\n            int[] arr = pq.poll();\n            int cost = arr[0], id = arr[1];\n            ans += cost;\n            if (left + 1 < right) {\n                if (id <= left) {\n                    ++left;\n                    pq.offer(new int[]{costs[left], left});\n                } else {\n                    --right;\n                    pq.offer(new int[]{costs[right], right});\n                }\n            }\n        }\n        return ans;\n    }", "target_Lan": "java###totalCost_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.*;\npublic class totalCost_Test {\n// TOFILL\n    public static void main(String[] args) {\n        System.out.println(totalCost(new int[]{1,2,3,4,5}, 2, 2));\n        System.out.println(totalCost(new int[]{5,4,3,2,1}, 3, 1));\n        System.out.println(totalCost(new int[]{10,20,30,40,50}, 1, 3));\n        System.out.println(totalCost(new int[]{100,200,300,400,500}, 5, 5));\n        System.out.println(totalCost(new int[]{1000,2000,3000,4000,5000}, 3, 2));\n    }\n}"}, {"source_Lan": "cpp###distinctIntegers.cpp", "source_code": "    int distinctIntegers(int n) {\n        vector<int> nums(n + 1);\n        nums[n] = 1;\n        for (int k = 0; k < n; k++) {\n            for (int x = 1; x <= n; x++) {\n                if (nums[x] == 0) {\n                    continue;\n                }\n                for (int i = 1; i <= n; i++) {\n                    if (x % i == 1) {\n                        nums[i] = 1;\n                    }\n                }\n            }\n        }\n        return accumulate(nums.begin(), nums.end(), 0);\n    }", "trans_code": "public static int distinctIntegers ( int n ) {\n  int [ ] nums = new int [ n + 1 ] ;\n  nums [ n ] = 1 ;\n  for ( int k = 0 ;\n  k < n ;\n  k ++ ) {\n    for ( int x = 1 ;\n    x <= n ;\n    x ++ ) {\n      if ( nums [ x ] == 0 ) {\n        continue ;\n      }\n      for ( int i = 1 ;\n      i <= n ;\n      i ++ ) {\n        if ( x % i == 1 ) {\n          nums [ i ] = 1 ;\n        }\n      }\n    }\n  }\n  return accumulate ( nums ) ;\n}\n", "reference_code": "    public static int distinctIntegers(int n) {\n        int[] nums = new int[n + 1];\n        nums[n] = 1;\n        for (int k = 0; k < n; k++) {\n            for (int x = 1; x <= n; x++) {\n                if (nums[x] == 0) {\n                    continue;\n                }\n                for (int i = 1; i <= n; i++) {\n                    if (x % i == 1) {\n                        nums[i] = 1;\n                    }\n                }\n            }\n        }\n        return Arrays.stream(nums).sum();\n    }", "target_Lan": "java###distinctIntegers_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.Arrays;\npublic class distinctIntegers_Test {\n// TOFILL\n    public static void main(String[] args) {\n        System.out.println(distinctIntegers(0));\n        System.out.println(distinctIntegers(1));\n        System.out.println(distinctIntegers(2));\n        System.out.println(distinctIntegers(10));\n        System.out.println(distinctIntegers(100));\n    }\n}"}, {"source_Lan": "cpp###minimumTime.cpp", "source_code": "    int minimumTime(vector<int>& nums1, vector<int>& nums2, int x) {\n        int n = nums1.size();\n        vector<vector<int>> dp(n + 1, vector<int>(n + 1, 0));\n        vector<pair<int, int>> nums(n);\n        for (int i = 0; i < n; i++) {\n            nums[i] = {nums2[i], nums1[i]};\n        }\n        sort(nums.begin(), nums.end());\n        for (int j = 1; j <= n; j++) {\n            int b = nums[j - 1].first, a = nums[j - 1].second;\n            for (int i = j; i > 0; i--) {\n                dp[j][i] = max(dp[j - 1][i], dp[j - 1][i - 1] + i * b + a);\n            }\n        }\n        int s1 = accumulate(nums1.begin(), nums1.end(), 0);\n        int s2 = accumulate(nums2.begin(), nums2.end(), 0);\n        for (int i = 0; i <= n; i++) {\n            if (s2 * i + s1 - dp[n][i] <= x) {\n                return i;\n            }\n        }\n        return -1;\n    }", "trans_code": "public static int minimumTime ( int [ ] [ ] nums1 , int [ ] [ ] nums2 , int x ) {\n  int n = nums1 . length ;\n  int [ ] [ ] dp = new int [ n + 1 ] [ n + 1 ] ;\n  int [ ] [ ] nums = new int [ n ] [ n ] ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) nums [ i ] = new int [ ] {\n    nums2 [ i ] , nums1 [ i ] }\n    ;\n    Arrays . sort ( nums ) ;\n    for ( int j = 1 ;\n    j <= n ;\n    j ++ ) {\n      int b = nums [ j - 1 ] [ 0 ] , a = nums [ j - 1 ] [ 1 ] ;\n      for ( int i = j ;\n      i > 0 ;\n      i -- ) dp [ j ] [ i ] = max ( dp [ j - 1 ] [ i ] , dp [ j - 1 ] [ i - 1 ] + i * b + a ) ;\n    }\n    int s1 = Arrays . binarySearch ( nums1 ) ;\n    int s2 = Arrays . binarySearch ( nums2 ) ;\n    for ( int i = 0 ;\n    i <= n ;\n    i ++ ) {\n      if ( s2 * i + s1 - dp [ n ] [ i ] <= x ) return i ;\n    }\n    return - 1 ;\n  }\n  ", "reference_code": "    public static int minimumTime(List<Integer> nums1, List<Integer> nums2, int x) {\n        int n = nums1.size(), s1 = 0, s2 = 0;\n        int[][] dp = new int[n + 1][n + 1];\n        List<List<Integer>> nums = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            int a = nums1.get(i), b = nums2.get(i);\n            nums.add(Arrays.asList(b, a));\n            s1 += a;\n            s2 += b;\n        }\n        Collections.sort(nums, (o1, o2) -> Integer.compare(o1.get(0), o2.get(0)));\n        for (int j = 1; j <= n; ++j) {\n            int b = nums.get(j - 1).get(0), a = nums.get(j - 1).get(1);\n            for (int i = j; i > 0; --i) {\n                dp[j][i] = Math.max(dp[j - 1][i], dp[j - 1][i - 1] + i * b + a);\n            }\n        }\n        for (int i = 0; i <= n; i++) {\n            if (s2 * i + s1 - dp[n][i] <= x) {\n                return i;\n            }\n        }\n        return -1;\n    }", "target_Lan": "java###minimumTime_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.*;\npublic class minimumTime_Test {\n// TOFILL\n    public static void main(String[] args) {\n        System.out.println(minimumTime(Arrays.asList(1,2,3,4,5), Arrays.asList(1,2,3,4,5), 15));\n        System.out.println(minimumTime(Arrays.asList(5,4,3,2,1), Arrays.asList(1,2,3,4,5), 15));\n        System.out.println(minimumTime(Arrays.asList(1,1,1,1,1), Arrays.asList(1,1,1,1,1), 5));\n        System.out.println(minimumTime(Arrays.asList(1,2,3,4,5), Arrays.asList(5,4,3,2,1), 15));\n        System.out.println(minimumTime(Arrays.asList(1,1,1,1,1), Arrays.asList(1,1,1,1,1), 0));\n    }\n}"}, {"source_Lan": "cpp###minLength.cpp", "source_code": "    int minLength(string s) {\n        vector<int> st;\n        for (char c : s) {\n            st.push_back(c);\n            int m = st.size();\n            if (m >= 2 &&\n                (st[m - 2] == 'A' && st[m - 1] == 'B' ||\n                st[m - 2] == 'C' && st[m - 1] == 'D')) {\n                st.pop_back();\n                st.pop_back();\n            }\n        }\n        return st.size();\n    }", "trans_code": "public static int minLength ( String s ) {\n  ArrayList < Integer > st = new ArrayList < Integer > ( ) ;\n  for ( char c : s . toCharArray ( ) ) {\n    st . add ( c ) ;\n    int m = st . size ( ) ;\n    if ( m >= 2 && ( st . get ( m - 2 ) == 'A' && st . get ( m - 1 ) == 'B' || st . get ( m - 2 ) == 'C' && st . get ( m - 1 ) == 'D' ) ) {\n      st . remove ( m ) ;\n      st . remove ( m ) ;\n    }\n  }\n  return st . size ( ) ;\n}\n", "reference_code": "    public static int minLength(String s) {\n        List<Character> stack = new ArrayList<Character>();\n        for (int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n            stack.add(c);\n            int m = stack.size();\n            if (m >= 2 &&\n                (stack.get(m - 2) == 'A' && stack.get(m - 1) == 'B' ||\n                stack.get(m - 2) == 'C' && stack.get(m - 1) == 'D')) {\n                stack.remove(m - 1);\n                stack.remove(m - 2);\n            }\n        }\n        return stack.size();\n    }", "target_Lan": "java###minLength_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.ArrayList;\nimport java.util.List;\npublic class minLength_Test {\n// TOFILL\n    public static void main(String[] args) {\n        System.out.println(minLength(\"AB\"));\n        System.out.println(minLength(\"CD\"));\n        System.out.println(minLength(\"AA\"));\n        System.out.println(minLength(\"BB\"));\n        System.out.println(minLength(\"CC\"));\n    }\n}"}, {"source_Lan": "cpp###addMinimum.cpp", "source_code": "    int addMinimum(string word) {\n        int n = word.size();\n        vector<int> d(n + 1);\n        for (int i = 1; i <= n; i++) {\n            d[i] = d[i - 1] + 2;\n            if (i > 1 && word[i - 1] > word[i - 2]) {\n                d[i] = d[i - 1] - 1;\n            }\n        }\n        return d[n];\n    }", "trans_code": "public static int addMinimum ( String word ) {\n  int n = word . length ( ) ;\n  int [ ] d = new int [ n + 1 ] ;\n  for ( int i = 1 ;\n  i <= n ;\n  i ++ ) {\n    d [ i ] = d [ i - 1 ] + 2 ;\n    if ( i > 1 && word . charAt ( i - 1 ) > word . charAt ( i - 2 ) ) d [ i ] = d [ i - 1 ] - 1 ;\n  }\n  return d [ n ] ;\n}\n", "reference_code": "    public static int addMinimum(String word) {\n        int n = word.length();\n        int[] d = new int[n + 1];\n        for (int i = 1; i <= n; i++) {\n            d[i] = d[i - 1] + 2;\n            if (i > 1 && word.charAt(i - 1) > word.charAt(i - 2)) {\n                d[i] = d[i - 1] - 1;\n            }\n        }\n        return d[n];\n    }", "target_Lan": "java###addMinimum_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\n\npublic class addMinimum_Test {\n// TOFILL\npublic static void main(String[] args) {\n    System.out.println(addMinimum(\"a\"));\n    System.out.println(addMinimum(\"ab\"));\n    System.out.println(addMinimum(\"ba\"));\n    System.out.println(addMinimum(\"abc\"));\n    System.out.println(addMinimum(\"cba\"));\n}\n}"}, {"source_Lan": "cpp###bobHappiness.cpp", "source_code": "    int bobHappiness(int n, int k, int q, vector<vector<int>> &students,\n                     vector<vector<int>> &queries) {\n        set<int> set1, set2;\n        for (auto &a : students) {\n            set1.insert(a[0]);\n            set2.insert(a[1]);\n        }\n        map<int, int> map1, map2;\n        int idx1 = 1, idx2 = 1;\n        while (!set1.empty()) {\n            map1[*set1.begin()] = idx1++;\n            set1.erase(set1.begin());\n            map2[*set2.begin()] = idx2++;\n            set2.erase(set2.begin());\n        }\n        vector<vector<int>> pre(n, vector<int>(n, 0));\n        for (int i = 0; i < n; ++i) {\n            pre[map1[students[i][0]] - 1][map2[students[i][1]] - 1]++;\n        }\n        vector<vector<int>> Arr(n + 1, vector<int>(n + 1, 0));\n        for (int i = 1; i <= n; ++i) {\n            for (int j = 1; j <= n; ++j) {\n                if (pre[i - 1][j - 1] == 0) {\n                    Arr[i][j] = Arr[i - 1][j] + Arr[i][j - 1] - Arr[i - 1][j - 1];\n                } else {\n                    Arr[i][j] = Arr[i - 1][j] + Arr[i][j - 1] + 1 - Arr[i - 1][j - 1];\n                }\n            }\n        }\n        int sum = 0;\n        for (int i = 0; i < q; ++i) {\n            int X = queries[i][0], Y = queries[i][1];\n            X--;\n            Y--;\n            int a = map1[students[Y][0]];\n            int b = map2[students[Y][1]];\n            int c = map1[students[X][0]], d = map2[students[X][1]];\n            swap(a, c);\n            int people = Arr[c][d] + Arr[a - 1][b - 1] - Arr[a - 1][d] - Arr[c][b - 1];\n            people -= 2;\n            if (people > k) {\n                \n            } else {\n                sum++;\n            }\n        }\n        return sum;\n    }", "trans_code": "public static int bobHappiness ( int n , int k , int q , List < List < Integer >> students , List < List < Integer >> queries ) {\n  Set < Integer > set1 , set2 ;\n  for ( List < Integer > a : students ) {\n    set1 . add ( a . get ( 0 ) ) ;\n    set2 . add ( a . get ( 1 ) ) ;\n  }\n  Map < Integer , Integer > map1 = new HashMap < > ( ) , map2 = new HashMap < > ( ) ;\n  int idx1 = 1 , idx2 = 1 ;\n  while ( ! set1 . isEmpty ( ) ) {\n    map1 . put ( * set1 . iterator ( ) . next ( ) , idx1 ++ ) ;\n    set1 . remove ( * set1 . iterator ( ) . next ( ) ) ;\n    map2 . put ( * set2 . iterator ( ) . next ( ) , idx2 ++ ) ;\n    set2 . remove ( * set2 . iterator ( ) . next ( ) ) ;\n  }\n  int [ ] [ ] pre = new int [ n ] [ n ] ;\n  for ( int i = 0 ;\n  i < n ;\n  ++ i ) pre [ map1 . get ( students . get ( i ) . get ( 0 ) ) - 1 ] [ map2 . get ( students . get ( i ) . get ( 1 ) ) - 1 ] ++ ;\n  int [ ] [ ] Arr = new int [ n + 1 ] [ n + 1 ] ;\n  for ( int i = 1 ;\n  i <= n ;\n  ++ i ) {\n    for ( int j = 1 ;\n    j <= n ;\n    ++ j ) {\n      if ( pre [ i - 1 ] [ j - 1 ] == 0 ) Arr [ i ] [ j ] = Arr [ i - 1 ] [ j ] + Arr [ i ] [ j - 1 ] - Arr [ i - 1 ] [ j - 1 ] ;\n      else Arr [ i ] [ j ] = Arr [ i - 1 ] [ j ] + Arr [ i ] [ j - 1 ] + 1 - Arr [ i - 1 ] [ j - 1 ] ;\n    }\n  }\n  int sum = 0 ;\n  for ( int i = 0 ;\n  i < q ;\n  ++ i ) {\n    int X = queries . get ( i ) . get ( 0 ) , Y = queries . get ( i ) . get ( 1 ) ;\n    X -- ;\n    Y -- ;\n    int a = map1 . get ( students . get ( Y ) . get ( 0 ) ) ;\n    int b = map2 . get ( students . get ( Y ) . get ( 1", "reference_code": "    public static int bobHappiness(int n, int k, int q, int[][] students,\n                                   int[][] queries) {\n        TreeSet<Integer> set1 = new TreeSet<>();\n        TreeSet<Integer> set2 = new TreeSet<>();\n        for (int[] a : students) {\n            set1.add(a[0]);\n            set2.add(a[1]);\n        }\n        Map<Integer, Integer> map1 = new HashMap<>();\n        Map<Integer, Integer> map2 = new HashMap<>();\n        int idx1 = 1, idx2 = 1;\n        while (!set1.isEmpty()) {\n            map1.put(set1.pollFirst(), idx1++);\n            map2.put(set2.pollFirst(), idx2++);\n        }\n        int[][] pre = new int[n][n];\n        for (int i = 0; i < n; i++) {\n            pre[map1.get(students[i][0]) - 1][map2.get(students[i][1]) - 1]++;\n        }\n        int[][] Arr = new int[n + 1][n + 1];\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= n; j++) {\n                if (pre[i - 1][j - 1] == 0) {\n                    Arr[i][j] = Arr[i - 1][j] + Arr[i][j - 1] - Arr[i - 1][j - 1];\n                } else {\n                    Arr[i][j] = Arr[i - 1][j] + Arr[i][j - 1] + 1 - Arr[i - 1][j - 1];\n                }\n            }\n        }\n        int sum = 0;\n        for (int i = 0; i < q; i++) {\n            int X = queries[i][0], Y = queries[i][1];\n            X--;\n            Y--;\n            int a = map1.get(students[Y][0]);\n            int b = map2.get(students[Y][1]);\n            int c = map1.get(students[X][0]), d = map2.get(students[X][1]);\n            int temp = a;\n            a = c;\n            c = temp;\n            int people = Arr[c][d] + Arr[a - 1][b - 1] - Arr[a - 1][d] - Arr[c][b - 1];\n            people -= 2;\n            if (people > k) {\n                \n            } else {\n                sum++;\n            }\n        }\n        return sum;\n    }", "target_Lan": "java###bobHappiness_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.*;\npublic class bobHappiness_Test {\n// TOFILL\n    public static void main(String[] args) {\n        int[][] students1 = {{1,2},{2,3},{3,1}};\n        int[][] queries1 = {{1,2},{2,3}};\n        System.out.println(bobHappiness(3, 2, 2, students1, queries1));\n\n        int[][] students2 = {{1,2},{2,3},{3,4},{4,1}};\n        int[][] queries2 = {{1,2},{2,3},{3,4}};\n        System.out.println(bobHappiness(4, 1, 3, students2, queries2));\n\n        int[][] students3 = {{1,2},{2,3},{3,4},{4,5},{5,1}};\n        int[][] queries3 = {{1,2},{2,3},{3,4},{4,5}};\n        System.out.println(bobHappiness(5, 3, 4, students3, queries3));\n\n        int[][] students4 = {{1,2},{2,3},{3,4},{4,5},{5,6},{6,1}};\n        int[][] queries4 = {{1,2},{2,3},{3,4},{4,5},{5,6}};\n        System.out.println(bobHappiness(6, 4, 5, students4, queries4));\n\n        int[][] students5 = {{1,2},{2,3},{3,4},{4,5},{5,6},{6,7},{7,1}};\n        int[][] queries5 = {{1,2},{2,3},{3,4},{4,5},{5,6},{6,7}};\n        System.out.println(bobHappiness(7, 5, 6, students5, queries5));\n    }\n}"}, {"source_Lan": "cpp###matchingCnt.cpp", "source_code": "    vector<int> matchingCnt(int n, vector<string>& X) {\n        unordered_map<int, array<int, 26>> map;\n        vector<int> ans(n);\n        for (int i = n - 1; i >= 0; i--) {\n            string x = X[i];\n            int cans = 0;\n            for (int j = 0; j < x.length(); j++) {\n                if (map.find(j) == map.end()) {\n                    map[j] = array<int, 26>{};\n                }\n                cans += map[j][x[j] - 'a'];\n                map[j][x[j] - 'a']++;\n            }\n            ans[i] = cans;\n        }\n        return ans;\n    }", "trans_code": "public static int [ ] matchingCnt ( int n , String [ ] X ) {\n  HashMap < Integer , int [ ] > map = new HashMap < Integer , int [ ] > ( ) ;\n  int [ ] ans = new int [ n ] ;\n  for ( int i = n - 1 ;\n  i >= 0 ;\n  i -- ) {\n    String x = X [ i ] ;\n    int cans = 0 ;\n    for ( int j = 0 ;\n    j < x . length ( ) ;\n    j ++ ) {\n      if ( map . get ( j ) == null ) map . put ( j , new int [ 26 ] ) ;\n      cans += map . get ( j ) [ x . charAt ( j ) - 'a' ] ;\n      map . get ( j ) [ x . charAt ( j ) - 'a' ] ++ ;\n    }\n    ans [ i ] = cans ;\n  }\n  return ans ;\n}\n", "reference_code": "    public static int[] matchingCnt(int n, String[] X) {\n        Map<Integer, int[]> map = new HashMap<>();\n        int[] ans = new int[n];\n        for (int i = n - 1; i >= 0; i--) {\n            String x = X[i];\n            int cans = 0;\n            for (int j = 0; j < x.length(); j++) {\n                if (!map.containsKey(j)) {\n                    map.put(j, new int[26]);\n                }\n                cans = cans + map.get(j)[x.charAt(j) - 'a'];\n                map.get(j)[x.charAt(j) - 'a']++;\n            }\n            ans[i] = cans;\n        }\n        return ans;\n    }", "target_Lan": "java###matchingCnt_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.*;\npublic class matchingCnt_Test {\n// TOFILL\n    public static void main(String[] args) {\n        System.out.println(Arrays.toString(matchingCnt(0, new String[]{})));\n        System.out.println(Arrays.toString(matchingCnt(1, new String[]{\"a\"})));\n        System.out.println(Arrays.toString(matchingCnt(2, new String[]{\"a\", \"b\"})));\n        System.out.println(Arrays.toString(matchingCnt(3, new String[]{\"a\", \"b\", \"c\"})));\n        System.out.println(Arrays.toString(matchingCnt(3, new String[]{\"abc\", \"def\", \"ghi\"})));\n    }\n}"}, {"source_Lan": "cpp###minimizeArrayScore.cpp", "source_code": "    int minimizeArrayScore(int n, vector<int> &arr) {\n        int ans =INT_MIN;\n        sort(arr.begin(),arr.end());\n        int l=0;\n        int r=n-1;\n        while (l<r){\n            ans=max(ans,arr[l]+arr[r]);\n            l+=1;\n            r-=1;\n        }\n        return ans;\n    }", "trans_code": "public static int minimizeArrayScore ( int n , int [ ] arr ) {\n  int ans = Integer . MIN_VALUE ;\n  Arrays . sort ( arr ) ;\n  int l = 0 ;\n  int r = n - 1 ;\n  while ( l < r ) {\n    ans = Math . max ( ans , arr [ l ] + arr [ r ] ) ;\n    l += 1 ;\n    r -= 1 ;\n  }\n  return ans ;\n}\n", "reference_code": "    public static int minimizeArrayScore(int n, int[] arr) {\n        Arrays.sort(arr);\n        int max = Integer.MIN_VALUE;\n        int low = 0, high = n - 1;\n        while(low < high)\n            max = Math.max(max, arr[high--] + arr[low++]);\n        return max;\n    }", "target_Lan": "java###minimizeArrayScore_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.Arrays;\npublic class minimizeArrayScore_Test {\n// TOFILL\n    public static void main(String[] args) {\n        System.out.println(minimizeArrayScore(0, new int[]{}));\n        System.out.println(minimizeArrayScore(1, new int[]{1}));\n        System.out.println(minimizeArrayScore(2, new int[]{1,2}));\n        System.out.println(minimizeArrayScore(3, new int[]{1,2,3}));\n        System.out.println(minimizeArrayScore(4, new int[]{1,2,3,4}));\n    }\n}"}, {"source_Lan": "cpp###maximumPrimeDifference.cpp", "source_code": "    int maximumPrimeDifference(vector<int>& nums) {\n        unordered_set<int> primes = {\n            2, 3, 5, 7, 11,\n            13, 17, 19, 23, 29,\n            31, 37, 41, 43, 47,\n            53, 59, 61, 67, 71,\n            73, 79, 83, 89, 97\n        };\n        int n = nums.size();\n        int first = -1, ans = 0;\n        for (int i = 0; i < n; ++i) {\n            if (primes.count(nums[i])) {\n                if (first != -1) {\n                    ans = max(ans, i - first);\n                }\n                else {\n                    first = i;\n                }\n            }\n        }\n        return ans;\n    }", "trans_code": "public static int maximumPrimeDifference ( int [ ] nums ) {\n  HashSet < Integer > primes = new HashSet < Integer > ( ) ;\n  primes . add ( 2 ) ;\n  primes . add ( 3 ) ;\n  primes . add ( 5 ) ;\n  primes . add ( 7 ) ;\n  primes . add ( 11 ) ;\n  primes . add ( 13 ) ;\n  primes . add ( 17 ) ;\n  primes . add ( 19 ) ;\n  primes . add ( 23 ) ;\n  primes . add ( 31 ) ;\n  primes . add ( 37 ) ;\n  primes . add ( 41 ) ;\n  primes . add ( 43 ) ;\n  primes . add ( 47 ) ;\n  primes . add ( 53 ) ;\n  primes . add ( 59 ) ;\n  primes . add ( 67 ) ;\n  primes . add ( 71 ) ;\n  primes . add ( 73 ) ;\n  primes . add ( 79 ) ;\n  primes . add ( 83 ) ;\n  primes . add ( 89 ) ;\n  primes . add ( 97 ) ;\n  int n = nums . length ;\n  int first = - 1 , ans = 0 ;\n  for ( int i = 0 ;\n  i < n ;\n  ++ i ) {\n    if ( primes . contains ( nums [ i ] ) ) {\n      if ( first != - 1 ) ans = Math . max ( ans , i - first ) ;\n      else first = i ;\n    }\n  }\n  return ans ;\n}\n", "reference_code": "    public static int maximumPrimeDifference(int[] nums) {\n        Set<Integer> primes = new HashSet<>(Arrays.asList(\n            2, 3, 5, 7, 11,\n            13, 17, 19, 23, 29,\n            31, 37, 41, 43, 47,\n            53, 59, 61, 67, 71,\n            73, 79, 83, 89, 97\n        ));\n        int n = nums.length;\n        int first = -1, ans = 0;\n        for (int i = 0; i < n; ++i) {\n            if (primes.contains(nums[i])) {\n                if (first != -1) {\n                    ans = Math.max(ans, i - first);\n                } else {\n                    first = i;\n                }\n            }\n        }\n        return ans;\n    }", "target_Lan": "java###maximumPrimeDifference_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.*;\npublic class maximumPrimeDifference_Test {\n// TOFILL\n    public static void main(String[] args) {\n        int[] nums1 = {2, 3, 5, 7, 11};\n        int[] nums2 = {2, 4, 6, 8, 10};\n        int[] nums3 = {1, 3, 5, 7, 9};\n        int[] nums4 = {11, 13, 17, 19, 23};\n        int[] nums5 = {4, 6, 8, 10, 12};\n\n        System.out.println(maximumPrimeDifference(nums1));\n        System.out.println(maximumPrimeDifference(nums2));\n        System.out.println(maximumPrimeDifference(nums3));\n        System.out.println(maximumPrimeDifference(nums4));\n        System.out.println(maximumPrimeDifference(nums5));\n    }\n}"}, {"source_Lan": "cpp###garbageCollection.cpp", "source_code": "    int garbageCollection(vector<string>& garbage, vector<int>& travel) {\n        unordered_map<char, int> distance;\n        int res = 0, cur_dis = 0;\n        for (int i = 0; i < garbage.size(); i++) {\n            res += garbage[i].size();\n            if (i > 0) {\n                cur_dis += travel[i - 1];\n            }\n            for (auto c : garbage[i]) {\n                distance[c] = cur_dis;\n            }\n        }\n        for (auto &[k, v] : distance) {\n            res += v;\n        }\n        return res;\n    }", "trans_code": "public static int garbageCollection ( String [ ] garbage , int [ ] travel ) {\n  HashMap < Character , Integer > distance = new HashMap < Character , Integer > ( ) ;\n  int res = 0 , cur_dis = 0 ;\n  for ( int i = 0 ;\n  i < garbage . length ;\n  i ++ ) {\n    res += garbage [ i ] . length ( ) ;\n    if ( i > 0 ) cur_dis += travel [ i - 1 ] ;\n    for ( char c : garbage [ i ] ) distance . put ( c , cur_dis ) ;\n  }\n  for ( int [ ] [ ] [ ] v : distance . values ( ) ) res += v [ 0 ] [ 0 ] . length ;\n  return res ;\n}\n", "reference_code": "    public static int garbageCollection(String[] garbage, int[] travel) {\n        Map<Character, Integer> distance = new HashMap<>();\n        int res = 0, curDis = 0;\n        for (int i = 0; i < garbage.length; i++) {\n            res += garbage[i].length();\n            if (i > 0) {\n                curDis += travel[i - 1];\n            }\n            for (char c : garbage[i].toCharArray()) {\n                distance.put(c, curDis);\n            }\n        }\n        return res + distance.values().stream().reduce(0, Integer::sum);\n    }", "target_Lan": "java###garbageCollection_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.*;\npublic class garbageCollection_Test {\n// TOFILL\n    public static void main(String[] args) {\n        System.out.println(garbageCollection(new String[]{\"G\",\"P\",\"GP\",\"GG\"}, new int[]{2,4,3}));\n        System.out.println(garbageCollection(new String[]{\"MMM\",\"PGM\",\"GP\"}, new int[]{3,10}));\n        System.out.println(garbageCollection(new String[]{\"MMM\",\"PGM\",\"GP\",\"GP\"}, new int[]{3,10,1}));\n        System.out.println(garbageCollection(new String[]{\"MMM\",\"PGM\",\"GP\",\"GP\",\"MMM\"}, new int[]{3,10,1,2}));\n        System.out.println(garbageCollection(new String[]{\"MMM\",\"PGM\",\"GP\",\"GP\",\"MMM\",\"GP\"}, new int[]{3,10,1,2,1}));\n    }\n}"}, {"source_Lan": "cpp###HeightTower.cpp", "source_code": "    int HeightTower(int n, int k, vector<int>& a) {\n        \n        stack<int> st;\n        int totalHeight = 0;\n        int i = 0;\n        \n        for (int j = 0; j < n; j++) {\n            totalHeight += a[j];\n            st.push(a[j]);\n            \n            if (totalHeight > k) {\n                \n                int removeBoxes = i + 1;\n                while (removeBoxes > 0 && !st.empty()) {\n                    totalHeight -= st.top();\n                    st.pop();\n                    removeBoxes--;\n                }\n                i++;\n            }\n        }\n        \n        return totalHeight;\n    }", "trans_code": "public static int HeightTower ( int n , int k , int [ ] a ) {\n  Stack < Integer > st = new Stack < Integer > ( ) ;\n  int totalHeight = 0 ;\n  int i = 0 ;\n  for ( int j = 0 ;\n  j < n ;\n  j ++ ) {\n    totalHeight += a [ j ] ;\n    st . push ( a [ j ] ) ;\n    if ( totalHeight > k ) {\n      int removeBoxes = i + 1 ;\n      while ( removeBoxes > 0 && ! st . empty ( ) ) {\n        totalHeight -= st . pop ( ) ;\n        st . pop ( ) ;\n        removeBoxes -- ;\n      }\n      i ++ ;\n    }\n  }\n  return totalHeight ;\n}\n", "reference_code": "    public static int HeightTower(int n, int k, int[] arr) {\n        \n        Stack<Integer> st = new Stack<>();\n        \n        int totalHeight = 0;\n        \n        int i = 0;\n        \n        for (int j = 0; j < n; j++) {\n            totalHeight += arr[j];\n            st.push(arr[j]);\n            \n            if (totalHeight > k) {\n                int removeBoxes = i + 1;\n                \n                while (removeBoxes > 0 && !st.empty()) {\n                    totalHeight -= st.pop();\n                    removeBoxes--;\n                }\n                i++;\n            }\n        }\n        \n        return totalHeight;\n    }", "target_Lan": "java###HeightTower_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.Stack;\npublic class HeightTower_Test {\n// TOFILL\n    public static void main(String[] args) {\n        System.out.println(HeightTower(0, 10, new int[]{})); // Expected output: 0\n        System.out.println(HeightTower(5, 20, new int[]{1, 2, 3, 4, 5})); // Expected output: 15\n        System.out.println(HeightTower(5, 6, new int[]{2, 5, 3, 1, 2})); // Expected output: 1(after removing)\n        System.out.println(HeightTower(5, 1000000, new int[]{200000, 300000, 500000, 700000, 1000000})); // Expected output: 2000000\n        System.out.println(HeightTower(5, 10, new int[]{-1, -2, -3, -4, -2})); // Expected output: -12\n    }\n}"}, {"source_Lan": "cpp###arrangingHorses.cpp", "source_code": "    vector<int> arrangingHorses(int n, int m, vector<vector<int>>& data) {\n        vector<int> inDegree(n, 0);\n        vector<vector<int>> adjList(n);\n        for (const auto& edge : data) {\n            int a = edge[0], b = edge[1];\n            adjList[b].push_back(a); \n            ++inDegree[a];\n        }\n        priority_queue<int, vector<int>, greater<int>> pq; \n        for (int i = 0; i < n; ++i) {\n            if (inDegree[i] == 0)\n                pq.push(i);\n        }\n        vector<int> order;\n        while (!pq.empty()) {\n            int horse = pq.top();\n            pq.pop();\n            order.push_back(horse);\n            for (int neigh : adjList[horse]) {\n                --inDegree[neigh];\n                if (inDegree[neigh] == 0)\n                    pq.push(neigh);\n            }\n        }\n        return order;\n    }", "trans_code": "public static int [ ] arrangingHorses ( int n , int m , List < List < Integer >> data ) {\n  int [ ] inDegree = new int [ n ] ;\n  List < List < Integer >> adjList = new ArrayList < List < Integer >> ( n ) ;\n  for ( List < Integer > edge : data ) {\n    int a = edge . get ( 0 ) , b = edge . get ( 1 ) ;\n    adjList . get ( b ) . add ( a ) ;\n    ++ inDegree [ a ] ;\n  }\n  PriorityQueue < Integer > pq = new PriorityQueue < Integer > ( ) ;\n  for ( int i = 0 ;\n  i < n ;\n  ++ i ) {\n    if ( inDegree [ i ] == 0 ) {\n      pq . add ( i ) ;\n    }\n  }\n  int [ ] order = new int [ n ] ;\n  while ( ! pq . isEmpty ( ) ) {\n    int horse = pq . poll ( ) ;\n    pq . remove ( ) ;\n    order [ horse ] = 0 ;\n    for ( int neigh : adjList . get ( horse ) ) {\n      -- inDegree [ neigh ] ;\n      if ( inDegree [ neigh ] == 0 ) {\n        pq . add ( neigh ) ;\n      }\n    }\n  }\n  return order ;\n}\n", "reference_code": "    public static ArrayList<Integer> arrangingHorses(int n, int m, int[][] data) {\n        int[] inDegree = new int[n];\n        ArrayList<ArrayList<Integer>> adjList = new ArrayList<>();\n        for (int i = 0; i < n; i++) adjList.add(new ArrayList<>());\n        for (int[] edge : data) {\n            int a = edge[0], b = edge[1];\n            adjList.get(b).add(a); \n            ++inDegree[a];\n        }\n        PriorityQueue<Integer> pq = new PriorityQueue<>(); \n        for (int i = 0; i < n; ++i) {\n            if (inDegree[i] == 0) pq.add(i);\n        }\n        ArrayList<Integer> order = new ArrayList<>();\n        while (!pq.isEmpty()) {\n            int horse = pq.poll();\n            order.add(horse);\n            for (int neigh : adjList.get(horse)) {\n                --inDegree[neigh];\n                if (inDegree[neigh] == 0) pq.add(neigh);\n            }\n        }\n        return order;\n    }", "target_Lan": "java###arrangingHorses_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.ArrayList;\npublic class arrangingHorses_Test {\n// TOFILL\n    public static void main(String[] args) {\n        System.out.println(arrangingHorses(0, 0, new int[][]{}));\n        System.out.println(arrangingHorses(1, 0, new int[][]{}));\n        System.out.println(arrangingHorses(2, 1, new int[][]{{1, 0}}));\n        System.out.println(arrangingHorses(4, 4, new int[][]{{1, 0}, {2, 1}, {3, 2}, {0, 3}})); // Cycle graph\n        System.out.println(arrangingHorses(5, 5, new int[][]{{1, 0}, {2, 0}, {3, 1}, {3, 2}})); // Multiple dependencies\n    }\n}"}, {"source_Lan": "cpp###substringsAndPermutations.cpp", "source_code": "    vector<int> substringsAndPermutations(int n, int m, string s, vector<string>&arr){\n        map<char,vector<int>>mp;\n        for (int i=0;i<n;i++){\n            char ch=s[i];\n            mp[ch].push_back(i);\n        }\n        vector<int>ans;\n        for (auto j:arr){\n            int ma=0;\n            unordered_map<char,int>ct;\n            for (auto k:j){\n                ct[k]+=1;\n            }\n            for (auto k:j){\n                int ele=ct[k];\n                if (ele>mp[k].size()){\n                    ma=-1;\n                    break;\n                }\n                else {\n                    ma=max(ma,mp[k][ele-1]+1);\n                }\n            }\n            ans.push_back(ma);\n        }\n        return ans;\n    }", "trans_code": "public static List < Integer > substringsAndPermutations ( int n , int m , String s , String [ ] arr ) {\n  Map < Character , List < Integer >> mp = new HashMap < Character , List < Integer >> ( ) ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    char ch = s . charAt ( i ) ;\n    mp . put ( ch , new ArrayList < Integer > ( ) ) ;\n  }\n  List < Integer > ans = new ArrayList < Integer > ( ) ;\n  for ( String j : arr ) {\n    int ma = 0 ;\n    HashMap < Character , Integer > ct = new HashMap < Character , Integer > ( ) ;\n    for ( Character k : j ) ct . put ( k , 1 ) ;\n    for ( Character k : j ) {\n      int ele = ct . get ( k ) ;\n      if ( ele > mp . get ( k ) . size ( ) ) {\n        ma = - 1 ;\n        break ;\n      }\n      else ma = Math . max ( ma , mp . get ( k ) . get ( ele - 1 ) + 1 ) ;\n    }\n    ans . add ( ma ) ;\n  }\n  return ans ;\n}\n", "reference_code": "    public static ArrayList<Integer> substringsAndPermutations(int n, int m, String s,\n                                                        String[] arr) {\n        Map<Character, List<Integer>> mp = new HashMap<>();\n        for (int i = 0; i < n; i++) {\n            char ch = s.charAt(i);\n            mp.computeIfAbsent(ch, k -> new ArrayList<>()).add(i);\n        }\n        ArrayList<Integer> ans = new ArrayList<>();\n        for (int q = 0; q < m; q++) {\n            String query = arr[q];\n            int ma = 0;\n            Map<Character, Integer> ct = new HashMap<>();\n            for (char c : query.toCharArray()) {\n                ct.put(c, ct.getOrDefault(c, 0) + 1);\n            }\n            for (char c : query.toCharArray()) {\n                int ele = ct.get(c);\n                if (ele > mp.getOrDefault(c, Collections.emptyList()).size()) {\n                    ma = -1;\n                    break;\n                } else {\n                    ma = Math.max(ma, mp.get(c).get(ele - 1) + 1);\n                }\n            }\n            ans.add(ma);\n        }\n        return ans;\n    }", "target_Lan": "java###substringsAndPermutations_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Collections;\npublic class substringsAndPermutations_Test {\n// TOFILL\n    public static void main(String[] args) {\n        int n1 = 4, m1 = 2;\n        String s1 = \"abca\";\n        String[] arr1 = {\"ab\", \"cab\"};\n\n        int n2 = 6, m2 = 1;\n        String s2 = \"abcdef\";\n        String[] arr2 = {\"ab\"};\n\n        int n3 = 5, m3 = 2;\n        String s3 = \"aabbc\";\n        String[] arr3 = {\"abc\", \"aabb\"};\n\n        int n4 = 3, m4 = 1;\n        String s4 = \"xyz\";\n        String[] arr4 = {\"xyz\"};\n\n        int n5 = 0, m5 = 1;\n        String s5 = \"\";\n        String[] arr5 = {\"a\"};\n\n        System.out.println(substringsAndPermutations(n1, m1, s1, arr1));\n        System.out.println(substringsAndPermutations(n2, m2, s2, arr2));\n        System.out.println(substringsAndPermutations(n3, m3, s3, arr3));\n        System.out.println(substringsAndPermutations(n4, m4, s4, arr4));\n        System.out.println(substringsAndPermutations(n5, m5, s5, arr5));\n    }\n}"}, {"source_Lan": "cpp###prefixDistinct.cpp", "source_code": "    vector<int> prefixDistinct(int n, vector<int> &arr)\n    {\n        vector<int>ans(n);\n        set<int>s;\n        for(int i=0;i<n;i++)\n        {\n            s.insert(arr[i]);\n            ans[i]=s.size();\n        }\n        return ans;\n    }", "trans_code": "public static int [ ] prefixDistinct ( int n , int [ ] arr ) {\n  int [ ] ans = new int [ n ] ;\n  Set < Integer > s = new HashSet < Integer > ( ) ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    s . add ( arr [ i ] ) ;\n    ans [ i ] = s . size ( ) ;\n  }\n  return ans ;\n}\n", "reference_code": "    public static int[] prefixDistinct(int n, int arr[]){\n        int ans[] = new int[n];\n        Set<Integer> hs = new HashSet<>();\n        for(int i = 0; i < n; i++){\n            hs.add(arr[i]);\n            ans[i] = hs.size();\n        }\n        return ans;\n    }", "target_Lan": "java###prefixDistinct_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.HashSet;\nimport java.util.Set;\npublic class prefixDistinct_Test {\n// TOFILL\n    public static void main(String[] args) {\n        // Test Input 1\n        int[] result1 = prefixDistinct(0, new int[]{});\n        System.out.print(\"Output for n=0, arr=[]: \");\n        for(int val : result1) {\n            System.out.print(val + \" \");\n        }\n        System.out.println();\n\n        // Test Input 2\n        int[] result2 = prefixDistinct(5, new int[]{1, 2, 3, 4, 5});\n        System.out.print(\"Output for n=5, arr=[1, 2, 3, 4, 5]: \");\n        for(int val : result2) {\n            System.out.print(val + \" \");\n        }\n        System.out.println();\n\n        // Test Input 3\n        int[] result3 = prefixDistinct(5, new int[]{1, 1, 1, 1, 1});\n        System.out.print(\"Output for n=5, arr=[1, 1, 1, 1, 1]: \");\n        for(int val : result3) {\n            System.out.print(val + \" \");\n        }\n        System.out.println();\n\n        // Test Input 4\n        int[] result4 = prefixDistinct(6, new int[]{1, 2, 2, 3, 4, 4});\n        System.out.print(\"Output for n=6, arr=[1, 2, 2, 3, 4, 4]: \");\n        for(int val : result4) {\n            System.out.print(val + \" \");\n        }\n        System.out.println();\n\n        // Test Input 5\n        int[] result5 = prefixDistinct(5, new int[]{-1, -2, -1, -3, -2});\n        System.out.print(\"Output for n=5, arr=[-1, -2, -1, -3, -2]: \");\n        for(int val : result5) {\n            System.out.print(val + \" \");\n        }\n        System.out.println();\n    }\n}"}, {"source_Lan": "cpp###minEnd.cpp", "source_code": "    long long minEnd(int n, int x) {\n        n--; \n        long long ans = x;\n        int i = 0, j = 0;\n        while (n >> j) {\n            \n            if ((ans >> i & 1) == 0) {\n                \n                ans |= (long long) (n >> j & 1) << i;\n                j++;\n            }\n            i++;\n        }\n        return ans;\n    }", "trans_code": "public static long minEnd ( int n , int x ) {\n  n -- ;\n  long ans = x ;\n  int i = 0 , j = 0 ;\n  while ( n >> j ) {\n    if ( ( ans >> i & 1 ) == 0 ) {\n      ans |= ( long ) ( n >> j & 1 ) << i ;\n      j ++ ;\n    }\n    i ++ ;\n  }\n  return ans ;\n}\n", "reference_code": "    public static long minEnd(int n, int x) {\n        n--; \n        long ans = x;\n        int i = 0, j = 0;\n        while ((n >> j) > 0) {\n            \n            if ((ans >> i & 1) == 0) {\n                \n                ans |= (long) (n >> j & 1) << i;\n                j++;\n            }\n            i++;\n        }\n        return ans;\n    }", "target_Lan": "java###minEnd_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.Scanner;\npublic class minEnd_Test {\n// TOFILL\n    public static void main(String[] args) {\n        int n1 = 1;\n        int x1 = 0;\n        System.out.println(minEnd(n1, x1));\n\n        int n2 = 1;\n        int x2 = 2147483647;\n        System.out.println(minEnd(n2, x2));\n\n        int n3 = 1;\n    }\n}"}, {"source_Lan": "cpp###numberGame.cpp", "source_code": "    vector<int> numberGame(vector<int>& nums) {\n        sort(nums.begin(), nums.end());\n        for (int i = 0; i < nums.size(); i += 2) {\n            swap(nums[i], nums[i + 1]);\n        }\n        return nums;\n    }", "trans_code": "public static int [ ] numberGame ( int [ ] nums ) {\n  Arrays . sort ( nums ) ;\n  for ( int i = 0 ;\n  i < nums . length ;\n  i += 2 ) {\n    swap ( nums , i , i + 1 ) ;\n  }\n  return nums ;\n}\n", "reference_code": "    public static int[] numberGame(int[] nums) {\n        Arrays.sort(nums);\n        for (int i = 0; i < nums.length; i += 2) {\n            int tmp = nums[i];\n            nums[i] = nums[i + 1];\n            nums[i + 1] = tmp;\n        }\n        return nums;\n    }", "target_Lan": "java###numberGame_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.Arrays;\npublic class numberGame_Test {\n// TOFILL\n    public static void main(String[] args) {\n        System.out.println(Arrays.toString(numberGame(new int[]{})));\n        System.out.println(Arrays.toString(numberGame(new int[]{2, 2, 4, 4})));\n        System.out.println(Arrays.toString(numberGame(new int[]{6, 5, 3, 1})));\n    }\n}"}, {"source_Lan": "cpp###paintWalls.cpp", "source_code": "    int paintWalls(vector<int>& cost, vector<int>& time) {\n        int n = cost.size();\n        vector<int> f(n * 2 + 1, INT_MAX / 2);\n        f[n] = 0;\n        for (int i = 0; i < n; ++i) {\n            vector<int> g(n * 2 + 1, INT_MAX / 2);\n            for (int j = 0; j <= n * 2; ++j) {\n                \n                g[min(j + time[i], n * 2)] = min(g[min(j + time[i], n * 2)], f[j] + cost[i]);\n                \n                if (j > 0) {\n                    g[j - 1] = min(g[j - 1], f[j]);\n                }\n            }\n            f = move(g);\n        }\n        return *min_element(f.begin() + n, f.end());\n    }", "trans_code": "public static int paintWalls ( int [ ] cost , int [ ] time ) {\n  int n = cost . length ;\n  int [ ] f = new int [ n * 2 + 1 ] ;\n  f [ n ] = 0 ;\n  for ( int i = 0 ;\n  i < n ;\n  ++ i ) {\n    int [ ] g = new int [ n * 2 + 1 ] ;\n    for ( int j = 0 ;\n    j <= n * 2 ;\n    ++ j ) {\n      g [ Math . min ( j + time [ i ] , n * 2 ) ] = Math . min ( g [ Math . min ( j + time [ i ] , n * 2 ) ] , f [ j ] + cost [ i ] ) ;\n      if ( j > 0 ) g [ j - 1 ] = Math . min ( g [ j - 1 ] , f [ j ] ) ;\n    }\n    f = Arrays . copyOf ( g , n ) ;\n  }\n  return new int [ n ] ;\n}\n", "reference_code": "    public static int paintWalls(int[] cost, int[] time) {\n        int n = cost.length;\n        int[] f = new int[n * 2 + 1];\n        Arrays.fill(f, Integer.MAX_VALUE / 2);\n        f[n] = 0;\n        for (int i = 0; i < n; ++i) {\n            int[] g = new int[n * 2 + 1];\n            Arrays.fill(g, Integer.MAX_VALUE / 2);\n            for (int j = 0; j <= n * 2; ++j) {\n                \n                g[Math.min(j + time[i], n * 2)] = Math.min(g[Math.min(j + time[i], n * 2)], f[j] + cost[i]);\n                \n                if (j > 0) {\n                    g[j - 1] = Math.min(g[j - 1], f[j]);\n                }\n            }\n            f = g;\n        }\n        int ans = f[n];\n        for (int i = n + 1; i <= n * 2; i++) {\n            ans = Math.min(ans, f[i]);\n        }\n        return ans;\n    }", "target_Lan": "java###paintWalls_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.Arrays;\npublic class paintWalls_Test {\n// TOFILL\n    public static void main(String[] args) {\n        System.out.println(paintWalls(new int[]{}, new int[]{}));\n        System.out.println(paintWalls(new int[]{10}, new int[]{5}));\n        System.out.println(paintWalls(new int[]{5, 10, 15}, new int[]{1, 2, 3}));\n        System.out.println(paintWalls(new int[]{Integer.MAX_VALUE, 2000000000, 150}, new int[]{1, 2, 100}));\n        System.out.println(paintWalls(new int[]{1, 2, 3, 4}, new int[]{2, 1, 3, 2}));\n    }\n}"}, {"source_Lan": "cpp###maxResult.cpp", "source_code": "    int maxResult(vector<int>& nums, int k) {\n        int n = nums.size();\n        vector<int> dp(n);\n        dp[0] = nums[0];\n        deque<int> queue;\n        queue.push_back(0);\n        for (int i = 1; i < n; i++) {\n            while (!queue.empty() && queue.front() < i - k) {\n                queue.pop_front();\n            }\n            dp[i] = dp[queue.front()] + nums[i];\n            while (!queue.empty() && dp[queue.back()] <= dp[i]) {\n                queue.pop_back();\n            }\n            queue.push_back(i);\n        }\n        return dp[n - 1];\n    }", "trans_code": "public static int maxResult ( int [ ] nums , int k ) {\n  int n = nums . length ;\n  int [ ] dp = new int [ n ] ;\n  dp [ 0 ] = nums [ 0 ] ;\n  Deque < Integer > queue = new ArrayDeque < Integer > ( ) ;\n  queue . add ( 0 ) ;\n  for ( int i = 1 ;\n  i < n ;\n  i ++ ) {\n    while ( ! queue . isEmpty ( ) && queue . peek ( ) < i - k ) queue . poll ( ) ;\n    dp [ i ] = dp [ queue . peek ( ) ] + nums [ i ] ;\n    while ( ! queue . isEmpty ( ) && dp [ queue . peek ( ) ] <= dp [ i ] ) queue . poll ( ) ;\n    queue . add ( i ) ;\n  }\n  return dp [ n - 1 ] ;\n}\n", "reference_code": "    public static int maxResult(int[] nums, int k) {\n        int n = nums.length;\n        int[] dp = new int[n];\n        dp[0] = nums[0];\n        Deque<Integer> queue = new ArrayDeque<>();\n        queue.offerLast(0);\n        for (int i = 1; i < n; i++) {\n            while (queue.peekFirst() < i - k) {\n                queue.pollFirst();\n            }\n            dp[i] = dp[queue.peekFirst()] + nums[i];\n            while (!queue.isEmpty() && dp[queue.peekLast()] <= dp[i]) {\n                queue.pollLast();\n            }\n            queue.offerLast(i);\n        }\n        return dp[n - 1];\n    }", "target_Lan": "java###maxResult_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.ArrayDeque;\nimport java.util.Deque;\npublic class maxResult_Test {\n// TOFILL\n    public static void main(String[] args) {\n        System.out.println(maxResult(new int[]{-1, -2, -3, -4}, 2)); // All negative numbers\n        System.out.println(maxResult(new int[]{1, 2, 3, 4, 100}, 4)); // Large positive number included\n        System.out.println(maxResult(new int[]{-1, 5, -2, 3, 4}, 2)); // Mixed positive and negative\n    }\n}"}, {"source_Lan": "cpp###distinctDifferenceArray.cpp", "source_code": "    vector<int> distinctDifferenceArray(vector<int>& nums) {\n        int n = nums.size();\n        unordered_set<int> st;\n        vector<int> sufCnt(n + 1, 0);\n        for (int i = n - 1; i > 0; i--) {\n            st.insert(nums[i]);\n            sufCnt[i] = st.size();\n        }\n        vector<int> res;\n        st.clear();\n        for (int i = 0; i < n; i++) {\n            st.insert(nums[i]);\n            res.push_back(int(st.size()) - sufCnt[i + 1]);\n        }\n        return res;\n    }", "trans_code": "public static int [ ] distinctDifferenceArray ( int [ ] nums ) {\n  int n = nums . length ;\n  HashSet < Integer > st = new HashSet < Integer > ( ) ;\n  int [ ] sufCnt = new int [ n + 1 ] ;\n  for ( int i = n - 1 ;\n  i > 0 ;\n  i -- ) {\n    st . add ( nums [ i ] ) ;\n    sufCnt [ i ] = st . size ( ) ;\n  }\n  int [ ] res = new int [ n ] ;\n  st . clear ( ) ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    st . add ( nums [ i ] ) ;\n    res [ i ] = ( int ) st . size ( ) - sufCnt [ i + 1 ] ;\n  }\n  return res ;\n}\n", "reference_code": "    public static int[] distinctDifferenceArray(int[] nums) {\n        int n = nums.length;\n        Set<Integer> set = new HashSet<Integer>();\n        int[] sufCnt = new int[n + 1];\n        for (int i = n - 1; i > 0; i--) {\n            set.add(nums[i]);\n            sufCnt[i] = set.size();\n        }\n        int[] res = new int[n];\n        set.clear();\n        for (int i = 0; i < n; i++) {\n            set.add(nums[i]);\n            res[i] = set.size() - sufCnt[i + 1];\n        }\n        return res;\n    }", "target_Lan": "java###distinctDifferenceArray_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.Arrays;\npublic class distinctDifferenceArray_Test {\n// TOFILL\n    public static void main(String[] args) {\n        System.out.println(Arrays.toString(distinctDifferenceArray(new int[]{})));\n        System.out.println(Arrays.toString(distinctDifferenceArray(new int[]{1})));\n        System.out.println(Arrays.toString(distinctDifferenceArray(new int[]{2, 2, 2, 2})));\n        System.out.println(Arrays.toString(distinctDifferenceArray(new int[]{1, 2, 3, 4})));\n        System.out.println(Arrays.toString(distinctDifferenceArray(new int[]{1, 2, -3, -3, 4, 1})));\n    }\n}"}, {"source_Lan": "cpp###findAnswer.cpp", "source_code": "  vector<int> findAnswer(int n, vector<int> &A)\n  {\n    vector<long long> pref(n, A[0]);\n    for (int i = 1; i < n; i++)\n    {\n      pref[i] = pref[i - 1] + A[i];\n    }\n    stack<int> s;\n    vector<int> res(n+1, 0);\n    for (int i = 0; i < n; i++)\n    {\n      if (pref[i] > 0)\n      {\n        res[0] = i + 1;\n        break;\n      }\n    }\n    for (int i = n - 1; i >= 0; i--)\n    {\n      while (!s.empty() && pref[s.top()] <= pref[i])\n        s.pop();\n      if (s.empty())\n        res[i+1] = 0;\n      else if (i < n - 1)\n        res[i + 1] = s.top() - i;\n      s.push(i);\n    }\n    res.pop_back();\n    return res;\n  }", "trans_code": "public static int [ ] findAnswer ( int n , int [ ] A ) {\n  long [ ] pref = new long [ n ] ;\n  for ( int i = 1 ;\n  i < n ;\n  i ++ ) pref [ i ] = pref [ i - 1 ] + A [ i ] ;\n  Stack < Integer > s = new Stack < Integer > ( ) ;\n  int [ ] res = new int [ n + 1 ] ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    if ( pref [ i ] > 0 ) {\n      res [ 0 ] = i + 1 ;\n      break ;\n    }\n  }\n  for ( int i = n - 1 ;\n  i >= 0 ;\n  i -- ) {\n    while ( ! s . empty ( ) && pref [ s . peek ( ) ] <= pref [ i ] ) {\n      s . pop ( ) ;\n    }\n    if ( s . empty ( ) ) {\n      res [ i + 1 ] = 0 ;\n    }\n    else if ( i < n - 1 ) {\n      res [ i + 1 ] = s . peek ( ) - i ;\n    }\n    s . push ( i ) ;\n  }\n  res [ n ] = 0 ;\n  return res ;\n}\n", "reference_code": "    public static ArrayList<Integer> findAnswer(int n, int[] A) \n    {\n        ArrayList<Long> pref = new ArrayList<>();\n        pref.add((long) A[0]);\n        \n        for (int i = 1; i < n; i++) {\n            pref.add(pref.get(i - 1) + A[i]);\n        }\n        Stack<Integer> s = new Stack<>();\n        ArrayList<Integer> res = new ArrayList<>();\n        for(int i=0;i<=n;i++)\n        {\n            res.add(0);\n        }\n        for (int i = 0; i < n; i++) {\n            if (pref.get(i) > 0) \n            {\n                res.set(0,i+1);\n                break;\n            }\n        }\n        for (int i = n - 1; i >= 0; i--) \n        {\n            while (!s.isEmpty() && pref.get(s.peek()) <= pref.get(i)) {\n                s.pop();\n            }\n            if (s.isEmpty()) \n            {\n                res.set(i+1,0);\n            } \n            else if (i < n - 1) \n            {\n                res.set(i + 1, s.peek() - i);\n            }\n            s.push(i);\n        }\n        res.remove(res.size() - 1);\n        return res;\n    }", "target_Lan": "java###findAnswer_Test.java", "target_code_shell": "import java.util.ArrayList;\nimport java.util.Stack;\npublic class findAnswer_Test {\n// TOFILL\n    public static void main(String[] args) {\n        // Test Input 1\n        int n1 = 1;\n        int[] A1 = {1};\n        ArrayList<Integer> result1 = findAnswer(n1, A1);\n        System.out.println(result1);\n\n        // Test Input 2\n        int n2 = 3;\n        int[] A2 = {0, 0, 0};\n        ArrayList<Integer> result2 = findAnswer(n2, A2);\n        System.out.println(result2);\n\n        // Test Input 3\n        int n3 = 5;\n        int[] A3 = {-1, -2, -3, -4, -5};\n        ArrayList<Integer> result3 = findAnswer(n3, A3);\n        System.out.println(result3);\n\n        // Test Input 4\n        int n4 = 6;\n        int[] A4 = {1000000000, -1000000000, 1000000000, -1000000000, 1000000000, -1000000000};\n        ArrayList<Integer> result4 = findAnswer(n4, A4);\n        System.out.println(result4);\n\n        // Test Input 5\n        int n5 = 4;\n        int[] A5 = {1, 2, 3, 4};\n        ArrayList<Integer> result5 = findAnswer(n5, A5);\n        System.out.println(result5);\n    }\n}"}, {"source_Lan": "cpp###stoneGameVI.cpp", "source_code": "    int stoneGameVI(vector<int>& aliceValues, vector<int>& bobValues) {\n        int n = aliceValues.size();\n        vector<tuple<int, int, int>> values;\n        for (int i = 0; i < aliceValues.size(); i++) {\n            values.emplace_back(aliceValues[i] + bobValues[i], aliceValues[i], bobValues[i]);\n        }\n        sort(values.begin(), values.end(), [](tuple<int, int, int> &a, tuple<int, int, int> &b) {\n            return get<0>(a) > get<0>(b);\n        });\n        int aliceSum = 0, bobSum = 0;\n        for (int i = 0; i < n; i++) {\n            if (i % 2 == 0) {\n                aliceSum += get<1>(values[i]);\n            } else {\n                bobSum += get<2>(values[i]);\n            }\n        }\n        if (aliceSum > bobSum) {\n            return 1;\n        } else if (aliceSum == bobSum) {\n            return 0;\n        } else {\n            return -1;\n        }\n    }", "trans_code": "public static int stoneGameVI ( int [ ] aliceValues , int [ ] bobValues ) {\n  int n = aliceValues . length ;\n  ArrayList < Tuple < Integer , Integer , Integer >> values = new ArrayList < Tuple < Integer , Integer , Integer >> ( ) ;\n  for ( int i = 0 ;\n  i < aliceValues . length ;\n  i ++ ) values . add ( new Tuple < Integer , Integer , Integer > ( aliceValues [ i ] + bobValues [ i ] , aliceValues [ i ] , bobValues [ i ] ) ) ;\n  Collections . sort ( values , new Comparator < Tuple < Integer , Integer , Integer >> ( ) {\n    @ Override public int compare ( Tuple < Integer , Integer , Integer > o1 , Tuple < Integer , Integer , Integer > o2 ) {\n      return get ( o1 ) . compareTo ( get ( o2 ) ) ;\n    }\n  }\n  ) ;\n  int aliceSum = 0 , bobSum = 0 ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    if ( i % 2 == 0 ) aliceSum += get ( values . get ( i ) ) ;\n    else bobSum += get ( values . get ( i ) ) ;\n  }\n  if ( aliceSum > bobSum ) return 1 ;\n  else if ( aliceSum == bobSum ) return 0 ;\n  else return - 1 ;\n}\n", "reference_code": "    public static int stoneGameVI(int[] aliceValues, int[] bobValues) {\n        int n = aliceValues.length;\n        int[][] values = new int[n][3];\n        for (int i = 0; i < n; i++) {\n            values[i][0] = aliceValues[i] + bobValues[i];\n            values[i][1] = aliceValues[i];\n            values[i][2] = bobValues[i];\n        }\n        Arrays.sort(values, (a, b) -> b[0] - a[0]);\n        int aliceSum = 0, bobSum = 0;\n        for (int i = 0; i < n; i++) {\n            if (i % 2 == 0) {\n                aliceSum += values[i][1];\n            } else {\n                bobSum += values[i][2];\n            }\n        }\n        if (aliceSum > bobSum) {\n            return 1;\n        } else if (aliceSum == bobSum) {\n            return 0;\n        } else {\n            return -1;\n        }\n    }", "target_Lan": "java###stoneGameVI_Test.java", "target_code_shell": "import java.util.Arrays;\npublic class stoneGameVI_Test {\n// TOFILL\n    public static void main(String[] args) {\n        // Test Input 1\n        int[] aliceValues1 = {1, 2, 3};\n        int[] bobValues1 = {1, 2, 3};\n        System.out.println(stoneGameVI(aliceValues1, bobValues1));\n\n        // Test Input 2\n        int[] aliceValues2 = {10, 5, 8};\n        int[] bobValues2 = {1, 2, 3};\n        System.out.println(stoneGameVI(aliceValues2, bobValues2));\n\n        // Test Input 3\n        int[] aliceValues3 = {1, 2, 3};\n        int[] bobValues3 = {10, 5, 8};\n        System.out.println(stoneGameVI(aliceValues3, bobValues3));\n\n        // Test Input 4\n        int[] aliceValues4 = {3};\n        int[] bobValues4 = {5};\n        System.out.println(stoneGameVI(aliceValues4, bobValues4));\n\n        // Test Input 5\n        int[] aliceValues5 = {5, 7, 9};\n        int[] bobValues5 = {4, 8, 10};\n        System.out.println(stoneGameVI(aliceValues5, bobValues5));\n    }\n}"}, {"source_Lan": "cpp###buyChoco.cpp", "source_code": "    int buyChoco(vector<int>& prices, int money) {\n        int fi = INT_MAX, se = INT_MAX;\n        for (auto p : prices) {\n            if (p < fi) {\n                se = fi;\n                fi = p;\n            } else if (p < se) {\n                se = p;\n            }\n        }\n        return money < fi + se ? money : money - fi - se;\n    }", "trans_code": "public static int buyChoco ( int [ ] prices , int money ) {\n  int fi = Integer . MAX_VALUE , se = Integer . MAX_VALUE ;\n  for ( int p : prices ) {\n    if ( p < fi ) {\n      se = fi ;\n      fi = p ;\n    }\n    else if ( p < se ) se = p ;\n  }\n  return money < fi + se ? money : money - fi - se ;\n}\n", "reference_code": "    public static int buyChoco(int[] prices, int money) {\n        int fi = Integer.MAX_VALUE, se = Integer.MAX_VALUE;\n        for (int price : prices) {\n            if (price < fi) {\n                se = fi;\n                fi = price;\n            } else if (price < se) {\n                se = price;\n            }\n        }\n        return money < fi + se ? money : money - fi - se;\n    }", "target_Lan": "java###buyChoco_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.Arrays;\npublic class buyChoco_Test {\n// TOFILL\n    public static void main(String[] args) {\n        System.out.println(buyChoco(new int[]{}, 10));                \n        System.out.println(buyChoco(new int[]{5}, 10));               \n        System.out.println(buyChoco(new int[]{2, 5, 3}, 10));         \n        System.out.println(buyChoco(new int[]{7, 7, 7}, 15));         \n        System.out.println(buyChoco(new int[]{10, 20, 30}, 5));       \n    }\n}"}, {"source_Lan": "cpp###minimumAddedCoins.cpp", "source_code": "int minimumAddedCoins(vector<int>& coins, int target) {\n        sort(coins.begin(), coins.end());\n        int ans = 0;\n        int x = 1;\n        int length = coins.size(), index = 0;\n        while (x <= target) {\n            if (index < length && coins[index] <= x) {\n                x += coins[index];\n                index++;\n            } else {\n                x <<= 1;\n                ans++;\n            }\n        }\n        return ans;\n    }", "trans_code": "public static int minimumAddedCoins ( int [ ] coins , int target ) {\n  Arrays . sort ( coins ) ;\n  int ans = 0 ;\n  int x = 1 ;\n  int length = coins . length , index = 0 ;\n  while ( x <= target ) {\n    if ( index < length && coins [ index ] <= x ) {\n      x += coins [ index ] ;\n      index ++ ;\n    }\n    else {\n      x <<= 1 ;\n      ans ++ ;\n    }\n  }\n  return ans ;\n}\n", "reference_code": "public static int minimumAddedCoins(int[] coins, int target) {\n        Arrays.sort(coins);\n        int ans = 0;\n        int x = 1;\n        int length = coins.length, index = 0;\n        while (x <= target) {\n            if (index < length && coins[index] <= x) {\n                x += coins[index];\n                index++;\n            } else {\n                x *= 2;\n                ans++;\n            }\n        }\n        return ans;\n    }", "target_Lan": "java###minimumAddedCoins_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.Arrays;\npublic class minimumAddedCoins_Test {\n// TOFILL\n    public static void main(String[] args) {\n        System.out.println(minimumAddedCoins(new int[]{}, 10)); \n        System.out.println(minimumAddedCoins(new int[]{5, 10, 20}, 1)); \n        System.out.println(minimumAddedCoins(new int[]{1, 2, 5}, 15)); \n        System.out.println(minimumAddedCoins(new int[]{2}, 1)); \n        System.out.println(minimumAddedCoins(new int[]{1, 2, 5}, -5)); \n    }\n}"}, {"source_Lan": "cpp###findPeakGrid.cpp", "source_code": "vector<int> findPeakGrid(vector<vector<int>>& mat) {\n        int m = mat.size();\n        int low = 0, high = m - 1;\n        while (low <= high) {\n            int i = (low + high) / 2;\n            int j = max_element(mat[i].begin(), mat[i].end()) - mat[i].begin();\n            if (i - 1 >= 0 && mat[i][j] < mat[i - 1][j]) {\n                high = i - 1;\n                continue;\n            }\n            if (i + 1 < m && mat[i][j] < mat[i + 1][j]) {\n                low = i + 1;\n                continue;\n            }\n            return {i, j};\n        }\n        return {}; \n    }", "trans_code": "public static int [ ] findPeakGrid ( int [ ] [ ] mat ) {\n  int m = mat . length ;\n  int low = 0 , high = m - 1 ;\n  while ( low <= high ) {\n    int i = ( low + high ) / 2 ;\n    int j = maxElement ( mat [ i ] . clone ( ) ) - mat [ i ] . clone ( ) ;\n    if ( i - 1 >= 0 && mat [ i ] [ j ] < mat [ i - 1 ] [ j ] ) {\n      high = i - 1 ;\n      continue ;\n    }\n    if ( i + 1 < m && mat [ i ] [ j ] < mat [ i + 1 ] [ j ] ) {\n      low = i + 1 ;\n      continue ;\n    }\n    return new int [ ] {\n      i , j }\n      ;\n    }\n    return new int [ ] {\n    }\n    ;\n  }\n  ", "reference_code": "public static int[] findPeakGrid(int[][] mat) {\n        int m = mat.length, n = mat[0].length;\n        int low = 0, high = m - 1;\n        while (low <= high) {\n            int i = (low + high) / 2;\n            int j = -1, maxElement = -1;\n            for (int k = 0; k < n; k++) {\n                if (mat[i][k] > maxElement) {\n                    j = k;\n                    maxElement = mat[i][k];\n                }\n            }\n            if (i - 1 >= 0 && mat[i][j] < mat[i - 1][j]) {\n                high = i - 1;\n                continue;\n            }\n            if (i + 1 < m && mat[i][j] < mat[i + 1][j]) {\n                low = i + 1;\n                continue;\n            }\n            return new int[]{i, j};\n        }\n        return new int[0]; \n    }", "target_Lan": "java###findPeakGrid_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.Arrays;\npublic class findPeakGrid_Test {\n// TOFILL\n    public static void main(String[] args) {\n        int[][] input1 = {{1}};                       \n        int[][] input2 = {{1, 1}, {1, 1}};           \n        int[][] input3 = {{10, 20}, {5, 8}};         \n        int[][] input4 = {{5, 4}, {6, 7}};           \n        int[][] input5 = {{1, 2, 3}, {6, 5, 4}};     \n\n        System.out.println(Arrays.toString(findPeakGrid(input1)));\n        System.out.println(Arrays.toString(findPeakGrid(input2)));\n        System.out.println(Arrays.toString(findPeakGrid(input3)));\n        System.out.println(Arrays.toString(findPeakGrid(input4)));\n        System.out.println(Arrays.toString(findPeakGrid(input5)));\n    }\n}"}, {"source_Lan": "cpp###maximumSumOfHeights.cpp", "source_code": "long long maximumSumOfHeights(vector<int>& maxHeights) {\n        int n = maxHeights.size();\n        long long res = 0;\n        vector<long long> prefix(n), suffix(n);\n        stack<int> stack1, stack2;\n        for (int i = 0; i < n; i++) {\n            while (!stack1.empty() && maxHeights[i] < maxHeights[stack1.top()]) {\n                stack1.pop();\n            }\n            if (stack1.empty()) {\n                prefix[i] = (long long)(i + 1) * maxHeights[i];\n            } else {\n                prefix[i] = prefix[stack1.top()] + (long long)(i - stack1.top()) * maxHeights[i];\n            }\n            stack1.emplace(i);\n        }\n        for (int i = n - 1; i >= 0; i--) {\n            while (!stack2.empty() && maxHeights[i] < maxHeights[stack2.top()]) {\n                stack2.pop();\n            }\n            if (stack2.empty()) {\n                suffix[i] = (long long)(n - i) * maxHeights[i];\n            } else {\n                suffix[i] = suffix[stack2.top()] + (long long)(stack2.top() - i) * maxHeights[i];\n            }\n            stack2.emplace(i);\n            res = max(res, prefix[i] + suffix[i] - maxHeights[i]);\n        }\n        return res;\n    }", "trans_code": "public static long maximumSumOfHeights ( int [ ] maxHeights ) {\n  int n = maxHeights . length ;\n  long res = 0 ;\n  long [ ] prefix = new long [ n ] , suffix = new long [ n ] ;\n  Stack < Integer > stack1 = new Stack < Integer > ( ) , stack2 = new Stack < Integer > ( ) ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    while ( ! stack1 . isEmpty ( ) && maxHeights [ i ] < maxHeights [ stack1 . pop ( ) ] ) stack1 . pop ( ) ;\n    if ( stack1 . isEmpty ( ) ) prefix [ i ] = ( long ) ( i + 1 ) * maxHeights [ i ] ;\n    else prefix [ i ] = prefix [ stack1 . pop ( ) ] + ( long ) ( i - stack1 . pop ( ) ) * maxHeights [ i ] ;\n    stack1 . push ( i ) ;\n  }\n  for ( int i = n - 1 ;\n  i >= 0 ;\n  i -- ) {\n    while ( ! stack2 . isEmpty ( ) && maxHeights [ i ] < maxHeights [ stack2 . pop ( ) ] ) stack2 . pop ( ) ;\n    if ( stack2 . isEmpty ( ) ) suffix [ i ] = ( long ) ( n - i ) * maxHeights [ i ] ;\n    else suffix [ i ] = suffix [ stack2 . pop ( ) ] + ( long ) ( stack2 . pop ( ) - i ) * maxHeights [ i ] ;\n    stack2 . push ( i ) ;\n    res = Math . max ( res , prefix [ i ] + suffix [ i ] - maxHeights [ i ] ) ;\n  }\n  return res ;\n}\n", "reference_code": "    public static long maximumSumOfHeights(List<Integer> maxHeights) {\n        int n = maxHeights.size();\n        long res = 0;\n        long[] prefix = new long[n];\n        long[] suffix = new long[n];\n        Deque<Integer> stack1 = new ArrayDeque<Integer>();\n        Deque<Integer> stack2 = new ArrayDeque<Integer>();\n        for (int i = 0; i < n; i++) {\n            while (!stack1.isEmpty() && maxHeights.get(i) < maxHeights.get(stack1.peek())) {\n                stack1.pop();\n            }\n            if (stack1.isEmpty()) {\n                prefix[i] = (long) (i + 1) * maxHeights.get(i);\n            } else {\n                prefix[i] = prefix[stack1.peek()] + (long) (i - stack1.peek()) * maxHeights.get(i);\n            }\n            stack1.push(i);\n        }\n        for (int i = n - 1; i >= 0; i--) {\n            while (!stack2.isEmpty() && maxHeights.get(i) < maxHeights.get(stack2.peek())) {\n                stack2.pop();\n            }\n            if (stack2.isEmpty()) {\n                suffix[i] = (long) (n - i) * maxHeights.get(i);\n            } else {\n                suffix[i] = suffix[stack2.peek()] + (long) (stack2.peek() - i) * maxHeights.get(i);\n            }\n            stack2.push(i);\n            res = Math.max(res, prefix[i] + suffix[i] - maxHeights.get(i));\n        }\n        return res;\n    }", "target_Lan": "java###maximumSumOfHeights_Test.java", "target_code_shell": "import java.util.*;\npublic class maximumSumOfHeights_Test {\n// TOFILL\n    public static void main(String[] args) {\n        \n        List<Integer> maxHeights1 = Arrays.asList(1);\n        System.out.println(maximumSumOfHeights(maxHeights1));  \n        \n        \n        List<Integer> maxHeights2 = Arrays.asList(3, 3, 3);\n        System.out.println(maximumSumOfHeights(maxHeights2));  \n        \n        \n        List<Integer> maxHeights3 = Arrays.asList(5, 4, 3, 2, 1);\n        System.out.println(maximumSumOfHeights(maxHeights3));  \n        \n        \n        List<Integer> maxHeights4 = Arrays.asList(1, 2, 3, 4, 5);\n        System.out.println(maximumSumOfHeights(maxHeights4));  \n        \n        \n        List<Integer> maxHeights5 = Arrays.asList(1000000000, 1000000000, 1000000000, 1000000000);\n        System.out.println(maximumSumOfHeights(maxHeights5));  \n    }\n}"}, {"source_Lan": "cpp###isAcronym.cpp", "source_code": "bool isAcronym(vector<string>& words, string s) {\n        if (s.size() != words.size()) {\n            return false;\n        }\n        for (int i = 0; i < s.size(); i++) {\n            if (words[i][0] != s[i]) {\n                return false;\n            }\n        }\n        return true;\n    }", "trans_code": "public static boolean isAcronym ( String [ ] words , String s ) {\n  if ( s . length ( ) != words . length ) {\n    return false ;\n  }\n  for ( int i = 0 ;\n  i < s . length ( ) ;\n  i ++ ) {\n    if ( words [ i ] . charAt ( 0 ) != s . charAt ( i ) ) {\n      return false ;\n    }\n  }\n  return true ;\n}\n", "reference_code": "public static boolean isAcronym(List<String> words, String s) {\n        if (words.size() != s.length()) {\n            return false;\n        }\n        for (int i = 0; i < s.length(); i++) {\n            if (words.get(i).charAt(0) != s.charAt(i)) {\n                return false;\n            }\n        }\n        return true;\n    }", "target_Lan": "java###isAcronym_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.Arrays;\nimport java.util.List;\npublic class isAcronym_Test {\n// TOFILL\n    public static void main(String[] args) {\n        \n        List<String> words1 = Arrays.asList(\"Hello\", \"World\");\n        String s1 = \"HW\";\n        System.out.println(isAcronym(words1, s1));  \n\n        \n        List<String> words2 = Arrays.asList(\"Random\", \"Access\", \"Memory\");\n        String s2 = \"RAM\";\n        System.out.println(isAcronym(words2, s2));  \n        \n        \n        List<String> words3 = Arrays.asList(\"One\", \"Two\");\n        String s3 = \"OneTwo\";\n        System.out.println(isAcronym(words3, s3));  \n        \n        \n        List<String> words4 = Arrays.asList();\n        String s4 = \"\";\n        System.out.println(isAcronym(words4, s4));  \n        \n        \n        List<String> words5 = Arrays.asList(\"A\");\n        String s5 = \"A\";\n        System.out.println(isAcronym(words5, s5));  \n    }\n}"}, {"source_Lan": "cpp###possibleToStamp.cpp", "source_code": "bool possibleToStamp(vector<vector<int>>& grid, int stampHeight, int stampWidth) {\n        int m = grid.size(), n = grid[0].size();\n        vector<vector<int>> sum(m + 2, vector<int>(n + 2, 0));\n        vector<vector<int>> diff(m + 2, vector<int>(n + 2, 0));\n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                sum[i][j] = sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1] + grid[i - 1][j - 1];\n            }\n        }\n        for (int i = 1; i + stampHeight - 1 <= m; i++) {\n            for (int j = 1; j + stampWidth - 1 <= n; j++) {\n                int x = i + stampHeight - 1;\n                int y = j + stampWidth - 1;\n                if (sum[x][y] - sum[x][j - 1] - sum[i - 1][y] + sum[i - 1][j - 1] == 0) {\n                    diff[i][j]++;\n                    diff[i][y + 1]--;\n                    diff[x + 1][j]--;\n                    diff[x + 1][y + 1]++;\n                }\n            }\n        }\n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                diff[i][j] += diff[i - 1][j] + diff[i][j - 1] - diff[i - 1][j - 1];\n                if (diff[i][j] == 0 && grid[i - 1][j - 1] == 0) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }", "trans_code": "public static boolean possibleToStamp ( int [ ] [ ] grid , int stampHeight , int stampWidth ) {\n  int m = grid . length , n = grid [ 0 ] . length ;\n  int [ ] [ ] sum = new int [ m + 2 ] [ n + 2 ] ;\n  int [ ] [ ] diff = new int [ m + 2 ] [ n + 2 ] ;\n  for ( int i = 1 ;\n  i <= m ;\n  i ++ ) {\n    for ( int j = 1 ;\n    j <= n ;\n    j ++ ) {\n      sum [ i ] [ j ] = sum [ i - 1 ] [ j ] + sum [ i ] [ j - 1 ] - sum [ i - 1 ] [ j - 1 ] + grid [ i - 1 ] [ j - 1 ] ;\n    }\n  }\n  for ( int i = 1 ;\n  i + stampHeight - 1 <= m ;\n  i ++ ) {\n    for ( int j = 1 ;\n    j + stampWidth - 1 <= n ;\n    j ++ ) {\n      int x = i + stampHeight - 1 ;\n      int y = j + stampWidth - 1 ;\n      if ( sum [ x ] [ y ] - sum [ x ] [ j - 1 ] - sum [ i - 1 ] [ y ] + sum [ i - 1 ] [ j - 1 ] == 0 ) {\n        diff [ i ] [ j ] ++ ;\n        diff [ i ] [ y + 1 ] -- ;\n        diff [ x + 1 ] [ j ] -- ;\n        diff [ x + 1 ] [ y + 1 ] ++ ;\n      }\n    }\n  }\n  for ( int i = 1 ;\n  i <= m ;\n  i ++ ) {\n    for ( int j = 1 ;\n    j <= n ;\n    j ++ ) {\n      diff [ i ] [ j ] += diff [ i - 1 ] [ j ] + diff [ i ] [ j - 1 ] - diff [ i - 1 ] [ j - 1 ] ;\n      if ( diff [ i ] [ j ] == 0 && grid [ i - 1 ] [ j - 1 ] == 0 ) {\n        return false ;\n      }\n    }\n  }\n  return true ;\n}\n", "reference_code": "    public static boolean possibleToStamp(int[][] grid, int stampHeight, int stampWidth) {\n        int m = grid.length, n = grid[0].length;\n        int[][] sum = new int[m + 2][n + 2];\n        int[][] diff = new int[m + 2][n + 2];\n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                sum[i][j] = sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1] + grid[i - 1][j - 1];\n            }\n        }\n        for (int i = 1; i + stampHeight - 1 <= m; i++) {\n            for (int j = 1; j + stampWidth - 1 <= n; j++) {\n                int x = i + stampHeight - 1;\n                int y = j + stampWidth - 1;\n                if (sum[x][y] - sum[x][j - 1] - sum[i - 1][y] + sum[i - 1][j - 1] == 0) {\n                    diff[i][j]++;\n                    diff[i][y + 1]--;\n                    diff[x + 1][j]--;\n                    diff[x + 1][y + 1]++;\n                }\n            }\n        }\n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                diff[i][j] += diff[i - 1][j] + diff[i][j - 1] - diff[i - 1][j - 1];\n                if (diff[i][j] == 0 && grid[i - 1][j - 1] == 0) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }", "target_Lan": "java###possibleToStamp_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.Arrays;\npublic class possibleToStamp_Test {\n// TOFILL\n    public static void main(String[] args) {\n        System.out.println(possibleToStamp(new int[][]{{0}}, 1, 1)); \n        System.out.println(possibleToStamp(new int[][]{{1}}, 1, 1)); \n        System.out.println(possibleToStamp(new int[][]{{0,0},{0,0}}, 1, 2)); \n        System.out.println(possibleToStamp(new int[][]{{1,1},{1,1}}, 1, 1)); \n        System.out.println(possibleToStamp(new int[][]{{0,1},{0,0}}, 2, 2)); \n    }\n}"}, {"source_Lan": "cpp###makeSmallestPalindrome.cpp", "source_code": "string makeSmallestPalindrome(string s) {\n        int left = 0, right = s.size() - 1;\n        while (left < right) {\n            if (s[left] != s[right]) {\n                s[left] = s[right] = min(s[left], s[right]);\n            }\n            ++left;\n            --right;\n        }\n        return s;\n    }", "trans_code": "public static String makeSmallestPalindrome ( String s ) {\n  int left = 0 , right = s . length ( ) - 1 ;\n  while ( left < right ) {\n    if ( s . charAt ( left ) != s . charAt ( right ) ) s . charAt ( left ) = s . charAt ( right ) = Math . min ( s . charAt ( left ) , s . charAt ( right ) ) ;\n    ++ left ;\n    -- right ;\n  }\n  return s ;\n}\n", "reference_code": "    public static String makeSmallestPalindrome(String s) {\n        char[] arr = s.toCharArray();\n        int left = 0, right = arr.length - 1;\n        while (left < right) {\n            if (arr[left] != arr[right]) {\n                arr[left] = arr[right] = (char) Math.min(arr[left], arr[right]);\n            }\n            ++left;\n            --right;\n        }\n        return new String(arr);\n    }", "target_Lan": "java###makeSmallestPalindrome_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.*;\npublic class makeSmallestPalindrome_Test {\n// TOFILL\n    public static void main(String[] args) {\n        System.out.println(makeSmallestPalindrome(\"\"));\n        System.out.println(makeSmallestPalindrome(\"a\"));\n        System.out.println(makeSmallestPalindrome(\"racecar\"));\n        System.out.println(makeSmallestPalindrome(\"ab\"));\n        System.out.println(makeSmallestPalindrome(\"abcdef\"));\n    }\n}"}, {"source_Lan": "cpp###secondGreaterElement.cpp", "source_code": "vector<int> secondGreaterElement(vector<int>& nums) {\n        vector<int> res(nums.size(), -1);\n        stack<int> st;\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> q;\n        for (int i = 0; i < nums.size(); ++i) {\n            while (!q.empty() && q.top().first < nums[i]) {\n                res[q.top().second] = nums[i];\n                q.pop();\n            }\n            while (!st.empty() && nums[st.top()] < nums[i]) {\n                q.push({nums[st.top()], st.top()});\n                st.pop();\n            }\n            st.push(i);\n        }\n        return res;\n    }", "trans_code": "public static int [ ] secondGreaterElement ( int [ ] nums ) {\n  int [ ] res = new int [ nums . length ] ;\n  Stack < Integer > st = new Stack < Integer > ( ) ;\n  PriorityQueue < Integer > q = new PriorityQueue < Integer > ( ) ;\n  for ( int i = 0 ;\n  i < nums . length ;\n  i ++ ) {\n    while ( ! q . isEmpty ( ) && q . peek ( ) . intValue ( ) < nums [ i ] ) {\n      res [ q . peek ( ) . intValue ( ) ] = nums [ i ] ;\n      q . pop ( ) ;\n    }\n    while ( ! st . isEmpty ( ) && nums [ st . peek ( ) . intValue ( ) < nums [ i ] ) {\n      q . push ( new Integer ( nums [ st . pop ( ) . intValue ( ) ] ) ) ;\n      st . pop ( ) ;\n    }\n    st . push ( i ) ;\n  }\n  return res ;\n}\n", "reference_code": "    public static int[] secondGreaterElement(int[] nums) {\n        int[] res = new int[nums.length];\n        Arrays.fill(res, -1);\n        Deque<Integer> stack = new ArrayDeque<Integer>();\n        PriorityQueue<int[]> pq = new PriorityQueue<int[]>((a, b) -> a[0] - b[0]);\n        for (int i = 0; i < nums.length; ++i) {\n            while (!pq.isEmpty() && pq.peek()[0] < nums[i]) {\n                res[pq.poll()[1]] = nums[i];\n            }\n            while (!stack.isEmpty() && nums[stack.peek()] < nums[i]) {\n                pq.offer(new int[]{nums[stack.peek()], stack.peek()});\n                stack.pop();\n            }\n            stack.push(i);\n        }\n        return res;\n    }", "target_Lan": "java###secondGreaterElement_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.Arrays;\nimport java.util.ArrayDeque;\nimport java.util.Deque;\nimport java.util.PriorityQueue;\npublic class secondGreaterElement_Test {\n// TOFILL\n    public static void main(String[] args) {\n        System.out.println(Arrays.toString(secondGreaterElement(new int[]{}))); \n        System.out.println(Arrays.toString(secondGreaterElement(new int[]{1}))); \n        System.out.println(Arrays.toString(secondGreaterElement(new int[]{5, 4, 3, 2, 1}))); \n        System.out.println(Arrays.toString(secondGreaterElement(new int[]{3, 1, 4, 2, 5, 5}))); \n        System.out.println(Arrays.toString(secondGreaterElement(new int[]{1, 2, 3, 4, 5}))); \n    }\n}"}, {"source_Lan": "cpp###maxTaxiEarnings.cpp", "source_code": "long long maxTaxiEarnings(int n, vector<vector<int>> &rides) {\n        vector<long long> dp(n + 1);\n        unordered_map<int, vector<vector<int>>> rideMap;\n        for (const auto &ride : rides) {\n            rideMap[ride[1]].push_back(ride);\n        }\n        for (int i = 1; i <= n; i++) {\n            dp[i] = dp[i - 1];\n            for (const auto &ride : rideMap[i]) {\n                dp[i] = max(dp[i], dp[ride[0]] + ride[1] - ride[0] + ride[2]);\n            }\n        }\n        return dp[n];\n    }", "trans_code": "public static long maxTaxiEarnings ( int n , List < List < Integer >> rides ) {\n  long [ ] dp = new long [ n + 1 ] ;\n  HashMap < Integer , List < List < Integer >>> rideMap = new HashMap < Integer , List < List < Integer >>> ( ) ;\n  for ( List < List < Integer >> ride : rides ) {\n    rideMap . put ( ride . get ( 1 ) , ride ) ;\n  }\n  for ( int i = 1 ;\n  i <= n ;\n  i ++ ) {\n    dp [ i ] = dp [ i - 1 ] ;\n    for ( List < List < Integer >> ride : rideMap . get ( i ) ) {\n      dp [ i ] = Math . max ( dp [ i ] , dp [ ride . get ( 0 ) ] + ride . get ( 1 ) - ride . get ( 0 ) + ride . get ( 2 ) ) ;\n    }\n  }\n  return dp [ n ] ;\n}\n", "reference_code": "    public static long maxTaxiEarnings(int n, int[][] rides) {\n        long[] dp = new long[n + 1];\n        Map<Integer, List<int[]>> rideMap = new HashMap<Integer, List<int[]>>();\n        for (int[] ride : rides) {\n            rideMap.putIfAbsent(ride[1], new ArrayList<int[]>());\n            rideMap.get(ride[1]).add(ride);\n        }\n        for (int i = 1; i <= n; i++) {\n            dp[i] = dp[i - 1];\n            for (int[] ride : rideMap.getOrDefault(i, new ArrayList<int[]>())) {\n                dp[i] = Math.max(dp[i], dp[ride[0]] + ride[1] - ride[0] + ride[2]);\n            }\n        }\n        return dp[n];\n    }", "target_Lan": "java###maxTaxiEarnings_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.*;\npublic class maxTaxiEarnings_Test {\n// TOFILL\n    public static void main(String[] args) {\n        \n        int n1 = 0;\n        int[][] rides1 = {};\n        System.out.println(maxTaxiEarnings(n1, rides1)); \n\n        \n        int n2 = 5;\n        int[][] rides2 = {{1, 2, 3}, {2, 5, 6}};\n        System.out.println(maxTaxiEarnings(n2, rides2)); \n\n        \n        int n3 = 5;\n        int[][] rides3 = {{1, 5, 10}, {3, 5, 8}};\n        System.out.println(maxTaxiEarnings(n3, rides3)); \n\n        \n        int n4 = 6;\n        int[][] rides4 = {{1, 3, 5}, {1, 4, 10}, {3, 6, 15}};\n        System.out.println(maxTaxiEarnings(n4, rides4)); \n\n        \n        int n5 = 10;\n        int[][] rides5 = {{2, 4, 5}, {3, 5, 10}, {1, 3, 10}};\n        System.out.println(maxTaxiEarnings(n5, rides5)); \n    }\n}"}, {"source_Lan": "cpp###carPooling.cpp", "source_code": "bool carPooling(vector<vector<int>>& trips, int capacity) {\n        int to_max = 0;\n        for (const auto& trip: trips) {\n            to_max = max(to_max, trip[2]);\n        }\n        vector<int> diff(to_max + 1);\n        for (const auto& trip: trips) {\n            diff[trip[1]] += trip[0];\n            diff[trip[2]] -= trip[0];\n        }\n        int count = 0;\n        for (int i = 0; i <= to_max; ++i) {\n            count += diff[i];\n            if (count > capacity) {\n                return false;\n            }\n        }\n        return true;\n    }", "trans_code": "public static boolean carPooling ( int [ ] [ ] trips , int capacity ) {\n  int toMax = 0 ;\n  for ( int [ ] trip : trips ) toMax = Math . max ( toMax , trip [ 2 ] ) ;\n  int [ ] diff = new int [ toMax + 1 ] ;\n  for ( int [ ] trip : trips ) {\n    diff [ trip [ 1 ] ] += trip [ 0 ] ;\n    diff [ trip [ 2 ] ] -= trip [ 0 ] ;\n  }\n  int count = 0 ;\n  for ( int i = 0 ;\n  i <= toMax ;\n  ++ i ) {\n    count += diff [ i ] ;\n    if ( count > capacity ) {\n      return false ;\n    }\n  }\n  return true ;\n}\n", "reference_code": "public static boolean carPooling(int[][] trips, int capacity) {\n        int toMax = 0;\n        for (int[] trip : trips) {\n            toMax = Math.max(toMax, trip[2]);\n        }\n        int[] diff = new int[toMax + 1];\n        for (int[] trip : trips) {\n            diff[trip[1]] += trip[0];\n            diff[trip[2]] -= trip[0];\n        }\n        int count = 0;\n        for (int i = 0; i <= toMax; ++i) {\n            count += diff[i];\n            if (count > capacity) {\n                return false;\n            }\n        }\n        return true;\n    }", "target_Lan": "java###carPooling_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.Arrays;\npublic class carPooling_Test {\n// TOFILL\n    public static void main(String[] args) {\n        System.out.println(carPooling(new int[][]{}, 5)); \n        System.out.println(carPooling(new int[][]{{2,1,5}}, 5)); \n        System.out.println(carPooling(new int[][]{{1,1,3},{2,2,5}}, 3)); \n        System.out.println(carPooling(new int[][]{{3,2,7},{3,5,9}}, 6)); \n        System.out.println(carPooling(new int[][]{{4,0,5},{3,5,8},{2,3,7}}, 6)); \n    }\n}"}, {"source_Lan": "cpp###firstCompleteIndex.cpp", "source_code": "int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\n        int n = mat.size();\n        int m = mat[0].size();\n        unordered_map<int, pair<int, int>> mp;\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                mp[mat[i][j]] = {i, j};\n            }\n        }\n        vector<int> rowCnt(n, 0);\n        vector<int> colCnt(m, 0);\n        for (int i = 0; i < arr.size(); ++i) {\n            auto& v = mp[arr[i]];\n            ++rowCnt[v.first];\n            if (rowCnt[v.first] == m) {\n                return i;\n            }\n            ++colCnt[v.second];\n            if (colCnt[v.second] == n) {\n                return i;\n            }\n        }\n        return -1;\n    }", "trans_code": "public static int firstCompleteIndex ( int [ ] [ ] arr , int [ ] [ ] mat ) {\n  int n = mat . length ;\n  int m = mat [ 0 ] . length ;\n  HashMap < Integer , Pair [ ] > mp = new HashMap < Integer , Pair [ ] > ( ) ;\n  for ( int i = 0 ;\n  i < n ;\n  ++ i ) {\n    for ( int j = 0 ;\n    j < m ;\n    ++ j ) {\n      mp . put ( mat [ i ] [ j ] , new Pair [ ] {\n        i , j }\n        ) ;\n      }\n    }\n    int [ ] rowCnt = new int [ n ] ;\n    int [ ] colCnt = new int [ m ] ;\n    for ( int i = 0 ;\n    i < arr . length ;\n    ++ i ) {\n      Pair v = mp . get ( arr [ i ] ) ;\n      ++ rowCnt [ v . first ] ;\n      if ( rowCnt [ v . first ] == m ) {\n        return i ;\n      }\n      ++ colCnt [ v . second ] ;\n      if ( colCnt [ v . second ] == n ) {\n        return i ;\n      }\n    }\n    return - 1 ;\n  }\n  ", "reference_code": "public static int firstCompleteIndex(int[] arr, int[][] mat) {\n        int n = mat.length;\n        int m = mat[0].length;\n        Map<Integer, int[]> map = new HashMap<Integer, int[]>();\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                map.put(mat[i][j], new int[]{i, j});\n            }\n        }\n        int[] rowCnt = new int[n];\n        int[] colCnt = new int[m];\n        for (int i = 0; i < arr.length; ++i) {\n            int[] v = map.get(arr[i]);\n            ++rowCnt[v[0]];\n            if (rowCnt[v[0]] == m) {\n                return i;\n            }\n            ++colCnt[v[1]];\n            if (colCnt[v[1]] == n) {\n                return i;\n            }\n        }\n        return -1;\n    }", "target_Lan": "java###firstCompleteIndex_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.HashMap;\nimport java.util.Map;\npublic class firstCompleteIndex_Test {\n// TOFILL\n    public static void main(String[] args) {\n        System.out.println(firstCompleteIndex(new int[]{1,2,3,4}, new int[][]{{1,2},{3,4}})); \n        System.out.println(firstCompleteIndex(new int[]{1,3,2,4}, new int[][]{{1,2},{4,3}})); \n        System.out.println(firstCompleteIndex(new int[]{1,2,3,4,5,6}, new int[][]{{1,2,3},{4,5,6}})); \n    }\n}"}, {"source_Lan": "cpp###closeStrings.cpp", "source_code": "bool closeStrings(string word1, string word2) {\n        vector<int> count1(26), count2(26);\n        for (char c : word1) {\n            count1[c - 'a']++;\n        }\n        for (char c : word2) {\n            count2[c - 'a']++;\n        }\n        for (int i = 0; i < 26; i++) {\n            if (count1[i] > 0 && count2[i] == 0 || count1[i] == 0 && count2[i] > 0) {\n                return false;\n            }\n        }\n        sort(count1.begin(), count1.end());\n        sort(count2.begin(), count2.end());\n        return count1 == count2;\n    }", "trans_code": "public static boolean closeStrings ( String word1 , String word2 ) {\n  int [ ] count1 = new int [ 26 ] , count2 = new int [ 26 ] ;\n  for ( char c : word1 . toCharArray ( ) ) count1 [ c - 'a' ] ++ ;\n  for ( char c : word2 . toCharArray ( ) ) count2 [ c - 'a' ] ++ ;\n  for ( int i = 0 ;\n  i < 26 ;\n  i ++ ) {\n    if ( count1 [ i ] > 0 && count2 [ i ] == 0 || count1 [ i ] == 0 && count2 [ i ] > 0 ) {\n      return false ;\n    }\n  }\n  Arrays . sort ( count1 ) ;\n  Arrays . sort ( count2 ) ;\n  return count1 . equals ( count2 ) ;\n}\n", "reference_code": "public static boolean closeStrings(String word1, String word2) {\n        int[] count1 = new int[26], count2 = new int[26];\n        for (char c : word1.toCharArray()) {\n            count1[c - 'a']++;\n        }\n        for (char c : word2.toCharArray()) {\n            count2[c - 'a']++;\n        }\n        for (int i = 0; i < 26; i++) {\n            if (count1[i] > 0 && count2[i] == 0 || count1[i] == 0 && count2[i] > 0) {\n                return false;\n            }\n        }\n        Arrays.sort(count1);\n        Arrays.sort(count2);\n        return Arrays.equals(count1, count2);\n    }", "target_Lan": "java###closeStrings_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.Arrays;\npublic class closeStrings_Test {\n// TOFILL\n    public static void main(String[] args) {\n        System.out.println(closeStrings(\"abc\", \"cab\"));      \n        System.out.println(closeStrings(\"aabbcc\", \"abcabc\")); \n        System.out.println(closeStrings(\"abc\", \"abcd\"));     \n        System.out.println(closeStrings(\"a\", \"b\"));          \n        System.out.println(closeStrings(\"abc\", \"def\"));      \n    }\n}"}, {"source_Lan": "cpp###minDeletion.cpp", "source_code": "int minDeletion(vector<int>& nums) {\n        int n = nums.size();\n        int ans = 0;\n        bool check = true;\n        for (int i = 0; i + 1 < n; ++i) {\n            if (nums[i] == nums[i + 1] && check) {\n                ++ans;\n            }\n            else {\n                check = !check;\n            }\n        }\n        if ((n - ans) % 2 != 0) {\n            ++ans;\n        }\n        return ans;\n    }", "trans_code": "public static int minDeletion ( int [ ] nums ) {\n  int n = nums . length ;\n  int ans = 0 ;\n  boolean check = true ;\n  for ( int i = 0 ;\n  i + 1 < n ;\n  ++ i ) {\n    if ( nums [ i ] == nums [ i + 1 ] && check ) ++ ans ;\n    else check = ! check ;\n  }\n  if ( ( n - ans ) % 2 != 0 ) ++ ans ;\n  return ans ;\n}\n", "reference_code": "public static int minDeletion(int[] nums) {\n        int n = nums.length;\n        int ans = 0;\n        boolean check = true;\n        for (int i = 0; i + 1 < n; ++i) {\n            if (nums[i] == nums[i + 1] && check) {\n                ++ans;\n            } else {\n                check = !check;\n            }\n        }\n        if ((n - ans) % 2 != 0) {\n            ++ans;\n        }\n        return ans;\n    }", "target_Lan": "java###minDeletion_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.Arrays;\npublic class minDeletion_Test {\n// TOFILL\n    public static void main(String[] args) {\n        int[] input1 = {};\n        int[] input2 = {1, 2, 3, 4};\n        int[] input3 = {1, 1, 2, 2};\n        int[] input4 = {1, 1, 1, 2, 2};\n        int[] input5 = {1, 2, 2, 3, 3};\n\n        System.out.println(minDeletion(input1)); \n        System.out.println(minDeletion(input2)); \n        System.out.println(minDeletion(input3)); \n        System.out.println(minDeletion(input4)); \n        System.out.println(minDeletion(input5)); \n    }\n}"}, {"source_Lan": "cpp###maximumSum.cpp", "source_code": "int maximumSum(vector<int>& nums) {\n        unordered_map<int, int> dict;\n        int res = -1;\n        for (int i : nums) {\n            int digitsSum = 0;\n            int temp = i;\n            while (temp > 0) {\n                digitsSum += temp % 10;\n                temp /= 10;\n            }\n            if (dict.count(digitsSum)) {\n                res = max(res, dict[digitsSum] + i);\n                dict[digitsSum] = max(dict[digitsSum], i);\n            } else {\n                dict[digitsSum] = i;\n            }\n        }\n        return res;\n    }", "trans_code": "public static int maximumSum ( int [ ] nums ) {\n  HashMap < Integer , Integer > dict = new HashMap < Integer , Integer > ( ) ;\n  int res = - 1 ;\n  for ( int i : nums ) {\n    int digitsSum = 0 ;\n    int temp = i ;\n    while ( temp > 0 ) {\n      digitsSum += temp % 10 ;\n      temp /= 10 ;\n    }\n    if ( dict . containsKey ( digitsSum ) ) {\n      res = Math . max ( res , dict . get ( digitsSum ) + i ) ;\n      dict . put ( digitsSum , Math . max ( dict . get ( digitsSum ) , i ) ) ;\n    }\n    else {\n      dict . put ( digitsSum , i ) ;\n    }\n  }\n  return res ;\n}\n", "reference_code": "public static int maximumSum(int[] nums) {\n        Map<Integer, Integer> map = new HashMap<Integer, Integer>();\n        int res = -1;\n        for (int i : nums) {\n            int digitsSum = 0;\n            int temp = i;\n            while (temp > 0) {\n                digitsSum += temp % 10;\n                temp /= 10;\n            }\n            if (map.containsKey(digitsSum)) {\n                res = Math.max(res, map.get(digitsSum) + i);\n                map.put(digitsSum, Math.max(map.get(digitsSum), i));\n            } else {\n                map.put(digitsSum, i);\n            }\n        }\n        return res;\n    }", "target_Lan": "java###maximumSum_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.HashMap;\nimport java.util.Map;\npublic class maximumSum_Test {\n// TOFILL\n    public static void main(String[] args) {\n        System.out.println(maximumSum(new int[]{12, 21, 30, 102, 111}));\n        System.out.println(maximumSum(new int[]{5}));\n        System.out.println(maximumSum(new int[]{-1, -10, 10}));\n        System.out.println(maximumSum(new int[]{0, 100, 200}));\n        System.out.println(maximumSum(new int[]{99999999, 88888888, 12345678}));\n    }\n}"}, {"source_Lan": "cpp###maximizeSum.cpp", "source_code": "int maximizeSum(vector<int>& nums, int k) {\n        int m = *max_element(nums.begin(), nums.end());\n        return (2 * m + k - 1) * k / 2;\n    }", "trans_code": "public static int maximizeSum ( int [ ] nums , int k ) {\n  int m = * maxElement ( nums ) ;\n  return ( 2 * m + k - 1 ) * k / 2 ;\n}\n", "reference_code": "public static int maximizeSum(int[] nums, int k) {\n        int m = Arrays.stream(nums).max().getAsInt();\n        return (2 * m + k - 1) * k / 2;\n    }", "target_Lan": "java###maximizeSum_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.Arrays;\npublic class maximizeSum_Test {\n// TOFILL\n    public static void main(String[] args) {\n        System.out.println(maximizeSum(new int[]{1}, 1)); \n        System.out.println(maximizeSum(new int[]{2, 3, 5, 1}, 3)); \n        System.out.println(maximizeSum(new int[]{10, 20, 30}, 5)); \n        System.out.println(maximizeSum(new int[]{100, 200, 300}, 10)); \n    }\n}"}, {"source_Lan": "cpp###findTheCity.cpp", "source_code": "int findTheCity(int n, vector<vector<int>> &edges, int distanceThreshold) {\n        pair<int, int> ans(INT_MAX / 2, -1);\n        vector<vector<int>> mp(n, vector<int>(n, INT_MAX / 2));\n        for (auto &eg: edges) {\n            int from = eg[0], to = eg[1], weight = eg[2];\n            mp[from][to] = mp[to][from] = weight;\n        }\n        for (int k = 0; k < n; ++k) {\n            mp[k][k] = 0;\n            for (int i = 0; i < n; ++i) {\n                for (int j = 0; j < n; ++j) {\n                    mp[i][j] = min(mp[i][j], mp[i][k] + mp[k][j]);\n                }\n            }\n        }\n        for (int i = 0; i < n; ++i) {\n            int cnt = 0;\n            for (int j = 0; j < n; ++j) {\n                if (mp[i][j] <= distanceThreshold) {\n                    cnt++;\n                }\n            }\n            if (cnt <= ans.first) {\n                ans = {cnt, i};\n            }\n        }\n        return ans.second;\n    }", "trans_code": "public static int findTheCity ( int n , List < List < Integer >> edges , int distanceThreshold ) {\n  Pair < Integer , Integer > ans = new Pair < Integer , Integer > ( Integer . MAX_VALUE / 2 , - 1 ) ;\n  int [ ] [ ] mp = new int [ n ] [ n ] ;\n  for ( List < Integer > eg : edges ) {\n    int from = eg . get ( 0 ) , to = eg . get ( 1 ) , weight = eg . get ( 2 ) ;\n    mp [ from ] [ to ] = mp [ to ] [ from ] = weight ;\n  }\n  for ( int k = 0 ;\n  k < n ;\n  ++ k ) {\n    mp [ k ] [ k ] = 0 ;\n    for ( int i = 0 ;\n    i < n ;\n    ++ i ) {\n      for ( int j = 0 ;\n      j < n ;\n      ++ j ) {\n        mp [ i ] [ j ] = Math . min ( mp [ i ] [ j ] , mp [ i ] [ k ] + mp [ k ] [ j ] ) ;\n      }\n    }\n  }\n  for ( int i = 0 ;\n  i < n ;\n  ++ i ) {\n    int cnt = 0 ;\n    for ( int j = 0 ;\n    j < n ;\n    ++ j ) {\n      if ( mp [ i ] [ j ] <= distanceThreshold ) cnt ++ ;\n    }\n    if ( cnt <= ans . first ) ans = new Pair < Integer , Integer > ( cnt , i ) ;\n  }\n  return ans . second ;\n}\n", "reference_code": "public static int findTheCity(int n, int[][] edges, int distanceThreshold) {\n        int[] ans = {Integer.MAX_VALUE / 2, -1};\n        int[][] mp = new int[n][n];\n        for (int i = 0; i < n; ++i) {\n            Arrays.fill(mp[i], Integer.MAX_VALUE / 2);\n        }\n        for (int[] eg : edges) {\n            int from = eg[0], to = eg[1], weight = eg[2];\n            mp[from][to] = mp[to][from] = weight;\n        }\n        for (int k = 0; k < n; ++k) {\n            mp[k][k] = 0;\n            for (int i = 0; i < n; ++i) {\n                for (int j = 0; j < n; ++j) {\n                    mp[i][j] = Math.min(mp[i][j], mp[i][k] + mp[k][j]);\n                }\n            }\n        }\n        for (int i = 0; i < n; ++i) {\n            int cnt = 0;\n            for (int j = 0; j < n; ++j) {\n                if (mp[i][j] <= distanceThreshold) {\n                    cnt++;\n                }\n            }\n            if (cnt <= ans[0]) {\n                ans[0] = cnt;\n                ans[1] = i;\n            }\n        }\n        return ans[1];\n    }", "target_Lan": "java###findTheCity_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.Arrays;\npublic class findTheCity_Test {\n// TOFILL\n    public static void main(String[] args) {\n        System.out.println(findTheCity(3, new int[][]{{0, 1, 5}, {0, 2, 10}}, 6));\n        System.out.println(findTheCity(2, new int[][]{{0, 1, 1}}, 2));\n        System.out.println(findTheCity(3, new int[][]{{0, 1, 2}}, 3));\n        System.out.println(findTheCity(4, new int[][]{{0, 1, 1}, {1, 2, 3}, {0, 2, 2}, {2, 3, 2}}, 5));\n        System.out.println(findTheCity(5, new int[][]{{0, 1, 1}, {1, 2, 2}, {2, 3, 1}, {3, 4, 1}, {0, 4, 10}}, 10));\n    }\n}"}, {"source_Lan": "cpp###longestAlternatingSubarray.cpp", "source_code": "int longestAlternatingSubarray(vector<int>& nums, int threshold) {\n        int res = 0, dp = 0, n = nums.size();\n        for (int l = n - 1; l >= 0; l--) {\n            if (nums[l] > threshold) {\n                dp = 0;\n            } else if (l == n - 1 || nums[l] % 2 != nums[l + 1] % 2) {\n                dp++;\n            } else {\n                dp = 1;\n            }\n            if (nums[l] % 2 == 0) {\n                res = max(res, dp);\n            }\n        }\n        return res;\n    }", "trans_code": "public static int longestAlternatingSubarray ( int [ ] nums , int threshold ) {\n  int res = 0 , dp = 0 , n = nums . length ;\n  for ( int l = n - 1 ;\n  l >= 0 ;\n  l -- ) {\n    if ( nums [ l ] > threshold ) dp = 0 ;\n    else if ( l == n - 1 || nums [ l ] % 2 != nums [ l + 1 ] % 2 ) dp ++ ;\n    else dp = 1 ;\n    if ( nums [ l ] % 2 == 0 ) res = Math . max ( res , dp ) ;\n  }\n  return res ;\n}\n", "reference_code": "public static int longestAlternatingSubarray(int[] nums, int threshold) {\n        int res = 0, dp = 0;\n        for (int l = nums.length - 1; l >= 0; l--) {\n            if (nums[l] > threshold) {\n                dp = 0;\n            } else if (l == nums.length - 1 || nums[l] % 2 != nums[l + 1] % 2) {\n                dp++;\n            } else {\n                dp = 1;\n            }\n            if (nums[l] % 2 == 0) {\n                res = Math.max(res, dp);\n            }\n        }\n        return res;\n    }", "target_Lan": "java###longestAlternatingSubarray_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.Arrays;\npublic class longestAlternatingSubarray_Test {\n// TOFILL\n    public static void main(String[] args) {\n        System.out.println(longestAlternatingSubarray(new int[]{1, 2, 3, 4, 5}, 5)); \n        System.out.println(longestAlternatingSubarray(new int[]{6, 7, 8, 9, 10}, 5)); \n        System.out.println(longestAlternatingSubarray(new int[]{2, 4, 6, 8}, 10)); \n        System.out.println(longestAlternatingSubarray(new int[]{1, 3, 5, 7}, 5)); \n        System.out.println(longestAlternatingSubarray(new int[]{2, 3, 5, 4, 1}, 5)); \n    }\n}"}, {"source_Lan": "cpp###findTheLongestBalancedSubstring.cpp", "source_code": "int findTheLongestBalancedSubstring(string s) {\n        int res = 0, n = s.size();\n        vector<int> count(2);\n        for (int i = 0; i < n; i++) {\n            if (s[i] == '1') {\n                count[1]++;\n                res = max(res, 2 * min(count[0], count[1]));\n            } else if (i == 0 || s[i - 1] == '1') {\n                count[0] = 1;\n                count[1] = 0;\n            } else {\n                count[0]++;\n            }\n        }\n        return res;            \n    }", "trans_code": "public static int findTheLongestBalancedSubstring ( String s ) {\n  int res = 0 , n = s . length ( ) ;\n  int [ ] count = new int [ 2 ] ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    if ( s . charAt ( i ) == '1' ) {\n      count [ 1 ] ++ ;\n      res = Math . max ( res , 2 * Math . min ( count [ 0 ] , count [ 1 ] ) ) ;\n    }\n    else if ( i == 0 || s . charAt ( i - 1 ) == '1' ) {\n      count [ 0 ] = 1 ;\n      count [ 1 ] = 0 ;\n    }\n    else {\n      count [ 0 ] ++ ;\n    }\n  }\n  return res ;\n}\n", "reference_code": "public static int findTheLongestBalancedSubstring(String s) {\n        int res = 0;\n        int n = s.length();\n        int[] count = new int[2];\n        for (int i = 0; i < n; i++) {\n            if (s.charAt(i) == '1') {\n                count[1]++;\n                res = Math.max(res, 2 * Math.min(count[0], count[1]));\n            } else if (i == 0 || s.charAt(i - 1) == '1') {\n                count[0] = 1;\n                count[1] = 0;\n            } else {\n                count[0]++;\n            }\n        }\n        return res;\n    }", "target_Lan": "java###findTheLongestBalancedSubstring_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.*;\npublic class findTheLongestBalancedSubstring_Test {\n// TOFILL\n    public static void main(String[] args) {\n        System.out.println(findTheLongestBalancedSubstring(\"011\"));\n        System.out.println(findTheLongestBalancedSubstring(\"1100\"));\n        System.out.println(findTheLongestBalancedSubstring(\"0011\"));\n        System.out.println(findTheLongestBalancedSubstring(\"010101\"));\n        System.out.println(findTheLongestBalancedSubstring(\"111000\"));\n    }\n}"}, {"source_Lan": "cpp###vowelStrings.cpp", "source_code": "int vowelStrings(vector<string>& words, int left, int right) {\n        unordered_set<char> vowels = {'a', 'e', 'i', 'o', 'u'};\n        int ans = 0;\n        for (int i = left; i <= right; ++i) {\n            const string& word = words[i];\n            if (vowels.count(word[0]) && vowels.count(word.back())) {\n                ++ans;\n            }\n        }\n        return ans;\n    }", "trans_code": "public static int vowelStrings ( String [ ] words , int left , int right ) {\n  Set < Character > vowels = new HashSet < Character > ( ) ;\n  vowels . add ( 'a' ) ;\n  vowels . add ( 'e' ) ;\n  vowels . add ( 'i' ) ;\n  vowels . add ( 'o' ) ;\n  vowels . add ( 'u' ) ;\n  int ans = 0 ;\n  for ( int i = left ;\n  i <= right ;\n  i ++ ) {\n    String word = words [ i ] ;\n    if ( vowels . contains ( word . charAt ( 0 ) ) && vowels . contains ( word . charAt ( word . length ( ) - 1 ) ) ) {\n      ans ++ ;\n    }\n  }\n  return ans ;\n}\n", "reference_code": "public static int vowelStrings(String[] words, int left, int right) {\n        Set<Character> vowels = new HashSet<Character>() {{\n            add('a');\n            add('e');\n            add('i');\n            add('o');\n            add('u');\n        }};\n        int ans = 0;\n        for (int i = left; i <= right; ++i) {\n            String word = words[i];\n            if (vowels.contains(word.charAt(0)) && vowels.contains(word.charAt(word.length() - 1))) {\n                ++ans;\n            }\n        }\n        return ans;\n    }", "target_Lan": "java###vowelStrings_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.HashSet;\nimport java.util.Set;\npublic class vowelStrings_Test {\n// TOFILL\n    public static void main(String[] args) {\n        String[] input1 = {\"apple\", \"banana\", \"orange\", \"grape\", \"kiwi\", \"\"};\n\n        String[] input2 = {\"air\", \"pin\", \"cream\", \"end\", \"oak\"};\n        System.out.println(vowelStrings(input2, 0, 4));\n\n        String[] input3 = {\"cat\", \"dog\", \"fish\", \"ant\", \"elephant\", \"eagle\"};\n        System.out.println(vowelStrings(input3, 0, 5));\n\n        String[] input4 = {\"umbrella\", \"table\", \"ime\", \"antelope\"};\n        System.out.println(vowelStrings(input4, 0, 3));\n\n        String[] input5 = {\"a\", \"b\", \"e\", \"c\", \"i\"};\n        System.out.println(vowelStrings(input5, 0, 4));\n    }\n}"}, {"source_Lan": "cpp###countDigits.cpp", "source_code": "int countDigits(int num) {\n        int t = num, res = 0;\n        while (t) {\n            if (num % (t % 10) == 0) {\n                res += 1;\n            }\n            t /= 10;\n        }\n        return res;\n    }", "trans_code": "public static int countDigits ( int num ) {\n  int t = num , res = 0 ;\n  while ( t > 0 ) {\n    if ( num % ( t % 10 ) == 0 ) res += 1 ;\n    t /= 10 ;\n  }\n  return res ;\n}\n", "reference_code": "public static int countDigits(int num) {\n        int t = num;\n        int res = 0;\n        while (t != 0) {\n            if (num % (t % 10) == 0) {\n                res++;\n            }\n            t /= 10;\n        }\n        return res;\n    }", "target_Lan": "java###countDigits_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.lang.Math;\npublic class countDigits_Test {\n// TOFILL\n    public static void main(String[] args) {\n        System.out.println(countDigits(0));          \n        System.out.println(countDigits(-123456));    \n        System.out.println(countDigits(12));         \n    }\n}"}, {"source_Lan": "cpp###categorizeBox.cpp", "source_code": "string categorizeBox(int length, int width, int height, int mass) {\n        long long maxd = max(length, max(width, height)), vol = 1L * length * width * height;\n        bool isBulky = maxd >= 10000 || vol >= 1000000000, isHeavy = mass >= 100;\n        if (isBulky && isHeavy) {\n             return \"Both\";\n        } else if (isBulky) {\n            return \"Bulky\";\n        } else if (isHeavy) {\n            return \"Heavy\";\n        } else {\n            return \"Neither\";\n        }\n    }", "trans_code": "public static String categorizeBox ( int length , int width , int height , int mass ) {\n  long maxd = Math . max ( length , Math . max ( width , height ) ) , vol = 1L * length * width * height ;\n  boolean isBulky = maxd >= 10000 || vol >= 1000000000 , isHeavy = mass >= 100 ;\n  if ( isBulky && isHeavy ) {\n    return \"Both\" ;\n  }\n  else if ( isBulky ) {\n    return \"Bulky\" ;\n  }\n  else if ( isHeavy ) {\n    return \"Heavy\" ;\n  }\n  else {\n    return \"Neither\" ;\n  }\n}\n", "reference_code": "public static String categorizeBox(int length, int width, int height, int mass) {\n        long maxd = Math.max(length, Math.max(width, height)), vol = 1L * length * width * height;\n        boolean isBulky = maxd >= 10000 || vol >= 1000000000, isHeavy = mass >= 100;\n        if (isBulky && isHeavy) {\n             return \"Both\";\n        } else if (isBulky) {\n            return \"Bulky\";\n        } else if (isHeavy) {\n            return \"Heavy\";\n        } else {\n            return \"Neither\";\n        }\n    }", "target_Lan": "java###categorizeBox_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.*;\npublic class categorizeBox_Test {\n// TOFILL\n    public static void main(String[] args) {\n        System.out.println(categorizeBox(10001, 1, 1, 150)); \n        System.out.println(categorizeBox(10001, 1, 1, 50));  \n        System.out.println(categorizeBox(1, 1, 1, 150));      \n        System.out.println(categorizeBox(1, 1, 1, 50));       \n        System.out.println(categorizeBox(10000, 10000, 10000, 1000000)); \n    }\n}"}, {"source_Lan": "cpp###maxKelements.cpp", "source_code": "long long maxKelements(vector<int>& nums, int k) {\n        priority_queue<int> q(nums.begin(), nums.end());\n        long long ans = 0;\n        for (int _ = 0; _ < k; ++_) {\n            int x = q.top();\n            q.pop();\n            ans += x;\n            q.push((x + 2) / 3);\n        }\n        return ans;\n    }", "trans_code": "public static long maxKelements ( int [ ] nums , int k ) {\n  PriorityQueue < Integer > q = new PriorityQueue < Integer > ( nums . length ) ;\n  long ans = 0 ;\n  for ( int _ = 0 ;\n  _ < k ;\n  _ ++ ) {\n    int x = q . peek ( ) ;\n    q . poll ( ) ;\n    ans += x ;\n    q . add ( ( x + 2 ) / 3 ) ;\n  }\n  return ans ;\n}\n", "reference_code": "public static long maxKelements(int[] nums, int k) {\n        PriorityQueue<Integer> q = new PriorityQueue<Integer>((a, b) -> b - a);\n        for (int num : nums) {\n            q.offer(num);\n        }\n        long ans = 0;\n        for (int i = 0; i < k; ++i) {\n            int x = q.poll();\n            ans += x;\n            q.offer((x + 2) / 3);\n        }\n        return ans;\n    }", "target_Lan": "java###maxKelements_Test.java", "target_code_shell": "import java.util.PriorityQueue;\npublic class maxKelements_Test {\n// TOFILL\n    public static void main(String[] args) {\n        \n        int[] nums1 = {0, 0, 0};\n        int k1 = 3;\n        System.out.println(maxKelements(nums1, k1));  \n\n        \n        int[] nums2 = {-5, 3, 2, -1, 4};\n        int k2 = 5;\n        System.out.println(maxKelements(nums2, k2));  \n\n        \n        int[] nums3 = {1024, 1024, 1024};\n        int k3 = 3;\n        System.out.println(maxKelements(nums3, k3));  \n\n        \n        int[] nums4 = {1000000};\n        int k4 = 1;\n        System.out.println(maxKelements(nums4, k4));  \n\n        \n        int[] nums5 = {};\n        int k5 = 0;\n        System.out.println(maxKelements(nums5, k5));  \n    }\n}"}, {"source_Lan": "cpp###minimumOneBitOperations.cpp", "source_code": "int minimumOneBitOperations(int n) {\n        int ans = 0;\n        int sign = 1;\n        for (int i = 29; i >= 0; --i) {\n            if (n & (1 << i)) {\n                ans += sign * ((1 << (i + 1)) - 1);\n                sign = -sign;\n            }\n        }\n        return ans;\n    }", "trans_code": "public static int minimumOneBitOperations ( int n ) {\n  int ans = 0 ;\n  int sign = 1 ;\n  for ( int i = 29 ;\n  i >= 0 ;\n  i -- ) {\n    if ( n & ( 1 << i ) ) {\n      ans += sign * ( ( 1 << ( i + 1 ) ) - 1 ) ;\n      sign = - sign ;\n    }\n  }\n  return ans ;\n}\n", "reference_code": "public static int minimumOneBitOperations(int n) {\n        int ans = 0;\n        int sign = 1;\n        for (int i = 29; i >= 0; --i) {\n            if ((n & (1 << i)) != 0) {\n                ans += sign * ((1 << (i + 1)) - 1);\n                sign = -sign;\n            }\n        }\n        return ans;\n    }", "target_Lan": "java###minimumOneBitOperations_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.*;\npublic class minimumOneBitOperations_Test {\n// TOFILL\n    public static void main(String[] args) {\n        System.out.println(minimumOneBitOperations(0));\n        System.out.println(minimumOneBitOperations(1));\n        System.out.println(minimumOneBitOperations(15));\n        System.out.println(minimumOneBitOperations(1073741823));\n        System.out.println(minimumOneBitOperations(-1));\n    }\n}"}, {"source_Lan": "cpp###successfulPairs.cpp", "source_code": "vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\n        vector<int> res(spells.size());\n        vector<int> idx(spells.size());\n        iota(idx.begin(), idx.end(), 0);\n        sort(idx.begin(), idx.end(), [&](int a, int b) {\n            return spells[a] < spells[b];\n        });\n        sort(potions.begin(), potions.end(), [](int a, int b) {\n            return a > b;\n        });\n        for (int i = 0, j = 0; i < spells.size(); ++i) {\n            int p = idx[i];\n            int v = spells[p];\n            while (j < potions.size() && (long long) potions[j] * v >= success) {\n                ++j;\n            }\n            res[p] = j;\n        }\n        return res;\n    }", "trans_code": "public static int [ ] successfulPairs ( int [ ] spells , int [ ] potions , long success ) {\n  int [ ] res = new int [ spells . length ] ;\n  int [ ] idx = new int [ spells . length ] ;\n  Arrays . fill ( idx , 0 ) ;\n  Arrays . fill ( potions , 0 ) ;\n  Arrays . fill ( res , 0 ) ;\n  for ( int i = 0 , j = 0 ;\n  i < spells . length ;\n  i ++ ) {\n    int p = idx [ i ] ;\n    int v = spells [ p ] ;\n    while ( j < potions . length && ( long ) potions [ j ] * v >= success ) j ++ ;\n    res [ p ] = j ;\n  }\n  return res ;\n}\n", "reference_code": "public static int[] successfulPairs(int[] spells, int[] potions, long success) {\n        int n = spells.length, m = potions.length;\n        int[] res = new int[n];\n        int[][] idx = new int[n][2];\n        for (int i = 0; i < n; ++i) {\n            idx[i][0] = spells[i];\n            idx[i][1] = i;\n        }\n        Arrays.sort(potions);\n        for (int i = 0, j = m - 1; i < j; ++i, --j) {\n            int temp = potions[i];\n            potions[i] = potions[j];\n            potions[j] = temp;\n        }\n        Arrays.sort(idx, (a, b) -> a[0] - b[0]);\n        for (int i = 0, j = 0; i < n; ++i) {\n            int p = idx[i][1];\n            int v = idx[i][0];\n            while (j < m && (long) potions[j] * v >= success) {\n                ++j;\n            }\n            res[p] = j;\n        }\n        return res;\n    }", "target_Lan": "java###successfulPairs_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.Arrays;\npublic class successfulPairs_Test {\n// TOFILL\n    public static void main(String[] args) {\n        int[] result1 = successfulPairs(new int[]{1, 2, 3}, new int[]{3, 2, 1}, 2);\n        System.out.println(Arrays.toString(result1));\n        \n        int[] result2 = successfulPairs(new int[]{0, 0, 0}, new int[]{1, 2, 3}, 1);\n        System.out.println(Arrays.toString(result2));\n        \n        int[] result3 = successfulPairs(new int[]{1, 1, 1}, new int[]{0, 0, 0}, 1);\n        System.out.println(Arrays.toString(result3));\n        \n        int[] result4 = successfulPairs(new int[]{1000000, 1000000}, new int[]{1000000, 1000000}, 1000000000000L);\n        System.out.println(Arrays.toString(result4));\n        \n        int[] result5 = successfulPairs(new int[]{-1, 2, 3}, new int[]{1, 2, 3}, 2);\n        System.out.println(Arrays.toString(result5));\n    }\n}"}, {"source_Lan": "cpp###countPairs.cpp", "source_code": "int countPairs(vector<int>& nums, int target) {\n        int res = 0;\n        for (int i = 0; i < nums.size(); i++) {\n            for (int j = i + 1; j < nums.size(); j++) {\n                if (nums[i] + nums[j] < target) {\n                    res++;\n                }\n            }\n        }\n        return res;\n    }", "trans_code": "public static int countPairs ( int [ ] nums , int target ) {\n  int res = 0 ;\n  for ( int i = 0 ;\n  i < nums . length ;\n  i ++ ) {\n    for ( int j = i + 1 ;\n    j < nums . length ;\n    j ++ ) {\n      if ( nums [ i ] + nums [ j ] < target ) res ++ ;\n    }\n  }\n  return res ;\n}\n", "reference_code": "public static int countPairs(List<Integer> nums, int target) {\n        int res = 0;\n        for (int i = 0; i < nums.size(); i++) {\n            for (int j = i + 1; j < nums.size(); j++) {\n                if (nums.get(i) + nums.get(j) < target) {\n                    res++;\n                }\n            }\n        }\n        return res;\n    }", "target_Lan": "java###countPairs_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.List;\nimport java.util.ArrayList;\npublic class countPairs_Test {\n// TOFILL\n    public static void main(String[] args) {\n        List<Integer> input1 = new ArrayList<>();\n        int target1 = 5;\n        System.out.println(countPairs(input1, target1));\n\n        List<Integer> input2 = new ArrayList<>();\n        input2.add(1);\n        int target2 = 5;\n        System.out.println(countPairs(input2, target2));\n\n        List<Integer> input3 = new ArrayList<>();\n        input3.add(1);\n        input3.add(2);\n        input3.add(3);\n        int target3 = 5;\n        System.out.println(countPairs(input3, target3));\n\n        List<Integer> input4 = new ArrayList<>();\n        input4.add(5);\n        input4.add(6);\n        input4.add(7);\n        int target4 = 10;\n        System.out.println(countPairs(input4, target4));\n\n        List<Integer> input5 = new ArrayList<>();\n        input5.add(-1);\n        input5.add(0);\n        input5.add(2);\n        input5.add(4);\n        int target5 = 3;\n        System.out.println(countPairs(input5, target5));\n    }\n}"}, {"source_Lan": "cpp###tupleSameProduct.cpp", "source_code": "int tupleSameProduct(vector<int>& nums) {\n        int n = nums.size();\n        int ans = 0;\n        unordered_map<int, int> cnt;\n        for (int i = 0; i < n; i++) {\n            for(int j = i + 1; j < n; j++) {\n                cnt[nums[i] * nums[j]]++;\n            }\n        }\n        for (auto &[k, v] : cnt) {\n            ans += v * (v - 1) * 4;\n        }\n        return ans;\n    }", "trans_code": "public static int tupleSameProduct ( int [ ] nums ) {\n  int n = nums . length ;\n  int ans = 0 ;\n  HashMap < Integer , Integer > cnt = new HashMap < Integer , Integer > ( ) ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    for ( int j = i + 1 ;\n    j < n ;\n    j ++ ) {\n      cnt . put ( nums [ i ] * nums [ j ] , ++ cnt . get ( nums [ i ] * nums [ j ] ) ) ;\n    }\n  }\n  for ( Integer [ ] [ ] [ ] each : cnt . values ( ) ) {\n    ans += each [ 0 ] [ 0 ] . length * each [ 1 ] [ 0 ] . length * each [ 2 ] [ 0 ] . length * each [ 3 ] [ 0 ] . length * each [ 4 ] [ 0 ] . length * each [ 5 ] [ 0 ] . length * each [ 6 ] [ 0 ] . length * each [ 7 ] [ 0 ] . length * each [ 8 ] [ 0 ] . length * each [ 9 ] [ 0 ] . length * each [ 10 ] [ 0 ] . length * each [ 11 ] [ 0 ] . length * each [ 12 ] [ 0 ] . length * each [ 13 ] [ 0 ] . length * each [ 14 ] [ 0 ] . length * each [ 15 ] [ 0 ] . length * each [ 16 ] [ 0 ] . length * each [ 17 ] [ 0 ] . length * each [ 18 ] [ 0 ] . length * each [ 19 ] [ 0 ] . length * each [ 20 ] [ 0 ] . length * each [ 21 ] [ 0 ] . length * each [ 22 ] [", "reference_code": "    public static int tupleSameProduct(int[] nums) {\n        int n = nums.length;\n        Map<Integer, Integer> cnt = new HashMap<>();\n        for (int i = 0; i < n; i++) {\n            for(int j = i + 1; j < n; j++) {\n                int key = nums[i] * nums[j];\n                cnt.put(key, cnt.getOrDefault(key, 0) + 1);\n            }\n        }\n        int ans = 0;\n        for (Integer v : cnt.values()) {\n            ans += v * (v - 1) * 4;\n        }\n        return ans;\n    }", "target_Lan": "java###tupleSameProduct_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.HashMap;\nimport java.util.Map;\npublic class tupleSameProduct_Test {\n// TOFILL\n    public static void main(String[] args) {\n        System.out.println(tupleSameProduct(new int[]{1, 2, 1, 2}));      \n        System.out.println(tupleSameProduct(new int[]{0, 0, 0, 0}));      \n        System.out.println(tupleSameProduct(new int[]{2, 4, 3, 6}));      \n        System.out.println(tupleSameProduct(new int[]{1, -1, 1, -1}));    \n        System.out.println(tupleSameProduct(new int[]{100000, 100000}));  \n    }\n}"}, {"source_Lan": "cpp###sumOfMultiples.cpp", "source_code": "int sumOfMultiples(int n) {\n        int res = 0;\n        for (int i = 1; i <= n; i++) {\n            if (i % 3 == 0 || i % 5 == 0 || i % 7 == 0) {\n                res += i;\n            }\n        }\n        return res;\n    }", "trans_code": "public static int sumOfMultiples ( int n ) {\n  int res = 0 ;\n  for ( int i = 1 ;\n  i <= n ;\n  i ++ ) {\n    if ( i % 3 == 0 || i % 5 == 0 || i % 7 == 0 ) res += i ;\n  }\n  return res ;\n}\n", "reference_code": "public static int sumOfMultiples(int n) {\n        int res = 0;\n        for (int i = 1; i <= n; i++) {\n            if (i % 3 == 0 || i % 5 == 0 || i % 7 == 0) {\n                res += i;\n            }\n        }\n        return res;\n    }", "target_Lan": "java###sumOfMultiples_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.Arrays;\npublic class sumOfMultiples_Test {\n// TOFILL\n    public static void main(String[] args) {\n        int[] testInputs = {0, 15, 2, 1000000, -5};\n        \n        for(int n : testInputs) {\n            System.out.println(\"sumOfMultiples(\" + n + \") = \" + sumOfMultiples(n));\n        }\n    }\n}"}, {"source_Lan": "cpp###topStudents.cpp", "source_code": "vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& student_id, int k) {\n        unordered_map<std::string, int> words;\n        for (const auto& word : positive_feedback) {\n            words[word] = 3;\n        }\n        for (const auto& word : negative_feedback) {\n            words[word] = -1;\n        }\n        vector<vector<int>> A;\n        for (int i = 0; i < report.size(); i++) {\n            stringstream ss; \n            string w;\n            int score = 0;\n            ss << report[i];\n            while (ss >> w) {\n                if (words.count(w)) {\n                    score += words[w];\n                }\n            }\n            A.push_back({-score, student_id[i]});\n        }\n        sort(A.begin(), A.end());\n        vector<int> top_k;\n        for (int i = 0; i < k; i++) {\n            top_k.push_back(A[i][1]);\n        }\n        return top_k;\n    }", "trans_code": "public static int [ ] [ ] topStudents ( String [ ] positiveFeedback , String [ ] negativeFeedback , String [ ] report , int [ ] studentId , int k ) {\n  HashMap < String , Integer > words = new HashMap < String , Integer > ( ) ;\n  for ( String word : positiveFeedback ) words . put ( word , 3 ) ;\n  for ( String word : negativeFeedback ) words . put ( word , - 1 ) ;\n  ArrayList < Integer [ ] > A = new ArrayList < Integer [ ] > ( ) ;\n  for ( int i = 0 ;\n  i < report . length ;\n  i ++ ) {\n    try {\n      String w ;\n      int score = 0 ;\n      w = report [ i ] ;\n      while ( w != null ) {\n        if ( words . containsKey ( w ) ) score += words . get ( w ) ;\n      }\n      A . add ( new Integer [ ] {\n        - score , studentId [ i ] }\n        ) ;\n      }\n      catch ( Exception e ) {\n        e . printStackTrace ( ) ;\n      }\n    }\n    Arrays . sort ( A ) ;\n    int [ ] [ ] topK = new int [ k ] [ A . size ( ) ] ;\n    for ( int i = 0 ;\n    i < k ;\n    i ++ ) topK [ i ] = A . get ( i ) [ 1 ] ;\n    return topK ;\n  }\n  ", "reference_code": "public static List<Integer> topStudents(String[] positive_feedback, String[] negative_feedback, String[] report, int[] student_id, int k) {\n        Map<String, Integer> words = new HashMap<>();\n        for (String word : positive_feedback) {\n            words.put(word, 3);\n        }\n        for (String word : negative_feedback) {\n            words.put(word, -1);\n        }\n        int n = report.length;\n        int[] scores = new int[n];\n        int[][] A = new int[n][2];\n        for (int i = 0; i < n; i++) {\n            int score = 0;\n            for (String word : report[i].split(\" \")) {\n                score += words.getOrDefault(word, 0);\n            }\n            A[i] = new int[]{-score, student_id[i]};\n        }\n        Arrays.sort(A, (a, b) -> a[0] == b[0] ? a[1] - b[1] : a[0] - b[0]);\n        List<Integer> topK = new ArrayList<>();\n        for (int i = 0; i < k; i++) {\n            topK.add(A[i][1]);\n        }\n        return topK;\n    }", "target_Lan": "java###topStudents_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.*;\npublic class topStudents_Test {\n// TOFILL\n    public static void main(String[] args) {\n        \n        String[] positive_feedback1 = {\"good\", \"excellent\", \"great\"};\n        String[] negative_feedback1 = {\"bad\", \"poor\"};\n        String[] report1 = {\"good work excellent\", \"bad performance\", \"great effort\", \"excellent but with some poor points\"};\n        int[] student_id1 = {1, 2, 3, 4};\n        int k1 = 2;\n        System.out.println(topStudents(positive_feedback1, negative_feedback1, report1, student_id1, k1));\n\n        \n        String[] positive_feedback2 = {};\n        String[] negative_feedback2 = {};\n        String[] report2 = {};\n        int[] student_id2 = {};\n        int k2 = 0;\n        System.out.println(topStudents(positive_feedback2, negative_feedback2, report2, student_id2, k2));\n\n        \n        String[] positive_feedback3 = {\"smart\", \"hardworking\"};\n        String[] negative_feedback3 = {\"lazy\"};\n        String[] report3 = {\"smart hardworking\", \"lazy lazy\"};\n        int[] student_id3 = {1, 2};\n        int k3 = 1;\n        System.out.println(topStudents(positive_feedback3, negative_feedback3, report3, student_id3, k3));\n\n        \n        String[] positive_feedback4 = {\"amazing\"};\n        String[] negative_feedback4 = {\"awful\"};\n        String[] report4 = {\"amazing work\", \"awful results\", \"amazing effort\"};\n        int[] student_id4 = {1, 2, 3};\n        int k4 = 2;\n        System.out.println(topStudents(positive_feedback4, negative_feedback4, report4, student_id4, k4));\n\n        \n        String[] positive_feedback5 = {\"fantastic\"};\n        String[] negative_feedback5 = {\"terrible\"};\n        String[] report5 = {\"fantastic performance\", \"terrible execution\", \"average effort\"};\n        int[] student_id5 = {1, 2, 3};\n        int k5 = 3;\n        System.out.println(topStudents(positive_feedback5, negative_feedback5, report5, student_id5, k5));\n    }\n}"}, {"source_Lan": "cpp###splitNum.cpp", "source_code": "int splitNum(int num) {\n        string stnum = to_string(num);\n        sort(stnum.begin(), stnum.end());\n        int num1 = 0, num2 = 0;\n        for (int i = 0; i < stnum.size(); ++i) {\n            if (i % 2 == 0) {\n                num1 = num1 * 10 + (stnum[i] - '0');\n            }\n            else {\n                num2 = num2 * 10 + (stnum[i] - '0');\n            }\n        }\n        return num1 + num2;\n    }", "trans_code": "public static int splitNum ( int num ) {\n  String stnum = Integer . toString ( num ) ;\n  Collections . sort ( stnum ) ;\n  int num1 = 0 , num2 = 0 ;\n  for ( int i = 0 ;\n  i < stnum . length ( ) ;\n  ++ i ) {\n    if ( i % 2 == 0 ) num1 = num1 * 10 + ( stnum . charAt ( i ) - '0' ) ;\n    else num2 = num2 * 10 + ( stnum . charAt ( i ) - '0' ) ;\n  }\n  return num1 + num2 ;\n}\n", "reference_code": "public static int splitNum(int num) {\n        char[] stnum = Integer.toString(num).toCharArray();\n        Arrays.sort(stnum);\n        int num1 = 0, num2 = 0;\n        for (int i = 0; i < stnum.length; ++i) {\n            if (i % 2 == 0) {\n                num1 = num1 * 10 + (stnum[i] - '0');\n            } else {\n                num2 = num2 * 10 + (stnum[i] - '0');\n            }\n        }\n        return num1 + num2;\n    }", "target_Lan": "java###splitNum_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.Arrays;\npublic class splitNum_Test {\n// TOFILL\n    public static void main(String[] args) {\n        System.out.println(splitNum(1000));\n        System.out.println(splitNum(2222));\n        System.out.println(splitNum(431));\n        System.out.println(splitNum(999999999));\n        System.out.println(splitNum(135792468));\n    }\n}"}, {"source_Lan": "cpp###filterRestaurants.cpp", "source_code": "vector<int> filterRestaurants(vector<vector<int>>& restaurants, int veganFriendly, int maxPrice, int maxDistance) {\n        int n = restaurants.size();\n        vector<vector<int>> filtered;\n        for (int i = 0; i < n; i++) {\n            if (restaurants[i][3] <= maxPrice && restaurants[i][4] <= maxDistance && !(veganFriendly && !restaurants[i][2])) {\n                filtered.push_back(restaurants[i]);\n            }\n        }\n        sort(filtered.begin(), filtered.end(), [](vector<int> &v1, vector<int> &v2) -> bool {\n            return v1[1] > v2[1] || (v1[1] == v2[1] && v1[0] > v2[0]);\n        });\n        vector<int> res;\n        for (auto &v : filtered) {\n            res.push_back(v[0]);\n        }\n        return res;\n    }", "trans_code": "public static int [ ] [ ] filterRestaurants ( int [ ] [ ] restaurants , int veganFriendly , int maxPrice , int maxDistance ) {\n  int n = restaurants . length ;\n  int [ ] [ ] filtered = new int [ n ] [ ] ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    if ( restaurants [ i ] [ 3 ] <= maxPrice && restaurants [ i ] [ 4 ] <= maxDistance && ! ( veganFriendly && ! restaurants [ i ] [ 2 ] ) ) filtered [ i ] = restaurants [ i ] ;\n  }\n  Arrays . sort ( filtered , new Comparator < int [ ] > ( ) {\n    @ Override public int compare ( int [ ] v1 , int [ ] v2 ) {\n      return v1 [ 1 ] > v2 [ 1 ] || ( v1 [ 1 ] == v2 [ 1 ] && v1 [ 0 ] > v2 [ 0 ] ) ? 1 : - 1 ;\n    }\n  }\n  ) ;\n  int [ ] [ ] res = new int [ filtered . length ] [ ] ;\n  for ( int i = 0 ;\n  i < filtered . length ;\n  i ++ ) res [ i ] = filtered [ i ] ;\n  return res ;\n}\n", "reference_code": "public static List<Integer> filterRestaurants(int[][] restaurants, int veganFriendly, int maxPrice, int maxDistance) {\n        int n = restaurants.length;\n        List<int[]> filtered = new ArrayList<int[]>();\n        for (int i = 0; i < n; i++) {\n            if (restaurants[i][3] <= maxPrice && restaurants[i][4] <= maxDistance && !(veganFriendly == 1 && restaurants[i][2] == 0)) {\n                filtered.add(restaurants[i]);\n            }\n        }\n        Collections.sort(filtered, (a, b) -> {\n            if (a[1] != b[1]) {\n                return b[1] - a[1];\n            } else {\n                return b[0] - a[0];\n            }\n        });\n        List<Integer> res = new ArrayList<Integer>();\n        for (int[] v : filtered) {\n            res.add(v[0]);\n        }\n        return res;\n    }", "target_Lan": "java###filterRestaurants_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\npublic class filterRestaurants_Test {\n// TOFILL\n    public static void main(String[] args) {\n        int[][] input1 = {};\n        System.out.println(filterRestaurants(input1, 1, 100, 10));\n\n        int[][] input2 = {{1, 5, 1, 50, 5}, {2, 3, 1, 30, 10}};\n        System.out.println(filterRestaurants(input2, 1, 40, 10));\n\n        int[][] input3 = {{1, 5, 0, 60, 6}, {2, 3, 1, 40, 4}, {3, 4, 0, 30, 3}};\n        System.out.println(filterRestaurants(input3, 1, 50, 5));\n\n        int[][] input4 = {{1, 4, 1, 20, 5}, {2, 3, 0, 30, 10}, {3, 5, 1, 20, 5}};\n        System.out.println(filterRestaurants(input4, 0, 30, 6));\n\n        int[][] input5 = {{1, 5, 1, 100, 10}, {2, 4, 0, 200, 20}, {3, 3, 1, 25, 2}};\n        System.out.println(filterRestaurants(input5, 1, 150, 15));\n    }\n}"}, {"source_Lan": "cpp###passThePillow.cpp", "source_code": "    int passThePillow(int n, int time) {\n        time %= (n - 1) * 2;\n        return time < n ? time + 1 : n * 2 - time - 1;\n    }", "trans_code": "public static int passThePillow ( int n , int time ) {\n  time %= ( n - 1 ) * 2 ;\n  return time < n ? time + 1 : n * 2 - time - 1 ;\n}\n", "reference_code": "public static int passThePillow(int n, int time) {\n        time %= (n - 1) * 2;\n        return time < n ? time + 1 : n * 2 - time - 1;\n    }", "target_Lan": "java###passThePillow_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\npublic class passThePillow_Test {\n// TOFILL\n    public static void main(String[] args) {\n        System.out.println(passThePillow(5, 7));   \n        System.out.println(passThePillow(5, 10));  \n        System.out.println(passThePillow(10, 20)); \n        System.out.println(passThePillow(2, 3));   \n    }\n}"}, {"source_Lan": "cpp###collectTheCoins.cpp", "source_code": "int collectTheCoins(vector<int>& coins, vector<vector<int>>& edges) {\n        int n = coins.size();\n        vector<vector<int>> g(n);\n        vector<int> degree(n);\n        for (const auto& edge: edges) {\n            int x = edge[0], y = edge[1];\n            g[x].push_back(y);\n            g[y].push_back(x);\n            ++degree[x];\n            ++degree[y];\n        }\n        int rest = n;\n        {\n            \n            queue<int> q;\n            for (int i = 0; i < n; ++i) {\n                if (degree[i] == 1 && !coins[i]) {\n                    q.push(i);\n                }\n            }\n            while (!q.empty()) {\n                int u = q.front();\n                --degree[u];\n                q.pop();\n                --rest;\n                for (int v: g[u]) {\n                    --degree[v];\n                    if (degree[v] == 1 && !coins[v]) {\n                        q.push(v);\n                    }\n                }\n            }\n        }\n        {\n            \n            for (int _ = 0; _ < 2; ++_) {\n                queue<int> q;\n                for (int i = 0; i < n; ++i) {\n                    if (degree[i] == 1) {\n                        q.push(i);\n                    }\n                }\n                while (!q.empty()) {\n                    int u = q.front();\n                    --degree[u];\n                    q.pop();\n                    --rest;\n                    for (int v: g[u]) {\n                        --degree[v];\n                    }\n                }\n            }\n        }\n        return rest == 0 ? 0 : (rest - 1) * 2;\n    }", "trans_code": "public static int collectTheCoins ( int [ ] coins , List < List < Integer >> edges ) {\n  int n = coins . length ;\n  int [ ] [ ] g = new int [ n ] [ ] ;\n  int [ ] degree = new int [ n ] ;\n  for ( List < Integer > edge : edges ) {\n    int x = edge . get ( 0 ) , y = edge . get ( 1 ) ;\n    g [ x ] [ y ] = new int [ n ] ;\n    g [ y ] [ x ] = new int [ n ] ;\n    ++ degree [ x ] ;\n    ++ degree [ y ] ;\n  }\n  int rest = n ;\n  {\n    Queue < Integer > q = new LinkedList < Integer > ( ) ;\n    for ( int i = 0 ;\n    i < n ;\n    ++ i ) {\n      if ( degree [ i ] == 1 && ! coins [ i ] ) q . add ( i ) ;\n    }\n    while ( ! q . isEmpty ( ) ) {\n      int u = q . poll ( ) ;\n      -- degree [ u ] ;\n      q . remove ( u ) ;\n      -- rest ;\n      for ( int v : g [ u ] ) {\n        -- degree [ v ] ;\n        if ( degree [ v ] == 1 && ! coins [ v ] ) q . add ( v ) ;\n      }\n    }\n  }\n  {\n    for ( int _ = 0 ;\n    _ < 2 ;\n    ++ _ ) {\n      Queue < Integer > q = new LinkedList < Integer > ( ) ;\n      for ( int i = 0 ;\n      i < n ;\n      ++ i ) {\n        if ( degree [ i ] == 1 ) q . add ( i ) ;\n      }\n      while ( ! q . isEmpty ( ) ) {\n        int u = q . poll ( ) ;\n        -- degree [ u ] ;\n        q . remove ( u ) ;\n        -- rest ;\n        for ( int v : g [ u ] ) {\n          -- degree [ v ] ;\n        }\n      }\n    }\n  }\n  return rest == 0 ? 0 : ( rest - 1 ) * 2 ;\n}\n", "reference_code": "public static int collectTheCoins(int[] coins, int[][] edges) {\n        int n = coins.length;\n        List<Integer>[] g = new List[n];\n        for (int i = 0; i < n; ++i) {\n            g[i] = new ArrayList<Integer>();\n        }\n        int[] degree = new int[n];\n        for (int[] edge : edges) {\n            int x = edge[0], y = edge[1];\n            g[x].add(y);\n            g[y].add(x);\n            ++degree[x];\n            ++degree[y];\n        }\n        int rest = n;\n        \n        Queue<Integer> queue = new ArrayDeque<Integer>();\n        for (int i = 0; i < n; ++i) {\n            if (degree[i] == 1 && coins[i] == 0) {\n                queue.offer(i);\n            }\n        }\n        while (!queue.isEmpty()) {\n            int u = queue.poll();\n            --degree[u];\n            --rest;\n            for (int v : g[u]) {\n                --degree[v];\n                if (degree[v] == 1 && coins[v] == 0) {\n                    queue.offer(v);\n                }\n            }\n        }\n        \n        for (int x = 0; x < 2; ++x) {\n            queue = new ArrayDeque<Integer>();\n            for (int i = 0; i < n; ++i) {\n                if (degree[i] == 1) {\n                    queue.offer(i);\n                }\n            }\n            while (!queue.isEmpty()) {\n                int u = queue.poll();\n                --degree[u];\n                --rest;\n                for (int v : g[u]) {\n                    --degree[v];\n                }\n            }\n        }\n        return rest == 0 ? 0 : (rest - 1) * 2;\n    }", "target_Lan": "java###collectTheCoins_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Queue;\npublic class collectTheCoins_Test {\n// TOFILL\n    public static void main(String[] args) {\n        System.out.println(collectTheCoins(new int[]{0, 0, 0, 0}, new int[][]{{0, 1}, {1, 2}, {1, 3}})); \n        System.out.println(collectTheCoins(new int[]{1, 0, 0, 0}, new int[][]{{0, 1}, {1, 2}, {1, 3}})); \n        System.out.println(collectTheCoins(new int[]{0, 0, 1, 0}, new int[][]{{0, 1}, {1, 2}, {1, 3}})); \n        System.out.println(collectTheCoins(new int[]{0, 1, 1, 1}, new int[][]{{0, 1}, {1, 2}, {1, 3}})); \n        System.out.println(collectTheCoins(new int[]{0}, new int[][]{})); \n    }\n}"}, {"source_Lan": "cpp###minCapability.cpp", "source_code": "int minCapability(vector<int>& nums, int k) {\n        int lower = *min_element(nums.begin(), nums.end());\n        int upper = *max_element(nums.begin(), nums.end());\n        while (lower <= upper) {\n            int middle = (lower + upper) / 2;\n            int count = 0;\n            bool visited = false;\n            for (int x : nums) {\n                if (x <= middle && !visited) {\n                    count++;\n                    visited = true;\n                } else {\n                    visited = false;\n                }\n            }\n            if (count >= k) {\n                upper = middle - 1;\n            } else {\n                lower = middle + 1;\n            }\n        }\n        return lower;\n    }", "trans_code": "public static int minCapability ( int [ ] nums , int k ) {\n  int lower = * minElement ( nums ) ;\n  int upper = * maxElement ( nums ) ;\n  while ( lower <= upper ) {\n    int middle = ( lower + upper ) / 2 ;\n    int count = 0 ;\n    boolean visited = false ;\n    for ( int x : nums ) {\n      if ( x <= middle && ! visited ) {\n        count ++ ;\n        visited = true ;\n      }\n      else {\n        visited = false ;\n      }\n    }\n    if ( count >= k ) upper = middle - 1 ;\n    else lower = middle + 1 ;\n  }\n  return lower ;\n}\n", "reference_code": "public static int minCapability(int[] nums, int k) {\n        int lower = Arrays.stream(nums).min().getAsInt();\n        int upper = Arrays.stream(nums).max().getAsInt();\n        while (lower <= upper) {\n            int middle = (lower + upper) / 2;\n            int count = 0;\n            boolean visited = false;\n            for (int x : nums) {\n                if (x <= middle && !visited) {\n                    count++;\n                    visited = true;\n                } else {\n                    visited = false;\n                }\n            }\n            if (count >= k) {\n                upper = middle - 1;\n            } else {\n                lower = middle + 1;\n            }\n        }\n        return lower;\n    }", "target_Lan": "java###minCapability_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.Arrays;\npublic class minCapability_Test {\n// TOFILL\n    public static void main(String[] args) {\n        System.out.println(minCapability(new int[]{1, 2, 3}, 5)); \n        System.out.println(minCapability(new int[]{10, 15, 20, 25}, 2)); \n        System.out.println(minCapability(new int[]{1, 10, 100, 1000}, 1)); \n        System.out.println(minCapability(new int[]{1, 3, 5, 7}, 3)); \n    }\n}"}, {"source_Lan": "cpp###distMoney.cpp", "source_code": "int distMoney(int money, int children) {\n        if (money < children) {\n            return -1;\n        }\n        money -= children;\n        int cnt = min(money / 7, children);\n        money -= cnt * 7;\n        children -= cnt;\n        if ((children == 0 && money > 0) || (children == 1 && money == 3)) {\n            cnt--;\n        }\n        return cnt;\n    }", "trans_code": "public static int distMoney ( int money , int children ) {\n  if ( money < children ) {\n    return - 1 ;\n  }\n  money -= children ;\n  int cnt = Math . min ( money / 7 , children ) ;\n  money -= cnt * 7 ;\n  children -= cnt ;\n  if ( ( children == 0 && money > 0 ) || ( children == 1 && money == 3 ) ) {\n    cnt -- ;\n  }\n  return cnt ;\n}\n", "reference_code": "public static int distMoney(int money, int children) {\n        if (money < children) {\n            return -1;\n        }\n        money -= children;\n        int cnt = Math.min(money / 7, children);\n        money -= cnt * 7;\n        children -= cnt;\n        if ((children == 0 && money > 0) || (children == 1 && money == 3)) {\n            cnt--;\n        }\n        return cnt;\n    }", "target_Lan": "java###distMoney_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\npublic class distMoney_Test {\n// TOFILL\n    public static void main(String[] args) {\n        System.out.println(distMoney(3, 5)); \n        System.out.println(distMoney(10, 2)); \n        System.out.println(distMoney(1000000000, 1000000)); \n        System.out.println(distMoney(4, 1)); \n        System.out.println(distMoney(8, 10)); \n    }\n}"}, {"source_Lan": "cpp###queensAttacktheKing.cpp", "source_code": "vector<vector<int>> queensAttacktheKing(vector<vector<int>>& queens, vector<int>& king) {\n        unordered_set<int> queen_pos;\n        for (const auto& queen: queens) {\n            int x = queen[0], y = queen[1];\n            queen_pos.insert(x * 8 + y);\n        }\n        vector<vector<int>> ans;\n        for (int dx = -1; dx <= 1; ++dx) {\n            for (int dy = -1; dy <= 1; ++dy) {\n                if (dx == 0 && dy == 0) {\n                    continue;\n                }\n                int kx = king[0] + dx, ky = king[1] + dy;\n                while (kx >= 0 && kx < 8 && ky >= 0 && ky < 8) {\n                    int pos = kx * 8 + ky;\n                    if (queen_pos.count(pos)) {\n                        ans.push_back({kx, ky});\n                        break;\n                    }\n                    kx += dx;\n                    ky += dy;\n                }\n            }\n        }\n        return ans;\n    }", "trans_code": "public static List < List < Integer >> queensAttacktheKing ( List < List < Integer >> queens , List < Integer > king ) {\n  HashSet < Integer > queenPos = new HashSet < Integer > ( ) ;\n  for ( List < Integer > queen : queens ) {\n    int x = queen . get ( 0 ) , y = queen . get ( 1 ) ;\n    queenPos . add ( x * 8 + y ) ;\n  }\n  List < List < Integer >> ans = new ArrayList < List < Integer >> ( ) ;\n  for ( int dx = - 1 ;\n  dx <= 1 ;\n  dx ++ ) {\n    for ( int dy = - 1 ;\n    dy <= 1 ;\n    dy ++ ) {\n      if ( dx == 0 && dy == 0 ) {\n        continue ;\n      }\n      int kx = king . get ( 0 ) + dx , ky = king . get ( 1 ) + dy ;\n      while ( kx >= 0 && kx < 8 && ky >= 0 && ky < 8 ) {\n        int pos = kx * 8 + ky ;\n        if ( queenPos . contains ( pos ) ) {\n          ans . add ( new ArrayList < Integer > ( ) ) ;\n          break ;\n        }\n        kx += dx ;\n        ky += dy ;\n      }\n    }\n  }\n  return ans ;\n}\n", "reference_code": "public static List<List<Integer>> queensAttacktheKing(int[][] queens, int[] king) {\n        Set<Integer> queenPos = new HashSet<Integer>();\n        for (int[] queen : queens) {\n            int x = queen[0], y = queen[1];\n            queenPos.add(x * 8 + y);\n        }\n        List<List<Integer>> ans = new ArrayList<List<Integer>>();\n        for (int dx = -1; dx <= 1; ++dx) {\n            for (int dy = -1; dy <= 1; ++dy) {\n                if (dx == 0 && dy == 0) {\n                    continue;\n                }\n                int kx = king[0] + dx, ky = king[1] + dy;\n                while (kx >= 0 && kx < 8 && ky >= 0 && ky < 8) {\n                    int pos = kx * 8 + ky;\n                    if (queenPos.contains(pos)) {\n                        List<Integer> posList = new ArrayList<Integer>();\n                        posList.add(kx);\n                        posList.add(ky);\n                        ans.add(posList);\n                        break;\n                    }\n                    kx += dx;\n                    ky += dy;\n                }\n            }\n        }\n        return ans;\n    }", "target_Lan": "java###queensAttacktheKing_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\npublic class queensAttacktheKing_Test {\n// TOFILL\n    public static void main(String[] args) {\n        int[][] queens1 = {};\n        int[] king1 = {4, 4};\n        System.out.println(queensAttacktheKing(queens1, king1));\n        \n        int[][] queens2 = {{0, 0}, {1, 1}, {2, 2}};\n        int[] king2 = {4, 4};\n        System.out.println(queensAttacktheKing(queens2, king2));\n        \n        int[][] queens3 = {{0, 1}, {1, 0}, {2, 0}, {1, 2}};\n        int[] king3 = {0, 0};\n        System.out.println(queensAttacktheKing(queens3, king3));\n        \n        int[][] queens4 = {{3, 3}, {3, 7}, {5, 5}};\n        int[] king4 = {4, 4};\n        System.out.println(queensAttacktheKing(queens4, king4));\n        \n        int[][] queens5 = {{0, 2}, {0, 5}, {5, 0}, {0, 1}, {2, 0}};\n        int[] king5 = {0, 0};\n        System.out.println(queensAttacktheKing(queens5, king5));\n    }\n}"}, {"source_Lan": "cpp###giveGem.cpp", "source_code": "int giveGem(vector<int>& gem, vector<vector<int>>& operations) {\n        for (auto &operation : operations) {\n            int x = operation[0], y = operation[1];\n            int number = gem[x] / 2;\n            gem[x] -= number;\n            gem[y] += number;\n        }\n        int mn = *min_element(gem.begin(), gem.end());\n        int mx = *max_element(gem.begin(), gem.end());\n        return mx - mn;\n    }", "trans_code": "public static int giveGem ( int [ ] gem , List < List < Integer >> operations ) {\n  for ( List < Integer > operation : operations ) {\n    int x = operation . get ( 0 ) , y = operation . get ( 1 ) ;\n    int number = gem [ x ] / 2 ;\n    gem [ x ] -= number ;\n    gem [ y ] += number ;\n  }\n  int mn = ( int ) minElement ( gem ) ;\n  int mx = ( int ) maxElement ( gem ) ;\n  return mx - mn ;\n}\n", "reference_code": "public static int giveGem(int[] gem, int[][] operations) {\n        for (int[] operation : operations) {\n            int x = operation[0], y = operation[1];\n            int number = gem[x] / 2;\n            gem[x] -= number;\n            gem[y] += number;\n        }\n        int mn = gem[0], mx = gem[0];\n        for (int number : gem) {\n            mn = Math.min(number, mn);\n            mx = Math.max(number, mx);\n        }\n        return mx - mn;\n    }", "target_Lan": "java###giveGem_Test.java", "target_code_shell": "public class giveGem_Test {\n// TOFILL\n    public static void main(String[] args) {\n        \n        int[] gem1 = {0, 0, 0};\n        int[][] operations1 = {{0, 1}, {1, 2}};\n        System.out.println(giveGem(gem1, operations1));  \n\n        \n        int[] gem2 = {5, 5, 5};\n        int[][] operations2 = {{0, 1}, {2, 1}};\n        System.out.println(giveGem(gem2, operations2));  \n\n        \n        int[] gem3 = {10, 20, 30};\n        int[][] operations3 = {{0, 1}, {1, 2}};\n        System.out.println(giveGem(gem3, operations3));  \n\n        \n        int[] gem4 = {1, 2, 3};\n        int[][] operations4 = {{0, 1}, {1, 0}, {2, 1}};\n        System.out.println(giveGem(gem4, operations4));  \n\n        \n        int[] gem5 = {100, 200, 300};\n        int[][] operations5 = {};\n        System.out.println(giveGem(gem5, operations5));  \n    }\n}"}, {"source_Lan": "cpp###checkValidGrid.cpp", "source_code": "bool checkValidGrid(vector<vector<int>>& grid) {\n        if (grid[0][0] != 0) {\n            return false;\n        }\n        int n = grid.size();\n        vector<array<int, 2>> indices(n * n);\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                indices[grid[i][j]] = {i, j};\n            }\n        }\n        for (int i = 1; i < indices.size(); i++) {\n            int dx = abs(indices[i][0] - indices[i - 1][0]);\n            int dy = abs(indices[i][1] - indices[i - 1][1]);\n            if (dx * dy != 2) {\n                return false;\n            }\n        }\n        return true;\n    }", "trans_code": "public static boolean checkValidGrid ( int [ ] [ ] grid ) {\n  if ( grid [ 0 ] [ 0 ] != 0 ) {\n    return false ;\n  }\n  int n = grid . length ;\n  int [ ] [ ] indices = new int [ n * n ] [ n ] ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < n ;\n    j ++ ) {\n      indices [ grid [ i ] [ j ] ] = new int [ n ] ;\n    }\n  }\n  for ( int i = 1 ;\n  i < indices . length ;\n  i ++ ) {\n    int dx = Math . abs ( indices [ i ] [ 0 ] - indices [ i - 1 ] [ 0 ] ) ;\n    int dy = Math . abs ( indices [ i ] [ 1 ] - indices [ i - 1 ] [ 1 ] ) ;\n    if ( dx * dy != 2 ) {\n      return false ;\n    }\n  }\n  return true ;\n}\n", "reference_code": "public static boolean checkValidGrid(int[][] grid) {\n        if (grid[0][0] != 0) {\n            return false;\n        }\n        int n = grid.length;\n        int[][] indices = new int[n * n][2];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                indices[grid[i][j]][0] = i;\n                indices[grid[i][j]][1] = j;\n            }\n        }\n        for (int i = 1; i < n * n; i++) {\n            int dx = Math.abs(indices[i][0] - indices[i - 1][0]);\n            int dy = Math.abs(indices[i][1] - indices[i - 1][1]);\n            if (dx * dy != 2) {\n                return false;\n            }\n        }\n        return true;\n    }", "target_Lan": "java###checkValidGrid_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.Arrays;\npublic class checkValidGrid_Test {\n// TOFILL\n    public static void main(String[] args) {\n        System.out.println(checkValidGrid(new int[][]{{0}})); \n        System.out.println(checkValidGrid(new int[][]{{0, 1}, {3, 2}})); \n        System.out.println(checkValidGrid(new int[][]{{1, 0}, {2, 3}})); \n        System.out.println(checkValidGrid(new int[][]{{0, 2}, {1, 3}})); \n        System.out.println(checkValidGrid(new int[][]{{0, 1, 2}, {5, 4, 3}, {6, 7, 8}})); \n    }\n}"}, {"source_Lan": "cpp###findTheArrayConcVal.cpp", "source_code": "long long findTheArrayConcVal(vector<int>& nums) {\n        long long ans = 0;\n        for (int i = 0, j = nums.size() - 1; i <= j; i++, j--) {\n            if (i != j) {\n                ans += stoi(to_string(nums[i]) + to_string(nums[j]));\n            } else {\n                ans += nums[i];\n            }\n        }\n        return ans;\n    }", "trans_code": "public static long findTheArrayConcVal ( int [ ] nums ) {\n  long ans = 0 ;\n  for ( int i = 0 , j = nums . length - 1 ;\n  i <= j ;\n  i ++ , j -- ) {\n    if ( i != j ) ans += Integer . parseInt ( String . valueOf ( nums [ i ] ) + String . valueOf ( nums [ j ] ) ) ;\n    else ans += nums [ i ] ;\n  }\n  return ans ;\n}\n", "reference_code": "public static long findTheArrayConcVal(int[] nums) {\n        long ans = 0;\n        for (int i = 0, j = nums.length - 1; i <= j; i++, j--) {\n            if (i != j) {\n                ans += Integer.parseInt(Integer.toString(nums[i]) + Integer.toString(nums[j]));\n            } else {\n                ans += nums[i];\n            }\n        }\n        return ans;\n    }", "target_Lan": "java###findTheArrayConcVal_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.Arrays;\npublic class findTheArrayConcVal_Test {\n// TOFILL\n    public static void main(String[] args) {\n        System.out.println(findTheArrayConcVal(new int[]{}));                      \n        System.out.println(findTheArrayConcVal(new int[]{7}));                    \n        System.out.println(findTheArrayConcVal(new int[]{3, 4}));                 \n        System.out.println(findTheArrayConcVal(new int[]{1, 2, 3, 4}));           \n        System.out.println(findTheArrayConcVal(new int[]{100000, 2000}));         \n    }\n}"}, {"source_Lan": "cpp###findDelayedArrivalTime.cpp", "source_code": "    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\n        return (arrivalTime + delayedTime) % 24;\n    }", "trans_code": "public static int findDelayedArrivalTime ( int arrivalTime , int delayedTime ) {\n  return ( arrivalTime + delayedTime ) % 24 ;\n}\n", "reference_code": "public static int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\n        return (arrivalTime + delayedTime) % 24;\n    }", "target_Lan": "java###findDelayedArrivalTime_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.Arrays;\npublic class findDelayedArrivalTime_Test {\n// TOFILL\n    public static void main(String[] args) {\n        int[][] testInputs = {\n            {0, 0},\n            {1, 23},\n            {12, 12},\n            {20, 5},\n            {25, 10},\n            {-1, 5}\n        };\n\n        for(int[] input : testInputs) {\n            int arrivalTime = input[0];\n            int delayedTime = input[1];\n            System.out.println(findDelayedArrivalTime(arrivalTime, delayedTime));\n        }\n    }\n}"}, {"source_Lan": "cpp###checkIfPrerequisite.cpp", "source_code": "vector<bool> checkIfPrerequisite(int numCourses, vector<vector<int>>& prerequisites, vector<vector<int>>& queries) {\n        vector<vector<int>> g(numCourses);\n        vector<int> indgree(numCourses, 0);\n        vector<vector<bool>> isPre(numCourses, vector<bool>(numCourses, false));\n        for (auto& p : prerequisites) {\n            ++indgree[p[1]];\n            g[p[0]].push_back(p[1]);\n        }\n        queue<int> q;\n        for (int i = 0; i < numCourses; ++i) {\n            if (indgree[i] == 0) {\n                q.push(i);\n            }\n        }\n        while (!q.empty()) {\n            auto cur = q.front();\n            q.pop();\n            for (auto& ne : g[cur]) {\n                isPre[cur][ne] = true;\n                for (int i = 0; i < numCourses; ++i) {\n                    isPre[i][ne] = isPre[i][ne] | isPre[i][cur];\n                }\n                --indgree[ne];\n                if (indgree[ne] == 0) {\n                    q.push(ne);\n                }\n            }\n        }\n        vector<bool> res;\n        for (auto& query : queries) {\n            res.push_back(isPre[query[0]][query[1]]);\n        }\n        return res;\n    }", "trans_code": "public static boolean [ ] [ ] checkIfPrerequisite ( int numCourses , int [ ] [ ] prerequisites , int [ ] [ ] queries ) {\n  int [ ] [ ] g = new int [ numCourses ] [ numCourses ] ;\n  int [ ] [ ] indgree = new int [ numCourses ] [ numCourses ] ;\n  boolean [ ] [ ] isPre = new boolean [ numCourses ] [ numCourses ] ;\n  for ( int [ ] p : prerequisites ) {\n    ++ indgree [ p [ 1 ] ] ;\n    g [ p [ 0 ] ] . add ( p [ 1 ] ) ;\n  }\n  Queue < Integer > q = new LinkedList < Integer > ( ) ;\n  for ( int i = 0 ;\n  i < numCourses ;\n  ++ i ) {\n    if ( indgree [ i ] == 0 ) q . add ( i ) ;\n  }\n  while ( ! q . isEmpty ( ) ) {\n    Integer cur = q . poll ( ) ;\n    q . remove ( ) ;\n    for ( int [ ] ne : g [ cur ] ) {\n      isPre [ cur ] [ ne ] = true ;\n      for ( int i = 0 ;\n      i < numCourses ;\n      ++ i ) isPre [ i ] [ ne ] = isPre [ i ] [ ne ] | isPre [ i ] [ cur ] ;\n      -- indgree [ ne ] ;\n      if ( indgree [ ne ] == 0 ) q . add ( ne ) ;\n    }\n  }\n  boolean [ ] [ ] res = new boolean [ numCourses ] [ numCourses ] ;\n  for ( int [ ] query : queries ) res [ query [ 0 ] ] = isPre [ query [ 1 ] ] ;\n  return res ;\n}\n", "reference_code": "    public static List<Boolean> checkIfPrerequisite(int numCourses, int[][] prerequisites, int[][] queries) {\n        List<Integer>[] g = new List[numCourses];\n        for (int i = 0; i < numCourses; i++) {\n            g[i] = new ArrayList<Integer>();\n        }\n        int[] indgree = new int[numCourses];\n        boolean[][] isPre = new boolean[numCourses][numCourses];\n        for (int[] p : prerequisites) {\n            ++indgree[p[1]];\n            g[p[0]].add(p[1]);\n        }\n        Queue<Integer> queue = new ArrayDeque<Integer>();\n        for (int i = 0; i < numCourses; ++i) {\n            if (indgree[i] == 0) {\n                queue.offer(i);\n            }\n        }\n        while (!queue.isEmpty()) {\n            int cur = queue.poll();\n            for (int ne : g[cur]) {\n                isPre[cur][ne] = true;\n                for (int i = 0; i < numCourses; ++i) {\n                    isPre[i][ne] = isPre[i][ne] | isPre[i][cur];\n                }\n                --indgree[ne];\n                if (indgree[ne] == 0) {\n                    queue.offer(ne);\n                }\n            }\n        }\n        List<Boolean> res = new ArrayList<Boolean>();\n        for (int[] query : queries) {\n            res.add(isPre[query[0]][query[1]]);\n        }\n        return res;\n    }", "target_Lan": "java###checkIfPrerequisite_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.*;\npublic class checkIfPrerequisite_Test {\n// TOFILL\n    public static void main(String[] args) {\n        \n        int numCourses1 = 2;\n        int[][] prerequisites1 = {};\n        int[][] queries1 = {{0, 1}, {1, 0}};\n        System.out.println(checkIfPrerequisite(numCourses1, prerequisites1, queries1));\n\n        \n        int numCourses2 = 3;\n        int[][] prerequisites2 = {{0, 1}, {1, 2}};\n        int[][] queries2 = {{0, 2}, {2, 0}, {0, 1}};\n        System.out.println(checkIfPrerequisite(numCourses2, prerequisites2, queries2));\n\n        \n        int numCourses3 = 4;\n        int[][] prerequisites3 = {{0, 1}, {1, 0}};\n        int[][] queries3 = {{0, 1}, {1, 0}, {2, 3}};\n        System.out.println(checkIfPrerequisite(numCourses3, prerequisites3, queries3));\n\n        \n        int numCourses4 = 5;\n        int[][] prerequisites4 = {{0, 1}, {1, 2}, {2, 3}, {3, 4}};\n        int[][] queries4 = {{0, 4}, {4, 0}, {1, 3}, {2, 1}};\n        System.out.println(checkIfPrerequisite(numCourses4, prerequisites4, queries4));\n\n        \n        int numCourses5 = 100;\n        int[][] prerequisites5 = new int[99][2];\n        for(int i = 0; i < 99; i++) {\n            prerequisites5[i][0] = i;\n            prerequisites5[i][1] = i + 1;\n        }\n        int[][] queries5 = {{0, 99}, {50, 49}, {99, 0}, {0, 0}};\n        System.out.println(checkIfPrerequisite(numCourses5, prerequisites5, queries5));\n    }\n}"}, {"source_Lan": "cpp###minTrioDegree.cpp", "source_code": "int minTrioDegree(int n, vector<vector<int>>& edges) {\n        vector<vector<int>> g(n, vector<int>(n));\n        vector<int> degree(n);\n        for (auto&& edge: edges) {\n            int x = edge[0] - 1, y = edge[1] - 1;\n            g[x][y] = g[y][x] = 1;\n            ++degree[x];\n            ++degree[y];\n        }\n        int ans = INT_MAX;\n        for (int i = 0; i < n; ++i) {\n            for (int j = i + 1; j < n; ++j) {\n                if (g[i][j] == 1) {\n                    for (int k = j + 1; k < n; ++k) {\n                        if (g[i][k] == 1 && g[j][k] == 1) {\n                            ans = min(ans, degree[i] + degree[j] + degree[k] - 6);\n                        }\n                    }\n                }\n            }\n        }\n        return ans == INT_MAX ? -1 : ans;\n    }", "trans_code": "public static int minTrioDegree ( int n , List < List < Integer >> edges ) {\n  int [ ] [ ] g = new int [ n ] [ n ] ;\n  int [ ] degree = new int [ n ] ;\n  for ( List < Integer > edge : edges ) {\n    int x = edge . get ( 0 ) - 1 , y = edge . get ( 1 ) - 1 ;\n    g [ x ] [ y ] = g [ y ] [ x ] = 1 ;\n    ++ degree [ x ] ;\n    ++ degree [ y ] ;\n  }\n  int ans = Integer . MAX_VALUE ;\n  for ( int i = 0 ;\n  i < n ;\n  ++ i ) {\n    for ( int j = i + 1 ;\n    j < n ;\n    ++ j ) {\n      if ( g [ i ] [ j ] == 1 ) {\n        for ( int k = j + 1 ;\n        k < n ;\n        ++ k ) {\n          if ( g [ i ] [ k ] == 1 && g [ j ] [ k ] == 1 ) {\n            ans = Math . min ( ans , degree [ i ] + degree [ j ] + degree [ k ] - 6 ) ;\n          }\n        }\n      }\n    }\n  }\n  return ans == Integer . MAX_VALUE ? - 1 : ans ;\n}\n", "reference_code": "    public static int minTrioDegree(int n, int[][] edges) {\n        int[][] g = new int[n][n];\n        int[] degree = new int[n];\n        for (int[] edge : edges) {\n            int x = edge[0] - 1, y = edge[1] - 1;\n            g[x][y] = g[y][x] = 1;\n            ++degree[x];\n            ++degree[y];\n        }\n        int ans = Integer.MAX_VALUE;\n        for (int i = 0; i < n; ++i) {\n            for (int j = i + 1; j < n; ++j) {\n                if (g[i][j] == 1) {\n                    for (int k = j + 1; k < n; ++k) {\n                        if (g[i][k] == 1 && g[j][k] == 1) {\n                            ans = Math.min(ans, degree[i] + degree[j] + degree[k] - 6);\n                        }\n                    }\n                }\n            }\n        }\n        return ans == Integer.MAX_VALUE ? -1 : ans;\n    }", "target_Lan": "java###minTrioDegree_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.Arrays;\npublic class minTrioDegree_Test {\n// TOFILL\n    public static void main(String[] args) {\n        System.out.println(minTrioDegree(3, new int[][]{{1, 2}, {2, 3}, {1, 3}})); \n        System.out.println(minTrioDegree(4, new int[][]{{1, 2}, {2, 3}, {3, 4}})); \n        System.out.println(minTrioDegree(5, new int[][]{{1, 2}, {2, 3}, {1, 3}, {1, 4}, {2, 4}, {3, 4}})); \n        System.out.println(minTrioDegree(5, new int[][]{{1, 2}, {1, 3}, {1, 4}})); \n        System.out.println(minTrioDegree(6, new int[][]{{1, 2}, {2, 3}, {1, 3}, {3, 4}, {4, 5}, {5, 6}, {3, 5}, {2, 4}})); \n    }\n}"}, {"source_Lan": "cpp###minTrioDegree.cpp", "source_code": "int minTrioDegree(int n, vector<vector<int>>& edges) {\n        \n        vector<unordered_set<int>> g(n);\n        \n        vector<vector<int>> h(n);\n        vector<int> degree(n);\n        for (auto&& edge: edges) {\n            int x = edge[0] - 1, y = edge[1] - 1;\n            g[x].insert(y);\n            g[y].insert(x);\n            ++degree[x];\n            ++degree[y];\n        }\n        for (auto&& edge: edges) {\n            int x = edge[0] - 1, y = edge[1] - 1;\n            if (degree[x] < degree[y] || (degree[x] == degree[y] && x < y)) {\n                h[x].push_back(y);\n            }\n            else {\n                h[y].push_back(x);\n            }\n        }\n        int ans = INT_MAX;\n        for (int i = 0; i < n; ++i) {\n            for (int j: h[i]) {\n                for (int k: h[j]) {\n                    if (g[i].count(k)) {\n                        ans = min(ans, degree[i] + degree[j] + degree[k] - 6);\n                    }\n                }\n            }\n        }\n        return ans == INT_MAX ? -1 : ans;\n    }", "trans_code": "public static int minTrioDegree ( int n , List < List < Integer >> edges ) {\n  BitSet g = new BitSet ( n ) ;\n  BitSet h = new BitSet ( n ) ;\n  int [ ] degree = new int [ n ] ;\n  for ( List < Integer > edge : edges ) {\n    int x = edge . get ( 0 ) - 1 , y = edge . get ( 1 ) - 1 ;\n    g . set ( x , y ) ;\n    g . set ( y , x ) ;\n    ++ degree [ x ] ;\n    ++ degree [ y ] ;\n  }\n  for ( List < Integer > edge : edges ) {\n    int x = edge . get ( 0 ) - 1 , y = edge . get ( 1 ) - 1 ;\n    if ( degree [ x ] < degree [ y ] || ( degree [ x ] == degree [ y ] && x < y ) ) h . set ( x , y ) ;\n    else h . set ( y , x ) ;\n  }\n  int ans = Integer . MAX_VALUE ;\n  for ( int i = 0 ;\n  i < n ;\n  ++ i ) {\n    for ( int j : h . get ( i ) ) {\n      for ( int k : h . get ( j ) ) {\n        if ( g . get ( i ) ) ans = Math . min ( ans , degree [ i ] + degree [ j ] + degree [ k ] - 6 ) ;\n      }\n    }\n  }\n  return ans == Integer . MAX_VALUE ? - 1 : ans ;\n}\n", "reference_code": "public static int minTrioDegree(int n, int[][] edges) {\n        \n        Set<Integer>[] g = new Set[n];\n        for (int i = 0; i < n; ++i) {\n            g[i] = new HashSet<Integer>();\n        }\n        \n        List<Integer>[] h = new List[n];\n        for (int i = 0; i < n; ++i) {\n            h[i] = new ArrayList<Integer>();\n        }\n        int[] degree = new int[n];\n        for (int[] edge : edges) {\n            int x = edge[0] - 1, y = edge[1] - 1;\n            g[x].add(y);\n            g[y].add(x);\n            ++degree[x];\n            ++degree[y];\n        }\n        for (int[] edge : edges) {\n            int x = edge[0] - 1, y = edge[1] - 1;\n            if (degree[x] < degree[y] || (degree[x] == degree[y] && x < y)) {\n                h[x].add(y);\n            } else {\n                h[y].add(x);\n            }\n        }\n        int ans = Integer.MAX_VALUE;\n        for (int i = 0; i < n; ++i) {\n            for (int j : h[i]) {\n                for (int k : h[j]) {\n                    if (g[i].contains(k)) {\n                        ans = Math.min(ans, degree[i] + degree[j] + degree[k] - 6);\n                    }\n                }\n            }\n        }\n        return ans == Integer.MAX_VALUE ? -1 : ans;\n    }", "target_Lan": "java###minTrioDegree_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.*;\npublic class minTrioDegree_Test {\n// TOFILL\n    public static void main(String[] args) {\n        \n        int n1 = 1;\n        int[][] edges1 = {};\n        System.out.println(minTrioDegree(n1, edges1)); \n\n        \n        int n2 = 3;\n        int[][] edges2 = {{1, 2}, {2, 3}, {3, 1}};\n        System.out.println(minTrioDegree(n2, edges2)); \n\n        \n        int n3 = 4;\n        int[][] edges3 = {{1, 2}, {3, 4}};\n        System.out.println(minTrioDegree(n3, edges3)); \n\n        \n        int n4 = 5;\n        int[][] edges4 = {{1, 2}, {1, 3}, {2, 3}, {2, 4}, {3, 4}, {4, 5}};\n        System.out.println(minTrioDegree(n4, edges4)); \n\n        \n        int n5 = 6;\n        int[][] edges5 = {{1, 2}, {1, 3}, {1, 4}, {2, 4}, {2, 5}, {3, 5}, {4, 5}, {5, 6}};\n        System.out.println(minTrioDegree(n5, edges5)); \n    }\n}"}, {"source_Lan": "cpp###minimumJumps.cpp", "source_code": "int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\n        queue<tuple<int, int, int>> q;\n        unordered_set<int> visited;\n        q.emplace(0, 1, 0);\n        visited.emplace(0);\n        int lower = 0, upper = max(*max_element(forbidden.begin(), forbidden.end()) + a, x) + b;\n        unordered_set<int> forbiddenSet(forbidden.begin(), forbidden.end());\n        while (!q.empty()) {\n            auto [position, direction, step] = q.front();\n            q.pop();\n            if (position == x) {\n                return step;\n            }\n            int nextPosition = position + a;\n            int nextDirection = 1;\n            if (lower <= nextPosition && nextPosition <= upper && !visited.count(nextPosition * nextDirection) && !forbiddenSet.count(nextPosition)) {\n                visited.emplace(nextPosition * nextDirection);\n                q.emplace(nextPosition, nextDirection, step + 1);\n            }\n            if (direction == 1) {\n                nextPosition = position - b;\n                nextDirection = -1;\n                if (lower <= nextPosition && nextPosition <= upper && !visited.count(nextPosition * nextDirection) && !forbiddenSet.count(nextPosition)) {\n                    visited.emplace(nextPosition * nextDirection);\n                    q.emplace(nextPosition, nextDirection, step + 1);\n                }\n            }\n        }\n        return -1;\n    }", "trans_code": "public static int minimumJumps ( int [ ] forbidden , int a , int b , int x ) {\n  Queue < Tuple < Integer , Integer , Integer >> q = new LinkedList < Tuple < Integer , Integer , Integer >> ( ) ;\n  TreeSet < Integer > visited = new TreeSet < Integer > ( ) ;\n  q . add ( new Tuple < Integer , Integer , Integer > ( 0 , 1 , 0 ) ) ;\n  visited . add ( new Tuple < Integer , Integer , Integer > ( 0 ) ) ;\n  int lower = 0 , upper = Math . max ( * maxElement ( forbidden ) + a , x ) + b ;\n  TreeSet < Integer > forbiddenSet = new TreeSet < Integer > ( ) ;\n  while ( ! q . isEmpty ( ) ) {\n    Tuple < Integer , Integer , Integer > [ ] position = q . poll ( ) ;\n    q . addAll ( Arrays . asList ( position ) ) ;\n    if ( position [ 0 ] . equals ( x ) ) {\n      return step ;\n    }\n    int nextPosition = position [ 0 ] . intValue ( ) + a ;\n    int nextDirection = 1 ;\n    if ( lower <= nextPosition && nextPosition <= upper && ! visited . contains ( nextPosition * nextDirection ) && ! forbiddenSet . contains ( nextPosition ) ) {\n      visited . add ( nextPosition * nextDirection ) ;\n      q . add ( nextPosition , nextDirection , step + 1 ) ;\n    }\n    if ( direction == 1 ) {\n      nextPosition = position [ 0 ] . intValue ( ) - b ;\n      nextDirection = - 1 ;\n      if ( lower <= nextPosition && nextPosition <= upper && ! visited . contains ( nextPosition * nextDirection ) && ! forbiddenSet . contains ( nextPosition ) ) {\n        visited . add ( nextPosition * nextDirection ) ;\n        q . add ( nextPosition , nextDirection , step + 1 ) ;\n      }\n    }\n  }\n  return - 1 ;\n}\n", "reference_code": "public static int minimumJumps(int[] forbidden, int a, int b, int x) {\n        Queue<int[]> queue = new ArrayDeque<int[]>();\n        Set<Integer> visited = new HashSet<Integer>();\n        queue.offer(new int[]{0, 1, 0});\n        visited.add(0);\n        int lower = 0, upper = Math.max(Arrays.stream(forbidden).max().getAsInt() + a, x) + b;\n        Set<Integer> forbiddenSet = new HashSet<Integer>();\n        for (int position : forbidden) {\n            forbiddenSet.add(position);\n        }\n        while (!queue.isEmpty()) {\n            int[] arr = queue.poll();\n            int position = arr[0], direction = arr[1], step = arr[2];\n            if (position == x) {\n                return step;\n            }\n            int nextPosition = position + a;\n            int nextDirection = 1;\n            if (lower <= nextPosition && nextPosition <= upper && !visited.contains(nextPosition * nextDirection) && !forbiddenSet.contains(nextPosition)) {\n                visited.add(nextPosition * nextDirection);\n                queue.offer(new int[]{nextPosition, nextDirection, step + 1});\n            }\n            if (direction == 1) {\n                nextPosition = position - b;\n                nextDirection = -1;\n                if (lower <= nextPosition && nextPosition <= upper && !visited.contains(nextPosition * nextDirection) && !forbiddenSet.contains(nextPosition)) {\n                    visited.add(nextPosition * nextDirection);\n                    queue.offer(new int[]{nextPosition, nextDirection, step + 1});\n                }\n            }\n        }\n        return -1;\n    }", "target_Lan": "java###minimumJumps_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.*;\npublic class minimumJumps_Test {\n// TOFILL\n    public static void main(String[] args) {\n        System.out.println(minimumJumps(new int[]{3}, 1, 2, 5));\n        System.out.println(minimumJumps(new int[]{1, 2, 4}, 2, 3, 6));\n    }\n}"}, {"source_Lan": "cpp###numFactoredBinaryTrees.cpp", "source_code": "int numFactoredBinaryTrees(vector<int>& arr) {\n        sort(arr.begin(), arr.end());\n        int n = arr.size();\n        vector<long long> dp(n);\n        long long res = 0, mod = 1e9 + 7;\n        for (int i = 0; i < n; i++) {\n            dp[i] = 1;\n            for (int left = 0, right = i - 1; left <= right; left++) {\n                while (right >= left && (long long)arr[left] * arr[right] > arr[i]) {\n                    right--;\n                }\n                if (right >= left && (long long)arr[left] * arr[right] == arr[i]) {\n                    if (right != left) {\n                        dp[i] = (dp[i] + dp[left] * dp[right] * 2) % mod;\n                    } else {\n                        dp[i] = (dp[i] + dp[left] * dp[right]) % mod;\n                    }\n                }\n            }\n            res = (res + dp[i]) % mod;\n        }\n        return res;\n    }", "trans_code": "public static int numFactoredBinaryTrees ( int [ ] arr ) {\n  Arrays . sort ( arr ) ;\n  int n = arr . length ;\n  long [ ] dp = new long [ n ] ;\n  long res = 0 , mod = 1e9 + 7 ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    dp [ i ] = 1 ;\n    for ( int left = 0 , right = i - 1 ;\n    left <= right ;\n    left ++ ) {\n      while ( right >= left && ( long ) arr [ left ] * arr [ right ] > arr [ i ] ) right -- ;\n      if ( right >= left && ( long ) arr [ left ] * arr [ right ] == arr [ i ] ) {\n        if ( right != left ) dp [ i ] = ( dp [ i ] + dp [ left ] * dp [ right ] * 2 ) % mod ;\n        else dp [ i ] = ( dp [ i ] + dp [ left ] * dp [ right ] ) % mod ;\n      }\n    }\n    res = ( res + dp [ i ] ) % mod ;\n  }\n  return res ;\n}\n", "reference_code": "public static int numFactoredBinaryTrees(int[] arr) {\n        Arrays.sort(arr);\n        int n = arr.length;\n        long[] dp = new long[n];\n        long res = 0, mod = 1000000007;\n        for (int i = 0; i < n; i++) {\n            dp[i] = 1;\n            for (int left = 0, right = i - 1; left <= right; left++) {\n                while (right >= left && (long) arr[left] * arr[right] > arr[i]) {\n                    right--;\n                }\n                if (right >= left && (long) arr[left] * arr[right] == arr[i]) {\n                    if (right != left) {\n                        dp[i] = (dp[i] + dp[left] * dp[right] * 2) % mod;\n                    } else {\n                        dp[i] = (dp[i] + dp[left] * dp[right]) % mod;\n                    }\n                }\n            }\n            res = (res + dp[i]) % mod;\n        }\n        return (int) res;\n    }", "target_Lan": "java###numFactoredBinaryTrees_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.Arrays;\npublic class numFactoredBinaryTrees_Test {\n// TOFILL\n    public static void main(String[] args) {\n        System.out.println(numFactoredBinaryTrees(new int[] {}));             \n        System.out.println(numFactoredBinaryTrees(new int[] { 1 }));          \n        System.out.println(numFactoredBinaryTrees(new int[] { 2, 4, 8 }));    \n        System.out.println(numFactoredBinaryTrees(new int[] { 10, 100, 1000 })); \n        System.out.println(numFactoredBinaryTrees(new int[] { 2, 2, 4, 4, 8 })); \n    }\n}"}, {"source_Lan": "cpp###countPairs.cpp", "source_code": "vector<int> countPairs(int n, vector<vector<int>>& edges, vector<int>& queries) {\n        vector<int> degree(n);\n        unordered_map<int, int> cnt;\n        for (auto edge : edges) {\n            int x = edge[0] - 1, y = edge[1] - 1;\n            if (x > y) {\n                swap(x, y);\n            }\n            degree[x]++;\n            degree[y]++;\n            cnt[x * n + y]++;\n        }\n        vector<int> arr = degree;\n        vector<int> ans;\n        sort(arr.begin(), arr.end());\n        for (int bound : queries) {\n            int total = 0;\n            for (int i = 0, j = n - 1; i < n; i++) {\n                while (j > i && arr[i] + arr[j] > bound) {\n                    j--;\n                }\n                total += n - 1 - max(i, j);\n            }\n            for (auto &[val, freq] : cnt) {\n                int x = val / n;\n                int y = val % n;\n                if (degree[x] + degree[y] > bound && degree[x] + degree[y] - freq <= bound) {\n                    total--;\n                }\n            }\n            ans.emplace_back(total);\n        }\n        return ans;\n    }", "trans_code": "public static List < Integer > countPairs ( int n , List < List < Integer >> edges , List < Integer > queries ) {\n  int [ ] degree = new int [ n ] ;\n  HashMap < Integer , Integer > cnt = new HashMap < Integer , Integer > ( ) ;\n  for ( List < Integer > edge : edges ) {\n    int x = edge . get ( 0 ) - 1 , y = edge . get ( 1 ) - 1 ;\n    if ( x > y ) swap ( x , y ) ;\n    degree [ x ] ++ ;\n    degree [ y ] ++ ;\n    cnt . put ( x * n + y , 1 ) ;\n  }\n  int [ ] arr = degree ;\n  List < Integer > ans = new ArrayList < Integer > ( ) ;\n  Arrays . sort ( arr ) ;\n  for ( int bound : queries ) {\n    int total = 0 ;\n    for ( int i = 0 , j = n - 1 ;\n    i < n ;\n    i ++ ) {\n      while ( j > i && arr [ i ] + arr [ j ] > bound ) j -- ;\n      total += n - 1 - max ( i , j ) ;\n    }\n    for ( Integer [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] : cnt . values ( ) ) {\n      int x = val / n ;\n      int y = val % n ;\n      if ( degree [ x ] + degree [ y ] > bound && degree [ x ] + degree [ y ] [ - freq <= bound ) total -- ;\n    }\n    ans . add ( total ) ;\n  }\n  return ans ;\n}\n", "reference_code": "public static int[] countPairs(int n, int[][] edges, int[] queries) {\n        int[] degree = new int[n];\n        Map<Integer, Integer> cnt = new HashMap<Integer, Integer>();\n        for (int[] edge : edges) {\n            int x = edge[0] - 1, y = edge[1] - 1;\n            if (x > y) {\n                int temp = x;\n                x = y;\n                y = temp;\n            }\n            degree[x]++;\n            degree[y]++;\n            cnt.put(x * n + y, cnt.getOrDefault(x * n + y, 0) + 1);\n        }\n        int[] arr = Arrays.copyOf(degree, n);\n        int[] ans = new int[queries.length];\n        Arrays.sort(arr);\n        for (int k = 0; k < queries.length; k++) {\n            int bound = queries[k], total = 0;\n            for (int i = 0, j = n - 1; i < n; i++) {\n                while (j > i && arr[i] + arr[j] > bound) {\n                    j--;\n                }\n                total += n - 1 - Math.max(i, j);\n            }\n            for (Map.Entry<Integer, Integer> entry : cnt.entrySet()) {\n                int val = entry.getKey(), freq = entry.getValue();\n                int x = val / n, y = val % n;\n                if (degree[x] + degree[y] > bound && degree[x] + degree[y] - freq <= bound) {\n                    total--;\n                }\n            }\n            ans[k] = total;\n        }\n        return ans;\n    }", "target_Lan": "java###countPairs_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Map;\npublic class countPairs_Test {\n// TOFILL\n    public static void main(String[] args) {\n        \n        int n1 = 0;\n        int[][] edges1 = {};\n        int[] queries1 = {1};\n        System.out.println(Arrays.toString(countPairs(n1, edges1, queries1))); \n\n        int n2 = 3;\n        int[][] edges2 = {{1, 2}, {2, 3}, {1, 3}};\n        int[] queries2 = {0, 1, 2, 3};\n        System.out.println(Arrays.toString(countPairs(n2, edges2, queries2))); \n\n        int n3 = 3;\n        int[][] edges3 = {{1, 1}, {2, 2}, {3, 3}};\n        int[] queries3 = {2, 3};\n        System.out.println(Arrays.toString(countPairs(n3, edges3, queries3))); \n\n        int n4 = 5;\n        int[][] edges4 = {{1, 2}, {1, 3}, {1, 4}, {2, 3}, {2, 4}, {3, 5}};\n        int[] queries4 = {1, 4, 8};\n        System.out.println(Arrays.toString(countPairs(n4, edges4, queries4))); \n\n        int n5 = 10;\n        int[][] edges5 = {{1, 2}, {2, 3}, {3, 4}, {4, 5}, {5, 6}, {6, 7}, {7, 8}, {8, 9}, {9, 10}};\n        int[] queries5 = {10};\n        System.out.println(Arrays.toString(countPairs(n5, edges5, queries5))); \n    }\n}"}, {"source_Lan": "cpp###captureForts.cpp", "source_code": "int captureForts(vector<int>& forts) {\n        int ans = 0, pre = -1;\n        for (int i = 0; i < forts.size(); i++) {\n            if (forts[i] == 1 || forts[i] == -1) {\n                if (pre >= 0 && forts[i] != forts[pre]) {\n                    ans = max(ans, i - pre - 1);\n                }\n                pre = i;\n            }\n        }\n        return ans;\n    }", "trans_code": "public static int captureForts ( int [ ] forts ) {\n  int ans = 0 , pre = - 1 ;\n  for ( int i = 0 ;\n  i < forts . length ;\n  i ++ ) {\n    if ( forts [ i ] == 1 || forts [ i ] == - 1 ) {\n      if ( pre >= 0 && forts [ i ] != forts [ pre ] ) ans = Math . max ( ans , i - pre - 1 ) ;\n      pre = i ;\n    }\n  }\n  return ans ;\n}\n", "reference_code": "public static int captureForts(int[] forts) {\n        int n = forts.length;\n        int ans = 0, pre = -1;\n        for (int i = 0; i < n; i++) {\n            if (forts[i] == 1 || forts[i] == -1) {\n                if (pre >= 0 && forts[i] != forts[pre]) {\n                    ans = Math.max(ans, i - pre - 1);\n                }\n                pre = i;\n            }\n        }\n        return ans;\n    }", "target_Lan": "java###captureForts_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.Arrays;\npublic class captureForts_Test {\n// TOFILL\n    public static void main(String[] args) {\n        System.out.println(captureForts(new int[]{0, 0, 0, 0, 0}));\n        System.out.println(captureForts(new int[]{1, 1, 1, 1, 1}));\n        System.out.println(captureForts(new int[]{1, 0, 0, -1}));\n        System.out.println(captureForts(new int[]{0, -1, 0, 1, 0}));\n        System.out.println(captureForts(new int[]{1}));\n    }\n}"}, {"source_Lan": "cpp###maxDistToClosest.cpp", "source_code": "int maxDistToClosest(vector<int>& seats) {\n        int res = 0;\n        int l = 0;\n        while (l < seats.size() && seats[l] == 0) {\n            ++l;\n        }\n        res = max(res, l);\n        while (l < seats.size()) {\n            int r = l + 1;\n            while (r < seats.size() && seats[r] == 0) {\n                ++r;\n            }\n            if (r == seats.size()) {\n                res = max(res, r - l - 1);\n            } else {\n                res = max(res, (r - l) / 2);\n            }\n            l = r;\n        }\n        return res;\n    }", "trans_code": "public static int maxDistToClosest ( int [ ] seats ) {\n  int res = 0 ;\n  int l = 0 ;\n  while ( l < seats . length && seats [ l ] == 0 ) l ++ ;\n  res = Math . max ( res , l ) ;\n  while ( l < seats . length ) {\n    int r = l + 1 ;\n    while ( r < seats . length && seats [ r ] == 0 ) r ++ ;\n    if ( r == seats . length ) res = Math . max ( res , r - l - 1 ) ;\n    else res = Math . max ( res , ( r - l ) / 2 ) ;\n    l = r ;\n  }\n  return res ;\n}\n", "reference_code": "public static int maxDistToClosest(int[] seats) {\n        int res = 0;\n        int l = 0;\n        while (l < seats.length && seats[l] == 0) {\n            ++l;\n        }\n        res = Math.max(res, l);\n        while (l < seats.length) {\n            int r = l + 1;\n            while (r < seats.length && seats[r] == 0) {\n                ++r;\n            }\n            if (r == seats.length) {\n                res = Math.max(res, r - l - 1);\n            } else {\n                res = Math.max(res, (r - l) / 2);\n            }\n            l = r;\n        }\n        return res;\n    }", "target_Lan": "java###maxDistToClosest_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.Arrays;\npublic class maxDistToClosest_Test {\n// TOFILL\n    public static void main(String[] args) {\n        System.out.println(maxDistToClosest(new int[]{1, 1, 1, 1}));              \n        System.out.println(maxDistToClosest(new int[]{0, 0, 0, 0}));              \n        System.out.println(maxDistToClosest(new int[]{0, 1, 0, 0, 1}));           \n        System.out.println(maxDistToClosest(new int[]{1, 0, 0, 0, 1}));           \n        System.out.println(maxDistToClosest(new int[]{1, 0, 0, 0, 0, 1, 0, 1}));  \n    }\n}"}, {"source_Lan": "cpp###ways.cpp", "source_code": "int ways(vector<string>& pizza, int k) {\n        int m = pizza.size(), n = pizza[0].size(), mod = 1e9 + 7;\n        vector<vector<int>> apples(m + 1, vector<int>(n + 1));\n        vector<vector<vector<int>>> dp(k + 1, vector<vector<int>>(m + 1, vector<int>(n + 1)));\n        \n        for (int i = m - 1; i >= 0; i--) {\n            for (int j = n - 1; j >= 0; j--) {\n                apples[i][j] = apples[i][j + 1] + apples[i + 1][j] - apples[i + 1][j + 1] + (pizza[i][j] == 'A');\n                dp[1][i][j] = apples[i][j] > 0;\n            }\n        }\n        for (int ki = 2; ki <= k; ki++) {\n            for (int i = 0; i < m; i++) {\n                for (int j = 0; j < n; j++) {\n                    \n                    for (int i2 = i + 1; i2 < m; i2++) {\n                        if (apples[i][j] > apples[i2][j]) {\n                            dp[ki][i][j] = (dp[ki][i][j] + dp[ki - 1][i2][j]) % mod;\n                        }\n                    }\n                    \n                    for (int j2 = j + 1; j2 < n; j2++) {\n                        if (apples[i][j] > apples[i][j2]) {\n                            dp[ki][i][j] = (dp[ki][i][j] + dp[ki - 1][i][j2]) % mod;\n                        }\n                    }\n                }\n            }\n        }\n        return dp[k][0][0];\n    }", "trans_code": "public static int ways ( String [ ] [ ] pizza , int k ) {\n  int m = pizza . length , n = pizza [ 0 ] . length , mod = 1e9 + 7 ;\n  int [ ] [ ] apples = new int [ m + 1 ] [ n + 1 ] ;\n  int [ ] [ ] dp = new int [ k + 1 ] [ m + 1 ] ;\n  for ( int i = m - 1 ;\n  i >= 0 ;\n  i -- ) {\n    for ( int j = n - 1 ;\n    j >= 0 ;\n    j -- ) {\n      apples [ i ] [ j ] = apples [ i ] [ j + 1 ] + apples [ i + 1 ] [ j ] - apples [ i + 1 ] [ j + 1 ] + ( pizza [ i ] [ j ] == 'A' ) ;\n      dp [ 1 ] [ i ] [ j ] = apples [ i ] [ j ] > 0 ;\n    }\n  }\n  for ( int ki = 2 ;\n  ki <= k ;\n  ki ++ ) {\n    for ( int i = 0 ;\n    i < m ;\n    i ++ ) {\n      for ( int j = 0 ;\n      j < n ;\n      j ++ ) {\n        for ( int i2 = i + 1 ;\n        i2 < m ;\n        i2 ++ ) {\n          if ( apples [ i ] [ j ] > apples [ i2 ] [ j ] ) {\n            dp [ ki ] [ i ] [ j ] = ( dp [ ki ] [ i ] [ j ] + dp [ ki - 1 ] [ i2 ] [ j ] ) % mod ;\n          }\n        }\n        for ( int j2 = j + 1 ;\n        j2 < n ;\n        j2 ++ ) {\n          if ( apples [ i ] [ j ] > apples [ i ] [ j2 ] ) {\n            dp [ ki ] [ i ] [ j ] = ( dp [ ki ] [ i ] [ j ] + dp [ ki - 1 ] [ i ] [ j2 ] ) % mod ;\n          }\n        }\n      }\n    }\n  }\n  return dp [ k ] [ 0 ] [ 0 ] ;\n}\n", "reference_code": "public static int ways(String[] pizza, int k) {\n        int m = pizza.length, n = pizza[0].length(), mod = 1_000_000_007;\n        int[][] apples = new int[m + 1][n + 1];\n        int[][][] dp = new int[k + 1][m + 1][n + 1];\n        \n        for (int i = m - 1; i >= 0; i--) {\n            for (int j = n - 1; j >= 0; j--) {\n                apples[i][j] = apples[i][j + 1] + apples[i + 1][j] - apples[i + 1][j + 1] + (pizza[i].charAt(j) == 'A' ? 1 : 0);\n                dp[1][i][j] = apples[i][j] > 0 ? 1 : 0;\n            }\n        }\n        for (int ki = 2; ki <= k; ki++) {\n            for (int i = 0; i < m; i++) {\n                for (int j = 0; j < n; j++) {\n                    \n                    for (int i2 = i + 1; i2 < m; i2++) {\n                        if (apples[i][j] > apples[i2][j]) {\n                            dp[ki][i][j] = (dp[ki][i][j] + dp[ki - 1][i2][j]) % mod;\n                        }\n                    }\n                    \n                    for (int j2 = j + 1; j2 < n; j2++) {\n                        if (apples[i][j] > apples[i][j2]) {\n                            dp[ki][i][j] = (dp[ki][i][j] + dp[ki - 1][i][j2]) % mod;\n                        }\n                    }\n                }\n            }\n        }\n        return dp[k][0][0];\n    }", "target_Lan": "java###ways_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.Arrays;\npublic class ways_Test {\n// TOFILL\n    public static void main(String[] args) {\n        System.out.println(ways(new String[]{\"A\"}, 1)); \n        System.out.println(ways(new String[]{\"A..\", \".A.\"}, 2)); \n        System.out.println(ways(new String[]{\"...\", \"...\"}, 2)); \n        System.out.println(ways(new String[]{\"A.A\", \"AAA\", \".A.\"}, 3)); \n        System.out.println(ways(new String[]{\"AAA\", \"AAA\", \"AAA\"}, 2)); \n    }\n}"}, {"source_Lan": "cpp###findReplaceString.cpp", "source_code": "string findReplaceString(string s, vector<int>& indices, vector<string>& sources, vector<string>& targets) {\n        int n = s.size(), m = indices.size();\n        vector<int> ops(m);\n        iota(ops.begin(), ops.end(), 0);\n        sort(ops.begin(), ops.end(), [&](int i, int j) { return indices[i] < indices[j]; });\n        string ans;\n        int pt = 0;\n        for (int i = 0; i < n;) {\n            while (pt < m && indices[ops[pt]] < i) {\n                ++pt;\n            }\n            bool succeed = false;\n            while (pt < m && indices[ops[pt]] == i) {\n                if (s.substr(i, sources[ops[pt]].size()) == sources[ops[pt]]) {\n                    succeed = true;\n                    break;\n                }\n                ++pt;\n            }\n            if (succeed) {\n                ans += targets[ops[pt]];\n                i += sources[ops[pt]].size();\n            }\n            else {\n                ans += s[i];\n                ++i;\n            }\n        }\n        return ans;\n    }", "trans_code": "public static String findReplaceString ( String s , int [ ] indices , String [ ] sources , String [ ] targets ) {\n  int n = s . length ( ) , m = indices . length ;\n  int [ ] ops = new int [ m ] ;\n  Arrays . fill ( ops , 0 ) ;\n  Arrays . fill ( indices , 0 ) ;\n  Arrays . fill ( sources , 0 ) ;\n  Arrays . fill ( targets , 0 ) ;\n  StringBuilder ans = new StringBuilder ( ) ;\n  int pt = 0 ;\n  for ( int i = 0 ;\n  i < n ;\n  ) {\n    while ( pt < m && indices [ ops [ pt ] ] < i ) ++ pt ;\n    boolean succeed = false ;\n    while ( pt < m && indices [ ops [ pt ] ] == i ) {\n      if ( s . substring ( i , sources [ ops [ ops [ pt ] ] ] . length ( ) ) . equals ( sources [ ops [ ops [ pt ] ] ] ) ) {\n        succeed = true ;\n        break ;\n      }\n      ++ pt ;\n    }\n    if ( succeed ) {\n      ans . append ( targets [ ops [ pt ] ] ) ;\n      i += sources [ ops [ pt ] ] . length ( ) ;\n    }\n    else {\n      ans . append ( s . charAt ( i ) ) ;\n      ++ i ;\n    }\n  }\n  return ans . toString ( ) ;\n}\n", "reference_code": "public static String findReplaceString(String s, int[] indices, String[] sources, String[] targets) {\n        int n = s.length(), m = indices.length;\n        List<Integer> ops = new ArrayList<>();\n        for (int i = 0; i < m; i++) {\n            ops.add(i);\n        }\n        ops.sort((i, j) -> indices[i] - indices[j]);\n        StringBuilder ans = new StringBuilder();\n        int pt = 0;\n        for (int i = 0; i < n;) {\n            while (pt < m && indices[ops.get(pt)] < i) {\n                pt++;\n            }\n            boolean succeed = false;\n            while (pt < m && indices[ops.get(pt)] == i) {\n                if (s.substring(i, Math.min(i + sources[ops.get(pt)].length(), n)).equals(sources[ops.get(pt)])) {\n                    succeed = true;\n                    break;\n                }\n                pt++;\n            }\n            if (succeed) {\n                ans.append(targets[ops.get(pt)]);\n                i += sources[ops.get(pt)].length();\n            } else {\n                ans.append(s.charAt(i));\n                i++;\n            }\n        }\n        return ans.toString();\n    }", "target_Lan": "java###findReplaceString_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.*;\npublic class findReplaceString_Test {\n// TOFILL\n    public static void main(String[] args) {\n        System.out.println(findReplaceString(\"ababc\", new int[]{0, 2}, new String[]{\"ab\", \"c\"}, new String[]{\"xy\", \"z\"}));\n        System.out.println(findReplaceString(\"abcdefg\", new int[]{0, 2, 4}, new String[]{\"ab\", \"cd\", \"ef\"}, new String[]{\"1\", \"2\", \"3\"}));\n        System.out.println(findReplaceString(\"hello world\", new int[]{0, 6}, new String[]{\"hello\", \"world\"}, new String[]{\"hi\", \"everyone\"}));\n        System.out.println(findReplaceString(\"x\", new int[]{0}, new String[]{\"x\"}, new String[]{\"y\"}));\n    }\n}"}, {"source_Lan": "cpp###circularGameLosers.cpp", "source_code": "vector<int> circularGameLosers(int n, int k) {\n        vector<bool> visit(n, false);\n        for (int i = k, j = 0; !visit[j]; i += k) {\n            visit[j] = true;\n            j = (j + i) % n;\n        }\n        vector<int> ans;\n        for (int i = 0; i < n; i++) {\n            if (!visit[i]) {\n                ans.emplace_back(i + 1);\n            }\n        }\n        return ans;\n    }", "trans_code": "public static int [ ] circularGameLosers ( int n , int k ) {\n  boolean [ ] visit = new boolean [ n ] ;\n  for ( int i = k , j = 0 ;\n  ! visit [ j ] ;\n  i += k ) {\n    visit [ j ] = true ;\n    j = ( j + i ) % n ;\n  }\n  int [ ] ans = new int [ n ] ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    if ( ! visit [ i ] ) ans [ i ] = i + 1 ;\n  }\n  return ans ;\n}\n", "reference_code": "public static int[] circularGameLosers(int n, int k) {\n        boolean[] visit = new boolean[n];\n        for (int i = k, j = 0; !visit[j]; i += k) {\n            visit[j] = true;\n            j = (j + i) % n;\n        }\n        List<Integer> list = new ArrayList<Integer>();\n        for (int i = 0; i < n; i++) {\n            if (!visit[i]) {\n                list.add(i + 1);\n            }\n        }\n        int[] ans = new int[list.size()];\n        for (int i = 0; i < list.size(); i++) {\n            ans[i] = list.get(i);\n        }\n        return ans;\n    }", "target_Lan": "java###circularGameLosers_Test.java", "target_code_shell": "import java.util.Arrays;\npublic class circularGameLosers_Test {\n// TOFILL\n    public static void main(String[] args) {\n        int n1 = 5, k1 = 2;\n        System.out.println(Arrays.toString(circularGameLosers(n1, k1)));  \n\n        int n2 = 7, k2 = 3;\n        System.out.println(Arrays.toString(circularGameLosers(n2, k2)));  \n\n        int n3 = 10, k3 = 1;\n        System.out.println(Arrays.toString(circularGameLosers(n3, k3)));  \n\n        int n4 = 6, k4 = 4;\n        System.out.println(Arrays.toString(circularGameLosers(n4, k4)));  \n\n        int n5 = 8, k5 = 7;\n        System.out.println(Arrays.toString(circularGameLosers(n5, k5)));  \n    }\n}"}, {"source_Lan": "cpp###countSeniors.cpp", "source_code": "int countSeniors(vector<string>& details) {\n        int count = 0;\n        for (string & info : details) {\n            if (stoi(info.substr(11, 2)) > 60) {\n                count++;\n            }\n        }\n        return count;\n    }", "trans_code": "public static int countSeniors ( String [ ] details ) {\n  int count = 0 ;\n  for ( String info : details ) {\n    if ( Integer . parseInt ( info . substring ( 11 , 12 ) ) > 60 ) count ++ ;\n  }\n  return count ;\n}\n", "reference_code": "public static int countSeniors(String[] details) {\n        int count = 0;\n        for (String info : details) {\n            if (Integer.parseInt(info.substring(11, 13)) > 60) {\n                count++;\n            }\n        }\n        return count;\n    }", "target_Lan": "java###countSeniors_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.Arrays;\npublic class countSeniors_Test {\n// TOFILL\n    public static void main(String[] args) {\n        System.out.println(countSeniors(new String[] {})); \n    }\n}"}, {"source_Lan": "cpp###maxAbsoluteSum.cpp", "source_code": "int maxAbsoluteSum(vector<int>& nums) {\n        int positiveMax = 0, negativeMin = 0;\n        int positiveSum = 0, negativeSum = 0;\n        for (int num : nums) {\n            positiveSum += num;\n            positiveMax = max(positiveMax, positiveSum);\n            positiveSum = max(0, positiveSum);\n            negativeSum += num;\n            negativeMin = min(negativeMin, negativeSum);\n            negativeSum = min(0, negativeSum);\n        }\n        return max(positiveMax, -negativeMin);\n    }", "trans_code": "public static int maxAbsoluteSum ( int [ ] nums ) {\n  int positiveMax = 0 , negativeMin = 0 ;\n  int positiveSum = 0 , negativeSum = 0 ;\n  for ( int num : nums ) {\n    positiveSum += num ;\n    positiveMax = Math . max ( positiveMax , positiveSum ) ;\n    positiveSum = Math . max ( 0 , positiveSum ) ;\n    negativeSum += num ;\n    negativeMin = Math . min ( negativeMin , negativeSum ) ;\n    negativeSum = Math . min ( 0 , negativeSum ) ;\n  }\n  return Math . max ( positiveMax , - negativeMin ) ;\n}\n", "reference_code": "public static int maxAbsoluteSum(int[] nums) {\n        int positiveMax = 0, negativeMin = 0;\n        int positiveSum = 0, negativeSum = 0;\n        for (int num : nums) {\n            positiveSum += num;\n            positiveMax = Math.max(positiveMax, positiveSum);\n            positiveSum = Math.max(0, positiveSum);\n            negativeSum += num;\n            negativeMin = Math.min(negativeMin, negativeSum);\n            negativeSum = Math.min(0, negativeSum);\n        }\n        return Math.max(positiveMax, -negativeMin);\n    }", "target_Lan": "java###maxAbsoluteSum_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.Arrays;\npublic class maxAbsoluteSum_Test {\n// TOFILL\n    public static void main(String[] args) {\n        System.out.println(maxAbsoluteSum(new int[]{1, 2, 3, 4, 5}));          \n        System.out.println(maxAbsoluteSum(new int[]{-1, -2, -3, -4, -5}));     \n        System.out.println(maxAbsoluteSum(new int[]{1, -2, 3, -4, 5}));        \n        System.out.println(maxAbsoluteSum(new int[]{0, 0, 0, 0, 0}));          \n        System.out.println(maxAbsoluteSum(new int[]{}));                        \n    }\n}"}, {"source_Lan": "cpp###minimumOperationsToMakeKPeriodic.cpp", "source_code": "int minimumOperationsToMakeKPeriodic(string word, int k) {\n        int n = word.size(), res = INT_MAX;\n        unordered_map<string, int> count;\n        for (int i = 0; i < n; i += k) {\n            string &&part = word.substr(i, k);\n            count[part]++;\n            res = min(res, n / k - count[part]);\n        }\n        return res;\n    }", "trans_code": "public static int minimumOperationsToMakeKPeriodic ( String word , int k ) {\n  int n = word . length ( ) , res = Integer . MAX_VALUE ;\n  HashMap < String , Integer > count = new HashMap < String , Integer > ( ) ;\n  for ( int i = 0 ;\n  i < n ;\n  i += k ) {\n    String part = word . substring ( i , i + k ) ;\n    count . get ( part ) ++ ;\n    res = Math . min ( res , n / k - count . get ( part ) ) ;\n  }\n  return res ;\n}\n", "reference_code": "public static int minimumOperationsToMakeKPeriodic(String word, int k) {\n        int n = word.length(), res = Integer.MAX_VALUE;\n        HashMap<String, Integer> count = new HashMap<>();\n        for (int i = 0; i < n; i += k) {\n            String part = word.substring(i, i + k);\n            res = Math.min(res, n / k - count.merge(part, 1, Integer::sum));\n        }\n        return res;\n    }", "target_Lan": "java###minimumOperationsToMakeKPeriodic_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.HashMap;\npublic class minimumOperationsToMakeKPeriodic_Test {\n// TOFILL\n    public static void main(String[] args) {\n        System.out.println(minimumOperationsToMakeKPeriodic(\"\", 1));  \n        System.out.println(minimumOperationsToMakeKPeriodic(\"ababab\", 2));  \n        System.out.println(minimumOperationsToMakeKPeriodic(\"aaaaaa\", 2));  \n        System.out.println(minimumOperationsToMakeKPeriodic(\"abcdabcd\", 4));  \n    }\n}"}, {"source_Lan": "cpp###maxScore.cpp", "source_code": "int maxScore(vector<vector<int>>& grid) {\n        int m = grid.size(), n = grid[0].size();\n        vector<vector<int>> prerow(m, vector<int>(n));\n        vector<vector<int>> precol(m, vector<int>(n));\n        vector<vector<int>> f(m, vector<int>(n, INT_MIN));\n        int ans = INT_MIN;\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (i > 0) {\n                    f[i][j] = max(f[i][j], grid[i][j] + precol[i - 1][j]);\n                }\n                if (j > 0) {\n                    f[i][j] = max(f[i][j], grid[i][j] + prerow[i][j - 1]);\n                }\n                ans = max(ans, f[i][j]);\n                prerow[i][j] = precol[i][j] = max(f[i][j], 0) - grid[i][j];\n                if (i > 0) {\n                    precol[i][j] = max(precol[i][j], precol[i - 1][j]);\n                }\n                if (j > 0) {\n                    prerow[i][j] = max(prerow[i][j], prerow[i][j - 1]);\n                }\n            }\n        }\n        return ans;\n    }", "trans_code": "public static int maxScore ( int [ ] [ ] grid ) {\n  int m = grid . length , n = grid [ 0 ] . length ;\n  int [ ] [ ] prerow = new int [ m ] [ n ] ;\n  int [ ] [ ] precol = new int [ m ] [ n ] ;\n  int [ ] [ ] f = new int [ m ] [ n ] ;\n  int ans = Integer . MIN_VALUE ;\n  for ( int i = 0 ;\n  i < m ;\n  ++ i ) {\n    for ( int j = 0 ;\n    j < n ;\n    ++ j ) {\n      if ( i > 0 ) f [ i ] [ j ] = Math . max ( f [ i ] [ j ] , grid [ i ] [ j ] + precol [ i - 1 ] [ j ] ) ;\n      if ( j > 0 ) f [ i ] [ j ] = Math . max ( f [ i ] [ j ] , grid [ i ] [ j ] + prerow [ i ] [ j - 1 ] ) ;\n      ans = Math . max ( ans , f [ i ] [ j ] ) ;\n      prerow [ i ] [ j ] = precol [ i ] [ j ] = Math . max ( f [ i ] [ j ] , 0 ) - grid [ i ] [ j ] ;\n      if ( i > 0 ) precol [ i ] [ j ] = Math . max ( precol [ i ] [ j ] , precol [ i - 1 ] [ j ] ) ;\n      if ( j > 0 ) prerow [ i ] [ j ] = Math . max ( prerow [ i ] [ j ] , prerow [ i ] [ j - 1 ] ) ;\n    }\n  }\n  return ans ;\n}\n", "reference_code": "public static int maxScore(List<List<Integer>> grid) {\n        int m = grid.size(), n = grid.get(0).size();\n        int[][] prerow = new int[m][n];\n        int[][] precol = new int[m][n];\n        int[][] f = new int[m][n];\n        for (int i = 0; i < m; ++i) {\n            Arrays.fill(f[i], Integer.MIN_VALUE);\n        }\n        int ans = Integer.MIN_VALUE;\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (i > 0) {\n                    f[i][j] = Math.max(f[i][j], grid.get(i).get(j) + precol[i - 1][j]);\n                }\n                if (j > 0) {\n                    f[i][j] = Math.max(f[i][j], grid.get(i).get(j) + prerow[i][j - 1]);\n                }\n                ans = Math.max(ans, f[i][j]);\n                prerow[i][j] = precol[i][j] = Math.max(f[i][j], 0) - grid.get(i).get(j);\n                if (i > 0) {\n                    precol[i][j] = Math.max(precol[i][j], precol[i - 1][j]);\n                }\n                if (j > 0) {\n                    prerow[i][j] = Math.max(prerow[i][j], prerow[i][j - 1]);\n                }\n            }\n        }\n        return ans;\n    }", "target_Lan": "java###maxScore_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.ArrayList;\npublic class maxScore_Test {\n// TOFILL\n    public static void main(String[] args) {\n        List<List<Integer>> input1 = new ArrayList<>();\n        input1.add(Arrays.asList(1));\n\n        List<List<Integer>> input2 = new ArrayList<>();\n        input2.add(Arrays.asList(-1, -2, -3));\n        input2.add(Arrays.asList(-4, -5, -6));\n\n        List<List<Integer>> input3 = new ArrayList<>();\n        input3.add(Arrays.asList(Integer.MAX_VALUE, Integer.MAX_VALUE));\n        input3.add(Arrays.asList(Integer.MAX_VALUE, Integer.MAX_VALUE));\n\n        List<List<Integer>> input4 = new ArrayList<>();\n        input4.add(Arrays.asList(0, 1, 2));\n        input4.add(Arrays.asList(-1, -2, -3));\n\n        List<List<Integer>> input5 = new ArrayList<>();\n        input5.add(Arrays.asList(1, 2, 3));\n        input5.add(Arrays.asList(4, 5, 6));\n        input5.add(Arrays.asList(7, 8, 9));\n\n        System.out.println(maxScore(input1));\n        System.out.println(maxScore(input2));\n        System.out.println(maxScore(input3));\n        System.out.println(maxScore(input4));\n        System.out.println(maxScore(input5));\n    }\n}"}, {"source_Lan": "cpp###isArraySpecial.cpp", "source_code": "vector<bool> isArraySpecial(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        vector<int> dp(n, 1);\n        for (int i = 1; i < n; i++) {\n            if ((nums[i] ^ nums[i - 1]) & 1) {\n                dp[i] = dp[i - 1] + 1;\n            }\n        }\n        vector<bool> res;\n        for (auto &q : queries) {\n            int x = q[0], y = q[1];\n            res.emplace_back(dp[y] >= y - x + 1);\n        }\n        return res;\n    }", "trans_code": "public static boolean [ ] isArraySpecial ( int [ ] nums , List < List < Integer >> queries ) {\n  int n = nums . length ;\n  int [ ] dp = new int [ n ] ;\n  for ( int i = 1 ;\n  i < n ;\n  i ++ ) {\n    if ( ( nums [ i ] ^ nums [ i - 1 ] ) & 1 ) dp [ i ] = dp [ i - 1 ] + 1 ;\n  }\n  boolean [ ] res = new boolean [ queries . size ( ) ] ;\n  for ( List < Integer > q : queries ) {\n    int x = q . get ( 0 ) , y = q . get ( 1 ) ;\n    res [ y ] = dp [ y ] >= y - x + 1 ;\n  }\n  return res ;\n}\n", "reference_code": "public static boolean[] isArraySpecial(int[] nums, int[][] queries) {\n        int n = nums.length;\n        int[] dp = new int[n];\n        Arrays.fill(dp, 1);\n        for (int i = 1; i < n; i++) {\n            if (((nums[i] ^ nums[i - 1]) & 1) != 0) {\n                dp[i] = dp[i - 1] + 1;\n            }\n        }\n        boolean[] res = new boolean[queries.length];\n        for (int i = 0; i < queries.length; i++) {\n            int x = queries[i][0], y = queries[i][1];\n            res[i] = dp[y] >= y - x + 1;\n        }\n        return res;\n    }", "target_Lan": "java###isArraySpecial_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.Arrays;\npublic class isArraySpecial_Test {\n// TOFILL\n    public static void main(String[] args) {\n        \n        int[] nums1 = {1, 2, 3, 4, 5};\n        int[][] queries1 = {{0, 4}, {1, 3}, {2, 2}, {0, 2}, {2, 4}};\n        System.out.println(Arrays.toString(isArraySpecial(nums1, queries1)));\n\n        int[] nums2 = {2, 4, 6, 8};\n        int[][] queries2 = {{0, 1}, {1, 3}, {0, 3}};\n        System.out.println(Arrays.toString(isArraySpecial(nums2, queries2)));\n\n        int[] nums3 = {1, 3, 5, 2, 4};\n        int[][] queries3 = {{0, 4}, {1, 2}, {0, 3}, {1, 4}};\n        System.out.println(Arrays.toString(isArraySpecial(nums3, queries3)));\n\n        int[] nums4 = {0, 0, 0, 0, 1};\n        int[][] queries4 = {{0, 4}, {1, 2}, {2, 3}};\n        System.out.println(Arrays.toString(isArraySpecial(nums4, queries4)));\n\n        int[] nums5 = {1, 0, 1, 0, 1};\n        int[][] queries5 = {{0, 4}, {0, 0}, {4, 4}};\n        System.out.println(Arrays.toString(isArraySpecial(nums5, queries5)));\n    }\n}"}, {"source_Lan": "cpp###leftmostBuildingQueries.cpp", "source_code": "vector<int> leftmostBuildingQueries(vector<int>& heights, vector<vector<int>>& queries) {\n        int n = heights.size();\n        int m = queries.size();\n        vector<vector<pair<int, int>>> query(n);\n        vector<int> ans(m);\n        vector<int> st;\n        for (int i = 0; i < m; i++) {\n            int a = queries[i][0];\n            int b = queries[i][1];\n            if (a > b) swap(a, b);\n            if (a == b || heights[a] < heights[b]) {\n                ans[i] = b;\n                continue;\n            }\n            query[b].push_back(make_pair(i, heights[a]));\n        }\n        int top = -1;\n        for (int i = n - 1; i >= 0; i--) {\n            for (int j = 0; j < query[i].size(); j++) {\n                int q = query[i][j].first;\n                int val = query[i][j].second;\n                if (top == -1 || heights[st[0]] <= val) {\n                    ans[q] = -1;\n                    continue;\n                }\n                int l = 0, r = top;\n                while (l <= r) {\n                    int mid = (l + r) >> 1;\n                    if (heights[st[mid]] > val) {\n                        l = mid + 1;\n                    } else {\n                        r = mid - 1;\n                    }\n                }\n                ans[q] = st[r];\n            }\n            while (top >= 0 && heights[st[top]] <= heights[i]) {\n                st.pop_back();\n                top--;\n            }\n            st.push_back(i);\n            top++;\n        }\n        return ans;\n    }", "trans_code": "public static int [ ] leftmostBuildingQueries ( int [ ] heights , int [ ] [ ] queries ) {\n  int n = heights . length ;\n  int m = queries . length ;\n  int [ ] [ ] query = new int [ n ] [ m ] ;\n  int [ ] ans = new int [ m ] ;\n  int [ ] st = new int [ m ] ;\n  for ( int i = 0 ;\n  i < m ;\n  i ++ ) {\n    int a = queries [ i ] [ 0 ] ;\n    int b = queries [ i ] [ 1 ] ;\n    if ( a > b ) {\n      swap ( a , b ) ;\n    }\n    if ( a == b || heights [ a ] < heights [ b ] ) {\n      ans [ i ] = b ;\n      continue ;\n    }\n    query [ b ] = new int [ a ] ;\n  }\n  int top = - 1 ;\n  for ( int i = n - 1 ;\n  i >= 0 ;\n  i -- ) {\n    for ( int j = 0 ;\n    j < query [ i ] . length ;\n    j ++ ) {\n      int q = query [ i ] [ j ] ;\n      int val = query [ i ] [ j ] ;\n      if ( top == - 1 || heights [ st [ 0 ] ] <= val ) {\n        ans [ q ] = - 1 ;\n        continue ;\n      }\n      int l = 0 , r = top ;\n      while ( l <= r ) {\n        int mid = ( l + r ) >>> 1 ;\n        if ( heights [ st [ mid ] ] > val ) l = mid + 1 ;\n        else r = mid - 1 ;\n      }\n      ans [ q ] = st [ r ] ;\n    }\n    while ( top >= 0 && heights [ st [ top ] ] <= heights [ i ] ) {\n      st . pop ( ) ;\n      top -- ;\n    }\n    st [ 0 ] = i ;\n    top ++ ;\n  }\n  return ans ;\n}\n", "reference_code": "public static int[] leftmostBuildingQueries(int[] heights, int[][] queries) {\n        int n = heights.length;\n        int m = queries.length;\n        List<int[]>[] query = new List[n];\n        for (int i = 0; i < n; i++) {\n            query[i] = new ArrayList<int[]>();\n        }\n        int[] ans = new int[m];\n        List<Integer> st = new ArrayList<Integer>();\n        for (int i = 0; i < m; i++) {\n            int a = queries[i][0];\n            int b = queries[i][1];\n            if (a > b) {\n                int temp = a;\n                a = b;\n                b = temp;\n            }\n            if (a == b || heights[a] < heights[b]) {\n                ans[i] = b;\n                continue;\n            }\n            query[b].add(new int[]{i, heights[a]});\n        }\n        int top = -1;\n        for (int i = n - 1; i >= 0; i--) {\n            for (int j = 0; j < query[i].size(); j++) {\n                int q = query[i].get(j)[0];\n                int val = query[i].get(j)[1];\n                if (top == -1 || heights[st.get(0)] <= val) {\n                    ans[q] = -1;\n                    continue;\n                }\n                int l = 0, r = top;\n                while (l <= r) {\n                    int mid = (l + r) >> 1;\n                    if (heights[st.get(mid)] > val) {\n                        l = mid + 1;\n                    } else {\n                        r = mid - 1;\n                    }\n                }\n                ans[q] = st.get(r);\n            }\n            while (top >= 0 && heights[st.get(top)] <= heights[i]) {\n                st.remove(st.size() - 1);\n                top--;\n            }\n            st.add(i);\n            top++;\n        }\n        return ans;\n    }", "target_Lan": "java###leftmostBuildingQueries_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.ArrayList;\nimport java.util.List;\npublic class leftmostBuildingQueries_Test {\n// TOFILL\n    public static void main(String[] args) {\n        int[] heights1 = {1, 3, 2, 4, 5};\n        int[][] queries1 = {{0, 1}, {2, 3}, {1, 4}, {0, 0}, {3, 2}};\n        int[] result1 = leftmostBuildingQueries(heights1, queries1);\n        for(int v : result1) {\n            System.out.print(v + \" \");\n        }\n        System.out.println();\n        \n        int[] heights2 = {5, 5, 5, 5};\n        int[][] queries2 = {{0, 3}, {1, 2}, {2, 0}, {3, 3}, {1, 3}};\n        int[] result2 = leftmostBuildingQueries(heights2, queries2);\n        for(int v : result2) {\n            System.out.print(v + \" \");\n        }\n        System.out.println();\n        \n        int[] heights3 = {10, 2, 8, 3, 6, 9};\n        int[][] queries3 = {{0, 5}, {5, 3}, {2, 4}, {1, 0}, {5, 1}};\n        int[] result3 = leftmostBuildingQueries(heights3, queries3);\n        for(int v : result3) {\n            System.out.print(v + \" \");\n        }\n        System.out.println();\n\n        int[] heights4 = {1, 2, 3, 4, 5};\n        int[][] queries4 = {{4, 0}, {0, 4}, {3, 3}, {4, 4}, {2, 1}};\n        int[] result4 = leftmostBuildingQueries(heights4, queries4);\n        for(int v : result4) {\n            System.out.print(v + \" \");\n        }\n        System.out.println();\n\n        int[] heights5 = {1000000, 999999, 1000001, 999998};\n        int[][] queries5 = {{0, 2}, {1, 3}, {3, 0}, {0, 0}, {2, 3}};\n        int[] result5 = leftmostBuildingQueries(heights5, queries5);\n        for(int v : result5) {\n            System.out.print(v + \" \");\n        }\n        System.out.println();\n    }\n}"}, {"source_Lan": "cpp###isArraySpecial.cpp", "source_code": "bool isArraySpecial(vector<int>& nums) {\n        int n = nums.size();\n        for (int i = 1; i < n; ++i) {\n            if (nums[i - 1] % 2 == nums[i] % 2) {\n                return false;\n            }\n        }\n        return true;\n    }", "trans_code": "public static boolean isArraySpecial ( int [ ] nums ) {\n  int n = nums . length ;\n  for ( int i = 1 ;\n  i < n ;\n  ++ i ) {\n    if ( nums [ i - 1 ] % 2 == nums [ i ] % 2 ) {\n      return false ;\n    }\n  }\n  return true ;\n}\n", "reference_code": "public static boolean isArraySpecial(int[] nums) {\n        int n = nums.length;\n        for (int i = 1; i < n; ++i) {\n            if (nums[i - 1] % 2 == nums[i] % 2) {\n                return false;\n            }\n        }\n        return true;\n    }", "target_Lan": "java###isArraySpecial_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.Arrays;\npublic class isArraySpecial_Test {\n// TOFILL\n    public static void main(String[] args) {\n        System.out.println(isArraySpecial(new int[]{})); \n        System.out.println(isArraySpecial(new int[]{1})); \n        System.out.println(isArraySpecial(new int[]{2})); \n        System.out.println(isArraySpecial(new int[]{1, 2, 3, 4})); \n        System.out.println(isArraySpecial(new int[]{1, 2, 5, 4})); \n    }\n}"}, {"source_Lan": "cpp###countOfPairs.cpp", "source_code": "int countOfPairs(vector<int>& nums) {\n        const int MOD = 1e9 + 7;\n        int m = nums.size();\n        int n = *max_element(nums.begin(), nums.end());\n        vector<int> f(n + 1);\n        \n        for (int v = 0; v <= nums[0]; ++v)\n            f[v] = 1;\n        vector<int> preSums;\n        \n        for (int i = 1; i <= m; ++i) {\n            \n            preSums.clear();\n            int preSum = 0;\n            for(int v : f){\n                preSum += v;\n                preSum %= MOD; \n                preSums.push_back(preSum);\n            }\n            \n            if (i == m) return preSums.back();\n            \n            for (int j = 0; j <= nums[i]; ++j) {\n                int ceil = min(j, nums[i-1] - nums[i] + j);\n                if (ceil >= 0)\n                    f[j] = preSums[ceil];\n                else \n                    f[j] = 0;\n            }\n            for (int j = nums[i] + 1; j < f.size(); ++j) {\n                f[j] = 0;\n            }\n        }\n        \n        return 0;\n    }", "trans_code": "public static int countOfPairs ( int [ ] nums ) {\n  final int MOD = 1e9 + 7 ;\n  int m = nums . length ;\n  int n = Arrays . binarySearch ( nums , 0 , m ) ;\n  int [ ] f = new int [ n + 1 ] ;\n  for ( int v = 0 ;\n  v <= nums [ 0 ] ;\n  v ++ ) {\n    f [ v ] = 1 ;\n  }\n  int [ ] preSums = new int [ m ] ;\n  for ( int i = 1 ;\n  i <= m ;\n  i ++ ) {\n    preSums = new int [ m ] ;\n    int preSum = 0 ;\n    for ( int v : f ) {\n      preSum += v ;\n      preSum %= MOD ;\n      preSums [ v ] = preSum ;\n    }\n    if ( i == m ) {\n      return preSums [ 0 ] ;\n    }\n    for ( int j = 0 ;\n    j <= nums [ i ] ;\n    j ++ ) {\n      int ceil = Math . min ( j , nums [ i - 1 ] - nums [ i ] + j ) ;\n      if ( ceil >= 0 ) {\n        f [ j ] = preSums [ ceil ] ;\n      }\n      else {\n        f [ j ] = 0 ;\n      }\n    }\n    for ( int j = nums [ i ] + 1 ;\n    j < f . length ;\n    j ++ ) {\n      f [ j ] = 0 ;\n    }\n  }\n  return 0 ;\n}\n", "reference_code": "public static int countOfPairs(int[] nums) {\n        final int MOD = (int)(1e9 + 7);\n        int m = nums.length;\n        int n = Arrays.stream(nums).max().getAsInt();\n        int[] f = new int[n + 1];\n        \n        for (int v = 0; v <= nums[0]; ++v) f[v] = 1;\n        List<Integer> preSums = new ArrayList<>();\n        \n        for (int i = 1; i <= m; ++i) {\n            \n            preSums.clear();\n            int preSum = 0;\n            for(int v : f){\n                preSum += v;\n                preSum %= MOD; \n                preSums.add(preSum);\n            }\n            \n            if (i == m) return preSums.get(preSums.size() - 1);\n            \n            for (int j = 0; j <= nums[i]; ++j) {\n                int ceil = Math.min(j, nums[i-1] - nums[i] + j);\n                if (ceil >= 0)\n                    f[j] = preSums.get(ceil);\n                else \n                    f[j] = 0;\n            }\n            for (int j = nums[i] + 1; j < f.length; ++j) {\n                f[j] = 0;\n            }\n        }\n        \n        return 0;\n    }", "target_Lan": "java###countOfPairs_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.Arrays;\npublic class countOfPairs_Test {\n// TOFILL\n    public static void main(String[] args) {\n        System.out.println(countOfPairs(new int[]{0, 0, 0, 0}));\n        System.out.println(countOfPairs(new int[]{1, 2, 3}));\n        System.out.println(countOfPairs(new int[]{-1, 0, 1}));\n        System.out.println(countOfPairs(new int[]{7}));\n        System.out.println(countOfPairs(new int[]{1000000, 999999}));\n    }\n}"}, {"source_Lan": "cpp###shortestDistanceAfterQueries.cpp", "source_code": "vector<int> shortestDistanceAfterQueries(int n, vector<vector<int>>& queries) {\n        vector<vector<int>> from(n);\n        vector<int> f(n);\n        iota(f.begin(), f.end(), 0);\n        vector<int> ans(queries.size());\n        for (int qi = 0; qi < queries.size(); qi++) {\n            int l = queries[qi][0], r = queries[qi][1];\n            from[r].push_back(l);\n            if (f[l] + 1 < f[r]) {\n                f[r] = f[l] + 1;\n                for (int i = r + 1; i < n; i++) {\n                    f[i] = min(f[i], f[i - 1] + 1);\n                    for (int j : from[i]) {\n                        f[i] = min(f[i], f[j] + 1);\n                    }\n                }\n            }\n            ans[qi] = f[n - 1];\n        }\n        return ans;\n    }", "trans_code": "public static int [ ] shortestDistanceAfterQueries ( int n , int [ ] [ ] queries ) {\n  int [ ] from = new int [ n ] ;\n  int [ ] f = new int [ n ] ;\n  iota ( from , f ) ;\n  int [ ] ans = new int [ queries . length ] ;\n  for ( int qi = 0 ;\n  qi < queries . length ;\n  qi ++ ) {\n    int l = queries [ qi ] [ 0 ] , r = queries [ qi ] [ 1 ] ;\n    from [ r ] = l ;\n    if ( f [ l ] + 1 < f [ r ] ) {\n      f [ r ] = f [ l ] + 1 ;\n      for ( int i = r + 1 ;\n      i < n ;\n      i ++ ) {\n        f [ i ] = Math . min ( f [ i ] , f [ i - 1 ] + 1 ) ;\n        for ( int j : from [ i ] ) f [ i ] = Math . min ( f [ i ] , f [ j ] + 1 ) ;\n      }\n    }\n    ans [ qi ] = f [ n - 1 ] ;\n  }\n  return ans ;\n}\n", "reference_code": "public static int[] shortestDistanceAfterQueries(int n, int[][] queries) {\n        List<Integer>[] from = new ArrayList[n];\n        Arrays.setAll(from, i -> new ArrayList<>());\n        int[] f = new int[n];\n        for (int i = 1; i < n; i++) {\n            f[i] = i;\n        }\n        int[] ans = new int[queries.length];\n        for (int qi = 0; qi < queries.length; qi++) {\n            int l = queries[qi][0];\n            int r = queries[qi][1];\n            from[r].add(l);\n            if (f[l] + 1 < f[r]) {\n                f[r] = f[l] + 1;\n                for (int i = r + 1; i < n; i++) {\n                    f[i] = Math.min(f[i], f[i - 1] + 1);\n                    for (int j : from[i]) {\n                        f[i] = Math.min(f[i], f[j] + 1);\n                    }\n                }\n            }\n            ans[qi] = f[n - 1];\n        }\n        return ans;\n    }", "target_Lan": "java###shortestDistanceAfterQueries_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.ArrayList;\nimport java.util.Arrays;\npublic class shortestDistanceAfterQueries_Test {\n// TOFILL\n    public static void main(String[] args) {\n        int[][] queries1 = {{0, 1}, {1, 2}, {2, 3}, {3, 4}, {0, 4}};\n        int[] result1 = shortestDistanceAfterQueries(5, queries1);\n        System.out.println(Arrays.toString(result1));\n\n        int[][] queries2 = {{0, 9}, {0, 1}, {1, 2}, {0, 5}};\n        int[] result2 = shortestDistanceAfterQueries(10, queries2);\n        System.out.println(Arrays.toString(result2));\n\n        int[][] queries3 = {{0, 0}};\n        int[] result3 = shortestDistanceAfterQueries(1, queries3);\n        System.out.println(Arrays.toString(result3));\n\n        int[][] queries4 = {{0, 2}, {3, 4}, {4, 5}, {1, 3}, {2, 5}};\n        int[] result4 = shortestDistanceAfterQueries(6, queries4);\n        System.out.println(Arrays.toString(result4));\n\n        int[][] queries5 = {{1, 3}, {0, 1}, {2, 6}, {5, 6}, {3, 2}};\n        int[] result5 = shortestDistanceAfterQueries(7, queries5);\n        System.out.println(Arrays.toString(result5));\n    }\n}"}, {"source_Lan": "cpp###winningPlayerCount.cpp", "source_code": "int winningPlayerCount(int n, vector<vector<int>>& pick) {\n        vector<array<int, 11>> cnts(n);\n        for (auto& p : pick) {\n            cnts[p[0]][p[1]]++;\n        }\n        int ans = 0;\n        for (int i = 0; i < n; i++) {\n            for (int c : cnts[i]) {\n                if (c > i) {\n                    ans++;\n                    break;\n                }\n            }\n        }\n        return ans;\n    }", "trans_code": "public static int winningPlayerCount ( int n , int [ ] [ ] pick ) {\n  int [ ] [ ] cnts = new int [ n ] [ n ] ;\n  for ( int [ ] p : pick ) cnts [ p [ 0 ] ] [ p [ 1 ] ] ++ ;\n  int ans = 0 ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    for ( int c : cnts [ i ] ) {\n      if ( c > i ) {\n        ans ++ ;\n        break ;\n      }\n    }\n  }\n  return ans ;\n}\n", "reference_code": "public static int winningPlayerCount(int n, int[][] pick) {\n        int[][] cnts = new int[n][11];\n        for (int[] p : pick) {\n            cnts[p[0]][p[1]]++;\n        }\n        int ans = 0;\n        for (int i = 0; i < n; i++) {\n            for (int c : cnts[i]) {\n                if (c > i) {\n                    ans++;\n                    break;\n                }\n            }\n        }\n        return ans;\n    }", "target_Lan": "java###winningPlayerCount_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.Arrays;\npublic class winningPlayerCount_Test {\n// TOFILL\n    public static void main(String[] args) {\n        System.out.println(winningPlayerCount(0, new int[][]{})); \n        System.out.println(winningPlayerCount(1, new int[][]{{0, 0}})); \n        System.out.println(winningPlayerCount(3, new int[][]{{0, 3}, {1, 4}, {2, 5}, {0, 2}, {1, 3}})); \n        System.out.println(winningPlayerCount(5, new int[][]{{0, 1}, {0, 10}, {1, 1}, {1, 9}, {2, 2}, {3, 3}, {3, 4}})); \n    }\n}"}, {"source_Lan": "cpp###minFlips.cpp", "source_code": "int minFlips(vector<vector<int>>& grid) {\n        int m = grid.size(), n = grid[0].size();\n        int diff_row = 0;\n        for (auto& row : grid) {\n            for (int j = 0; j < n / 2; j++) {\n                diff_row += row[j] != row[n - 1 - j];\n            }\n        }\n        int diff_col = 0;\n        for (int j = 0; j < n; j++) {\n            for (int i = 0; i < m / 2; i++) {\n                diff_col += grid[i][j] != grid[m - 1 - i][j];\n            }\n        }\n        return min(diff_row, diff_col);\n    }", "trans_code": "public static int minFlips ( int [ ] [ ] grid ) {\n  int m = grid . length , n = grid [ 0 ] . length ;\n  int diffRow = 0 ;\n  for ( int [ ] row : grid ) {\n    for ( int j = 0 ;\n    j < n / 2 ;\n    j ++ ) diffRow += row [ j ] != row [ n - 1 - j ] ;\n  }\n  int diffCol = 0 ;\n  for ( int j = 0 ;\n  j < n ;\n  j ++ ) {\n    for ( int i = 0 ;\n    i < m / 2 ;\n    i ++ ) diffCol += grid [ i ] [ j ] != grid [ m - 1 - i ] [ j ] ;\n  }\n  return Math . min ( diffRow , diffCol ) ;\n}\n", "reference_code": "    public static int minFlips(int[][] grid) {\n        int m = grid.length;\n        int n = grid[0].length;\n        int diffRow = 0;\n        for (int[] row : grid) {\n            for (int j = 0; j < n / 2; j++) {\n                if (row[j] != row[n - 1 - j]) {\n                    diffRow++;\n                }\n            }\n        }\n        int diffCol = 0;\n        for (int j = 0; j < n; j++) {\n            for (int i = 0; i < m / 2; i++) {\n                if (grid[i][j] != grid[m - 1 - i][j]) {\n                    diffCol++;\n                }\n            }\n        }\n        return Math.min(diffRow, diffCol);\n    }", "target_Lan": "java###minFlips_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.Arrays;\npublic class minFlips_Test {\n// TOFILL\n    public static void main(String[] args) {\n        System.out.println(minFlips(new int[][]{{0, 0}, {0, 0}})); \n        System.out.println(minFlips(new int[][]{{0, 1}, {0, 0}})); \n        System.out.println(minFlips(new int[][]{{0, 1}, {0, 1}})); \n        System.out.println(minFlips(new int[][]{{1, 0, 0}, {0, 1, 0}, {0, 0, 1}})); \n    }\n}"}, {"source_Lan": "cpp###minFlips.cpp", "source_code": "int minFlips(vector<vector<int>>& a) {\n        int m = a.size(), n = a[0].size(), ans = 0;\n        for (int i = 0; i < m / 2; i++) {\n            for (int j = 0; j < n / 2; j++) {\n                int cnt1 = a[i][j] + a[i][n - 1 - j] + a[m - 1 - i][j] + a[m - 1 - i][n - 1 - j];\n                ans += min(cnt1, 4 - cnt1);  \n            }\n        }\n        if (m % 2 && n % 2) {\n            \n            ans += a[m / 2][n / 2];\n        }\n        int diff = 0, cnt1 = 0;\n        if (m % 2) {\n            \n            for (int j = 0; j < n / 2; j++) {\n                if (a[m / 2][j] != a[m / 2][n - 1 - j]) {\n                    diff++;\n                } else {\n                    cnt1 += a[m / 2][j] * 2;\n                }\n            }\n        }\n        if (n % 2) {\n            \n            for (int i = 0; i < m / 2; i++) {\n                if (a[i][n / 2] != a[m - 1 - i][n / 2]) {\n                    diff++;\n                } else {\n                    cnt1 += a[i][n / 2] * 2;\n                }\n            }\n        }\n        return ans + (diff ? diff : cnt1 % 4);\n    }", "trans_code": "public static int minFlips ( int [ ] [ ] a ) {\n  int m = a . length , n = a [ 0 ] . length , ans = 0 ;\n  for ( int i = 0 ;\n  i < m / 2 ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < n / 2 ;\n    j ++ ) {\n      int cnt1 = a [ i ] [ j ] + a [ i ] [ n - 1 - j ] + a [ m - 1 - i ] [ j ] + a [ m - 1 - i ] [ n - 1 - j ] ;\n      ans += Math . min ( cnt1 , 4 - cnt1 ) ;\n    }\n  }\n  if ( m % 2 && n % 2 ) ans += a [ m / 2 ] [ n / 2 ] ;\n  int diff = 0 , cnt1 = 0 ;\n  if ( m % 2 ) {\n    for ( int j = 0 ;\n    j < n / 2 ;\n    j ++ ) {\n      if ( a [ m / 2 ] [ j ] != a [ m / 2 ] [ n - 1 - j ] ) diff ++ ;\n      else cnt1 += a [ m / 2 ] [ j ] * 2 ;\n    }\n  }\n  if ( n % 2 ) {\n    for ( int i = 0 ;\n    i < m / 2 ;\n    i ++ ) {\n      if ( a [ i ] [ n / 2 ] != a [ m - 1 - i ] [ n / 2 ] ) diff ++ ;\n      else cnt1 += a [ i ] [ n / 2 ] * 2 ;\n    }\n  }\n  return ans + ( diff > 0 ? diff : cnt1 % 4 ) ;\n}\n", "reference_code": "    public static int minFlips(int[][] a) {\n        int ans = 0;\n        int m = a.length;\n        int n = a[0].length;\n        for (int i = 0; i < m / 2; i++) {\n            for (int j = 0; j < n / 2; j++) {\n                int cnt1 = a[i][j] + a[i][n - 1 - j] + a[m - 1 - i][j] + a[m - 1 - i][n - 1 - j];\n                ans += Math.min(cnt1, 4 - cnt1); \n            }\n        }\n        if (m % 2 > 0 && n % 2 > 0) {\n            \n            ans += a[m / 2][n / 2];\n        }\n        int diff = 0, cnt1 = 0;\n        if (m % 2 > 0) {\n            \n            for (int j = 0; j < n / 2; j++) {\n                if (a[m / 2][j] != a[m / 2][n - 1 - j]) {\n                    diff++;\n                } else {\n                    cnt1 += a[m / 2][j] * 2;\n                }\n            }\n        }\n        if (n % 2 > 0) {\n            \n            for (int i = 0; i < m / 2; i++) {\n                if (a[i][n / 2] != a[m - 1 - i][n / 2]) {\n                    diff++;\n                } else {\n                    cnt1 += a[i][n / 2] * 2;\n                }\n            }\n        }\n        return ans + (diff > 0 ? diff : cnt1 % 4);\n    }", "target_Lan": "java###minFlips_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.Arrays;\npublic class minFlips_Test {\n// TOFILL\n    public static void main(String[] args) {\n        System.out.println(minFlips(new int[][]{{0}}));\n        System.out.println(minFlips(new int[][]{{1, 1}, {1, 0}}));\n        System.out.println(minFlips(new int[][]{{0, 1, 0}, {1, 1, 1}, {0, 0, 0}}));\n        System.out.println(minFlips(new int[][]{{1, 0}, {0, 1}, {1, 0}}));\n        System.out.println(minFlips(new int[][]{{1, 1, 1}, {0, 0, 0}, {1, 1, 1}}));\n    }\n}"}, {"source_Lan": "cpp###canAliceWin.cpp", "source_code": "bool canAliceWin(vector<int>& nums) {\n        int s = 0;\n        for (int x : nums) {\n            s += x < 10 ? x : -x;\n        }\n        return s; \n    }", "trans_code": "public static boolean canAliceWin ( int [ ] nums ) {\n  int s = 0 ;\n  for ( int x : nums ) s += x < 10 ? x : - x ;\n  return s ;\n}\n", "reference_code": "public static boolean canAliceWin(int[] nums) {\n        int s = 0;\n        for (int x : nums) {\n            s += x < 10 ? x : -x;\n        }\n        return s != 0;\n    }", "target_Lan": "java###canAliceWin_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.Arrays;\npublic class canAliceWin_Test {\n// TOFILL\n    public static void main(String[] args) {\n        System.out.println(canAliceWin(new int[]{1, 2, 3, 4, 5}));         \n        System.out.println(canAliceWin(new int[]{10, 12, 15}));            \n        System.out.println(canAliceWin(new int[]{-5, -2, 15}));            \n        System.out.println(canAliceWin(new int[]{6, 7, 8, 10, 11}));      \n        System.out.println(canAliceWin(new int[]{0}));                      \n    }\n}"}, {"source_Lan": "cpp###numberOfSubstrings.cpp", "source_code": "int numberOfSubstrings(string s) {\n        int n = s.length();\n        vector<int> a;\n        for (int i = 0; i < n; i++) {\n            if (s[i] == '0') {\n                a.push_back(i);\n            }\n        }\n        int tot1 = n - a.size();\n        a.push_back(n); \n        int ans = 0, i = 0; \n        for (int left = 0; left < n; left++) {\n            if (s[left] == '1') {\n                ans += a[i] - left; \n            }\n            for (int k = i; k < a.size() - 1; k++) {\n                int cnt0 = k - i + 1;\n                if (cnt0 * cnt0 > tot1) {\n                    break;\n                }\n                int cnt1 = a[k] - left - (k - i);\n                ans += max(a[k + 1] - a[k] - max(cnt0 * cnt0 - cnt1, 0), 0);\n            }\n            if (s[left] == '0') {\n                i++; \n            }\n        }\n        return ans;\n    }", "trans_code": "public static int numberOfSubstrings ( String s ) {\n  int n = s . length ( ) ;\n  int [ ] a = new int [ n ] ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    if ( s . charAt ( i ) == '0' ) a [ i ] = i ;\n  }\n  int tot1 = n - a . length ;\n  a [ 0 ] = n ;\n  int ans = 0 , i = 0 ;\n  for ( int left = 0 ;\n  left < n ;\n  left ++ ) {\n    if ( s . charAt ( left ) == '1' ) ans += a [ i ] - left ;\n    for ( int k = i ;\n    k < a . length - 1 ;\n    k ++ ) {\n      int cnt0 = k - i + 1 ;\n      if ( cnt0 * cnt0 > tot1 ) break ;\n      int cnt1 = a [ k ] - left - ( k - i ) ;\n      ans += Math . max ( a [ k + 1 ] - a [ k ] - Math . max ( cnt0 * cnt0 - cnt1 , 0 ) , 0 ) ;\n    }\n    if ( s . charAt ( left ) == '0' ) i ++ ;\n  }\n  return ans ;\n}\n", "reference_code": "public static int numberOfSubstrings(String S) {\n        char[] s = S.toCharArray();\n        int n = s.length;\n        int m = 0;\n        int[] a = new int[n + 1];\n        for (int i = 0; i < n; i++) {\n            if (s[i] == '0') {\n                a[m++] = i;\n            }\n        }\n        int tot1 = n - m;\n        a[m] = n; \n        int ans = 0;\n        int i = 0; \n        for (int left = 0; left < n; left++) {\n            if (s[left] == '1') {\n                ans += a[i] - left; \n            }\n            for (int k = i; k < m; k++) {\n                int cnt0 = k - i + 1;\n                if (cnt0 * cnt0 > tot1) {\n                    break;\n                }\n                int cnt1 = a[k] - left - (k - i);\n                ans += Math.max(a[k + 1] - a[k] - Math.max(cnt0 * cnt0 - cnt1, 0), 0);\n            }\n            if (s[left] == '0') {\n                i++; \n            }\n        }\n        return ans;\n    }", "target_Lan": "java###numberOfSubstrings_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.*;\npublic class numberOfSubstrings_Test {\n// TOFILL\n    public static void main(String[] args) {\n        System.out.println(numberOfSubstrings(\"00000\")); \n        System.out.println(numberOfSubstrings(\"11111\")); \n        System.out.println(numberOfSubstrings(\"1010101010\")); \n        System.out.println(numberOfSubstrings(\"0111100000\")); \n        System.out.println(numberOfSubstrings(\"110000111110000011\")); \n    }\n}"}, {"source_Lan": "cpp###mostFrequent.cpp", "source_code": "int mostFrequent(int n, vector<int> &a){\n    map<int,int> m;\n    for(int i:a)m[i]++;\n    int mx=0;\n    for(auto i:m)mx=max(mx,i.second);\n    int ans=-1;\n    for(auto i:m)if(mx==i.second)ans=i.first;\n    return ans;\n}", "trans_code": "public static int mostFrequent ( int n , int [ ] a ) {\n  Map < Integer , Integer > m = new HashMap < Integer , Integer > ( ) ;\n  for ( int i : a ) {\n    m . put ( i , i ) ;\n  }\n  int mx = 0 ;\n  for ( Map . Entry < Integer , Integer > entry : m . entrySet ( ) ) {\n    mx = Math . max ( mx , entry . getValue ( ) ) ;\n  }\n  int ans = - 1 ;\n  for ( Map . Entry < Integer , Integer > entry : m . entrySet ( ) ) if ( mx == entry . getValue ( ) ) ans = entry . getKey ( ) ;\n  return ans ;\n}\n", "reference_code": "public static int mostFrequent(int a[], int n)\n    {\n        HashMap<Integer, Integer> mp = new HashMap<>();\n        for(int i=0;i<n;i++)\n        {\n            if(mp.containsKey(a[i]))\n                mp.put(a[i], mp.get(a[i])+1);\n            else\n                mp.put(a[i],1);\n        }\n        int ans=-1,res=0;\n        for(Entry<Integer,Integer> val : mp.entrySet())\n            res=Math.max(res,val.getValue());\n        for(Entry<Integer,Integer> val : mp.entrySet())\n        {\n            if (val.getValue()==res&&val.getKey()>ans)\n                ans=val.getKey();\n        }\n        return ans;\n    }", "target_Lan": "java###mostFrequent_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.HashMap;\nimport java.util.Map.Entry;\npublic class mostFrequent_Test {\n// TOFILL\n    public static void main(String[] args) {\n        System.out.println(mostFrequent(new int[]{1, 2, 3, 4, 5}, 5)); \n        System.out.println(mostFrequent(new int[]{2, 2, 2, 2, 2}, 5)); \n        System.out.println(mostFrequent(new int[]{1, 1, 2, 2, 3}, 5)); \n        System.out.println(mostFrequent(new int[]{}, 0)); \n        System.out.println(mostFrequent(new int[]{-1, -2, -1, 2, 2, -1}, 6)); \n    }\n}"}, {"source_Lan": "cpp###getMax.cpp", "source_code": "    int getMax(int x) {\n        \n        bool flag = false;\n        int prev = -1;\n        int cnt = 0;\n        for (int i = 30; i >= 0; i--) {\n            if (cnt >= 2)\n                break;\n            if (flag == false and (x & (1 << i)) > 0) {\n                flag = true;\n                continue;\n            }\n            if (flag) {\n                if ((x & (1 << i)) == 0 and prev == -1) {\n                    prev = i;\n                    x |= (1 << i);\n                    cnt++;\n                }\n                if ((x & (1 << i)) == 0 and prev - i > 1) {\n                    x |= (1 << i);\n                    cnt++;\n                }\n            }\n        }\n        return x;\n    }", "trans_code": "public static int getMax ( int x ) {\n  boolean flag = false ;\n  int prev = - 1 ;\n  int cnt = 0 ;\n  for ( int i = 30 ;\n  i >= 0 ;\n  i -- ) {\n    if ( cnt >= 2 ) break ;\n    if ( flag == false and ( x & ( 1 << i ) ) > 0 ) {\n      flag = true ;\n      continue ;\n    }\n    if ( flag ) {\n      if ( ( x & ( 1 << i ) ) == 0 and prev == - 1 ) {\n        prev = i ;\n        x |= ( 1 << i ) ;\n        cnt ++ ;\n      }\n      if ( ( x & ( 1 << i ) ) == 0 and prev - i > 1 ) {\n        x |= ( 1 << i ) ;\n        cnt ++ ;\n      }\n    }\n  }\n  return x ;\n}\n", "reference_code": "public static int getMax(int x) {\n        \n        boolean flag = false;\n        int prev = -1;\n        int cnt = 0;\n        for (int i = 30; i >= 0; i--) {\n            if (cnt >= 2) break;\n            if (!flag && (x & (1 << i)) > 0) {\n                flag = true;\n                continue;\n            }\n            if (flag) {\n                if ((x & (1 << i)) == 0 && prev == -1) {\n                    prev = i;\n                    x |= (1 << i);\n                    cnt++;\n                }\n                if ((x & (1 << i)) == 0 && prev - i > 1) {\n                    x |= (1 << i);\n                    cnt++;\n                }\n            }\n        }\n        return x;\n    }", "target_Lan": "java###getMax_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.*;\npublic class getMax_Test {\n// TOFILL\n    public static void main(String[] args) {\n        System.out.println(getMax(2147483647)); \n        System.out.println(getMax(1));          \n        System.out.println(getMax(0));          \n        System.out.println(getMax(-5));         \n        System.out.println(getMax(21));         \n    }\n}"}, {"source_Lan": "cpp###getCount.cpp", "source_code": "long long getCount(int n, vector<int> &arr, int a, int b) {\n        \n        int ans=0;\n        for(int i=0;i<n;i++){\n            for(int j=i;j<n;j++){\n                bool flag=false;\n                for(int k=i;k<=j;k++){\n                    for(int l=k+1;l<=j;l++){\n                        if(arr[k]+arr[l]<a || arr[k]+arr[l]>b)\n                        flag=true;\n                    }\n                }\n                if(flag==false)  ans++;\n            }\n        }\n        return ans;\n    }", "trans_code": "public static long getCount ( int n , int [ ] arr , int a , int b ) {\n  int ans = 0 ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    for ( int j = i ;\n    j < n ;\n    j ++ ) {\n      boolean flag = false ;\n      for ( int k = i ;\n      k <= j ;\n      k ++ ) {\n        for ( int l = k + 1 ;\n        l <= j ;\n        l ++ ) {\n          if ( arr [ k ] + arr [ l ] < a || arr [ k ] + arr [ l ] > b ) {\n            flag = true ;\n          }\n        }\n      }\n      if ( flag == false ) {\n        ans ++ ;\n      }\n    }\n  }\n  return ans ;\n}\n", "reference_code": "    public static long getCount(int n, int[] arr, int a, int b) {\n        \n        int ans = 0;\n        for (int i = 0; i < n; i++) {\n            for (int j = i; j < n; j++) {\n                boolean flag = false;\n                for (int k = i; k <= j; k++) {\n                    for (int l = k + 1; l <= j; l++) {\n                        if (arr[k] + arr[l] < a || arr[k] + arr[l] > b) {\n                            flag = true;\n                        }\n                    }\n                }\n                if (!flag) ans++;\n            }\n        }\n        return ans;\n    }", "target_Lan": "java###getCount_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.Arrays;\npublic class getCount_Test {\n// TOFILL\n    public static void main(String[] args) {\n        System.out.println(getCount(0, new int[]{}, 1, 5));\n        System.out.println(getCount(5, new int[]{1, 2, 3, 4, -10}, 0, 10));\n        System.out.println(getCount(4, new int[]{1, 2, 3, 4}, 8, 12));\n        System.out.println(getCount(3, new int[]{5, 7, 9}, 20, 25));\n        System.out.println(getCount(6, new int[]{1, 2, 3, 4, 5, 6}, 5, 10));\n    }\n}"}, {"source_Lan": "cpp###minSwaps.cpp", "source_code": "int minSwaps(string S) {\n        int evenSum = 0, oddSum = 0;\n        int n = S.size();\n        \n        for (int i = 0; i < n; i++) {\n            if (i & 1)\n                oddSum += (S[i] == '1');\n            else\n                evenSum += (S[i] == '1');\n        }\n        \n        int difference = abs(oddSum - evenSum);\n        \n        if (difference & 1)\n            return -1;\n        \n        return difference / 2;\n    }", "trans_code": "public static int minSwaps ( String S ) {\n  int evenSum = 0 , oddSum = 0 ;\n  int n = S . length ( ) ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    if ( i & 1 ) {\n      oddSum += ( S . charAt ( i ) == '1' ) ;\n    }\n    else {\n      evenSum += ( S . charAt ( i ) == '1' ) ;\n    }\n  }\n  int difference = Math . abs ( oddSum - evenSum ) ;\n  if ( difference & 1 ) {\n    return - 1 ;\n  }\n  return difference / 2 ;\n}\n", "reference_code": "public static int minSwaps(String S) {\n        int evenSum = 0, oddSum = 0;\n        int n = S.length();\n        \n        for (int i = 0; i < n; i++) {\n            if (i % 2 == 1)\n                oddSum += (S.charAt(i) == '1') ? 1 : 0;\n            else\n                evenSum += (S.charAt(i) == '1') ? 1 : 0;\n        }\n        \n        int difference = Math.abs(oddSum - evenSum);\n        \n        if (difference % 2 == 1) return -1;\n        \n        return difference / 2;\n    }", "target_Lan": "java###minSwaps_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\npublic class minSwaps_Test {\n// TOFILL\n    public static void main(String[] args) {\n        System.out.println(minSwaps(\"\")); \n        System.out.println(minSwaps(\"0000000000\")); \n        System.out.println(minSwaps(\"111\")); \n        System.out.println(minSwaps(\"1010\")); \n        System.out.println(minSwaps(\"1001\")); \n    }\n}"}, {"source_Lan": "cpp###countUniques.cpp", "source_code": "int countUniques(vector<int> a, int k, int l, int r) {\n        \n        unordered_set<int> set;\n        int dup = 0;\n        for (int i : a) {\n            if (!set.insert(i).second) {\n                dup++;\n            }\n        }\n        int unique = set.size();\n        for (int i = l; i <= r; i++) {\n            if (k > 0 && dup > 0 && set.find(i) == set.end()) {\n                unique++;\n                k--;\n                dup--;\n            }\n        }\n        return unique;\n    }", "trans_code": "public static int countUniques ( int [ ] a , int k , int l , int r ) {\n  HashSet < Integer > set = new HashSet < Integer > ( ) ;\n  int dup = 0 ;\n  for ( int i : a ) {\n    if ( ! set . add ( i ) ) dup ++ ;\n  }\n  int unique = set . size ( ) ;\n  for ( int i = l ;\n  i <= r ;\n  i ++ ) {\n    if ( k > 0 && dup > 0 && set . contains ( i ) == false ) {\n      unique ++ ;\n      k -- ;\n      dup -- ;\n    }\n  }\n  return unique ;\n}\n", "reference_code": "public static int countUniques(int[] a, int k, int l, int r) {\n        Set<Integer> set = new HashSet<>();\n        int dup = 0;\n        for(int i : a) if(!set.add(i)) dup++;\n        int unique = set.size();\n        for(int i = l ; i <= r ; i++)\n            if(k>0 && dup>0 && !set.contains(i)){\n                unique++; k--; dup--;\n            }\n        return unique;\n    }", "target_Lan": "java###countUniques_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.HashSet;\nimport java.util.Set;\npublic class countUniques_Test {\n// TOFILL\n    public static void main(String[] args) {\n        \n        int[] a1 = {};\n        System.out.println(countUniques(a1, 2, 1, 10)); \n        \n        \n        int[] a2 = {1, 2, 3, 4};\n        System.out.println(countUniques(a2, 2, 5, 5)); \n        \n        \n        int[] a3 = {1, 2, 2, 3};\n        System.out.println(countUniques(a3, 1, 4, 6)); \n        \n        \n        int[] a4 = {5, 5, 5, 6};\n        System.out.println(countUniques(a4, 0, 1, 10)); \n        \n        \n        int[] a5 = {-1, -2, 0, 1};\n        System.out.println(countUniques(a5, 3, -2, 2)); \n    }\n}"}, {"source_Lan": "cpp###maxLength.cpp", "source_code": "int maxLength(vector<int> arr) {\n        \n        int ans = 0;\n        int N = arr.size();\n        for (int i = 0; i < N; i++) {\n            int or_val = 0;\n            for (int j = i; j < N; j++) {\n                or_val = or_val | arr[j];\n                int x = __builtin_popcount(or_val);\n                if (x == (int)log2(or_val) + 1) {\n                    ans = max(ans, j - i + 1);\n                }\n            }\n        }\n        return ans;\n    }", "trans_code": "public static int maxLength ( int [ ] arr ) {\n  int ans = 0 ;\n  int N = arr . length ;\n  for ( int i = 0 ;\n  i < N ;\n  i ++ ) {\n    int or_val = 0 ;\n    for ( int j = i ;\n    j < N ;\n    j ++ ) {\n      or_val = or_val | arr [ j ] ;\n      int x = __builtinMath . log2 ( or_val ) ;\n      if ( x == ( int ) log2 ( or_val ) + 1 ) ans = Math . max ( ans , j - i + 1 ) ;\n    }\n  }\n  return ans ;\n}\n", "reference_code": "public static int maxLength(int N, int[] arr) {\n        int ans = 0;\n        for(int i = 0 ; i < N; i++){\n            int or = 0;\n            for(int j = i ; j < N; j++){\n                or = or | arr[j];\n                int x = Integer.bitCount(or);\n                if(x == Integer.toBinaryString(or).length()){\n                    ans = Math.max(ans , j - i + 1);\n                }\n            }\n        }\n        return ans;\n    }", "target_Lan": "java###maxLength_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.Arrays;\npublic class maxLength_Test {\n// TOFILL\n    public static void main(String[] args) {\n        int[] input1 = {}; \n        int[] input2 = {0, 0, 0, 0}; \n        int[] input3 = {1, 2, 3, 4}; \n        int[] input4 = {7, 7, 7, 7}; \n        int[] input5 = {15, 31, 63, 127}; \n\n        System.out.println(maxLength(input1.length, input1));\n        System.out.println(maxLength(input2.length, input2));\n        System.out.println(maxLength(input3.length, input3));\n        System.out.println(maxLength(input4.length, input4));\n        System.out.println(maxLength(input5.length, input5));\n    }\n}"}, {"source_Lan": "cpp###firstWord.cpp", "source_code": "string firstWord(int n, vector<string> &dictionary) {\n        \n        sort(dictionary.begin(), dictionary.end());\n        for(int i=0;i<n;i++) {\n            for(int j=i+1;j<n;j++) {\n                if(dictionary[i]==dictionary[j]){\n                    return \"Invalid\";\n                }\n            }\n        }\n        return dictionary[0];\n    }", "trans_code": "public static String firstWord ( int n , String [ ] dictionary ) {\n  Arrays . sort ( dictionary ) ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    for ( int j = i + 1 ;\n    j < n ;\n    j ++ ) {\n      if ( dictionary [ i ] . equals ( dictionary [ j ] ) ) {\n        return \"Invalid\" ;\n      }\n    }\n  }\n  return dictionary [ 0 ] ;\n}\n", "reference_code": "public static String firstWord(int n, String[] dictionary) {\n        \n        Arrays.sort(dictionary);\n        Set<String> seenWords = new HashSet<>();\n        for (String word : dictionary) {\n            if (seenWords.contains(word)) {\n                return \"Invalid\";\n            }\n            seenWords.add(word);\n        }\n        return dictionary[0];\n    }", "target_Lan": "java###firstWord_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Set;\npublic class firstWord_Test {\n// TOFILL\n    public static void main(String[] args) {\n        System.out.println(firstWord(1, new String[]{\"apple\"})); \n        System.out.println(firstWord(3, new String[]{\"banana\", \"apple\", \"grape\"})); \n        System.out.println(firstWord(4, new String[]{\"cat\", \"dog\", \"cat\", \"elephant\"})); \n        System.out.println(firstWord(3, new String[]{\"Apple\", \"apple\", \"banana\"})); \n    }\n}"}, {"source_Lan": "cpp###longestSubarray.cpp", "source_code": "int longestSubarray(int n, vector<int> &arr) {\n        \n        int ans=-1;\n        for(int i=0;i<n;i++){\n            int count=0;\n            int sum=0;\n            for(int j=i;j<n;j++) {\n                count++;\n                sum += arr[j];\n                if(count == sum){\n                    ans = max(ans, count);\n                }\n            }\n        }\n        return ans;\n    }", "trans_code": "public static int longestSubarray ( int n , int [ ] arr ) {\n  int ans = - 1 ;\n  for ( int i = 0 ;\n  i < n ;\n  i ++ ) {\n    int count = 0 ;\n    int sum = 0 ;\n    for ( int j = i ;\n    j < n ;\n    j ++ ) {\n      count ++ ;\n      sum += arr [ j ] ;\n      if ( count == sum ) ans = Math . max ( ans , count ) ;\n    }\n  }\n  return ans ;\n}\n", "reference_code": "public static int longestSubarray(int n, int[] arr) {\n        int ans = -1;\n        for (int i = 0; i < n; i++) {\n            int count = 0;\n            int sum = 0;\n            for (int j = i; j < n; j++) {\n                count++;\n                sum += arr[j];\n                if (count == sum) {\n                    ans = Math.max(ans, count);\n                }\n            }\n        }\n        return ans;\n    }", "target_Lan": "java###longestSubarray_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.Arrays;\npublic class longestSubarray_Test {\n// TOFILL\n    public static void main(String[] args) {\n        System.out.println(longestSubarray(0, new int[]{})); \n        System.out.println(longestSubarray(5, new int[]{1, 2, 3, 4, 5})); \n        System.out.println(longestSubarray(4, new int[]{0, 0, 0, 0})); \n        System.out.println(longestSubarray(6, new int[]{1, 1, 1, 1, 1, 5})); \n        System.out.println(longestSubarray(5, new int[]{5, 1, 1, 1, 1})); \n    }\n}"}, {"source_Lan": "cpp###minDifference.cpp", "source_code": "int minDifference(int n, vector<int> &arr, int x) {\n        \n        int ans=n+1;\n        for(int i=0;i<n-1;i++){\n            for(int j=i+1;j<n;j++){\n                if((arr[i]^arr[j]) <= x){\n                    ans = min(ans, j-i);\n                }\n            }\n        }\n        return (ans == n+1 ? -1 : ans);\n    }", "trans_code": "public static int minDifference ( int n , int [ ] arr , int x ) {\n  int ans = n + 1 ;\n  for ( int i = 0 ;\n  i < n - 1 ;\n  i ++ ) {\n    for ( int j = i + 1 ;\n    j < n ;\n    j ++ ) {\n      if ( ( arr [ i ] ^ arr [ j ] ) <= x ) ans = Math . min ( ans , j - i ) ;\n    }\n  }\n  return ( ans == n + 1 ? - 1 : ans ) ;\n}\n", "reference_code": "public static int minDifference(int n, int[] arr, int x) {\n        int ans = n + 1;\n        for (int i = 0; i < n - 1; i++) {\n            for (int j = i + 1; j < n; j++) {\n                if ((arr[i] ^ arr[j]) <= x) {\n                    ans = Math.min(ans, j - i);\n                }\n            }\n        }\n        return (ans == n + 1) ? -1 : ans;\n    }", "target_Lan": "java###minDifference_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.Arrays;\npublic class minDifference_Test {\n// TOFILL\n    public static void main(String[] args) {\n        int[] arr1 = {3, 5, 6, 1};\n        System.out.println(minDifference(4, arr1, 4));\n\n        int[] arr2 = {1, 2, 8, 4, 3};\n        System.out.println(minDifference(5, arr2, 3));\n\n        int[] arr3 = {7, -2, 4};\n        System.out.println(minDifference(3, arr3, 5));\n\n        int[] arr4 = {0, 0};\n        System.out.println(minDifference(2, arr4, 0));\n\n        int[] arr5 = {1000000000};\n        System.out.println(minDifference(1, arr5, 0));\n    }\n}"}, {"source_Lan": "cpp###reachAlice.cpp", "source_code": "string reachAlice(int d, int x, int y, int k) {\n        int t1 = d / x;\n        int t2 = d / y + k;\n        if (t1 <= t2)\n            return \"Walk\";\n        return \"Bike\";\n    }", "trans_code": "public static String reachAlice ( int d , int x , int y , int k ) {\n  int t1 = d / x ;\n  int t2 = d / y + k ;\n  if ( t1 <= t2 ) return \"Walk\" ;\n  return \"Bike\" ;\n}\n", "reference_code": "public static String reachAlice(int d, int x, int y, int k) {\n        int p = d / x;\n        int q = d / y;\n        q += k;\n        return (p <= q) ? \"Walk\" : \"Bike\";\n    }", "target_Lan": "java###reachAlice_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.Arrays;\npublic class reachAlice_Test {\n// TOFILL\n    public static void main(String[] args) {\n        System.out.println(reachAlice(1000, 10, 10, 5));  \n        System.out.println(reachAlice(1000, 10, 10, 0));  \n        System.out.println(reachAlice(-1, 10, 10, 5));     \n    }\n}"}, {"source_Lan": "cpp###removeOrder.cpp", "source_code": "vector<int> removeOrder(int n, vector<int> &arr, string str) {\n        sort(arr.begin(), arr.end());\n        int i = 0, j = n - 1;\n        vector<int> ans(n);\n        for (int k = 0; k < n; k++) {\n            if (str[k] == '0')\n                ans[k] = arr[i++];\n            else\n                ans[k] = arr[j--];\n        }\n        return ans;\n    }", "trans_code": "public static int [ ] removeOrder ( int n , int [ ] arr , String str ) {\n  Arrays . sort ( arr ) ;\n  int i = 0 , j = n - 1 ;\n  int [ ] ans = new int [ n ] ;\n  for ( int k = 0 ;\n  k < n ;\n  k ++ ) {\n    if ( str . charAt ( k ) == '0' ) {\n      ans [ k ] = arr [ i ++ ] ;\n    }\n    else {\n      ans [ k ] = arr [ j -- ] ;\n    }\n  }\n  return ans ;\n}\n", "reference_code": "public static int[] removeOrder(int n, int[] arr, String str) {\n        Arrays.sort(arr);\n        int i = 0, j = n - 1;\n        int[] ans = new int[n];\n        int idx = 0;\n        for (char ch : str.toCharArray()) {\n            if (ch == '0')\n                ans[idx++] = arr[i++];\n            else\n                ans[idx++] = arr[j--];\n        }\n        return ans;\n    }", "target_Lan": "java###removeOrder_Test.java", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.Arrays;\npublic class removeOrder_Test {\n// TOFILL\n    public static void main(String[] args) {\n        \n        int[] result1 = removeOrder(5, new int[]{5, 3, 1, 4, 2}, \"01010\");\n        System.out.println(Arrays.toString(result1));\n\n        \n        int[] result2 = removeOrder(0, new int[]{}, \"\");\n        System.out.println(Arrays.toString(result2));\n\n        \n        int[] result3 = removeOrder(4, new int[]{7, 8, 9, 10}, \"0000\");\n        System.out.println(Arrays.toString(result3));\n\n        \n        int[] result4 = removeOrder(3, new int[]{1, 2, 3}, \"111\");\n        System.out.println(Arrays.toString(result4));\n\n        \n        int[] result5 = removeOrder(6, new int[]{6, 5, 4, 3, 2, 1}, \"001100\");\n        System.out.println(Arrays.toString(result5));\n    }\n}"}]