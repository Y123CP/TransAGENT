{"source_Lan": "python###ANDequalOR.py", "source_code_str": "def ANDequalOR( n: int, arr: List[int]) -> int:\n    ans = 0\n    pre = 0\n    count = 0\n    for i in range(n):\n        if arr[i] == arr[pre]:\n            count += 1\n        else:\n            ans += (count * (count + 1)) // 2\n            pre = i\n            count = 1\n    ans += (count * (count + 1)) // 2\n    return ans", "source_code_block": "", "target_Lan": "cpp###ANDequalOR.cpp", "reference_code": "    long long ANDequalOR(int n, vector<int> arr) {\n        long long ans = 0;\n        for (int i = 0; i < n; i++) {\n            int pt = i;\n            long long ct = 0;\n            while (pt < n) {\n                if (arr[pt] == arr[i]) {\n                    pt++;\n                    ct++;\n                } else\n                    break;\n            }\n            ct *= (ct + 1);\n            ct /= 2;\n            ans += ct;\n            i = pt - 1;\n        }\n        return ans;\n    }", "target_method_signature": "ANDequalOR", "source_method_signature": "ANDequalOR", "target_allMS": "    long long ANDequalOR(int n, vector<int> arr) {", "source_allMS": "def ANDequalOR( n: int, arr: List[int]) -> int:", "source_import": "from typing import List", "target_import": "#include <iostream>\nusing namespace std;", "commentTag": "//", "source_code_shell": "from typing import List\nfrom typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(ANDequalOR(0, []))\n    print(ANDequalOR(1, [5]))\n    print(ANDequalOR(5, [1, 1, 1, 1, 1]))\n    print(ANDequalOR(5, [1, 2, 2, 1, 1]))\n    print(ANDequalOR(6, [1, 1, 2, 2, 2, 3]))\n    print(ANDequalOR(3, [5, 5, 5]))\n    print(ANDequalOR(4, [10, 10, 20, 10]))\n    print(ANDequalOR(5, [1, 2, 3, 4, 5]))\n    print(ANDequalOR(4, [9, 9, 9, 9]))\n    print(ANDequalOR(2, [1, 1]))", "all_input_output_value": "\ninput1: n=0, arr=[]\noutput1: 0\n--------\ninput2: n=1, arr=[5]\noutput2: 1\n--------\ninput3: n=5, arr=[1, 1, 1, 1, 1]\noutput3: 15\n--------\ninput4: n=5, arr=[1, 2, 2, 1, 1]\noutput4: 7\n--------\ninput5: n=6, arr=[1, 1, 2, 2, 2, 3]\noutput5: 10\n--------\ninput6: n=3, arr=[5, 5, 5]\noutput6: 6\n--------\ninput7: n=4, arr=[10, 10, 20, 10]\noutput7: 5\n--------\ninput8: n=5, arr=[1, 2, 3, 4, 5]\noutput8: 5\n--------\ninput9: n=4, arr=[9, 9, 9, 9]\noutput9: 10\n--------\ninput10: n=2, arr=[1, 1]\noutput10: 3\n", "input_output_value": ["\ninput1: n=0, arr=[]\noutput1: 0\n", "\ninput2: n=1, arr=[5]\noutput2: 1\n", "\ninput3: n=5, arr=[1, 1, 1, 1, 1]\noutput3: 15\n"], "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    cout << ANDequalOR(0, {}) << endl;\n    cout << ANDequalOR(1, {5}) << endl;\n    cout << ANDequalOR(5, {1, 1, 1, 1, 1}) << endl;\n    cout << ANDequalOR(5, {1, 2, 2, 1, 1}) << endl;\n    cout << ANDequalOR(6, {1, 1, 2, 2, 2, 3}) << endl;\n    cout << ANDequalOR(3, {5, 5, 5}) << endl;\n    cout << ANDequalOR(4, {10, 10, 20, 10}) << endl;\n    cout << ANDequalOR(5, {1, 2, 3, 4, 5}) << endl;\n    cout << ANDequalOR(4, {9, 9, 9, 9}) << endl;\n    cout << ANDequalOR(2, {1, 1}) << endl;\n}", "TAG": "Success"}
{"source_Lan": "python###MinSize.py", "source_code_str": "def MinSize( A: List[int],  n: int) -> int:\n    \n    curr = A[0]\n    count = 1\n    for i in range(1, n):\n        if A[i] == curr:\n            count += 1\n        else:\n            count -= 1\n            if count == 0:\n                curr = A[i]\n                count = 1\n    max_f = A.count(curr)\n    if max_f <= (n + 1) // 2:\n        return n & 1\n    else:\n        return 2 * max_f - n", "source_code_block": "", "target_Lan": "cpp###MinSize.cpp", "reference_code": "    int MinSize(vector<int> A, int n) {\n        \n        \n        int curr = A[0];\n        int count = 1;\n        for (int i = 1; i < n; ++i) {\n            if (A[i] == curr) {\n                count += 1;\n            } else {\n                count -= 1;\n                if (count == 0) {\n                    curr = A[i];\n                    count = 1;\n                }\n            }\n        }\n        int max_f = 0;\n        for (int i = 0; i < n; i++)\n            if (curr == A[i])\n                max_f++;\n        if (max_f <= (n + 1) / 2) {\n            return n & 1;\n        } else {\n            return 2 * max_f - n;\n        }\n    }", "target_method_signature": "MinSize", "source_method_signature": "MinSize", "target_allMS": "    int MinSize(vector<int> A, int n) {", "source_allMS": "def MinSize(A: List[int],  n: int) -> int:", "source_import": "from typing import List", "target_import": "#include <iostream>\nusing namespace std;", "commentTag": "//", "source_code_shell": "from typing import List\nfrom typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(MinSize([1, 2, 3, 4, 5], 5))    # No majority element\n    print(MinSize([1, 1, 1, 2, 3], 5))    # Majority element is 1\n    print(MinSize([2, 2, 1, 1, 2], 5))    # Majority element is 2\n    print(MinSize([1, 2, 2, 3, 3], 5))    # No majority element, pairs of elements\n    print(MinSize([5], 1))                  # Edge case: one element\n    print(MinSize([3, 3, 4, 2, 4, 4, 2, 4], 8)) # Majority element is 4\n    print(MinSize([6, 7, 7, 6, 6], 5))      # Majority element is 6\n    print(MinSize([8, -8, 8, 8], 4))       # Majority element is 8, mixed signs\n    print(MinSize([9, 10, 10, 9, 9, 10, 9], 7)) # Majority element is 9", "all_input_output_value": "\ninput1: A=[1, 2, 3, 4, 5], n=5\noutput1: 1\n--------\ninput2: A=[1, 1, 1, 2, 3], n=5\noutput2: 1\n--------\ninput3: A=[2, 2, 1, 1, 2], n=5\noutput3: 1\n--------\ninput4: A=[1, 2, 2, 3, 3], n=5\noutput4: 1\n--------\ninput5: A=[5], n=1\noutput5: 1\n--------\ninput6: A=[3, 3, 4, 2, 4, 4, 2, 4], n=8\noutput6: 0\n--------\ninput7: A=[6, 7, 7, 6, 6], n=5\noutput7: 1\n--------\ninput8: A=[8, -8, 8, 8], n=4\noutput8: 2\n--------\ninput9: A=[9, 10, 10, 9, 9, 10, 9], n=7\noutput9: 1\n", "input_output_value": ["\ninput1: A=[1, 2, 3, 4, 5], n=5\noutput1: 1\n", "\ninput2: A=[1, 1, 1, 2, 3], n=5\noutput2: 1\n", "\ninput3: A=[2, 2, 1, 1, 2], n=5\noutput3: 1\n"], "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    cout << MinSize({1, 2, 3, 4, 5}, 5) << endl;\n    cout << MinSize({1, 1, 1, 2, 3}, 5) << endl;\n    cout << MinSize({2, 2, 1, 1, 2}, 5) << endl;\n    cout << MinSize({1, 2, 2, 3, 3}, 5) << endl;\n    cout << MinSize({5}, 1) << endl;\n    cout << MinSize({3, 3, 4, 2, 4, 4, 2, 4}, 8) << endl;\n    cout << MinSize({6, 7, 7, 6, 6}, 5) << endl;\n    cout << MinSize({8, -8, 8, 8}, 4) << endl;\n    cout << MinSize({9, 10, 10, 9, 9, 10, 9}, 7) << endl;\n}", "TAG": "Success"}
{"source_Lan": "python###findGoodPairs.py", "source_code_str": "def findGoodPairs( a, n, k):\n    mp=dict()\n    for i in range(n):\n        if (a[i] in mp):\n            mp[a[i]].append(i)\n        else:\n            mp[a[i]]=[i]\n    c=0\n    for i in mp:\n        li=mp[i]\n        le=len(li)\n        i=0\n        j=0\n        while(j<le):\n            if (li[j]-li[i])>=k:\n                c+=(le-j)\n                i+=1\n            else:\n                j+=1\n    return c", "source_code_block": "", "target_Lan": "cpp###findGoodPairs.cpp", "reference_code": "    long long findGoodPairs(vector<int> a, int n, int k) {\n        map<int, int > ma;\n        long long ans = 0;\n        for (int i = k; i < n; i++) {\n            ma[a[i - k]]++;\n            ans += ma[a[i]];\n        }\n        return ans;\n    }", "target_method_signature": "findGoodPairs", "source_method_signature": "findGoodPairs", "target_allMS": "    long long findGoodPairs(vector<int> a, int n, int k) {", "source_allMS": "def findGoodPairs( a, n, k):", "source_import": "", "target_import": "#include <iostream>\nusing namespace std;", "commentTag": "//", "source_code_shell": "# TOFILL\nif __name__ == \"__main__\":\n    print(findGoodPairs([], 0, 1))  # Edge case: empty vector\n    print(findGoodPairs([1, 1, 1, 1], 4, 2))  # All elements same\n    print(findGoodPairs([1, 2, 2, 1], 4, 2))  # Normal case with pairs\n    print(findGoodPairs([-1, 0, 1, 2, 3], 5, 2))  # Mixed values, counts with negatives\n    print(findGoodPairs([1, 2, 3, 1, 2, 3], 6, 3))  # Larger input with repeated elements\n    print(findGoodPairs([0, 0, 0, 1, 1, 1], 6, 3))  # Edge case: k and n are the same\n    print(findGoodPairs([1, 2, 3, 4, 5], 5, 5))  # Edge case: k larger than n\n    print(findGoodPairs([1, 2], 2, 1))  # Minimum size of 2\n    print(findGoodPairs([5, 2, 5, 2, 5, 2], 6, 3))  # Alternate repeating pattern", "all_input_output_value": "\ninput1: a=[], n=0, k=1\noutput1: 0\n--------\ninput2: a=[1, 1, 1, 1], n=4, k=2\noutput2: 3\n--------\ninput3: a=[1, 2, 2, 1], n=4, k=2\noutput3: 1\n--------\ninput4: a=[-1, 0, 1, 2, 3], n=5, k=2\noutput4: 0\n--------\ninput5: a=[1, 2, 3, 1, 2, 3], n=6, k=3\noutput5: 3\n--------\ninput6: a=[0, 0, 0, 1, 1, 1], n=6, k=3\noutput6: 0\n--------\ninput7: a=[1, 2, 3, 4, 5], n=5, k=5\noutput7: 0\n--------\ninput8: a=[1, 2], n=2, k=1\noutput8: 0\n--------\ninput9: a=[5, 2, 5, 2, 5, 2], n=6, k=3\noutput9: 2\n", "input_output_value": ["\ninput1: a=[], n=0, k=1\noutput1: 0\n", "\ninput2: a=[1, 1, 1, 1], n=4, k=2\noutput2: 3\n", "\ninput3: a=[1, 2, 2, 1], n=4, k=2\noutput3: 1\n"], "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <map>\n// TOFILL\nint main() {\n    cout << findGoodPairs({}, 0, 1) << endl; // Test Input 1\n    cout << findGoodPairs({1, 1, 1, 1}, 4, 2) << endl; // Test Input 2\n    cout << findGoodPairs({1, 2, 2, 1}, 4, 2) << endl; // Test Input 3\n    cout << findGoodPairs({-1, 0, 1, 2, 3}, 5, 2) << endl; // Test Input 4\n    cout << findGoodPairs({1, 2, 3, 1, 2, 3}, 6, 3) << endl; // Test Input 5\n    cout << findGoodPairs({0, 0, 0, 1, 1, 1}, 6, 3) << endl; // Test Input 6\n    cout << findGoodPairs({1, 2, 3, 4, 5}, 5, 5) << endl; // Test Input 7\n    cout << findGoodPairs({1, 2}, 2, 1) << endl; // Test Input 8\n    cout << findGoodPairs({5, 2, 5, 2, 5, 2}, 6, 3) << endl; // Test Input 9\n}", "TAG": "Success"}
{"source_Lan": "python###timeTravel.py", "source_code_str": "def timeTravel( n, arr):\n    ans=0\n    for i in range(1,n):\n        if (arr[i]>arr[i-1]):\n            ans+=1\n        elif (arr[i]<arr[i-1]):\n            ans+=2\n    return ans", "source_code_block": "", "target_Lan": "cpp###timeTravel.cpp", "reference_code": "    int timeTravel(int n, vector<int> &arr) {\n        int ans = 0;\n        for(int i = 1; i < n; i++)\n            ans += (arr[i] > arr[i - 1] ? 1 : (arr[i] < arr[i - 1] ? 2 : 0));\n        return ans;\n    }", "target_method_signature": "timeTravel", "source_method_signature": "timeTravel", "target_allMS": "    int timeTravel(int n, vector<int> &arr) {", "source_allMS": "def timeTravel( n, arr):", "source_import": "", "target_import": "#include <iostream>\nusing namespace std;", "commentTag": "//", "source_code_shell": "# TOFILL\nif __name__ == \"__main__\":\n    print(timeTravel(0, []))                     # Test case 1\n    print(timeTravel(1, [5]))                    # Test case 2\n    print(timeTravel(5, [1, 2, 3, 4, 5]))       # Test case 3\n    print(timeTravel(5, [5, 4, 3, 2, 1]))       # Test case 4\n    print(timeTravel(5, [2, 2, 2, 2, 2]))       # Test case 5\n    print(timeTravel(5, [1, 3, 2, 4, 3]))       # Test case 6\n    print(timeTravel(6, [2, 2, 1, 1, 2, 3]))    # Test case 7\n    print(timeTravel(4, [1, 1, 1, 1]))          # Test case 8\n    print(timeTravel(5, [0, -1, 0, 1, 0]))      # Test case 9\n    print(timeTravel(10, [5, 5, 4, 4, 3, 3, 2, 2, 1, 1]))  # Test case 10", "all_input_output_value": "\ninput1: n=0, arr=[]\noutput1: 0\n--------\ninput2: n=1, arr=[5]\noutput2: 0\n--------\ninput3: n=5, arr=[1, 2, 3, 4, 5]\noutput3: 4\n--------\ninput4: n=5, arr=[5, 4, 3, 2, 1]\noutput4: 8\n--------\ninput5: n=5, arr=[2, 2, 2, 2, 2]\noutput5: 0\n--------\ninput6: n=5, arr=[1, 3, 2, 4, 3]\noutput6: 6\n--------\ninput7: n=6, arr=[2, 2, 1, 1, 2, 3]\noutput7: 4\n--------\ninput8: n=4, arr=[1, 1, 1, 1]\noutput8: 0\n--------\ninput9: n=5, arr=[0, -1, 0, 1, 0]\noutput9: 6\n--------\ninput10: n=10, arr=[5, 5, 4, 4, 3, 3, 2, 2, 1, 1]\noutput10: 8\n", "input_output_value": ["\ninput1: n=0, arr=[]\noutput1: 0\n", "\ninput2: n=1, arr=[5]\noutput2: 0\n", "\ninput3: n=5, arr=[1, 2, 3, 4, 5]\noutput3: 4\n"], "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    // Test Inputs\n    vector<int> arr1 = {};\n    cout << timeTravel(0, arr1) << endl;  // Input 1: n=0, arr=[]\n\n    vector<int> arr2 = {5};\n    cout << timeTravel(1, arr2) << endl;  // Input 2: n=1, arr=[5]\n\n    vector<int> arr3 = {1, 2, 3, 4, 5};\n    cout << timeTravel(5, arr3) << endl;  // Input 3: n=5, arr=[1, 2, 3, 4, 5]\n    \n    vector<int> arr4 = {5, 4, 3, 2, 1};\n    cout << timeTravel(5, arr4) << endl;  // Input 4: n=5, arr=[5, 4, 3, 2, 1]\n\n    vector<int> arr5 = {2, 2, 2, 2, 2};\n    cout << timeTravel(5, arr5) << endl;  // Input 5: n=5, arr=[2, 2, 2, 2, 2]\n\n    vector<int> arr6 = {1, 3, 2, 4, 3};\n    cout << timeTravel(5, arr6) << endl;  // Input 6: n=5, arr=[1, 3, 2, 4, 3]\n\n    vector<int> arr7 = {2, 2, 1, 1, 2, 3};\n    cout << timeTravel(6, arr7) << endl;  // Input 7: n=6, arr=[2, 2, 1, 1, 2, 3]\n\n    vector<int> arr8 = {1, 1, 1, 1};\n    cout << timeTravel(4, arr8) << endl;  // Input 8: n=4, arr=[1, 1, 1, 1]\n\n    vector<int> arr9 = {0, -1, 0, 1, 0};\n    cout << timeTravel(5, arr9) << endl;  // Input 9: n=5, arr=[0, -1, 0, 1, 0]\n\n    vector<int> arr10 = {5, 5, 4, 4, 3, 3, 2, 2, 1, 1};\n    cout << timeTravel(10, arr10) << endl; // Input 10: n=10, arr=[5, 5, 4, 4, 3, 3, 2, 2, 1, 1]\n\n    return 0;\n}", "TAG": "Success"}
{"source_Lan": "python###trafficLights.py", "source_code_str": "def trafficLights( n: int, q: int, queries: List[List[int]]) -> str:\n    sweap = [0] * (n + 1)\n    for l, r in queries:\n        sweap[l - 1] += 1\n        sweap[r] -= 1\n    curr = 0\n    ans = \"\"\n    for i in range(n):\n        curr = (curr + sweap[i]) % 3\n        if curr == 0:\n            ans += 'R'\n        elif curr == 1:\n            ans += 'Y'\n        else:\n            ans += 'G'\n    return ans", "source_code_block": "", "target_Lan": "cpp###trafficLights.cpp", "reference_code": "    string trafficLights(int n, int q, vector<vector<int>>& queries) {\n        \n        vector<int> darr(n + 1, 0);\n        for (vector<int>& Q : queries) {\n            int a = Q[0];\n            int b = Q[1];\n            darr[a - 1]++;\n            darr[b]--;\n        }\n        partial_sum(darr.begin(), darr.end(), darr.begin());\n        string result = \"\";\n        for (int i = 0; i < n; i++) {\n            int X = darr[i] % 3;\n            if (X == 0)\n                result += \"R\";\n            else if (X == 1)\n                result += \"Y\";\n            else if (X == 2)\n                result += \"G\";\n        }\n        return result;\n    }", "target_method_signature": "trafficLights", "source_method_signature": "trafficLights", "target_allMS": "    string trafficLights(int n, int q, vector<vector<int>>& queries) {", "source_allMS": "def trafficLights( n: int, q: int, queries: List[List[int]]) -> str:", "source_import": "from typing import List", "target_import": "#include <iostream>\nusing namespace std;", "commentTag": "//", "source_code_shell": "from typing import List\nfrom typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(trafficLights(5, 0, []))\n    print(trafficLights(5, 1, [[1, 3]]))\n    print(trafficLights(5, 2, [[1, 5], [2, 4]]))\n    print(trafficLights(5, 3, [[1, 5], [1, 3], [4, 5]]))\n    print(trafficLights(3, 2, [[1, 2], [2, 3]]))\n    print(trafficLights(6, 4, [[1, 6], [2, 4], [1, 2], [3, 3]]))\n    print(trafficLights(7, 5, [[1, 7], [1, 1], [2, 2], [3, 4], [5, 7]]))\n    print(trafficLights(5, 3, [[1, 5], [1, 2], [2, 5]]))\n    print(trafficLights(4, 2, [[1, 4], [1, 2]]))\n    print(trafficLights(3, 3, [[1, 3], [1, 2], [2, 3]]))", "all_input_output_value": "\ninput1: n=5, q=0, queries=[]\noutput1: RRRRR\n--------\ninput2: n=5, q=1, queries=[[1, 3]]\noutput2: YYYRR\n--------\ninput3: n=5, q=2, queries=[[1, 5], [2, 4]]\noutput3: YGGGY\n--------\ninput4: n=5, q=3, queries=[[1, 5], [1, 3], [4, 5]]\noutput4: GGGGG\n--------\ninput5: n=3, q=2, queries=[[1, 2], [2, 3]]\noutput5: YGY\n--------\ninput6: n=6, q=4, queries=[[1, 6], [2, 4], [1, 2], [3, 3]]\noutput6: GRRGYY\n--------\ninput7: n=7, q=5, queries=[[1, 7], [1, 1], [2, 2], [3, 4], [5, 7]]\noutput7: GGGGGGG\n--------\ninput8: n=5, q=3, queries=[[1, 5], [1, 2], [2, 5]]\noutput8: GRGGG\n--------\ninput9: n=4, q=2, queries=[[1, 4], [1, 2]]\noutput9: GGYY\n--------\ninput10: n=3, q=3, queries=[[1, 3], [1, 2], [2, 3]]\noutput10: GRG\n", "input_output_value": ["\ninput1: n=5, q=0, queries=[]\noutput1: RRRRR\n", "\ninput2: n=5, q=1, queries=[[1, 3]]\noutput2: YYYRR\n", "\ninput3: n=5, q=2, queries=[[1, 5], [2, 4]]\noutput3: YGGGY\n"], "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <numeric>\n// TOFILL\nint main() {\n    // Test Input 1\n    vector<vector<int>> queries1;\n    cout << trafficLights(5, 0, queries1) << endl;\n\n    // Test Input 2\n    vector<vector<int>> queries2 = {{1, 3}};\n    cout << trafficLights(5, 1, queries2) << endl;\n\n    // Test Input 3\n    vector<vector<int>> queries3 = {{1, 5}, {2, 4}};\n    cout << trafficLights(5, 2, queries3) << endl;\n\n    // Test Input 4\n    vector<vector<int>> queries4 = {{1, 5}, {1, 3}, {4, 5}};\n    cout << trafficLights(5, 3, queries4) << endl;\n\n    // Test Input 5\n    vector<vector<int>> queries5 = {{1, 2}, {2, 3}};\n    cout << trafficLights(3, 2, queries5) << endl;\n\n    // Test Input 6\n    vector<vector<int>> queries6 = {{1, 6}, {2, 4}, {1, 2}, {3, 3}};\n    cout << trafficLights(6, 4, queries6) << endl;\n\n    // Test Input 7\n    vector<vector<int>> queries7 = {{1, 7}, {1, 1}, {2, 2}, {3, 4}, {5, 7}};\n    cout << trafficLights(7, 5, queries7) << endl;\n\n    // Test Input 8\n    vector<vector<int>> queries8 = {{1, 5}, {1, 2}, {2, 5}};\n    cout << trafficLights(5, 3, queries8) << endl;\n\n    // Test Input 9\n    vector<vector<int>> queries9 = {{1, 4}, {1, 2}};\n    cout << trafficLights(4, 2, queries9) << endl;\n\n    // Test Input 10\n    vector<vector<int>> queries10 = {{1, 3}, {1, 2}, {2, 3}};\n    cout << trafficLights(3, 3, queries10) << endl;\n\n    return 0;\n}", "TAG": "Success"}
{"source_Lan": "python###smallestString.py", "source_code_str": "def smallestString( n : int, s : str) -> str:\n    \n    if n == 1:\n        return \"-1\"\n    answer = list(s)\n    \n    for i in range(n // 2):\n        \n        if s[i] != 'a':\n            answer[i] = 'a'\n            return ''.join(answer)\n    \n    answer[-1] = 'b'\n    return ''.join(answer)", "source_code_block": "", "target_Lan": "cpp###smallestString.cpp", "reference_code": "    string smallestString(int n, string s) {\n        string answer = s;\n        int odd = n%2;\n        if(n == 1){\n            return \"-1\";\n        }\n        for(int i = 0; i < (n/2); i ++){\n            if(s[i] != 'a'){\n                answer[i] = 'a';\n                return answer;\n            }\n        }\n        answer[answer.size() - 1] = 'b';\n        return answer;\n    }", "target_method_signature": "smallestString", "source_method_signature": "smallestString", "target_allMS": "    string smallestString(int n, string s) {", "source_allMS": "def smallestString( n : int, s : str) -> str:", "source_import": "", "target_import": "#include <iostream>\nusing namespace std;", "commentTag": "//", "source_code_shell": "# TOFILL\nif __name__ == \"__main__\":\n    print(smallestString(1, \"a\"))           # should return \"-1\"\n    print(smallestString(2, \"aaaa\"))        # should return \"aaab\"\n    print(smallestString(3, \"abaa\"))        # should return \"aaaa\"\n    print(smallestString(4, \"bcbc\"))        # should return \"aacb\"\n    print(smallestString(6, \"c\"))           # should return \"a\"\n    print(smallestString(8, \"aaaaa\"))       # should return \"-1\"\n    print(smallestString(9, \"abcdabcd\"))    # should return \"aacdabcd\"\n    print(smallestString(10, \"bbbbbbbbbb\")) # should return \"abbbbbbbbb\"", "all_input_output_value": "\ninput1: n=1, s=\"a\"\noutput1: -1\n--------\ninput2: n=2, s=\"aaaa\"\noutput2: aaab\n--------\ninput3: n=3, s=\"abaa\"\noutput3: abac\n--------\ninput4: n=4, s=\"bcbc\"\noutput4: acbc\n--------\ninput5: n=6, s=\"c\"\noutput5: a\n--------\ninput6: n=8, s=\"aaaaa\"\noutput6: -1\n--------\ninput7: n=9, s=\"abcdabcd\"\noutput7: aabcdcd\n--------\ninput8: n=10, s=\"bbbbbbbbbb\"\noutput8: abbbbbbbbb\n", "input_output_value": ["\ninput1: n=1, s=\"a\"\noutput1: -1\n", "\ninput2: n=2, s=\"aaaa\"\noutput2: aaab\n", "\ninput3: n=3, s=\"abaa\"\noutput3: abac\n"], "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <string>\n// TOFILL\nint main() {\n    cout << smallestString(1, \"a\") << endl;       // Expected: -1\n    cout << smallestString(2, \"aaaa\") << endl;    // Expected: aaab\n    cout << smallestString(3, \"abaa\") << endl;    // Expected: aaaa\n    cout << smallestString(4, \"bcbc\") << endl;    // Expected: aabc\n    cout << smallestString(6, \"c\") << endl;       // Expected: aaabaa\n    cout << smallestString(8, \"aaaaa\") << endl;   // Expected: aaaaaaaab\n    cout << smallestString(9, \"abcdabcd\") << endl; // Expected: aabcdabcd\n    cout << smallestString(10, \"bbbbbbbbbb\") << endl; // Expected: aaaaaaaaaab\n}", "TAG": "Success"}
{"source_Lan": "python###countOperations.py", "source_code_str": "def countOperations( s: str) -> int:\n    mod = 10**9 + 7\n    ans = 0\n    count_b = 0\n    for i in range(len(s) - 1, -1, -1):\n        if s[i] == 'b':\n            count_b = (count_b + 1) % mod\n        else:\n            ans = (ans + count_b) % mod\n            count_b = (count_b + count_b) % mod\n    return ans", "source_code_block": "", "target_Lan": "cpp###countOperations.cpp", "reference_code": "    int countOperations(string s) {\n        const int mod = 1000000007;\n        int ans = 0;\n        int count_b = 0;\n        for (int i = s.length() - 1; i >= 0; --i) {\n            if (s[i] == 'b')\n                count_b = (count_b + 1) % mod;\n            else {\n                ans = (ans + count_b) % mod;\n                count_b = (count_b + count_b) % mod;\n            }\n        }\n        return ans;\n    }", "target_method_signature": "countOperations", "source_method_signature": "countOperations", "target_allMS": "    int countOperations(string s) {", "source_allMS": "def countOperations( s: str) -> int:", "source_import": "", "target_import": "#include <iostream>\nusing namespace std;", "commentTag": "//", "source_code_shell": "# TOFILL\nif __name__ == \"__main__\":\n    test_inputs = [\"ab\", \"ba\", \"bcbc\", \"bbb\", \"abc\", \"cba\", \"aabb\", \"bbbaaa\", \"a\", \"\"]\n    for s in test_inputs:\n        print(countOperations(s))", "all_input_output_value": "\ninput1: s=\"ab\"\noutput1: 1\n--------\ninput2: s=\"ba\"\noutput2: 0\n--------\ninput3: s=\"bcbc\"\noutput3: 1\n--------\ninput4: s=\"bbb\"\noutput4: 0\n--------\ninput5: s=\"abc\"\noutput5: 1\n--------\ninput6: s=\"cba\"\noutput6: 1\n--------\ninput7: s=\"aabb\"\noutput7: 6\n--------\ninput8: s=\"bbbaaa\"\noutput8: 0\n--------\ninput9: s=\"a\"\noutput9: 0\n--------\ninput10: s=\"\"\noutput10: 0\n", "input_output_value": ["\ninput1: s=\"ab\"\noutput1: 1\n", "\ninput2: s=\"ba\"\noutput2: 0\n", "\ninput3: s=\"bcbc\"\noutput3: 1\n"], "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <string>\n// TOFILL\nint main() {\n    cout << countOperations(\"ab\") << endl;\n    cout << countOperations(\"ba\") << endl;\n    cout << countOperations(\"bcbc\") << endl;\n    cout << countOperations(\"bbb\") << endl;\n    cout << countOperations(\"abc\") << endl;\n    cout << countOperations(\"cba\") << endl;\n    cout << countOperations(\"aabb\") << endl;\n    cout << countOperations(\"bbbaaa\") << endl;\n    cout << countOperations(\"a\") << endl;\n    cout << countOperations(\"\") << endl;\n}", "TAG": "Success"}
{"source_Lan": "python###geekTasks.py", "source_code_str": "def geekTasks( n : int, m : int, q : int, tasks : List[List[int]]) -> int:\n    minA=0\n    minB=0\n    for i in range(q):\n        a,b=tasks[i][0],tasks[i][1]\n        a+=1\n        b+=1\n        if i==0:\n            minA=a\n            minB=b\n        else:\n            if minA>a:\n                minA=a\n            if minB>b:\n                minB=b\n    total=0\n    maxi=0\n    col=[0]*(n)\n    for i in range(q):\n        col[tasks[i][0]]=max(col[tasks[i][0]],tasks[i][1]+1)\n    for i in range(n-1,-1,-1):\n        maxi=max(maxi,col[i])\n        total+=maxi\n    total-=minA*minB\n    return total", "source_code_block": "", "target_Lan": "cpp###geekTasks.cpp", "reference_code": "    long long geekTasks(int n, int m, int q, vector<vector<int>> &tasks) {\n        long long int total = 0;\n        long long int a,b, minA, minB;\n        for(long long int i=0; i<q; i++)\n        {\n            a = tasks[i][0];\n            b = tasks[i][1];\n            a += 1;\n            b += 1;\n            if(i==0){\n                minA=a;\n                minB=b;\n            }\n            if(a<minA){\n                minA=a;\n            }\n            if(b<minB){\n                minB=b;\n            }\n        }\n        vector<int> col(n, 0);\n        for(auto i : tasks){\n            long long int x = i[1] + 1;\n            col[i[0]] = max((long long int)col[i[0]], x);\n        }\n        long long int maxi = 0;\n        for(int i = n - 1; i >= 0; i--){\n            maxi = max(maxi, (long long int)col[i]);\n            total += maxi;\n        }\n        long long int cellsWithMaxValue = minA*minB;\n        total -= cellsWithMaxValue;\n        return total;\n    }", "target_method_signature": "geekTasks", "source_method_signature": "geekTasks", "target_allMS": "    long long geekTasks(int n, int m, int q, vector<vector<int>> &tasks) {", "source_allMS": "def geekTasks( n : int, m : int, q : int, tasks : List[List[int]]) -> int:", "source_import": "from typing import List", "target_import": "#include <iostream>\nusing namespace std;", "commentTag": "//", "source_code_shell": "from typing import List\nfrom typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(geekTasks(10, 5, 3, [[0, 0], [1, 1], [2, 2]]))\n    print(geekTasks(5, 5, 4, [[0, 4], [1, 3], [1, 4], [4, 4]]))\n    print(geekTasks(3, 2, 5, [[0, 0], [0, 1], [1, 0], [1, 1], [2, 1]]))\n    print(geekTasks(4, 4, 2, [[0, -1], [1, 0]]))\n    print(geekTasks(2, 2, 2, [[0, 0], [0, 1]]))\n    print(geekTasks(100, 100, 5, [[0, 0], [99, 99], [99, 50], [50, 99], [0, 99]]))\n    print(geekTasks(1, 1, 1, [[0, 0]]))\n    print(geekTasks(3, 5, 3, [[0, 5], [1, 5], [2, 2]]))\n    print(geekTasks(2, 3, 2, [[1, 2], [0, 1]]))\n    print(geekTasks(1, 1, 1, [[0, 0]]))", "all_input_output_value": "\ninput1: n=10, m=5, q=3, tasks=[[0, 0], [1, 1], [2, 2]]\noutput1: 8\n--------\ninput2: n=5, m=5, q=4, tasks=[[0, 4], [1, 3], [1, 4], [4, 4]]\noutput2: 21\n--------\ninput3: n=3, m=2, q=5, tasks=[[0, 0], [0, 1], [1, 0], [1, 1], [2, 1]]\noutput3: 5\n--------\ninput4: n=4, m=4, q=2, tasks=[[0, -1], [1, 0]]\noutput4: 2\n--------\ninput5: n=2, m=2, q=2, tasks=[[0, 0], [0, 1]]\noutput5: 1\n--------\ninput6: n=100, m=100, q=5, tasks=[[0, 0], [99, 99], [99, 50], [50, 99], [0, 99]]\noutput6: 9999\n--------\ninput7: n=1, m=1, q=1, tasks=[[0, 0]]\noutput7: 0\n--------\ninput8: n=3, m=5, q=3, tasks=[[0, 5], [1, 5], [2, 2]]\noutput8: 12\n--------\ninput9: n=2, m=3, q=2, tasks=[[1, 2], [0, 1]]\noutput9: 4\n--------\ninput10: n=1, m=1, q=1, tasks=[[0, 0]]\noutput10: 0\n", "input_output_value": ["\ninput1: n=10, m=5, q=3, tasks=[[0, 0], [1, 1], [2, 2]]\noutput1: 8\n", "\ninput2: n=5, m=5, q=4, tasks=[[0, 4], [1, 3], [1, 4], [4, 4]]\noutput2: 21\n", "\ninput3: n=3, m=2, q=5, tasks=[[0, 0], [0, 1], [1, 0], [1, 1], [2, 1]]\noutput3: 5\n"], "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    vector<vector<int>> tasks1 = {{0, 0}, {1, 1}, {2, 2}};\n    cout << geekTasks(10, 5, 3, tasks1) << endl;\n\n    vector<vector<int>> tasks2 = {{0, 4}, {1, 3}, {1, 4}, {4, 4}};\n    cout << geekTasks(5, 5, 4, tasks2) << endl;\n\n    vector<vector<int>> tasks3 = {{0, 0}, {0, 1}, {1, 0}, {1, 1}, {2, 1}};\n    cout << geekTasks(3, 2, 5, tasks3) << endl;\n\n    vector<vector<int>> tasks4 = {{0, -1}, {1, 0}};\n    cout << geekTasks(4, 4, 2, tasks4) << endl;\n\n    vector<vector<int>> tasks5 = {{0, 0}, {0, 1}};\n    cout << geekTasks(2, 2, 2, tasks5) << endl;\n\n    vector<vector<int>> tasks6 = {{0, 0}, {99, 99}, {99, 50}, {50, 99}, {0, 99}};\n    cout << geekTasks(100, 100, 5, tasks6) << endl;\n\n    vector<vector<int>> tasks7 = {{0, 0}};\n    cout << geekTasks(1, 1, 1, tasks7) << endl;\n\n    vector<vector<int>> tasks8 = {{0, 5}, {1, 5}, {2, 2}};\n    cout << geekTasks(3, 5, 3, tasks8) << endl;\n\n    vector<vector<int>> tasks9 = {{1, 2}, {0, 1}};\n    cout << geekTasks(2, 3, 2, tasks9) << endl;\n\n    vector<vector<int>> tasks10 = {{0, 0}};\n    cout << geekTasks(1, 1, 1, tasks10) << endl;\n\n    return 0;\n}", "TAG": "Success"}
{"source_Lan": "python###majorityWins.py", "source_code_str": "def majorityWins( arr, n, x, y):\n    count_x=0;\n    count_y=0;\n    for i in range(0,n):\n        \n        \n        if(arr[i]==x):\n            count_x+=1\n        if(arr[i]==y):\n            count_y+=1\n    \n    \n    if(count_x>count_y or (count_x==count_y and x<y)):\n        \n        return x\n    else:\n        \n        return y", "source_code_block": "", "target_Lan": "cpp###majorityWins.cpp", "reference_code": "    int majorityWins(int arr[], int n, int x, int y) {\n        int count_x = 0;\n        int count_y = 0;\n        \n        \n        for (int i = 0; i < n; i++) {\n            if (arr[i] == x) count_x++;\n            if (arr[i] == y) count_y++;\n        }\n        \n        if (count_x > count_y)\n            \n            return x;\n        else if (count_y > count_x)\n            \n            return y;\n        \n        else\n            return x < y ? x : y;\n    }", "target_method_signature": "majorityWins", "source_method_signature": "majorityWins", "target_allMS": "    int majorityWins(int arr[], int n, int x, int y) {", "source_allMS": "def majorityWins( arr, n, x, y):", "source_import": "", "target_import": "#include <iostream>\nusing namespace std;", "commentTag": "//", "source_code_shell": "# TOFILL\nif __name__ == \"__main__\":\n    print(majorityWins([1, 1, 2, 2, 1], 5, 1, 2))  # Output: 1\n    print(majorityWins([2, 2, 1, 1, 2], 5, 1, 2))  # Output: 2\n    print(majorityWins([2, 2, 1, 1], 4, 1, 2))     # Output: 1\n    print(majorityWins([], 0, 3, 4))                # Output: 3\n    print(majorityWins([5, 6, 7, 8, 5], 5, 5, 10)) # Output: 5\n    print(majorityWins([10, 20, 30], 3, 10, 5))     # Output: 10\n    print(majorityWins([1, 3, 1, 3, 1, 4, 4], 7, 1, 3))  # Output: 1\n    print(majorityWins([7, 8, 8, 7, 7], 5, 8, 7))   # Output: 8\n    print(majorityWins([2, 2, 2, 3, 4, 4], 6, 2, 4)) # Output: 2\n    print(majorityWins([5, 1, 1, 2, 2, 3, 3], 7, 2, 5)) # Output: 2", "all_input_output_value": "\ninput1: arr=[1, 1, 2, 2, 1], n=5, x=1, y=2\noutput1: 1\n--------\ninput2: arr=[2, 2, 1, 1, 2], n=5, x=1, y=2\noutput2: 2\n--------\ninput3: arr=[2, 2, 1, 1], n=4, x=1, y=2\noutput3: 1\n--------\ninput4: arr=[], n=0, x=3, y=4\noutput4: 3\n--------\ninput5: arr=[5, 6, 7, 8, 5], n=5, x=5, y=10\noutput5: 5\n--------\ninput6: arr=[10, 20, 30], n=3, x=10, y=5\noutput6: 10\n--------\ninput7: arr=[1, 3, 1, 3, 1, 4, 4], n=7, x=1, y=3\noutput7: 1\n--------\ninput8: arr=[7, 8, 8, 7, 7], n=5, x=8, y=7\noutput8: 7\n--------\ninput9: arr=[2, 2, 2, 3, 4, 4], n=6, x=2, y=4\noutput9: 2\n--------\ninput10: arr=[5, 1, 1, 2, 2, 3, 3], n=7, x=2, y=5\noutput10: 2\n", "input_output_value": ["\ninput1: arr=[1, 1, 2, 2, 1], n=5, x=1, y=2\noutput1: 1\n", "\ninput2: arr=[2, 2, 1, 1, 2], n=5, x=1, y=2\noutput2: 2\n", "\ninput3: arr=[2, 2, 1, 1], n=4, x=1, y=2\noutput3: 1\n"], "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n// TOFILL\nint main() {\n    int arr1[] = {1, 1, 2, 2, 1};\n    cout << majorityWins(arr1, 5, 1, 2) << endl;\n\n    int arr2[] = {2, 2, 1, 1, 2};\n    cout << majorityWins(arr2, 5, 1, 2) << endl;\n\n    int arr3[] = {2, 2, 1, 1};\n    cout << majorityWins(arr3, 4, 1, 2) << endl;\n\n    int arr4[] = {};\n    cout << majorityWins(arr4, 0, 3, 4) << endl;\n\n    int arr5[] = {5, 6, 7, 8, 5};\n    cout << majorityWins(arr5, 5, 5, 10) << endl;\n\n    int arr6[] = {10, 20, 30};\n    cout << majorityWins(arr6, 3, 10, 5) << endl;\n\n    int arr7[] = {1, 3, 1, 3, 1, 4, 4};\n    cout << majorityWins(arr7, 7, 1, 3) << endl;\n\n    int arr8[] = {7, 8, 8, 7, 7};\n    cout << majorityWins(arr8, 5, 8, 7) << endl;\n\n    int arr9[] = {2, 2, 2, 3, 4, 4};\n    cout << majorityWins(arr9, 6, 2, 4) << endl;\n\n    int arr10[] = {5, 1, 1, 2, 2, 3, 3};\n    cout << majorityWins(arr10, 7, 2, 5) << endl;\n\n    return 0;\n}", "TAG": "Success"}
{"source_Lan": "python###areaOfMaxDiagonal.py", "source_code_str": "def areaOfMaxDiagonal( dimensions: List[List[int]]) -> int:\n    return max((x * x + y * y, x * y) for x, y in dimensions)[1]", "source_code_block": "", "target_Lan": "cpp###areaOfMaxDiagonal.cpp", "reference_code": "    int areaOfMaxDiagonal(vector<vector<int>> &dimensions) {\n        int ans = 0, max_l = 0;\n        for (auto &d: dimensions) {\n            int x = d[0], y = d[1];\n            int l = x * x + y * y;\n            if (l > max_l || (l == max_l && x * y > ans)) {\n                max_l = l;\n                ans = x * y;\n            }\n        }\n        return ans;\n    }", "target_method_signature": "areaOfMaxDiagonal", "source_method_signature": "areaOfMaxDiagonal", "target_allMS": "    int areaOfMaxDiagonal(vector<vector<int>> &dimensions) {", "source_allMS": "def areaOfMaxDiagonal( dimensions: List[List[int]]) -> int:", "source_import": "", "target_import": "#include <iostream>\nusing namespace std;", "commentTag": "//", "source_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(areaOfMaxDiagonal([[3, 4], [5, 12], [6, 8], [0, 0], [1, 1]]))\n    print(areaOfMaxDiagonal([[1, 2], [3, 2], [3, 4], [4, 4], [2, 4]]))\n    print(areaOfMaxDiagonal([[10, 10], [10, 20], [20, 10], [15, 15], [0, 5]]))\n    print(areaOfMaxDiagonal([[1, 1], [2, 2], [0, 3], [3, 0], [5, 5]]))\n    print(areaOfMaxDiagonal([[7, 24], [24, 7], [20, 21], [21, 20], [0, 0]]))\n    print(areaOfMaxDiagonal([[8, 6], [6, 8], [20, 15], [15, 20], [10, 10]]))\n    print(areaOfMaxDiagonal([[1, 100], [100, 1], [50, 50], [10, 10], [5, 20]]))\n    print(areaOfMaxDiagonal([[9, 12], [12, 9], [8, 15], [15, 8], [0, 0]]))\n    print(areaOfMaxDiagonal([[50, 100], [100, 50], [0, 0], [10, 5], [5, 10]]))\n    print(areaOfMaxDiagonal([[3, 4], [4, 3], [5, 5], [6, 7], [7, 6]]))", "all_input_output_value": "\ninput1: dimensions=[[3, 4], [5, 12], [6, 8], [0, 0], [1, 1]]\noutput1: 60\n--------\ninput2: dimensions=[[1, 2], [3, 2], [3, 4], [4, 4], [2, 4]]\noutput2: 16\n--------\ninput3: dimensions=[[10, 10], [10, 20], [20, 10], [15, 15], [0, 5]]\noutput3: 200\n--------\ninput4: dimensions=[[1, 1], [2, 2], [0, 3], [3, 0], [5, 5]]\noutput4: 25\n--------\ninput5: dimensions=[[7, 24], [24, 7], [20, 21], [21, 20], [0, 0]]\noutput5: 420\n--------\ninput6: dimensions=[[8, 6], [6, 8], [20, 15], [15, 20], [10, 10]]\noutput6: 300\n--------\ninput7: dimensions=[[1, 100], [100, 1], [50, 50], [10, 10], [5, 20]]\noutput7: 100\n--------\ninput8: dimensions=[[9, 12], [12, 9], [8, 15], [15, 8], [0, 0]]\noutput8: 120\n--------\ninput9: dimensions=[[50, 100], [100, 50], [0, 0], [10, 5], [5, 10]]\noutput9: 5000\n--------\ninput10: dimensions=[[3, 4], [4, 3], [5, 5], [6, 7], [7, 6]]\noutput10: 42\n", "input_output_value": ["\ninput1: dimensions=[[3, 4], [5, 12], [6, 8], [0, 0], [1, 1]]\noutput1: 60\n", "\ninput2: dimensions=[[1, 2], [3, 2], [3, 4], [4, 4], [2, 4]]\noutput2: 16\n", "\ninput3: dimensions=[[10, 10], [10, 20], [20, 10], [15, 15], [0, 5]]\noutput3: 200\n"], "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    vector<vector<int>> test1 = {{3, 4}, {5, 12}, {6, 8}, {0, 0}, {1, 1}};\n    vector<vector<int>> test2 = {{1, 2}, {3, 2}, {3, 4}, {4, 4}, {2, 4}};\n    vector<vector<int>> test3 = {{10, 10}, {10, 20}, {20, 10}, {15, 15}, {0, 5}};\n    vector<vector<int>> test4 = {{1, 1}, {2, 2}, {0, 3}, {3, 0}, {5, 5}};\n    vector<vector<int>> test5 = {{7, 24}, {24, 7}, {20, 21}, {21, 20}, {0, 0}};\n    vector<vector<int>> test6 = {{8, 6}, {6, 8}, {20, 15}, {15, 20}, {10, 10}};\n    vector<vector<int>> test7 = {{1, 100}, {100, 1}, {50, 50}, {10, 10}, {5, 20}};\n    vector<vector<int>> test8 = {{9, 12}, {12, 9}, {8, 15}, {15, 8}, {0, 0}};\n    vector<vector<int>> test9 = {{50, 100}, {100, 50}, {0, 0}, {10, 5}, {5, 10}};\n    vector<vector<int>> test10 = {{3, 4}, {4, 3}, {5, 5}, {6, 7}, {7, 6}};\n    \n    cout << areaOfMaxDiagonal(test1) << endl;\n    cout << areaOfMaxDiagonal(test2) << endl;\n    cout << areaOfMaxDiagonal(test3) << endl;\n    cout << areaOfMaxDiagonal(test4) << endl;\n    cout << areaOfMaxDiagonal(test5) << endl;\n    cout << areaOfMaxDiagonal(test6) << endl;\n    cout << areaOfMaxDiagonal(test7) << endl;\n    cout << areaOfMaxDiagonal(test8) << endl;\n    cout << areaOfMaxDiagonal(test9) << endl;\n    cout << areaOfMaxDiagonal(test10) << endl;\n\n    return 0;\n}", "TAG": "Success"}
{"source_Lan": "python###countSubmatrices.py", "source_code_str": "def countSubmatrices( grid: List[List[int]], k: int) -> int:\n    ans = 0\n    m, n = len(grid), len(grid[0])\n    s = [[0] * (n + 1) for _ in range(m + 1)]\n    for i, row in enumerate(grid):\n        for j, x in enumerate(row):\n            s[i + 1][j + 1] = s[i + 1][j] + s[i][j + 1] - s[i][j] + x\n            if s[i + 1][j + 1] <= k:\n                ans += 1\n    return ans", "source_code_block": "", "target_Lan": "cpp###countSubmatrices.cpp", "reference_code": "    int countSubmatrices(vector<vector<int>> &grid, int k) {\n        int ans = 0, m = grid.size(), n = grid[0].size();\n        vector<vector<int>> sum(m + 1, vector<int>(n + 1));\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                sum[i + 1][j + 1] = sum[i + 1][j] + sum[i][j + 1] - sum[i][j] + grid[i][j];\n                ans += sum[i + 1][j + 1] <= k;\n            }\n        }\n        return ans;\n    }", "target_method_signature": "countSubmatrices", "source_method_signature": "countSubmatrices", "target_allMS": "    int countSubmatrices(vector<vector<int>> &grid, int k) {", "source_allMS": "def countSubmatrices( grid: List[List[int]], k: int) -> int:", "source_import": "", "target_import": "#include <iostream>\nusing namespace std;", "commentTag": "//", "source_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(countSubmatrices([[1, 2], [3, 4]], 10))\n    print(countSubmatrices([[0]], 0))\n    print(countSubmatrices([[1, 1], [1, 1]], 2))\n    print(countSubmatrices([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 45))\n    print(countSubmatrices([[-1, -2], [-3, -4]], -5))\n    print(countSubmatrices([[5, 5], [5, 5]], 25))\n    print(countSubmatrices([[0, 0], [0, 0]], 0))\n    print(countSubmatrices([[1]], 1))\n    print(countSubmatrices([[1, -1], [-1, 1]], 0))\n    print(countSubmatrices([[10, 20], [30, 40]], 60))", "all_input_output_value": "\ninput1: grid=[[1, 2], [3, 4]], k=10\noutput1: 4\n--------\ninput2: grid=[[0]], k=0\noutput2: 1\n--------\ninput3: grid=[[1, 1], [1, 1]], k=2\noutput3: 3\n--------\ninput4: grid=[[1, 2, 3], [4, 5, 6], [7, 8, 9]], k=45\noutput4: 9\n--------\ninput5: grid=[[-1, -2], [-3, -4]], k=-5\noutput5: 1\n--------\ninput6: grid=[[5, 5], [5, 5]], k=25\noutput6: 4\n--------\ninput7: grid=[[0, 0], [0, 0]], k=0\noutput7: 4\n--------\ninput8: grid=[[1]], k=1\noutput8: 1\n--------\ninput9: grid=[[1, -1], [-1, 1]], k=0\noutput9: 3\n--------\ninput10: grid=[[10, 20], [30, 40]], k=60\noutput10: 3\n", "input_output_value": ["\ninput1: grid=[[1, 2], [3, 4]], k=10\noutput1: 4\n", "\ninput2: grid=[[0]], k=0\noutput2: 1\n", "\ninput3: grid=[[1, 1], [1, 1]], k=2\noutput3: 3\n"], "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    vector<vector<int>> input1 = {{1, 2}, {3, 4}};\n    cout << countSubmatrices(input1, 10) << endl;\n\n    vector<vector<int>> input2 = {{0}};\n    cout << countSubmatrices(input2, 0) << endl;\n\n    vector<vector<int>> input3 = {{1, 1}, {1, 1}};\n    cout << countSubmatrices(input3, 2) << endl;\n\n    vector<vector<int>> input4 = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};\n    cout << countSubmatrices(input4, 45) << endl;\n\n    vector<vector<int>> input5 = {{-1, -2}, {-3, -4}};\n    cout << countSubmatrices(input5, -5) << endl;\n\n    vector<vector<int>> input6 = {{5, 5}, {5, 5}};\n    cout << countSubmatrices(input6, 25) << endl;\n\n    vector<vector<int>> input7 = {{0, 0}, {0, 0}};\n    cout << countSubmatrices(input7, 0) << endl;\n\n    vector<vector<int>> input8 = {{1}};\n    cout << countSubmatrices(input8, 1) << endl;\n\n    vector<vector<int>> input9 = {{1, -1}, {-1, 1}};\n    cout << countSubmatrices(input9, 0) << endl;\n\n    vector<vector<int>> input10 = {{10, 20}, {30, 40}};\n    cout << countSubmatrices(input10, 60) << endl;\n\n    return 0;\n}", "TAG": "Success"}
{"source_Lan": "python###minimumOperationsToWriteY.py", "source_code_str": "def minimumOperationsToWriteY( grid: List[List[int]]) -> int:\n    cnt1 = [0] * 3\n    cnt2 = [0] * 3\n    n = len(grid)\n    m = n // 2\n    for i, row in enumerate(grid[:m]):\n        cnt1[row[i]] += 1\n        cnt1[row[-1 - i]] += 1\n        for j, x in enumerate(row):\n            if j != i and j != n - 1 - i:\n                cnt2[x] += 1\n    for row in grid[m:]:\n        cnt1[row[m]] += 1\n        for j, x in enumerate(row):\n            if j != m:\n                cnt2[x] += 1\n    max_not_change = 0\n    for i, c1 in enumerate(cnt1):\n        for j, c2 in enumerate(cnt2):\n            if i != j:\n                max_not_change = max(max_not_change, c1 + c2)\n    return n * n - max_not_change", "source_code_block": "", "target_Lan": "cpp###minimumOperationsToWriteY.cpp", "reference_code": "    int minimumOperationsToWriteY(vector<vector<int>> &grid) {\n        int cnt1[3]{}, cnt2[3]{};\n        int n = grid.size();\n        int m = n / 2;\n        for (int i = 0; i < m; i++) {\n            cnt1[grid[i][i]]++;\n            cnt1[grid[i][n - 1 - i]]++;\n            for (int j = 0; j < n; j++) {\n                if (j != i && j != n - 1 - i) {\n                    cnt2[grid[i][j]]++;\n                }\n            }\n        }\n        for (int i = m; i < n; i++) {\n            cnt1[grid[i][m]]++;\n            for (int j = 0; j < n; j++) {\n                if (j != m) {\n                    cnt2[grid[i][j]]++;\n                }\n            }\n        }\n        int max_not_change = 0;\n        for (int i = 0; i < 3; i++) {\n            for (int j = 0; j < 3; j++) {\n                if (i != j) {\n                    max_not_change = max(max_not_change, cnt1[i] + cnt2[j]);\n                }\n            }\n        }\n        return n * n - max_not_change;\n    }", "target_method_signature": "minimumOperationsToWriteY", "source_method_signature": "minimumOperationsToWriteY", "target_allMS": "    int minimumOperationsToWriteY(vector<vector<int>> &grid) {", "source_allMS": "def minimumOperationsToWriteY( grid: List[List[int]]) -> int:", "source_import": "", "target_import": "#include <iostream>\nusing namespace std;", "commentTag": "//", "source_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(minimumOperationsToWriteY([[0]]))                    # Minimum size case\n    print(minimumOperationsToWriteY([[1, 1], [1, 1]]))        # Uniform case\n    print(minimumOperationsToWriteY([[0, 1], [1, 0]]))        # Simple diagonal case\n    print(minimumOperationsToWriteY([[0, 1, 2], [1, 2, 0], [2, 0, 1]])) # All elements different\n    print(minimumOperationsToWriteY([[0, 2, 0], [1, 1, 2], [2, 0, 1]])) # Mixed case\n    print(minimumOperationsToWriteY([[1, 0, 1], [0, 1, 0], [1, 0, 1]])) # Checkerboard pattern\n    print(minimumOperationsToWriteY([[2, 2, 2], [2, 0, 2], [2, 2, 2]])) # One element different\n    print(minimumOperationsToWriteY([[1, 0, 2, 1], [0, 1, 2, 0], [2, 0, 1, 1], [1, 2, 0, 1]])) # Even sized grid\n    print(minimumOperationsToWriteY([[0, 1, 2, 1], [1, 0, 1, 1], [0, 2, 0, 2], [1, 1, 2, 0]])) # Complex pattern\n    print(minimumOperationsToWriteY([[1, 1, 1], [1, 1, 1], [1, 1, 1]])) # Large uniform grid", "all_input_output_value": "\ninput1: grid=[[0]]\noutput1: 0\n--------\ninput2: grid=[[1, 1], [1, 1]]\noutput2: 1\n--------\ninput3: grid=[[0, 1], [1, 0]]\noutput3: 1\n--------\ninput4: grid=[[0, 1, 2], [1, 2, 0], [2, 0, 1]]\noutput4: 4\n--------\ninput5: grid=[[0, 2, 0], [1, 1, 2], [2, 0, 1]]\noutput5: 3\n--------\ninput6: grid=[[1, 0, 1], [0, 1, 0], [1, 0, 1]]\noutput6: 3\n--------\ninput7: grid=[[2, 2, 2], [2, 0, 2], [2, 2, 2]]\noutput7: 3\n--------\ninput8: grid=[[1, 0, 2, 1], [0, 1, 2, 0], [2, 0, 1, 1], [1, 2, 0, 1]]\noutput8: 8\n--------\ninput9: grid=[[0, 1, 2, 1], [1, 0, 1, 1], [0, 2, 0, 2], [1, 1, 2, 0]]\noutput9: 8\n--------\ninput10: grid=[[1, 1, 1], [1, 1, 1], [1, 1, 1]]\noutput10: 4\n", "input_output_value": ["\ninput1: grid=[[0]]\noutput1: 0\n", "\ninput2: grid=[[1, 1], [1, 1]]\noutput2: 1\n", "\ninput3: grid=[[0, 1], [1, 0]]\noutput3: 1\n"], "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    vector<vector<int>> grid1 = {{0}};\n    vector<vector<int>> grid2 = {{1, 1}, {1, 1}};\n    vector<vector<int>> grid3 = {{0, 1}, {1, 0}};\n    vector<vector<int>> grid4 = {{0, 1, 2}, {1, 2, 0}, {2, 0, 1}};\n    vector<vector<int>> grid5 = {{0, 2, 0}, {1, 1, 2}, {2, 0, 1}};\n    vector<vector<int>> grid6 = {{1, 0, 1}, {0, 1, 0}, {1, 0, 1}};\n    vector<vector<int>> grid7 = {{2, 2, 2}, {2, 0, 2}, {2, 2, 2}};\n    vector<vector<int>> grid8 = {{1, 0, 2, 1}, {0, 1, 2, 0}, {2, 0, 1, 1}, {1, 2, 0, 1}};\n    vector<vector<int>> grid9 = {{0, 1, 2, 1}, {1, 0, 1, 1}, {0, 2, 0, 2}, {1, 1, 2, 0}};\n    vector<vector<int>> grid10 = {{1, 1, 1}, {1, 1, 1}, {1, 1, 1}};\n    \n    cout << minimumOperationsToWriteY(grid1) << endl;\n    cout << minimumOperationsToWriteY(grid2) << endl;\n    cout << minimumOperationsToWriteY(grid3) << endl;\n    cout << minimumOperationsToWriteY(grid4) << endl;\n    cout << minimumOperationsToWriteY(grid5) << endl;\n    cout << minimumOperationsToWriteY(grid6) << endl;\n    cout << minimumOperationsToWriteY(grid7) << endl;\n    cout << minimumOperationsToWriteY(grid8) << endl;\n    cout << minimumOperationsToWriteY(grid9) << endl;\n    cout << minimumOperationsToWriteY(grid10) << endl;\n\n    return 0;\n}", "TAG": "Success"}
{"source_Lan": "python###maximumLengthSubstring.py", "source_code_str": "def maximumLengthSubstring( s: str) -> int:\n    ans = left = 0\n    cnt = Counter()\n    for i, c in enumerate(s):\n        cnt[c] += 1\n        while cnt[c] > 2:\n            cnt[s[left]] -= 1\n            left += 1\n        ans = max(ans, i - left + 1)\n    return ans", "source_code_block": "", "target_Lan": "cpp###maximumLengthSubstring.cpp", "reference_code": "    int maximumLengthSubstring(string s) {\n        int ans = 0, left = 0, cnt[26]{};\n        for (int i = 0; i < s.length(); i++) {\n            int b = s[i] - 'a';\n            cnt[b]++;\n            while (cnt[b] > 2) {\n                cnt[s[left++] - 'a']--;\n            }\n            ans = max(ans, i - left + 1);\n        }\n        return ans;\n    }", "target_method_signature": "maximumLengthSubstring", "source_method_signature": "maximumLengthSubstring", "target_allMS": "    int maximumLengthSubstring(string s) {", "source_allMS": "def maximumLengthSubstring( s: str) -> int:", "source_import": "", "target_import": "#include <iostream>\nusing namespace std;", "commentTag": "//", "source_code_shell": "from collections import Counter\n# TOFILL\nif __name__ == \"__main__\":\n    print(maximumLengthSubstring(\"abcdef\"))       # No characters repeat\n    print(maximumLengthSubstring(\"aaabbb\"))      # Two characters, three repetitions\n    print(maximumLengthSubstring(\"abcabcabc\"))   # Two characters, repetitions exceeding two\n    print(maximumLengthSubstring(\"zzzzzz\"))      # Single repeated character\n    print(maximumLengthSubstring(\"\"))             # Edge case: empty string\n    print(maximumLengthSubstring(\"aabcc\"))       # Two characters, valid length of substring is 4\n    print(maximumLengthSubstring(\"aabbccdde\"))   # Longer string with more valid characters\n    print(maximumLengthSubstring(\"aabb\"))        # Exactly two of two characters\n    print(maximumLengthSubstring(\"ac\"))          # Simple case: two different characters\n    print(maximumLengthSubstring(\"bbaaaac\"))     # Mixed case with maximum in between", "all_input_output_value": "\ninput1: s=\"abcdef\"\noutput1: 6\n--------\ninput2: s=\"aaabbb\"\noutput2: 4\n--------\ninput3: s=\"abcabcabc\"\noutput3: 6\n--------\ninput4: s=\"zzzzzz\"\noutput4: 2\n--------\ninput5: s=\"\"\noutput5: 0\n--------\ninput6: s=\"aabcc\"\noutput6: 5\n--------\ninput7: s=\"aabbccdde\"\noutput7: 9\n--------\ninput8: s=\"aabb\"\noutput8: 4\n--------\ninput9: s=\"ac\"\noutput9: 2\n--------\ninput10: s=\"bbaaaac\"\noutput10: 4\n", "input_output_value": ["\ninput1: s=\"abcdef\"\noutput1: 6\n", "\ninput2: s=\"aaabbb\"\noutput2: 4\n", "\ninput3: s=\"abcabcabc\"\noutput3: 6\n"], "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <string>\n// TOFILL\nint main() {\n    cout << maximumLengthSubstring(\"abcdef\") << endl;\n    cout << maximumLengthSubstring(\"aaabbb\") << endl;\n    cout << maximumLengthSubstring(\"abcabcabc\") << endl;\n    cout << maximumLengthSubstring(\"zzzzzz\") << endl;\n    cout << maximumLengthSubstring(\"\") << endl;\n    cout << maximumLengthSubstring(\"aabcc\") << endl;\n    cout << maximumLengthSubstring(\"aabbccdde\") << endl;\n    cout << maximumLengthSubstring(\"aabb\") << endl;\n    cout << maximumLengthSubstring(\"ac\") << endl;\n    cout << maximumLengthSubstring(\"bbaaaac\") << endl;\n}", "TAG": "Success"}
{"source_Lan": "python###compressedString.py", "source_code_str": "def compressedString( word: str) -> str:\n    t = []\n    i0 = -1\n    for i, c in enumerate(word):\n        if i + 1 == len(word) or c != word[i + 1]:\n            k, rem = divmod(i - i0, 9)\n            t.append((\"9\" + c) * k)\n            if rem:\n                t.append(str(rem))\n                t.append(c)\n            i0 = i\n    return ''.join(t)", "source_code_block": "", "target_Lan": "cpp###compressedString.cpp", "reference_code": "    string compressedString(string word) {\n        string t;\n        int i0 = -1;\n        for (int i = 0; i < word.length(); i++) {\n            char c = word[i];\n            if (i + 1 == word.length() || c != word[i + 1]) {\n                int k = i - i0;\n                for (int j = 0; j < k / 9; j++) {\n                    t += '9';\n                    t += c;\n                }\n                if (k % 9) {\n                    t += '0' + (k % 9);\n                    t += c;\n                }\n                i0 = i;\n            }\n        }\n        return t;\n    }", "target_method_signature": "compressedString", "source_method_signature": "compressedString", "target_allMS": "    string compressedString(string word) {", "source_allMS": "def compressedString( word: str) -> str:", "source_import": "", "target_import": "#include <iostream>\nusing namespace std;", "commentTag": "//", "source_code_shell": "# TOFILL\nif __name__ == \"__main__\":\n    inputs = [\n        \"\",                           # Test input 1: Empty string\n        \"a\",                          # Test input 2: Single character\n        \"aaa\",                        # Test input 3: Three 'a'\n        \"aaaaaaaaa\",                 # Test input 4: Nine 'a'\n        \"aaaaaaaaaa\",                # Test input 5: Ten 'a'\n        \"bbbbaaaacccccdd\",          # Test input 6: Mixed character counts\n        \"xxxxxxxxxxxxxx\",            # Test input 7: Fourteen 'x'\n        \"abcde\",                      # Test input 8: All unique characters\n        \"aaabbbccc\",                 # Test input 9: Groups of three\n        \"aaaaaaabbb\"                 # Test input 10: Mixed counts\n    ]\n    for input_str in inputs:\n        print(f\"Input: '{input_str}' -> Compressed: '{compressedString(input_str)}'\")", "all_input_output_value": "\ninput1: word=''\noutput1: ''\n--------\ninput2: word='a'\noutput2: '1a'\n--------\ninput3: word='aaa'\noutput3: '3a'\n--------\ninput4: word='aaaaaaaaa'\noutput4: '9a'\n--------\ninput5: word='aaaaaaaaaa'\noutput5: '9a1a'\n--------\ninput6: word='bbbbaaaacccccdd'\noutput6: '4b4a5c2d'\n--------\ninput7: word='xxxxxxxxxxxxxx'\noutput7: '9x5x'\n--------\ninput8: word='abcde'\noutput8: '1a1b1c1d1e'\n--------\ninput9: word='aaabbbccc'\noutput9: '3a3b3c'\n--------\ninput10: word='aaaaaaabbb'\noutput10: '7a3b'\n", "input_output_value": ["\ninput1: word=''\noutput1: ''\n", "\ninput2: word='a'\noutput2: '1a'\n", "\ninput3: word='aaa'\noutput3: '3a'\n"], "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <string>\n// TOFILL\nint main() {\n    cout << compressedString(\"\") << endl; // Test input 1: word=''\n    cout << compressedString(\"a\") << endl; // Test input 2: word='a'\n    cout << compressedString(\"aaa\") << endl; // Test input 3: word='aaa'\n    cout << compressedString(\"aaaaaaaaa\") << endl; // Test input 4: word='aaaaaaaaa'\n    cout << compressedString(\"aaaaaaaaaa\") << endl; // Test input 5: word='aaaaaaaaaa'\n    cout << compressedString(\"bbbbaaaacccccdd\") << endl; // Test input 6: word='bbbbaaaacccccdd'\n    cout << compressedString(\"xxxxxxxxxxxxxx\") << endl; // Test input 7: word='xxxxxxxxxxxxxx'\n    cout << compressedString(\"abcde\") << endl; // Test input 8: word='abcde'\n    cout << compressedString(\"aaabbbccc\") << endl; // Test input 9: word='aaabbbccc'\n    cout << compressedString(\"aaaaaaabbb\") << endl; // Test input 10: word='aaaaaaabbb'\n}", "TAG": "Success"}
{"source_Lan": "python###numberOfChild.py", "source_code_str": "def numberOfChild( n: int, k: int) -> int:\n    k, t = divmod(k, n - 1)\n    return n - t - 1 if k % 2 else t", "source_code_block": "", "target_Lan": "cpp###numberOfChild.cpp", "reference_code": "   int numberOfChild(int n, int k) {\n       int a = k / (n - 1), b = k % (n - 1);\n       return (a & 1) == 0 ? b : n - 1 - b;\n   }", "target_method_signature": "numberOfChild", "source_method_signature": "numberOfChild", "target_allMS": "   int numberOfChild(int n, int k) {", "source_allMS": "def numberOfChild( n: int, k: int) -> int:", "source_import": "", "target_import": "#include <iostream>\nusing namespace std;", "commentTag": "//", "source_code_shell": "# TOFILL\nif __name__ == \"__main__\":\n    print(numberOfChild(2, 0))   # Expected output: 0\n    print(numberOfChild(2, 1))   # Expected output: 1\n    print(numberOfChild(2, 2))   # Expected output: 0\n    print(numberOfChild(3, 3))   # Expected output: 0\n    print(numberOfChild(3, 4))   # Expected output: 1\n    print(numberOfChild(4, 8))   # Expected output: 0\n    print(numberOfChild(4, 9))   # Expected output: 2\n    print(numberOfChild(5, 12))  # Expected output: 2\n    print(numberOfChild(5, 13))  # Expected output: 3\n    print(numberOfChild(10, 99)) # Expected output: <Some result>", "all_input_output_value": "\ninput1: n=2, k=0\noutput1: 0\n--------\ninput2: n=2, k=1\noutput2: 1\n--------\ninput3: n=2, k=2\noutput3: 0\n--------\ninput4: n=3, k=3\noutput4: 1\n--------\ninput5: n=3, k=4\noutput5: 0\n--------\ninput6: n=4, k=8\noutput6: 2\n--------\ninput7: n=4, k=9\noutput7: 3\n--------\ninput8: n=5, k=12\noutput8: 3\n--------\ninput9: n=5, k=13\noutput9: 4\n--------\ninput10: n=10, k=99\noutput10: 9\n", "input_output_value": ["\ninput1: n=2, k=0\noutput1: 0\n", "\ninput2: n=2, k=1\noutput2: 1\n", "\ninput3: n=2, k=2\noutput3: 0\n"], "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n// TOFILL\nint main() {\n    cout << numberOfChild(2, 0) << endl;\n    cout << numberOfChild(2, 1) << endl;\n    cout << numberOfChild(2, 2) << endl;\n    cout << numberOfChild(3, 3) << endl;\n    cout << numberOfChild(3, 4) << endl;\n    cout << numberOfChild(4, 8) << endl;\n    cout << numberOfChild(4, 9) << endl;\n    cout << numberOfChild(5, 12) << endl;\n    cout << numberOfChild(5, 13) << endl;\n    cout << numberOfChild(10, 99) << endl;\n}", "TAG": "Success"}
{"source_Lan": "python###triangleType.py", "source_code_str": "def triangleType( nums: List[int]) -> str:\n    nums.sort()\n    x, y, z = nums\n    if x + y <= z:  \n        return \"none\"\n    if x == z:  \n        return \"equilateral\"\n    if x == y or y == z:\n        return \"isosceles\"\n    return \"scalene\"", "source_code_block": "", "target_Lan": "cpp###triangleType.cpp", "reference_code": "    string triangleType(vector<int> &nums) {\n        sort(nums.begin(), nums.end());\n        int x = nums[0], y = nums[1], z = nums[2];\n        if (x + y <= z) { \n            return \"none\";\n        }\n        if (x == z) { \n            return \"equilateral\";\n        }\n        if (x == y || y == z) {\n            return \"isosceles\";\n        }\n        return \"scalene\";\n    }", "target_method_signature": "triangleType", "source_method_signature": "triangleType", "target_allMS": "    string triangleType(vector<int> &nums) {", "source_allMS": "def triangleType( nums: List[int]) -> str:", "source_import": "", "target_import": "#include <iostream>\nusing namespace std;", "commentTag": "//", "source_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    test_inputs = [\n        [3, 4, 5],  # valid scalene triangle\n        [2, 2, 2],  # valid equilateral triangle\n        [1, 1, 2],  # cannot form a triangle (isosceles check)\n        [5, 5, 8],  # valid isosceles triangle\n        [3, 3, 7],  # cannot form a triangle (isosceles check)\n        [2, 3, 4],  # valid scalene triangle\n        [6, 7, 12], # cannot form a triangle (scalene check)\n        [10, 10, 10], # valid equilateral triangle\n        [1, 2, 3],  # cannot form a triangle (none check)\n        [1, 2, 2],  # valid isosceles triangle\n    ]\n    for nums in test_inputs:\n        print(f\"Input: {nums}, Triangle Type: {triangleType(nums)}\")", "all_input_output_value": "\ninput1: nums=[3, 4, 5]\noutput1: scalene\n--------\ninput2: nums=[2, 2, 2]\noutput2: equilateral\n--------\ninput3: nums=[1, 1, 2]\noutput3: none\n--------\ninput4: nums=[5, 5, 8]\noutput4: isosceles\n--------\ninput5: nums=[3, 3, 7]\noutput5: none\n--------\ninput6: nums=[2, 3, 4]\noutput6: scalene\n--------\ninput7: nums=[6, 7, 12]\noutput7: scalene\n--------\ninput8: nums=[10, 10, 10]\noutput8: equilateral\n--------\ninput9: nums=[1, 2, 3]\noutput9: none\n--------\ninput10: nums=[1, 2, 2]\noutput10: isosceles\n", "input_output_value": ["\ninput1: nums=[3, 4, 5]\noutput1: scalene\n", "\ninput2: nums=[2, 2, 2]\noutput2: equilateral\n", "\ninput3: nums=[1, 1, 2]\noutput3: none\n"], "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n// TOFILL\nint main() {\n    vector<int> input1 = {3, 4, 5};\n    vector<int> input2 = {2, 2, 2};\n    vector<int> input3 = {1, 1, 2};\n    vector<int> input4 = {5, 5, 8};\n    vector<int> input5 = {3, 3, 7};\n    vector<int> input6 = {2, 3, 4};\n    vector<int> input7 = {6, 7, 12};\n    vector<int> input8 = {10, 10, 10};\n    vector<int> input9 = {1, 2, 3};\n    vector<int> input10 = {1, 2, 2};\n\n    cout << triangleType(input1) << endl;\n    cout << triangleType(input2) << endl;\n    cout << triangleType(input3) << endl;\n    cout << triangleType(input4) << endl;\n    cout << triangleType(input5) << endl;\n    cout << triangleType(input6) << endl;\n    cout << triangleType(input7) << endl;\n    cout << triangleType(input8) << endl;\n    cout << triangleType(input9) << endl;\n    cout << triangleType(input10) << endl;\n\n    return 0;\n}", "TAG": "Success"}
{"source_Lan": "python###minOperations.py", "source_code_str": "def minOperations( h: List[int], k: int) -> int:\n    ans = 0\n    heapify(h)\n    while h[0] < k:\n        x = heappop(h)\n        heapreplace(h, x * 2 + h[0])\n        ans += 1\n    return ans", "source_code_block": "", "target_Lan": "cpp###minOperations.cpp", "reference_code": "    int minOperations(vector<int> nums, int k) {\n        int ans = 0;\n        priority_queue<long long, vector<long long>, greater<>> pq;\n        for (int x : nums) {\n            pq.push((long long) x);\n        }\n        while (pq.top() < k) {\n            long long x = pq.top(); pq.pop();\n            long long y = pq.top(); pq.pop();\n            pq.push(x * 2 + y);\n            ans++;\n        }\n        return ans;\n    }", "target_method_signature": "minOperations", "source_method_signature": "minOperations", "target_allMS": "    int minOperations(vector<int> &nums, int k) {", "source_allMS": "def minOperations( h: List[int], k: int) -> int:", "source_import": "", "target_import": "#include <iostream>\nusing namespace std;", "commentTag": "//", "source_code_shell": "from typing import List\nfrom heapq import heapify, heappop, heapreplace\n# TOFILL\nif __name__ == \"__main__\":\n    print(minOperations([3, 1, 4], 5))\n    print(minOperations([2, 2, 2], 5))\n    print(minOperations([1, 2, 3, 4], 15))\n    print(minOperations([10, 20, 30], 10))\n    print(minOperations([2, 2, 1], 5))\n    print(minOperations([5, 1, 1], 10))\n    print(minOperations([100, 50, 25], 200))\n    print(minOperations([1, 1, 1, 1], 4))", "all_input_output_value": "\ninput1: h=[3, 1, 4], k=5\noutput1: 2\n--------\ninput2: h=[2, 2, 2], k=5\noutput2: 2\n--------\ninput3: h=[1, 2, 3, 4], k=15\noutput3: 3\n--------\ninput4: h=[10, 20, 30], k=10\noutput4: 0\n--------\ninput5: h=[2, 2, 1], k=5\noutput5: 2\n--------\ninput6: h=[5, 1, 1], k=10\noutput6: 2\n--------\ninput7: h=[100, 50, 25], k=200\noutput7: 2\n--------\ninput8: h=[1, 1, 1, 1], k=4\noutput8: 3\n", "input_output_value": ["\ninput1: h=[3, 1, 4], k=5\noutput1: 2\n", "\ninput2: h=[2, 2, 2], k=5\noutput2: 2\n", "\ninput3: h=[1, 2, 3, 4], k=15\noutput3: 3\n"], "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <queue>\n// TOFILL\nint main() {\n    cout << minOperations({3, 1, 4}, 5) << endl;\n    cout << minOperations({2, 2, 2}, 5) << endl;\n    cout << minOperations({1, 2, 3, 4}, 15) << endl;\n    cout << minOperations({10, 20, 30}, 10) << endl;\n    cout << minOperations({2, 2, 1}, 5) << endl;\n    cout << minOperations({5, 1, 1}, 10) << endl;\n    cout << minOperations({100, 50, 25}, 200) << endl;\n    cout << minOperations({1, 1, 1, 1}, 4) << endl;\n}", "TAG": "Success"}
{"source_Lan": "python###sumOfPower.py", "source_code_str": "def sumOfPower( nums: List[int], k: int) -> int:\n    MOD = 1_000_000_007\n    n = len(nums)\n    f = [[0] * (n + 1) for _ in range(k + 1)]\n    f[0][0] = 1\n    for i, x in enumerate(nums):\n        for j in range(k, x - 1, -1):\n            for c in range(i + 1, 0, -1):\n                f[j][c] = (f[j][c] + f[j - x][c - 1]) % MOD\n    ans = 0\n    pow2 = 1\n    for i in range(n, 0, -1):\n        ans = (ans + f[k][i] * pow2) % MOD\n        pow2 = pow2 * 2 % MOD\n    return ans", "source_code_block": "", "target_Lan": "cpp###sumOfPower.cpp", "reference_code": "    int sumOfPower(vector<int> &nums, int k) {\n        const int MOD = 1'000'000'007;\n        int n = nums.size();\n        vector<vector<int>> f(k + 1, vector<int>(n + 1));\n        f[0][0] = 1;\n        for (int i = 0; i < n; i++) {\n            for (int j = k; j >= nums[i]; j--) {\n                for (int c = i + 1; c > 0; c--) {\n                    f[j][c] = (f[j][c] + f[j - nums[i]][c - 1]) % MOD;\n                }\n            }\n        }\n        int ans = 0;\n        int pow2 = 1;\n        for (int i = n; i > 0; i--) {\n            ans = (ans + (long long) f[k][i] * pow2) % MOD;\n            pow2 = pow2 * 2 % MOD;\n        }\n        return ans;\n    }", "target_method_signature": "sumOfPower", "source_method_signature": "sumOfPower", "target_allMS": "    int sumOfPower(vector<int> &nums, int k) {", "source_allMS": "def sumOfPower( nums: List[int], k: int) -> int:", "source_import": "", "target_import": "#include <iostream>\nusing namespace std;", "commentTag": "//", "source_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(sumOfPower([], 0))               # Test input 1\n    print(sumOfPower([1], 1))               # Test input 2\n    print(sumOfPower([1, 1], 2))            # Test input 3\n    print(sumOfPower([1, 2], 3))            # Test input 4\n    print(sumOfPower([1, 2, 3], 4))         # Test input 5\n    print(sumOfPower([1, 2, 3, 4], 5))      # Test input 6\n    print(sumOfPower([5, 5, 5], 10))        # Test input 7\n    print(sumOfPower([10, 10, 10, 5], 20))  # Test input 8\n    print(sumOfPower([3, 6, 9], 15))        # Test input 9\n    print(sumOfPower([100, 1, 2], 100))     # Test input 10", "all_input_output_value": "\ninput1: nums=[], k=0\noutput1: 0\n--------\ninput2: nums=[1], k=1\noutput2: 1\n--------\ninput3: nums=[1, 1], k=2\noutput3: 1\n--------\ninput4: nums=[1, 2], k=3\noutput4: 1\n--------\ninput5: nums=[1, 2, 3], k=4\noutput5: 2\n--------\ninput6: nums=[1, 2, 3, 4], k=5\noutput6: 8\n--------\ninput7: nums=[5, 5, 5], k=10\noutput7: 6\n--------\ninput8: nums=[10, 10, 10, 5], k=20\noutput8: 12\n--------\ninput9: nums=[3, 6, 9], k=15\noutput9: 2\n--------\ninput10: nums=[100, 1, 2], k=100\noutput10: 4\n", "input_output_value": ["\ninput1: nums=[], k=0\noutput1: 0\n", "\ninput2: nums=[1], k=1\noutput2: 1\n", "\ninput3: nums=[1, 1], k=2\noutput3: 1\n"], "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    vector<int> nums1 = {};\n    vector<int> nums2 = {1};\n    vector<int> nums3 = {1, 1};\n    vector<int> nums4 = {1, 2};\n    vector<int> nums5 = {1, 2, 3};\n    vector<int> nums6 = {1, 2, 3, 4};\n    vector<int> nums7 = {5, 5, 5};\n    vector<int> nums8 = {10, 10, 10, 5};\n    vector<int> nums9 = {3, 6, 9};\n    vector<int> nums10 = {100, 1, 2};\n\n    cout << sumOfPower(nums1, 0) << endl;\n    cout << sumOfPower(nums2, 1) << endl;\n    cout << sumOfPower(nums3, 2) << endl;\n    cout << sumOfPower(nums4, 3) << endl;\n    cout << sumOfPower(nums5, 4) << endl;\n    cout << sumOfPower(nums6, 5) << endl;\n    cout << sumOfPower(nums7, 10) << endl;\n    cout << sumOfPower(nums8, 20) << endl;\n    cout << sumOfPower(nums9, 15) << endl;\n    cout << sumOfPower(nums10, 100) << endl;\n\n    return 0;\n}", "TAG": "Success"}
{"source_Lan": "python###accountBalanceAfterPurchase.py", "source_code_str": "def accountBalanceAfterPurchase( purchaseAmount: int) -> int:\n    r = purchaseAmount % 10\n    purchaseAmount = purchaseAmount - r if r < 5 else purchaseAmount + 10 - r\n    return 100 - purchaseAmount", "source_code_block": "", "target_Lan": "cpp###accountBalanceAfterPurchase.cpp", "reference_code": "    int accountBalanceAfterPurchase(int purchaseAmount) {\n        int r = purchaseAmount % 10;\n        if (r < 5) {\n            purchaseAmount -= r;\n        } else {\n            purchaseAmount += 10 - r;\n        }\n        return 100 - purchaseAmount;\n    }", "target_method_signature": "accountBalanceAfterPurchase", "source_method_signature": "accountBalanceAfterPurchase", "target_allMS": "    int accountBalanceAfterPurchase(int purchaseAmount) {", "source_allMS": "def accountBalanceAfterPurchase( purchaseAmount: int) -> int:", "source_import": "", "target_import": "#include <iostream>\nusing namespace std;", "commentTag": "//", "source_code_shell": "# TOFILL\nif __name__ == \"__main__\":\n    test_inputs = [0, 5, 12, 37, 99, 100, 1, 3, 9, 15]\n    for amount in test_inputs:\n        print(accountBalanceAfterPurchase(amount))", "all_input_output_value": "\ninput1: purchaseAmount=0\noutput1: 100\n--------\ninput2: purchaseAmount=5\noutput2: 90\n--------\ninput3: purchaseAmount=12\noutput3: 90\n--------\ninput4: purchaseAmount=37\noutput4: 60\n--------\ninput5: purchaseAmount=99\noutput5: 0\n--------\ninput6: purchaseAmount=100\noutput6: 0\n--------\ninput7: purchaseAmount=1\noutput7: 100\n--------\ninput8: purchaseAmount=3\noutput8: 100\n--------\ninput9: purchaseAmount=9\noutput9: 90\n--------\ninput10: purchaseAmount=15\noutput10: 80\n", "input_output_value": ["\ninput1: purchaseAmount=0\noutput1: 100\n", "\ninput2: purchaseAmount=5\noutput2: 90\n", "\ninput3: purchaseAmount=12\noutput3: 90\n"], "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n// TOFILL\nint main() {\n    cout << accountBalanceAfterPurchase(0) << endl;\n    cout << accountBalanceAfterPurchase(5) << endl;\n    cout << accountBalanceAfterPurchase(12) << endl;\n    cout << accountBalanceAfterPurchase(37) << endl;\n    cout << accountBalanceAfterPurchase(99) << endl;\n    cout << accountBalanceAfterPurchase(100) << endl;\n    cout << accountBalanceAfterPurchase(1) << endl;\n    cout << accountBalanceAfterPurchase(3) << endl;\n    cout << accountBalanceAfterPurchase(9) << endl;\n    cout << accountBalanceAfterPurchase(15) << endl;\n}", "TAG": "Success"}
{"source_Lan": "python###maxOperations.py", "source_code_str": "def maxOperations( nums: List[int]) -> int:\n    n, t = len(nums), 0\n    for i in range(1, n, 2):\n        if nums[i] + nums[i - 1] != nums[1] + nums[0]:\n            break\n        t += 1\n    return t", "source_code_block": "", "target_Lan": "cpp###maxOperations.cpp", "reference_code": "    int maxOperations(vector<int>& nums) {\n        int n = nums.size(), t = 0;\n        for (int i = 1; i < n; i += 2) {\n            if (nums[i] + nums[i - 1] != nums[1] + nums[0]) {\n                break;\n            }\n            t++;\n        }\n        return t;\n    }", "target_method_signature": "maxOperations", "source_method_signature": "maxOperations", "target_allMS": "    int maxOperations(vector<int>& nums) {", "source_allMS": "def maxOperations( nums: List[int]) -> int:", "source_import": "", "target_import": "#include <iostream>\nusing namespace std;", "commentTag": "//", "source_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(maxOperations([2, 2, 2, 2]))         # Should return 2\n    print(maxOperations([1, 1, 1, 1]))         # Should return 2\n    print(maxOperations([2, 2, 3, 3]))         # Should return 1\n    print(maxOperations([1, 2, 3]))            # Should return 0\n    print(maxOperations([5]))                   # Should return 0\n    print(maxOperations([]))                    # Should return 0\n    print(maxOperations([1, 2, 2, 1, 2]))      # Should return 2\n    print(maxOperations([7, 7, 7, 8, 7]))      # Should return 2\n    print(maxOperations([10, 10, 10, 20, 10])) # Should return 2\n    print(maxOperations([5, 6, 5, 6]))         # Should return 2", "all_input_output_value": "\ninput1: nums=[2, 2, 2, 2]\noutput1: 2\n--------\ninput2: nums=[1, 1, 1, 1]\noutput2: 2\n--------\ninput3: nums=[2, 2, 3, 3]\noutput3: 1\n--------\ninput4: nums=[1, 2, 3]\noutput4: 0\n--------\ninput5: nums=[5]\noutput5: 0\n--------\ninput6: nums=[]\noutput6: 0\n--------\ninput7: nums=[1, 2, 2, 1, 2]\noutput7: 2\n--------\ninput8: nums=[7, 7, 7, 8, 7]\noutput8: 2\n--------\ninput9: nums=[10, 10, 10, 20, 10]\noutput9: 2\n--------\ninput10: nums=[5, 6, 5, 6]\noutput10: 2\n", "input_output_value": ["\ninput1: nums=[2, 2, 2, 2]\noutput1: 2\n", "\ninput2: nums=[1, 1, 1, 1]\noutput2: 2\n", "\ninput3: nums=[2, 2, 3, 3]\noutput3: 1\n"], "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    vector<int> input1 = {2, 2, 2, 2};\n    vector<int> input2 = {1, 1, 1, 1};\n    vector<int> input3 = {2, 2, 3, 3};\n    vector<int> input4 = {1, 2, 3};\n    vector<int> input5 = {5};\n    vector<int> input6 = {};\n    vector<int> input7 = {1, 2, 2, 1, 2};\n    vector<int> input8 = {7, 7, 7, 8, 7};\n    vector<int> input9 = {10, 10, 10, 20, 10};\n    vector<int> input10 = {5, 6, 5, 6};\n\n    cout << maxOperations(input1) << endl;\n    cout << maxOperations(input2) << endl;\n    cout << maxOperations(input3) << endl;\n    cout << maxOperations(input4) << endl;\n    cout << maxOperations(input5) << endl;\n    cout << maxOperations(input6) << endl;\n    cout << maxOperations(input7) << endl;\n    cout << maxOperations(input8) << endl;\n    cout << maxOperations(input9) << endl;\n    cout << maxOperations(input10) << endl;\n\n    return 0;\n}", "TAG": "Success"}
{"source_Lan": "python###distributeCandies2.py", "source_code_str": "def distributeCandies2( n: int, limit: int) -> int:\n    ans = 0\n    for i in range(min(limit, n) + 1):\n        if n - i > 2 * limit:\n            continue\n        ans += min(n - i, limit) - max(0, n - i - limit) + 1\n    return ans", "source_code_block": "", "target_Lan": "cpp###distributeCandies2.cpp", "reference_code": "    long long distributeCandies2(int n, int limit) {\n        long long ans = 0;\n        for (int i = 0; i <= min(limit, n); i++) {\n            if (n - i > 2 * limit) {\n                continue;\n            }\n            ans += min(n - i, limit) - max(0, n - i - limit) + 1;\n        }\n        return ans;\n    }", "target_method_signature": "distributeCandies2", "source_method_signature": "distributeCandies2", "target_allMS": "    long long distributeCandies2(int n, int limit) {", "source_allMS": "def distributeCandies2( n: int, limit: int) -> int:", "source_import": "", "target_import": "#include <iostream>\nusing namespace std;", "commentTag": "//", "source_code_shell": "# TOFILL\nif __name__ == \"__main__\":\n    test_cases = [\n        (10, 5),\n        (0, 15),\n        (8, 20),\n        (30, 10),\n        (2, 1)\n    ]\n    for n, limit in test_cases:\n        print(distributeCandies2(n, limit))", "all_input_output_value": "\ninput1: n=10, limit=5\noutput1: 21\n--------\ninput2: n=0, limit=15\noutput2: 1\n--------\ninput3: n=8, limit=20\noutput3: 45\n--------\ninput4: n=30, limit=10\noutput4: 1\n--------\ninput5: n=2, limit=1\noutput5: 3\n", "input_output_value": ["\ninput1: n=10, limit=5\noutput1: 21\n", "\ninput2: n=0, limit=15\noutput2: 1\n", "\ninput3: n=8, limit=20\noutput3: 45\n"], "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <algorithm>\n// TOFILL\nint main() {\n    cout << distributeCandies2(10, 5) << endl;  // Test Input 1\n    cout << distributeCandies2(0, 15) << endl;   // Test Input 2\n    cout << distributeCandies2(8, 20) << endl;   // Test Input 3\n    cout << distributeCandies2(30, 10) << endl;  // Test Input 4\n    cout << distributeCandies2(2, 1) << endl;    // Test Input 5\n}", "TAG": "Success"}
{"source_Lan": "python###distributeCandies.py", "source_code_str": "def distributeCandies( n: int, limit: int) -> int:\n    ans = 0\n    for i in range(limit + 1):\n        for j in range(limit + 1):\n            if i + j > n:\n                break\n            if n - i - j <= limit:\n                ans += 1\n    return ans", "source_code_block": "", "target_Lan": "cpp###distributeCandies.cpp", "reference_code": "    int distributeCandies(int n, int limit) {\n        int ans = 0;\n        for (int i = 0; i <= limit; i++) {\n            for (int j = 0; j <= limit; j++) {\n                if (i + j > n) {\n                    break;\n                }\n                if (n - i - j <= limit) {\n                    ans++;\n                }\n            }\n        }\n        return ans;\n    }", "target_method_signature": "distributeCandies", "source_method_signature": "distributeCandies", "target_allMS": "    int distributeCandies(int n, int limit) {", "source_allMS": "def distributeCandies( n: int, limit: int) -> int:", "source_import": "", "target_import": "#include <iostream>\nusing namespace std;", "commentTag": "//", "source_code_shell": "# TOFILL\nif __name__ == \"__main__\":\n    test_inputs = [(0, 0), (1, 1), (5, 2), (10, 10), (3, 20)]\n    for n, limit in test_inputs:\n        print(distributeCandies(n, limit))", "all_input_output_value": "\ninput1: n=0, limit=0\noutput1: 1\n--------\ninput2: n=1, limit=1\noutput2: 3\n--------\ninput3: n=5, limit=2\noutput3: 3\n--------\ninput4: n=10, limit=10\noutput4: 66\n--------\ninput5: n=3, limit=20\noutput5: 10\n", "input_output_value": ["\ninput1: n=0, limit=0\noutput1: 1\n", "\ninput2: n=1, limit=1\noutput2: 3\n", "\ninput3: n=5, limit=2\noutput3: 3\n"], "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n// TOFILL\nint main() {\n    cout << distributeCandies(0, 0) << endl;\n    cout << distributeCandies(1, 1) << endl;\n    cout << distributeCandies(5, 2) << endl;\n    cout << distributeCandies(10, 10) << endl;\n    cout << distributeCandies(3, 20) << endl;\n}", "TAG": "Success"}
{"source_Lan": "python###maximumBinaryString.py", "source_code_str": "def maximumBinaryString( binary: str) -> str:\n    n = len(binary)\n    s = list(binary)\n    j = 0\n    for i in range(n):\n        if s[i] == '0':\n            while j <= i or (j < n and s[j] == '1'):\n                j += 1\n            if j < n:\n                s[j] = '1'\n                s[i] = '1'\n                s[i + 1] = '0'\n    return ''.join(s)", "source_code_block": "", "target_Lan": "cpp###maximumBinaryString.cpp", "reference_code": "    string maximumBinaryString(string binary) {\n        int n = binary.size();\n        int j = 0;\n        for (int i = 0; i < n; i++) {\n            if (binary[i] == '0') {\n                while (j <= i || (j < n && binary[j] == '1')) {\n                    j++;\n                }\n                if (j < n) {\n                    binary[j] = '1';\n                    binary[i] = '1';\n                    binary[i + 1] = '0';\n                }\n            }\n        }\n        return binary;\n    }", "target_method_signature": "maximumBinaryString", "source_method_signature": "maximumBinaryString", "target_allMS": "    string maximumBinaryString(string binary) {", "source_allMS": "def maximumBinaryString( binary: str) -> str:", "source_import": "", "target_import": "#include <iostream>\nusing namespace std;", "commentTag": "//", "source_code_shell": "# TOFILL\nif __name__ == \"__main__\":\n    test_inputs = [\n        \"\",\n        \"1111\",\n        \"0\",\n        \"1000\",\n        \"11001100\",\n        \"1110\",\n        \"1010101\",\n        \"0000\",\n        \"1110\",\n        \"110\"\n    ]\n    for binary in test_inputs:\n        print(maximumBinaryString(binary))", "all_input_output_value": "\ninput1: binary=\"\"\noutput1: 1111\n--------\ninput2: binary=\"1111\"\noutput2: 0\n--------\ninput3: binary=\"0\"\noutput3: 1110\n--------\ninput4: binary=\"1000\"\noutput4: 11111011\n--------\ninput5: binary=\"11001100\"\noutput5: 1110\n--------\ninput6: binary=\"1110\"\noutput6: 1110111\n--------\ninput7: binary=\"1010101\"\noutput7: 1110\n--------\ninput8: binary=\"0000\"\noutput8: 1110\n--------\ninput9: binary=\"1110\"\noutput9: 110\n--------\ninput10: binary=\"110\"\noutput10: 110\n", "input_output_value": ["\ninput1: binary=\"\"\noutput1: 1111\n", "\ninput2: binary=\"1111\"\noutput2: 0\n", "\ninput3: binary=\"0\"\noutput3: 1110\n"], "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <string>\n// TOFILL\nint main() {\n    cout << maximumBinaryString(\"\") << endl;\n    cout << maximumBinaryString(\"1111\") << endl;\n    cout << maximumBinaryString(\"0\") << endl;\n    cout << maximumBinaryString(\"1000\") << endl;\n    cout << maximumBinaryString(\"11001100\") << endl;\n    cout << maximumBinaryString(\"1110\") << endl;\n    cout << maximumBinaryString(\"1010101\") << endl;\n    cout << maximumBinaryString(\"0000\") << endl;\n    cout << maximumBinaryString(\"1110\") << endl;\n    cout << maximumBinaryString(\"110\") << endl;\n}", "TAG": "Success"}
{"source_Lan": "python###maxArrayValue.py", "source_code_str": "def maxArrayValue( nums: List[int]) -> int:\n    for i in range(len(nums) - 2, -1, -1):\n        if nums[i] <= nums[i + 1]:\n            nums[i] += nums[i + 1]\n    return nums[0]", "source_code_block": "", "target_Lan": "cpp###maxArrayValue.cpp", "reference_code": "    long long maxArrayValue(vector<int> nums) {\n        long long sum = nums.back();\n        for (int i = nums.size() - 2; i >= 0; i--) {\n            sum = nums[i] <= sum ? nums[i] + sum : nums[i];\n        }\n        return sum;\n    }", "target_method_signature": "maxArrayValue", "source_method_signature": "maxArrayValue", "target_allMS": "    long long maxArrayValue(vector<int> nums) {", "source_allMS": "def maxArrayValue( nums: List[int]) -> int:", "source_import": "", "target_import": "#include <iostream>\nusing namespace std;", "commentTag": "//", "source_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(maxArrayValue([1, 2, 3, 4, 5]))\n    print(maxArrayValue([5, 4, 3, 2, 1]))\n    print(maxArrayValue([-1, -2, -3, -4, -5]))\n    print(maxArrayValue([5, 10, 15, 10, 5]))\n    print(maxArrayValue([10, 20, 30, 40]))\n    print(maxArrayValue([0]))\n    print(maxArrayValue([50, 75, 100, 75, 50]))\n    print(maxArrayValue([1, 3, 5, 7, 9]))\n    print(maxArrayValue([2, 2, 2, 2, 2]))\n    print(maxArrayValue([10, 20, 5, 15, 25]))", "all_input_output_value": "\ninput1: nums=[1, 2, 3, 4, 5]\noutput1: 15\n--------\ninput2: nums=[5, 4, 3, 2, 1]\noutput2: 5\n--------\ninput3: nums=[-1, -2, -3, -4, -5]\noutput3: -1\n--------\ninput4: nums=[5, 10, 15, 10, 5]\noutput4: 30\n--------\ninput5: nums=[10, 20, 30, 40]\noutput5: 100\n--------\ninput6: nums=[0]\noutput6: 0\n--------\ninput7: nums=[50, 75, 100, 75, 50]\noutput7: 225\n--------\ninput8: nums=[1, 3, 5, 7, 9]\noutput8: 25\n--------\ninput9: nums=[2, 2, 2, 2, 2]\noutput9: 10\n--------\ninput10: nums=[10, 20, 5, 15, 25]\noutput10: 75\n", "input_output_value": ["\ninput1: nums=[1, 2, 3, 4, 5]\noutput1: 15\n", "\ninput2: nums=[5, 4, 3, 2, 1]\noutput2: 5\n", "\ninput3: nums=[-1, -2, -3, -4, -5]\noutput3: -1\n"], "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    cout << maxArrayValue({1, 2, 3, 4, 5}) << endl;\n    cout << maxArrayValue({5, 4, 3, 2, 1}) << endl;\n    cout << maxArrayValue({-1, -2, -3, -4, -5}) << endl;\n    cout << maxArrayValue({5, 10, 15, 10, 5}) << endl;\n    cout << maxArrayValue({10, 20, 30, 40}) << endl;\n    cout << maxArrayValue({0}) << endl;\n    cout << maxArrayValue({50, 75, 100, 75, 50}) << endl;\n    cout << maxArrayValue({1, 3, 5, 7, 9}) << endl;\n    cout << maxArrayValue({2, 2, 2, 2, 2}) << endl;\n    cout << maxArrayValue({10, 20, 5, 15, 25}) << endl;\n}", "TAG": "Success"}
{"source_Lan": "python###maxNumberOfAlloys.py", "source_code_str": "def maxNumberOfAlloys( n: int, k: int, budget: int, composition: List[List[int]], stock: List[int], cost: List[int]) -> int:\n    left, right, ans = 1, 2 * 10**8, 0\n    while left <= right:\n        mid = (left + right) // 2\n        valid = False\n        for i in range(k):\n            spend = 0\n            for j, (composition_j, stock_j, cost_j) in enumerate(zip(composition[i], stock, cost)):\n                spend += max(composition_j * mid - stock_j, 0) * cost_j\n            if spend <= budget:\n                valid = True\n                break\n        if valid:\n            ans = mid\n            left = mid + 1\n        else:\n            right = mid - 1\n    return ans", "source_code_block": "", "target_Lan": "cpp###maxNumberOfAlloys.cpp", "reference_code": "    int maxNumberOfAlloys(int n, int k, int budget, vector<vector<int>>& composition, vector<int>& stock, vector<int>& cost) {\n        int left = 1, right = 2e8, ans = 0;\n        while (left <= right) {\n            int mid = (left + right) / 2;\n            bool valid = false;\n            for (int i = 0; i < k; ++i) {\n                long long spend = 0;\n                for (int j = 0; j < n; ++j) {\n                    spend += max(static_cast<long long>(composition[i][j]) * mid - stock[j], 0LL) * cost[j];\n                }\n                if (spend <= budget) {\n                    valid = true;\n                    break;\n                }\n            }\n            if (valid) {\n                ans = mid;\n                left = mid + 1;\n            }\n            else {\n                right = mid - 1;\n            }\n        }\n        return ans;\n    }", "target_method_signature": "maxNumberOfAlloys", "source_method_signature": "maxNumberOfAlloys", "target_allMS": "    int maxNumberOfAlloys(int n, int k, int budget, vector<vector<int>>& composition, vector<int>& stock, vector<int>& cost) {", "source_allMS": "def maxNumberOfAlloys( n: int, k: int, budget: int, composition: List[List[int]], stock: List[int], cost: List[int]) -> int:", "source_import": "", "target_import": "#include <iostream>\nusing namespace std;", "commentTag": "//", "source_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(maxNumberOfAlloys(1, 1, 0, [[0]], [0], [1]))\n    print(maxNumberOfAlloys(1, 1, 1, [[1]], [0], [1]))\n    print(maxNumberOfAlloys(1, 1, 10, [[1]], [10], [2]))\n    print(maxNumberOfAlloys(2, 1, 100, [[1, 1]], [50, 50], [2, 3]))\n    print(maxNumberOfAlloys(2, 2, 100, [[1, 0], [0, 1]], [50, 50], [2, 3]))\n    print(maxNumberOfAlloys(3, 2, 100, [[1, 2, 3], [0, 1, 2]], [100, 100, 100], [10, 5, 2]))\n    print(maxNumberOfAlloys(2, 2, 50, [[2, 1], [1, 2]], [0, 0], [10, 10]))\n    print(maxNumberOfAlloys(3, 1, 100, [[2, 5, 3]], [5, 5, 5], [10, 5, 2]))\n    print(maxNumberOfAlloys(2, 2, 500, [[1, 1], [2, 2]], [25, 25], [5, 5]))\n    print(maxNumberOfAlloys(3, 3, 1000, [[2, 2, 2], [1, 1, 1], [3, 3, 3]], [100, 100, 100], [10, 20, 5]))", "all_input_output_value": "\ninput1: n=1, k=1, budget=0, composition=[[0]], stock=[0], cost=[1]\noutput1: 200000000\n--------\ninput2: n=1, k=1, budget=1, composition=[[1]], stock=[0], cost=[1]\noutput2: 1\n--------\ninput3: n=1, k=1, budget=10, composition=[[1]], stock=[10], cost=[2]\noutput3: 15\n--------\ninput4: n=2, k=1, budget=100, composition=[[1, 1]], stock=[50, 50], cost=[2, 3]\noutput4: 70\n--------\ninput5: n=2, k=2, budget=100, composition=[[1, 0], [0, 1]], stock=[50, 50], cost=[2, 3]\noutput5: 100\n--------\ninput6: n=3, k=2, budget=100, composition=[[1, 2, 3], [0, 1, 2]], stock=[100, 100, 100], cost=[10, 5, 2]\noutput6: 75\n--------\ninput7: n=2, k=2, budget=50, composition=[[2, 1], [1, 2]], stock=[0, 0], cost=[10, 10]\noutput7: 1\n--------\ninput8: n=3, k=1, budget=100, composition=[[2, 5, 3]], stock=[5, 5, 5], cost=[10, 5, 2]\noutput8: 3\n--------\ninput9: n=2, k=2, budget=500, composition=[[1, 1], [2, 2]], stock=[25, 25], cost=[5, 5]\noutput9: 75\n--------\ninput10: n=3, k=3, budget=1000, composition=[[2, 2, 2], [1, 1, 1], [3, 3, 3]], stock=[100, 100, 100], cost=[10, 20, 5]\noutput10: 128\n", "input_output_value": ["\ninput1: n=1, k=1, budget=0, composition=[[0]], stock=[0], cost=[1]\noutput1: 200000000\n", "\ninput2: n=1, k=1, budget=1, composition=[[1]], stock=[0], cost=[1]\noutput2: 1\n", "\ninput3: n=1, k=1, budget=10, composition=[[1]], stock=[10], cost=[2]\noutput3: 15\n"], "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    vector<vector<int>> composition1 = {{0}};\n    vector<int> stock1 = {0};\n    vector<int> cost1 = {1};\n    cout << maxNumberOfAlloys(1, 1, 0, composition1, stock1, cost1) << endl;\n\n    vector<vector<int>> composition2 = {{1}};\n    vector<int> stock2 = {0};\n    vector<int> cost2 = {1};\n    cout << maxNumberOfAlloys(1, 1, 1, composition2, stock2, cost2) << endl;\n\n    vector<vector<int>> composition3 = {{1}};\n    vector<int> stock3 = {10};\n    vector<int> cost3 = {2};\n    cout << maxNumberOfAlloys(1, 1, 10, composition3, stock3, cost3) << endl;\n\n    vector<vector<int>> composition4 = {{1, 1}};\n    vector<int> stock4 = {50, 50};\n    vector<int> cost4 = {2, 3};\n    cout << maxNumberOfAlloys(2, 1, 100, composition4, stock4, cost4) << endl;\n\n    vector<vector<int>> composition5 = {{1, 0}, {0, 1}};\n    vector<int> stock5 = {50, 50};\n    vector<int> cost5 = {2, 3};\n    cout << maxNumberOfAlloys(2, 2, 100, composition5, stock5, cost5) << endl;\n\n    vector<vector<int>> composition6 = {{1, 2, 3}, {0, 1, 2}};\n    vector<int> stock6 = {100, 100, 100};\n    vector<int> cost6 = {10, 5, 2};\n    cout << maxNumberOfAlloys(3, 2, 100, composition6, stock6, cost6) << endl;\n\n    vector<vector<int>> composition7 = {{2, 1}, {1, 2}};\n    vector<int> stock7 = {0, 0};\n    vector<int> cost7 = {10, 10};\n    cout << maxNumberOfAlloys(2, 2, 50, composition7, stock7, cost7) << endl;\n\n    vector<vector<int>> composition8 = {{2, 5, 3}};\n    vector<int> stock8 = {5, 5, 5};\n    vector<int> cost8 = {10, 5, 2};\n    cout << maxNumberOfAlloys(3, 1, 100, composition8, stock8, cost8) << endl;\n\n    vector<vector<int>> composition9 = {{1, 1}, {2, 2}};\n    vector<int> stock9 = {25, 25};\n    vector<int> cost9 = {5, 5};\n    cout << maxNumberOfAlloys(2, 2, 500, composition9, stock9, cost9) << endl;\n\n    vector<vector<int>> composition10 = {{2, 2, 2}, {1, 1, 1}, {3, 3, 3}};\n    vector<int> stock10 = {100, 100, 100};\n    vector<int> cost10 = {10, 20, 5};\n    cout << maxNumberOfAlloys(3, 3, 1000, composition10, stock10, cost10) << endl;\n\n    return 0;\n}", "TAG": "Success"}
{"source_Lan": "python###alternatingSubarray.py", "source_code_str": "def alternatingSubarray( nums: List[int]) -> int:\n    res = -1\n    n = len(nums)\n    for firstIndex in range(n):\n        for i in range(firstIndex + 1, n):\n            length = i - firstIndex + 1\n            if nums[i] - nums[firstIndex] == (length - 1) % 2:\n                res = max(res, length)\n            else:\n                break\n    return res", "source_code_block": "", "target_Lan": "cpp###alternatingSubarray.cpp", "reference_code": "    int alternatingSubarray(vector<int>& nums) {\n        int res = -1;\n        int n = nums.size();\n        for (int firstIndex = 0; firstIndex < n; firstIndex++) {\n            for (int i = firstIndex + 1; i < n; i++) {\n                int length = i - firstIndex + 1;\n                if (nums[i] - nums[firstIndex] == (length - 1) % 2) {\n                    res = max(res, length);\n                } else {\n                    break;\n                }\n            }\n        }\n        return res;\n    }", "target_method_signature": "alternatingSubarray", "source_method_signature": "alternatingSubarray", "target_allMS": "    int alternatingSubarray(vector<int>& nums) {", "source_allMS": "def alternatingSubarray( nums: List[int]) -> int:", "source_import": "", "target_import": "#include <iostream>\nusing namespace std;", "commentTag": "//", "source_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(alternatingSubarray([]))                         # Test with an empty array\n    print(alternatingSubarray([1]))                        # Single element array\n    print(alternatingSubarray([1, 2, 3]))                  # No alternating pattern\n    print(alternatingSubarray([1, 0, 1, 0, 1]))           # Perfect alternating pattern\n    print(alternatingSubarray([1, 0, 1, 0, 1, 2]))        # Alternating pattern then breaks\n    print(alternatingSubarray([0, 1, 0, 1, 0]))           # Perfect alternating pattern with different start\n    print(alternatingSubarray([2, 3, 4]))                  # Linear increase\n    print(alternatingSubarray([1, 3, 2, 4, 3, 5]))        # Some alternation possible\n    print(alternatingSubarray([1, 2, 1, 2, 1, 2]))        # Full pattern repeating\n    print(alternatingSubarray([5, 6, 7, 8, 9]))           # Strictly increasing", "all_input_output_value": "\ninput1: nums=[]\noutput1: -1\n--------\ninput2: nums=[1]\noutput2: -1\n--------\ninput3: nums=[1, 2, 3]\noutput3: 2\n--------\ninput4: nums=[1, 0, 1, 0, 1]\noutput4: 4\n--------\ninput5: nums=[1, 0, 1, 0, 1, 2]\noutput5: 4\n--------\ninput6: nums=[0, 1, 0, 1, 0]\noutput6: 5\n--------\ninput7: nums=[2, 3, 4]\noutput7: 2\n--------\ninput8: nums=[1, 3, 2, 4, 3, 5]\noutput8: -1\n--------\ninput9: nums=[1, 2, 1, 2, 1, 2]\noutput9: 6\n--------\ninput10: nums=[5, 6, 7, 8, 9]\noutput10: 2\n", "input_output_value": ["\ninput1: nums=[]\noutput1: -1\n", "\ninput2: nums=[1]\noutput2: -1\n", "\ninput3: nums=[1, 2, 3]\noutput3: 2\n"], "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    vector<int> input1 = {};\n    vector<int> input2 = {1};\n    vector<int> input3 = {1, 2, 3};\n    vector<int> input4 = {1, 0, 1, 0, 1};\n    vector<int> input5 = {1, 0, 1, 0, 1, 2};\n    vector<int> input6 = {0, 1, 0, 1, 0};\n    vector<int> input7 = {2, 3, 4};\n    vector<int> input8 = {1, 3, 2, 4, 3, 5};\n    vector<int> input9 = {1, 2, 1, 2, 1, 2};\n    vector<int> input10 = {5, 6, 7, 8, 9};\n\n    cout << alternatingSubarray(input1) << endl; // Expected output: -1\n    cout << alternatingSubarray(input2) << endl; // Expected output: -1\n    cout << alternatingSubarray(input3) << endl; // Expected output: -1\n    cout << alternatingSubarray(input4) << endl; // Expected output: 5\n    cout << alternatingSubarray(input5) << endl; // Expected output: 6\n    cout << alternatingSubarray(input6) << endl; // Expected output: 5\n    cout << alternatingSubarray(input7) << endl; // Expected output: -1\n    cout << alternatingSubarray(input8) << endl; // Expected output: 4\n    cout << alternatingSubarray(input9) << endl; // Expected output: 6\n    cout << alternatingSubarray(input10) << endl; // Expected output: -1\n}", "TAG": "Success"}
{"source_Lan": "python###minimumTime.py", "source_code_str": "def minimumTime( nums1: List[int], nums2: List[int], x: int) -> int:\n    n = len(nums1)\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    for j, (b, a) in enumerate(sorted(zip(nums2, nums1)), 1):\n        for i in range(j, 0, -1):\n            dp[j][i] = max(dp[j - 1][i], dp[j - 1][i - 1] + i * b + a)\n    sa, sb = sum(nums1), sum(nums2)\n    for i in range(0, n + 1):\n        if sb * i + sa - dp[n][i] <= x:\n            return i\n    return -1", "source_code_block": "", "target_Lan": "cpp###minimumTime.cpp", "reference_code": "    int minimumTime(vector<int>& nums1, vector<int>& nums2, int x) {\n        int n = nums1.size();\n        vector<vector<int>> dp(n + 1, vector<int>(n + 1, 0));\n        vector<pair<int, int>> nums(n);\n        for (int i = 0; i < n; i++) {\n            nums[i] = {nums2[i], nums1[i]};\n        }\n        sort(nums.begin(), nums.end());\n        for (int j = 1; j <= n; j++) {\n            int b = nums[j - 1].first, a = nums[j - 1].second;\n            for (int i = j; i > 0; i--) {\n                dp[j][i] = max(dp[j - 1][i], dp[j - 1][i - 1] + i * b + a);\n            }\n        }\n        int s1 = accumulate(nums1.begin(), nums1.end(), 0);\n        int s2 = accumulate(nums2.begin(), nums2.end(), 0);\n        for (int i = 0; i <= n; i++) {\n            if (s2 * i + s1 - dp[n][i] <= x) {\n                return i;\n            }\n        }\n        return -1;\n    }", "target_method_signature": "minimumTime", "source_method_signature": "minimumTime", "target_allMS": "    int minimumTime(vector<int>& nums1, vector<int>& nums2, int x) {", "source_allMS": "def minimumTime( nums1: List[int], nums2: List[int], x: int) -> int:", "source_import": "", "target_import": "#include <iostream>\nusing namespace std;", "commentTag": "//", "source_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(minimumTime([0, 0, 0], [0, 0, 0], 0))\n    print(minimumTime([1, 2, 3], [4, 5, 6], 10))\n    print(minimumTime([1, 2, 3], [4, 5, 6], 100))\n    print(minimumTime([0, 0, 0], [1, 1, 1], 1))\n    print(minimumTime([5, 10, 15], [1, 2, 3], 50))\n    print(minimumTime([1, 20, 3, 40], [10, 200, 30, 400], 2000))\n    print(minimumTime([100, 300, 500], [600, 700, 800], 10000))\n    print(minimumTime([-1, -2, -3], [1, 1, 1], 0))\n    print(minimumTime([1000, 2000, 3000], [1000, 2000, 3000], 100000))\n    print(minimumTime([10, 20, 30], [30, 20, 10], 500))", "all_input_output_value": "\ninput1: nums1=[0, 0, 0], nums2=[0, 0, 0], x=0\noutput1: 0\n--------\ninput2: nums1=[1, 2, 3], nums2=[4, 5, 6], x=10\noutput2: 0\n--------\ninput3: nums1=[1, 2, 3], nums2=[4, 5, 6], x=100\noutput3: 0\n--------\ninput4: nums1=[0, 0, 0], nums2=[1, 1, 1], x=1\noutput4: 0\n--------\ninput5: nums1=[5, 10, 15], nums2=[1, 2, 3], x=50\noutput5: 0\n--------\ninput6: nums1=[1, 20, 3, 40], nums2=[10, 200, 30, 400], x=2000\noutput6: 0\n--------\ninput7: nums1=[100, 300, 500], nums2=[600, 700, 800], x=10000\noutput7: 0\n--------\ninput8: nums1=[-1, -2, -3], nums2=[1, 1, 1], x=0\noutput8: 0\n--------\ninput9: nums1=[1000, 2000, 3000], nums2=[1000, 2000, 3000], x=100000\noutput9: 0\n--------\ninput10: nums1=[10, 20, 30], nums2=[30, 20, 10], x=500\noutput10: 0\n", "input_output_value": ["\ninput1: nums1=[0, 0, 0], nums2=[0, 0, 0], x=0\noutput1: 0\n", "\ninput2: nums1=[1, 2, 3], nums2=[4, 5, 6], x=10\noutput2: 0\n", "\ninput3: nums1=[1, 2, 3], nums2=[4, 5, 6], x=100\noutput3: 0\n"], "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <numeric>\n#include <algorithm>\n// TOFILL\nint main() {\n    vector<int> nums1_1 = {0, 0, 0}, nums2_1 = {0, 0, 0}; int x1 = 0;\n    vector<int> nums1_2 = {1, 2, 3}, nums2_2 = {4, 5, 6}; int x2 = 10;\n    vector<int> nums1_3 = {1, 2, 3}, nums2_3 = {4, 5, 6}; int x3 = 100;\n    vector<int> nums1_4 = {0, 0, 0}, nums2_4 = {1, 1, 1}; int x4 = 1;\n    vector<int> nums1_5 = {5, 10, 15}, nums2_5 = {1, 2, 3}; int x5 = 50;\n    vector<int> nums1_6 = {1, 20, 3, 40}, nums2_6 = {10, 200, 30, 400}; int x6 = 2000;\n    vector<int> nums1_7 = {100, 300, 500}, nums2_7 = {600, 700, 800}; int x7 = 10000;\n    vector<int> nums1_8 = {-1, -2, -3}, nums2_8 = {1, 1, 1}; int x8 = 0;\n    vector<int> nums1_9 = {1000, 2000, 3000}, nums2_9 = {1000, 2000, 3000}; int x9 = 100000;\n    vector<int> nums1_10 = {10, 20, 30}, nums2_10 = {30, 20, 10}; int x10 = 500;\n\n    cout << minimumTime(nums1_1, nums2_1, x1) << endl;\n    cout << minimumTime(nums1_2, nums2_2, x2) << endl;\n    cout << minimumTime(nums1_3, nums2_3, x3) << endl;\n    cout << minimumTime(nums1_4, nums2_4, x4) << endl;\n    cout << minimumTime(nums1_5, nums2_5, x5) << endl;\n    cout << minimumTime(nums1_6, nums2_6, x6) << endl;\n    cout << minimumTime(nums1_7, nums2_7, x7) << endl;\n    cout << minimumTime(nums1_8, nums2_8, x8) << endl;\n    cout << minimumTime(nums1_9, nums2_9, x9) << endl;\n    cout << minimumTime(nums1_10, nums2_10, x10) << endl;\n\n    return 0;\n}", "TAG": "Success"}
{"source_Lan": "python###equality.py", "source_code_str": "def equality( A, B):\n    if A > B:\n        return 0\n    if A == B:\n        return 1\n    if B % 2 == 0:\n        return 1\n    return 0", "source_code_block": "", "target_Lan": "cpp###equality.cpp", "reference_code": "    int equality(int A, int B) {\n        if (B<A) return 0;\n        if (A==B) return 1;\n        if (B%2==0) return 1;\n        return 0;\n    }", "target_method_signature": "equality", "source_method_signature": "equality", "target_allMS": "    int equality(int A, int B) {", "source_allMS": "def equality( A, B):", "source_import": "", "target_import": "#include <iostream>\nusing namespace std;", "commentTag": "//", "source_code_shell": "# TOFILL\nif __name__ == \"__main__\":\n    test_cases = [\n        (5, 3),\n        (4, 4),\n        (3, 4),\n        (3, 5),\n        (-1, 0),\n        (-5, -3),\n        (100000, 100001),\n        (99999, 100000),\n        (0, 2),\n        (1, -2),\n    ]\n    for A, B in test_cases:\n        print(equality(A, B))", "all_input_output_value": "\ninput1: A=5, B=3\noutput1: 0\n--------\ninput2: A=4, B=4\noutput2: 1\n--------\ninput3: A=3, B=4\noutput3: 1\n--------\ninput4: A=3, B=5\noutput4: 0\n--------\ninput5: A=-1, B=0\noutput5: 1\n--------\ninput6: A=-5, B=-3\noutput6: 0\n--------\ninput7: A=100000, B=100001\noutput7: 0\n--------\ninput8: A=99999, B=100000\noutput8: 1\n--------\ninput9: A=0, B=2\noutput9: 1\n--------\ninput10: A=1, B=-2\noutput10: 0\n", "input_output_value": ["\ninput1: A=5, B=3\noutput1: 0\n", "\ninput2: A=4, B=4\noutput2: 1\n", "\ninput3: A=3, B=4\noutput3: 1\n"], "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n// TOFILL\nint main() {\n    cout << equality(5, 3) << endl;\n    cout << equality(4, 4) << endl;\n    cout << equality(3, 4) << endl;\n    cout << equality(3, 5) << endl;\n    cout << equality(-1, 0) << endl;\n    cout << equality(-5, -3) << endl;\n    cout << equality(100000, 100001) << endl;\n    cout << equality(99999, 100000) << endl;\n    cout << equality(0, 2) << endl;\n    cout << equality(1, -2) << endl;\n}", "TAG": "Success"}
{"source_Lan": "python###isPossible.py", "source_code_str": "def isPossible( a: int, b: int, c: int) -> str:\n    \n    if (a + b) > c and (a + c) > b and (b + c) > a:\n        return \"YES\"\n    else:\n        return \"NO\"", "source_code_block": "", "target_Lan": "cpp###isPossible.cpp", "reference_code": "    string isPossible(int a, int b, int c) {\n        \n        if ((a + b) > c && (a + c) > b && (b + c) > a)\n            return \"YES\";\n        else\n            return \"NO\";\n    }", "target_method_signature": "isPossible", "source_method_signature": "isPossible", "target_allMS": "    string isPossible(int a, int b, int c) {", "source_allMS": "def isPossible( a: int, b: int, c: int) -> str:", "source_import": "", "target_import": "#include <iostream>\nusing namespace std;", "commentTag": "//", "source_code_shell": "# TOFILL\nif __name__ == \"__main__\":\n    print(isPossible(5, 10, 12))  # Should return \"YES\"\n    print(isPossible(3, 4, 5))    # Should return \"YES\"\n    print(isPossible(1, 1, 2))    # Should return \"NO\"\n    print(isPossible(0, 0, 0))    # Should return \"NO\"\n    print(isPossible(5, 7, 15))   # Should return \"NO\"\n    print(isPossible(10, -2, 7))  # Should return \"NO\"\n    print(isPossible(3, 3, 3))    # Should return \"YES\"\n    print(isPossible(8, 8, 16))   # Should return \"NO\"\n    print(isPossible(1, 2, 3))    # Should return \"NO\"\n    print(isPossible(0, 5, 5))    # Should return \"NO\"", "all_input_output_value": "\ninput1: a=5, b=10, c=12\noutput1: \"YES\"\n--------\ninput2: a=3, b=4, c=5\noutput2: \"YES\"\n--------\ninput3: a=1, b=1, c=2\noutput3: \"NO\"\n--------\ninput4: a=0, b=0, c=0\noutput4: \"NO\"\n--------\ninput5: a=5, b=7, c=15\noutput5: \"NO\"\n--------\ninput6: a=10, b=-2, c=7\noutput6: \"NO\"\n--------\ninput7: a=3, b=3, c=3\noutput7: \"YES\"\n--------\ninput8: a=8, b=8, c=16\noutput8: \"NO\"\n--------\ninput9: a=1, b=2, c=3\noutput9: \"NO\"\n--------\ninput10: a=0, b=5, c=5\noutput10: \"NO\"\n", "input_output_value": ["\ninput1: a=5, b=10, c=12\noutput1: \"YES\"\n", "\ninput2: a=3, b=4, c=5\noutput2: \"YES\"\n", "\ninput3: a=1, b=1, c=2\noutput3: \"NO\"\n"], "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <string>\n// TOFILL\nint main() {\n    cout << isPossible(5, 10, 12) << endl;\n    cout << isPossible(3, 4, 5) << endl;\n    cout << isPossible(1, 1, 2) << endl;\n    cout << isPossible(0, 0, 0) << endl;\n    cout << isPossible(5, 7, 15) << endl;\n    cout << isPossible(10, -2, 7) << endl;\n    cout << isPossible(3, 3, 3) << endl;\n    cout << isPossible(8, 8, 16) << endl;\n    cout << isPossible(1, 2, 3) << endl;\n    cout << isPossible(0, 5, 5) << endl;\n}", "TAG": "Success"}
{"source_Lan": "python###isFriend.py", "source_code_str": "def isFriend( n : int, x : int, y : int, arr : List[int]) -> str:\n    if y-x in arr:\n        return \"yes\"\n    else:\n        return \"no\"", "source_code_block": "", "target_Lan": "cpp###isFriend.cpp", "reference_code": "    string isFriend(int n, int x, int y, vector<int> &arr) {\n        for (auto j:arr){\n            if (x+j==y) return \"yes\";\n        }\n        return \"no\";\n    }", "target_method_signature": "isFriend", "source_method_signature": "isFriend", "target_allMS": "    string isFriend(int n, int x, int y, vector<int> &arr) {", "source_allMS": "def isFriend( n : int, x : int, y : int, arr : List[int]) -> str:", "source_import": "from typing import List", "target_import": "#include <iostream>\nusing namespace std;", "commentTag": "//", "source_code_shell": "from typing import List\nfrom typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(isFriend(5, 5, 10, [5, 1, 3, 4, 0]))    # Should return \"yes\"\n    print(isFriend(3, -2, 0, [1, 2, 3]))           # Should return \"no\"\n    print(isFriend(4, 0, 0, [0, 0, 0, 0]))         # Should return \"yes\"\n    print(isFriend(6, 1, 1, [-1, 0, 1, 2, 3, 4]))  # Should return \"yes\"\n    print(isFriend(5, 10, 15, [1, 2, 3, 4, 5]))    # Should return \"yes\"\n    print(isFriend(0, 10, 15, []))                   # Should return \"no\" (empty array)\n    print(isFriend(5, -5, 0, [-5, -10, -20, 10, 5])) # Should return \"yes\"\n    print(isFriend(5, 100, 50, [-50, -20, 0, 20, 50])) # Should return \"no\"\n    print(isFriend(4, 2, 4, [2, 3, 4, 5]))         # Should return \"yes\"\n    print(isFriend(3, 3, 10, [4, 5, 1]))           # Should return \"no\"", "all_input_output_value": "\ninput1: n=5, x=5, y=10, arr=[5, 1, 3, 4, 0]\noutput1: yes\n--------\ninput2: n=3, x=-2, y=0, arr=[1, 2, 3]\noutput2: yes\n--------\ninput3: n=4, x=0, y=0, arr=[0, 0, 0, 0]\noutput3: yes\n--------\ninput4: n=6, x=1, y=1, arr=[-1, 0, 1, 2, 3, 4]\noutput4: yes\n--------\ninput5: n=5, x=10, y=15, arr=[1, 2, 3, 4, 5]\noutput5: yes\n--------\ninput6: n=0, x=10, y=15, arr=[]\noutput6: no\n--------\ninput7: n=5, x=-5, y=0, arr=[-5, -10, -20, 10, 5]\noutput7: yes\n--------\ninput8: n=5, x=100, y=50, arr=[-50, -20, 0, 20, 50]\noutput8: no\n--------\ninput9: n=4, x=2, y=4, arr=[2, 3, 4, 5]\noutput9: yes\n--------\ninput10: n=3, x=3, y=10, arr=[4, 5, 1]\noutput10: no\n", "input_output_value": ["\ninput1: n=5, x=5, y=10, arr=[5, 1, 3, 4, 0]\noutput1: yes\n", "\ninput2: n=3, x=-2, y=0, arr=[1, 2, 3]\noutput2: yes\n", "\ninput3: n=4, x=0, y=0, arr=[0, 0, 0, 0]\noutput3: yes\n"], "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <string>\n// TOFILL\nint main() {\n    vector<int> arr1 = {5, 1, 3, 4, 0};\n    cout << isFriend(5, 5, 10, arr1) << endl;\n\n    vector<int> arr2 = {1, 2, 3};\n    cout << isFriend(3, -2, 0, arr2) << endl;\n\n    vector<int> arr3 = {0, 0, 0, 0};\n    cout << isFriend(4, 0, 0, arr3) << endl;\n\n    vector<int> arr4 = {-1, 0, 1, 2, 3, 4};\n    cout << isFriend(6, 1, 1, arr4) << endl;\n\n    vector<int> arr5 = {1, 2, 3, 4, 5};\n    cout << isFriend(5, 10, 15, arr5) << endl;\n\n    vector<int> arr6; // empty array\n    cout << isFriend(0, 10, 15, arr6) << endl;\n\n    vector<int> arr7 = {-5, -10, -20, 10, 5};\n    cout << isFriend(5, -5, 0, arr7) << endl;\n\n    vector<int> arr8 = {-50, -20, 0, 20, 50};\n    cout << isFriend(5, 100, 50, arr8) << endl;\n\n    vector<int> arr9 = {2, 3, 4, 5};\n    cout << isFriend(4, 2, 4, arr9) << endl;\n\n    vector<int> arr10 = {4, 5, 1};\n    cout << isFriend(3, 3, 10, arr10) << endl;\n\n    return 0;\n}", "TAG": "Success"}
{"source_Lan": "python###chocolateDistribution.py", "source_code_str": "def chocolateDistribution( N, M, arr, brr):\n    arr.sort()\n    brr.sort()\n    ans = 0\n    i, j = 0, 0\n    while i < N and j < M:\n        if arr[i] <= brr[j]:\n            ans += 1\n            i += 1\n            j += 1\n        else:\n            j += 1\n    return ans", "source_code_block": "", "target_Lan": "cpp###chocolateDistribution.cpp", "reference_code": "    int chocolateDistribution(int N, int M, vector<int> &arr, vector<int> &brr) {\n        sort(arr.begin(), arr.end());\n        sort(brr.begin(), brr.end());\n        int ans = 0;\n        int i = 0, j = 0;\n        while (i < N && j < M) {\n            if (arr[i] <= brr[j]) {\n                ans++;\n                i++;\n                j++;\n            } else {\n                j++;\n            }\n        }\n        return ans;\n    }", "target_method_signature": "chocolateDistribution", "source_method_signature": "chocolateDistribution", "target_allMS": "    int chocolateDistribution(int N, int M, vector<int> &arr, vector<int> &brr) {", "source_allMS": "def chocolateDistribution( N, M, arr, brr):", "source_import": "", "target_import": "#include <iostream>\nusing namespace std;", "commentTag": "//", "source_code_shell": "# TOFILL\nif __name__ == \"__main__\":\n    print(chocolateDistribution(3, 3, [1, 2, 3], [2, 3, 4]))\n    print(chocolateDistribution(4, 4, [5, 7, 8, 9], [1, 2, 3, 4]))\n    print(chocolateDistribution(0, 4, [], [1, 2, 3, 4]))\n    print(chocolateDistribution(4, 0, [1, 2, 3, 4], []))\n    print(chocolateDistribution(3, 3, [1, 2, 2], [2, 2, 3]))\n    print(chocolateDistribution(3, 3, [2, 3, 4], [1, 2, 3]))\n    print(chocolateDistribution(5, 5, [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]))\n    print(chocolateDistribution(4, 4, [1, 2, 3, 5], [2, 3, 5, 7]))\n    print(chocolateDistribution(5, 5, [10, 20, 30, 40, 50], [15, 25, 35, 45, 55]))\n    print(chocolateDistribution(3, 3, [3, 3, 3], [1, 4, 5]))", "all_input_output_value": "\ninput1: N=3, M=3, arr=[1, 2, 3], brr=[2, 3, 4]\noutput1: 3\n--------\ninput2: N=4, M=4, arr=[5, 7, 8, 9], brr=[1, 2, 3, 4]\noutput2: 0\n--------\ninput3: N=0, M=4, arr=[], brr=[1, 2, 3, 4]\noutput3: 0\n--------\ninput4: N=4, M=0, arr=[1, 2, 3, 4], brr=[]\noutput4: 0\n--------\ninput5: N=3, M=3, arr=[1, 2, 2], brr=[2, 2, 3]\noutput5: 3\n--------\ninput6: N=3, M=3, arr=[2, 3, 4], brr=[1, 2, 3]\noutput6: 2\n--------\ninput7: N=5, M=5, arr=[1, 1, 1, 1, 1], brr=[1, 1, 1, 1, 1]\noutput7: 5\n--------\ninput8: N=4, M=4, arr=[1, 2, 3, 5], brr=[2, 3, 5, 7]\noutput8: 4\n--------\ninput9: N=5, M=5, arr=[10, 20, 30, 40, 50], brr=[15, 25, 35, 45, 55]\noutput9: 5\n--------\ninput10: N=3, M=3, arr=[3, 3, 3], brr=[1, 4, 5]\noutput10: 2\n", "input_output_value": ["\ninput1: N=3, M=3, arr=[1, 2, 3], brr=[2, 3, 4]\noutput1: 3\n", "\ninput2: N=4, M=4, arr=[5, 7, 8, 9], brr=[1, 2, 3, 4]\noutput2: 0\n", "\ninput3: N=0, M=4, arr=[], brr=[1, 2, 3, 4]\noutput3: 0\n"], "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <algorithm>\n// TOFILL\nint main() {\n    vector<int> arr1 = {1, 2, 3};\n    vector<int> brr1 = {2, 3, 4};\n    cout << chocolateDistribution(3, 3, arr1, brr1) << endl; // Test input 1\n\n    vector<int> arr2 = {5, 7, 8, 9};\n    vector<int> brr2 = {1, 2, 3, 4};\n    cout << chocolateDistribution(4, 4, arr2, brr2) << endl; // Test input 2\n\n    vector<int> arr3 = {};\n    vector<int> brr3 = {1, 2, 3, 4};\n    cout << chocolateDistribution(0, 4, arr3, brr3) << endl; // Test input 3\n\n    vector<int> arr4 = {1, 2, 3, 4};\n    vector<int> brr4 = {};\n    cout << chocolateDistribution(4, 0, arr4, brr4) << endl; // Test input 4\n\n    vector<int> arr5 = {1, 2, 2};\n    vector<int> brr5 = {2, 2, 3};\n    cout << chocolateDistribution(3, 3, arr5, brr5) << endl; // Test input 5\n\n    vector<int> arr6 = {2, 3, 4};\n    vector<int> brr6 = {1, 2, 3};\n    cout << chocolateDistribution(3, 3, arr6, brr6) << endl; // Test input 6\n\n    vector<int> arr7 = {1, 1, 1, 1, 1};\n    vector<int> brr7 = {1, 1, 1, 1, 1};\n    cout << chocolateDistribution(5, 5, arr7, brr7) << endl; // Test input 7\n\n    vector<int> arr8 = {1, 2, 3, 5};\n    vector<int> brr8 = {2, 3, 5, 7};\n    cout << chocolateDistribution(4, 4, arr8, brr8) << endl; // Test input 8\n\n    vector<int> arr9 = {10, 20, 30, 40, 50};\n    vector<int> brr9 = {15, 25, 35, 45, 55};\n    cout << chocolateDistribution(5, 5, arr9, brr9) << endl; // Test input 9\n\n    vector<int> arr10 = {3, 3, 3};\n    vector<int> brr10 = {1, 4, 5};\n    cout << chocolateDistribution(3, 3, arr10, brr10) << endl; // Test input 10\n\n    return 0;\n}", "TAG": "Success"}
{"source_Lan": "python###resultArray.py", "source_code_str": "def resultArray( nums: List[int]) -> List[int]:\n    a = nums[:1]\n    b = nums[1:2]\n    for x in nums[2:]:\n        if a[-1] > b[-1]:\n            a.append(x)\n        else:\n            b.append(x)\n    return a + b", "source_code_block": "", "target_Lan": "cpp###resultArray.cpp", "reference_code": "    vector<int> resultArray(vector<int> &nums) {\n        vector<int> a{nums[0]}, b{nums[1]};\n        for (int i = 2; i < nums.size(); i++) {\n            (a.back() > b.back() ? a : b).push_back(nums[i]);\n        }\n        a.insert(a.end(), b.begin(), b.end());\n        return a;\n    }", "target_method_signature": "resultArray", "source_method_signature": "resultArray", "target_allMS": "    vector<int> resultArray(vector<int> &nums) {", "source_allMS": "def resultArray( nums: List[int]) -> List[int]:", "source_import": "", "target_import": "#include <iostream>\nusing namespace std;", "commentTag": "//", "source_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(resultArray([5, 10]))\n    print(resultArray([1, 1]))\n    print(resultArray([1, 2, 3, 4, 5]))\n    print(resultArray([-1, -2, -3]))\n    print(resultArray([1, -1, 2, -2]))\n    print(resultArray([-5, -10, -15]))\n    print(resultArray([5, 4, 3, 2, 1]))\n    print(resultArray([1, 2, 3, 4, 5]))\n    print(resultArray([10, 20, 30, 40, 50, 60, 70, 80, 90, 100]))\n    print(resultArray([10, 20, 10, 20, 10]))", "all_input_output_value": "\ninput1: nums=[5, 10]\noutput1: [5, 10]\n--------\ninput2: nums=[1, 1]\noutput2: [1, 1]\n--------\ninput3: nums=[1, 2, 3, 4, 5]\noutput3: [1, 2, 3, 4, 5]\n--------\ninput4: nums=[-1, -2, -3]\noutput4: [-1, -3, -2]\n--------\ninput5: nums=[1, -1, 2, -2]\noutput5: [1, 2, -2, -1]\n--------\ninput6: nums=[-5, -10, -15]\noutput6: [-5, -15, -10]\n--------\ninput7: nums=[5, 4, 3, 2, 1]\noutput7: [5, 3, 1, 4, 2]\n--------\ninput8: nums=[1, 2, 3, 4, 5]\noutput8: [1, 2, 3, 4, 5]\n--------\ninput9: nums=[10, 20, 30, 40, 50, 60, 70, 80, 90, 100]\noutput9: [10, 20, 30, 40, 50, 60, 70, 80, 90, 100]\n--------\ninput10: nums=[10, 20, 10, 20, 10]\noutput10: [10, 20, 10, 20, 10]\n", "input_output_value": ["\ninput1: nums=[5, 10]\noutput1: [5, 10]\n", "\ninput2: nums=[1, 1]\noutput2: [1, 1]\n", "\ninput3: nums=[1, 2, 3, 4, 5]\noutput3: [1, 2, 3, 4, 5]\n"], "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    vector<int> input1 = {5, 10};\n    vector<int> input2 = {1, 1};\n    vector<int> input3 = {1, 2, 3, 4, 5};\n    vector<int> input4 = {-1, -2, -3};\n    vector<int> input5 = {1, -1, 2, -2};\n    vector<int> input6 = {-5, -10, -15};\n    vector<int> input7 = {5, 4, 3, 2, 1};\n    vector<int> input8 = {1, 2, 3, 4, 5};\n    vector<int> input9 = {10, 20, 30, 40, 50, 60, 70, 80, 90, 100};\n    vector<int> input10 = {10, 20, 10, 20, 10};\n\n    vector<int> result;\n\n    result = resultArray(input1);\n    for(int num : result) cout << num << \" \";\n    cout << endl;\n\n    result = resultArray(input2);\n    for(int num : result) cout << num << \" \";\n    cout << endl;\n\n    result = resultArray(input3);\n    for(int num : result) cout << num << \" \";\n    cout << endl;\n\n    result = resultArray(input4);\n    for(int num : result) cout << num << \" \";\n    cout << endl;\n\n    result = resultArray(input5);\n    for(int num : result) cout << num << \" \";\n    cout << endl;\n\n    result = resultArray(input6);\n    for(int num : result) cout << num << \" \";\n    cout << endl;\n\n    result = resultArray(input7);\n    for(int num : result) cout << num << \" \";\n    cout << endl;\n\n    result = resultArray(input8);\n    for(int num : result) cout << num << \" \";\n    cout << endl;\n\n    result = resultArray(input9);\n    for(int num : result) cout << num << \" \";\n    cout << endl;\n\n    result = resultArray(input10);\n    for(int num : result) cout << num << \" \";\n    cout << endl;\n\n    return 0;\n}", "TAG": "Success"}
{"source_Lan": "python###maxBottlesDrunk.py", "source_code_str": "def maxBottlesDrunk( numBottles: int, numExchange: int) -> int:\n    ans = numBottles  \n    while numBottles >= numExchange:  \n        ans += 1  \n        numBottles += 1 - numExchange\n        numExchange += 1\n    return ans", "source_code_block": "", "target_Lan": "cpp###maxBottlesDrunk.cpp", "reference_code": "    int maxBottlesDrunk(int numBottles, int numExchange) {\n        int ans = numBottles; \n        while (numBottles >= numExchange) { \n            ans++; \n            numBottles += 1 - numExchange++;\n        }\n        return ans;\n    }", "target_method_signature": "maxBottlesDrunk", "source_method_signature": "maxBottlesDrunk", "target_allMS": "    int maxBottlesDrunk(int numBottles, int numExchange) {", "source_allMS": "def maxBottlesDrunk( numBottles: int, numExchange: int) -> int:", "source_import": "", "target_import": "#include <iostream>\nusing namespace std;", "commentTag": "//", "source_code_shell": "# TOFILL\nif __name__ == \"__main__\":\n    inputs = [(0, 5), (2, 1), (10, 3), (8, 4), (15, 1)]\n    for numBottles, numExchange in inputs:\n        print(maxBottlesDrunk(numBottles, numExchange))", "all_input_output_value": "\ninput1: numBottles=0, numExchange=5\noutput1: 0\n--------\ninput2: numBottles=2, numExchange=1\noutput2: 4\n--------\ninput3: numBottles=10, numExchange=3\noutput3: 13\n--------\ninput4: numBottles=8, numExchange=4\noutput4: 10\n--------\ninput5: numBottles=15, numExchange=1\noutput5: 20\n", "input_output_value": ["\ninput1: numBottles=0, numExchange=5\noutput1: 0\n", "\ninput2: numBottles=2, numExchange=1\noutput2: 4\n", "\ninput3: numBottles=10, numExchange=3\noutput3: 13\n"], "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n// TOFILL\nint main() {\n    cout << maxBottlesDrunk(0, 5) << endl; // Test Input 1\n    cout << maxBottlesDrunk(2, 1) << endl; // Test Input 2\n    cout << maxBottlesDrunk(10, 3) << endl; // Test Input 3\n    cout << maxBottlesDrunk(8, 4) << endl; // Test Input 4\n    cout << maxBottlesDrunk(15, 1) << endl; // Test Input 5\n}", "TAG": "Success"}
{"source_Lan": "python###findIndices.py", "source_code_str": "def findIndices( nums: List[int], indexDifference: int, valueDifference: int) -> List[int]:\n    for i in range(len(nums)):\n        for j in range(i, len(nums)):\n            if j - i >= indexDifference and abs(nums[j] - nums[i]) >= valueDifference:\n                return [i, j]\n    return [-1, -1]", "source_code_block": "", "target_Lan": "cpp###findIndices.cpp", "reference_code": "    vector<int> findIndices(vector<int>& nums, int indexDifference, int valueDifference) {\n        for (int i = 0; i < nums.size(); i++) {\n            for (int j = i; j < nums.size(); j++) {\n                if (j - i >= indexDifference && abs(nums[j] - nums[i]) >= valueDifference) {\n                    return {i, j};\n                }\n            }\n        }\n        return {-1, -1};\n    }", "target_method_signature": "findIndices", "source_method_signature": "findIndices", "target_allMS": "    vector<int> findIndices(vector<int>& nums, int indexDifference, int valueDifference) {", "source_allMS": "def findIndices( nums: List[int], indexDifference: int, valueDifference: int) -> List[int]:", "source_import": "", "target_import": "#include <iostream>\nusing namespace std;", "commentTag": "//", "source_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(findIndices([1, 2, 3, 4], 1, 1))\n    print(findIndices([3, 3, 3, 3], 2, 0))\n    print(findIndices([1, 5, 9, 2, 4], 1, 4))\n    print(findIndices([7, 8, 9, 10], 2, 1))\n    print(findIndices([], 1, 1))\n    print(findIndices([10], 1, 5))\n    print(findIndices([-1, -2, -3], 1, 1))\n    print(findIndices([5, 10, 20, 30], 2, 15))\n    print(findIndices([5, 5, 5, 10, 10], 3, 5))\n    print(findIndices([1, 3, 5, 7, 9], 4, 2))", "all_input_output_value": "\ninput1: nums=[1, 2, 3, 4], indexDifference=1, valueDifference=1\noutput1: [0, 1]\n--------\ninput2: nums=[3, 3, 3, 3], indexDifference=2, valueDifference=0\noutput2: [0, 2]\n--------\ninput3: nums=[1, 5, 9, 2, 4], indexDifference=1, valueDifference=4\noutput3: [0, 1]\n--------\ninput4: nums=[7, 8, 9, 10], indexDifference=2, valueDifference=1\noutput4: [0, 2]\n--------\ninput5: nums=[], indexDifference=1, valueDifference=1\noutput5: [-1, -1]\n--------\ninput6: nums=[10], indexDifference=1, valueDifference=5\noutput6: [-1, -1]\n--------\ninput7: nums=[-1, -2, -3], indexDifference=1, valueDifference=1\noutput7: [0, 1]\n--------\ninput8: nums=[5, 10, 20, 30], indexDifference=2, valueDifference=15\noutput8: [0, 2]\n--------\ninput9: nums=[5, 5, 5, 10, 10], indexDifference=3, valueDifference=5\noutput9: [0, 4]\n--------\ninput10: nums=[1, 3, 5, 7, 9], indexDifference=4, valueDifference=2\noutput10: [0, 4]\n", "input_output_value": ["\ninput1: nums=[1, 2, 3, 4], indexDifference=1, valueDifference=1\noutput1: [0, 1]\n", "\ninput2: nums=[3, 3, 3, 3], indexDifference=2, valueDifference=0\noutput2: [0, 2]\n", "\ninput3: nums=[1, 5, 9, 2, 4], indexDifference=1, valueDifference=4\noutput3: [0, 1]\n"], "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <cstdlib> // for abs\n// TOFILL\nint main() {\n    vector<int> nums1 = {1, 2, 3, 4};\n    vector<int> result1 = findIndices(nums1, 1, 1);\n    cout << \"Result 1: [\" << result1[0] << \", \" << result1[1] << \"]\" << endl;\n\n    vector<int> nums2 = {3, 3, 3, 3};\n    vector<int> result2 = findIndices(nums2, 2, 0);\n    cout << \"Result 2: [\" << result2[0] << \", \" << result2[1] << \"]\" << endl;\n\n    vector<int> nums3 = {1, 5, 9, 2, 4};\n    vector<int> result3 = findIndices(nums3, 1, 4);\n    cout << \"Result 3: [\" << result3[0] << \", \" << result3[1] << \"]\" << endl;\n\n    vector<int> nums4 = {7, 8, 9, 10};\n    vector<int> result4 = findIndices(nums4, 2, 1);\n    cout << \"Result 4: [\" << result4[0] << \", \" << result4[1] << \"]\" << endl;\n\n    vector<int> nums5 = {};\n    vector<int> result5 = findIndices(nums5, 1, 1);\n    cout << \"Result 5: [\" << result5[0] << \", \" << result5[1] << \"]\" << endl;\n\n    vector<int> nums6 = {10};\n    vector<int> result6 = findIndices(nums6, 1, 5);\n    cout << \"Result 6: [\" << result6[0] << \", \" << result6[1] << \"]\" << endl;\n\n    vector<int> nums7 = {-1, -2, -3};\n    vector<int> result7 = findIndices(nums7, 1, 1);\n    cout << \"Result 7: [\" << result7[0] << \", \" << result7[1] << \"]\" << endl;\n\n    vector<int> nums8 = {5, 10, 20, 30};\n    vector<int> result8 = findIndices(nums8, 2, 15);\n    cout << \"Result 8: [\" << result8[0] << \", \" << result8[1] << \"]\" << endl;\n\n    vector<int> nums9 = {5, 5, 5, 10, 10};\n    vector<int> result9 = findIndices(nums9, 3, 5);\n    cout << \"Result 9: [\" << result9[0] << \", \" << result9[1] << \"]\" << endl;\n\n    vector<int> nums10 = {1, 3, 5, 7, 9};\n    vector<int> result10 = findIndices(nums10, 4, 2);\n    cout << \"Result 10: [\" << result10[0] << \", \" << result10[1] << \"]\" << endl;\n\n    return 0;\n}", "TAG": "Success"}
{"source_Lan": "python###frequency.py", "source_code_str": "def frequency( n ,a):\n    mp=dict()\n    for i in range(n):\n        if a[i] in mp:\n            mp[a[i]]+=1\n        else:\n            mp[a[i]]=1\n    ans=[]\n    for i in range(n):\n        ans.append(mp[a[i]])\n        mp[a[i]]-=1\n    return ans", "source_code_block": "", "target_Lan": "cpp###frequency.cpp", "reference_code": "    vector<int> frequency(int n, vector<int> &a){\n        vector<int>ans(n);\n        unordered_map<int,int>mp;\n        for(int i=n-1;i>-1;i--)\n        {\n            mp[a[i]]++;\n            ans[i]=mp[a[i]];\n        }\n        return ans;\n    }", "target_method_signature": "frequency", "source_method_signature": "frequency", "target_allMS": "    vector<int> frequency(int n, vector<int> &a){", "source_allMS": "def frequency( n ,a):", "source_import": "", "target_import": "#include <iostream>\nusing namespace std;", "commentTag": "//", "source_code_shell": "# TOFILL\nif __name__ == \"__main__\":\n    print(frequency(10, [1, 5, 3, 4, 1, 2, 3, 5, 6, 5]))\n    print(frequency(4, [2, 2, 2, 2]))\n    print(frequency(6, [6, -1, -1, 3, 4, -1, 6]))\n    print(frequency(0, []))\n    print(frequency(5, [1000, 1001, 1000, 1002, 1001]))\n    print(frequency(7, [100, 100, 100, 200, 200, 200, 300]))", "all_input_output_value": "\ninput1: n=10, a=[1, 5, 3, 4, 1, 2, 3, 5, 6, 5]\noutput1: [2, 3, 2, 1, 1, 1, 1, 2, 1, 1]\n--------\ninput2: n=4, a=[2, 2, 2, 2]\noutput2: [4, 3, 2, 1]\n--------\ninput3: n=6, a=[6, -1, -1, 3, 4, -1, 6]\noutput3: [1, 3, 2, 1, 1, 1]\n--------\ninput4: n=0, a=[]\noutput4: []\n--------\ninput5: n=5, a=[1000, 1001, 1000, 1002, 1001]\noutput5: [2, 2, 1, 1, 1]\n--------\ninput6: n=7, a=[100, 100, 100, 200, 200, 200, 300]\noutput6: [3, 2, 1, 3, 2, 1, 1]\n", "input_output_value": ["\ninput1: n=10, a=[1, 5, 3, 4, 1, 2, 3, 5, 6, 5]\noutput1: [2, 3, 2, 1, 1, 1, 1, 2, 1, 1]\n", "\ninput2: n=4, a=[2, 2, 2, 2]\noutput2: [4, 3, 2, 1]\n", "\ninput3: n=6, a=[6, -1, -1, 3, 4, -1, 6]\noutput3: [1, 3, 2, 1, 1, 1]\n"], "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n// TOFILL\nint main() {\n    vector<int> a1 = {1, 5, 3, 4, 1, 2, 3, 5, 6, 5};\n    vector<int> res1 = frequency(10, a1);\n    for(int val : res1) cout << val << \" \";\n    cout << endl;\n\n    vector<int> a2 = {2, 2, 2, 2};\n    vector<int> res2 = frequency(4, a2);\n    for(int val : res2) cout << val << \" \";\n    cout << endl;\n\n    vector<int> a3 = {6, -1, -1, 3, 4, -1, 6};\n    vector<int> res3 = frequency(6, a3);\n    for(int val : res3) cout << val << \" \";\n    cout << endl;\n\n    vector<int> a4 = {};\n    vector<int> res4 = frequency(0, a4);\n    for(int val : res4) cout << val << \" \";\n    cout << endl;\n\n    vector<int> a5 = {1000, 1001, 1000, 1002, 1001};\n    vector<int> res5 = frequency(5, a5);\n    for(int val : res5) cout << val << \" \";\n    cout << endl;\n\n    vector<int> a6 = {100, 100, 100, 200, 200, 200, 300};\n    vector<int> res6 = frequency(7, a6);\n    for(int val : res6) cout << val << \" \";\n    cout << endl;\n\n    return 0;\n}", "TAG": "Success"}
{"source_Lan": "python###lastFairyStanding.py", "source_code_str": "def lastFairyStanding( n : int, k : int) -> int:\n    ans = 0\n    for x in range(2, n+1): \n        ans = (ans + k) % x\n    return ans + 1", "source_code_block": "", "target_Lan": "cpp###lastFairyStanding.cpp", "reference_code": "    int lastFairyStanding(int n, int k) {\n        \n        int i = 1, ans = 0;\n        while (i <= n)\n            ans = (ans + k) % i++;\n        return ans + 1;\n    }", "target_method_signature": "lastFairyStanding", "source_method_signature": "lastFairyStanding", "target_allMS": "    int lastFairyStanding(int n, int k) {", "source_allMS": "def lastFairyStanding( n : int, k : int) -> int:", "source_import": "", "target_import": "#include <iostream>\nusing namespace std;", "commentTag": "//", "source_code_shell": "# TOFILL\nif __name__ == \"__main__\":\n    test_inputs = [\n        (1, 5),\n        (1, 5),\n        (2, 10),\n        (3, 10),\n        (10, 20),\n        (5, 15),\n        (7, 100),\n        (1, 100),\n        (50, 1000),\n        (999, 999)\n    ]\n    for n, k in test_inputs:\n        print(lastFairyStanding(n, k))", "all_input_output_value": "\ninput1: n=1, k=5\noutput1: 1\n--------\ninput2: n=1, k=5\noutput2: 1\n--------\ninput3: n=2, k=10\noutput3: 1\n--------\ninput4: n=3, k=10\noutput4: 2\n--------\ninput5: n=10, k=20\noutput5: 1\n--------\ninput6: n=5, k=15\noutput6: 1\n--------\ninput7: n=7, k=100\noutput7: 1\n--------\ninput8: n=1, k=100\noutput8: 1\n--------\ninput9: n=50, k=1000\noutput9: 46\n--------\ninput10: n=999, k=999\noutput10: 335\n", "input_output_value": ["\ninput1: n=1, k=5\noutput1: 1\n", "\ninput2: n=1, k=5\noutput2: 1\n", "\ninput3: n=2, k=10\noutput3: 1\n"], "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n// TOFILL\nint main() {\n    cout << lastFairyStanding(1, 5) << endl;\n    cout << lastFairyStanding(1, 5) << endl;\n    cout << lastFairyStanding(2, 10) << endl;\n    cout << lastFairyStanding(3, 10) << endl;\n    cout << lastFairyStanding(10, 20) << endl;\n    cout << lastFairyStanding(5, 15) << endl;\n    cout << lastFairyStanding(7, 100) << endl;\n    cout << lastFairyStanding(1, 100) << endl;\n    cout << lastFairyStanding(50, 1000) << endl;\n    cout << lastFairyStanding(999, 999) << endl;\n}", "TAG": "Success"}
{"source_Lan": "python###validStrings.py", "source_code_str": "def validStrings( n : int, k : int, arr : List[str]) -> int:\n    ans=0\n    for el in arr:\n        C=0\n        for e in el:\n            if e in \"aeiou\":\n                C+=1\n        if C==k:\n            ans+=1\n    return ans", "source_code_block": "", "target_Lan": "cpp###validStrings.cpp", "reference_code": "    int validStrings(int n, int k, vector<string> &arr) {\n        int tot=0;\n        for (auto j:arr){\n            int c=0;\n            for (auto q:j){\n                if (q=='a'||q=='e'||q=='i'||q=='o'||q=='u') c+=1;\n            }\n            if (c==k) tot+=1;\n        }\n        return tot;\n    }", "target_method_signature": "validStrings", "source_method_signature": "validStrings", "target_allMS": "    int validStrings(int n, int k, vector<string> &arr) {", "source_allMS": "def validStrings( n : int, k : int, arr : List[str]) -> int:", "source_import": "from typing import List", "target_import": "#include <iostream>\nusing namespace std;", "commentTag": "//", "source_code_shell": "from typing import List\nfrom typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(validStrings(5, 2, [\"apple\", \"banana\", \"kiwi\", \"grape\", \"plum\"]))\n    print(validStrings(3, 1, [\"sky\", \"by\", \"a\"]))\n    print(validStrings(4, 3, [\"beautiful\", \"melody\", \"song\", \"a\"]))\n    print(validStrings(2, 5, [\"queue\", \"aaeei\"]))\n    print(validStrings(6, 0, [\"\", \"b\", \"c\", \"d\", \"f\", \"g\"]))\n    print(validStrings(3, 2, [\"aeiou\", \"xyz\", \"pqrst\"]))\n    print(validStrings(4, 2, [\"ooii\", \"tttt\", \"ae\", \"aaa\"]))\n    print(validStrings(1, 6, [\"aeeeee\"]))\n    print(validStrings(2, 3, [\"uuuuuu\", \"aeio\"]))\n    print(validStrings(3, 4, [\"iouae\", \"bdfghjkl\", \"eaiuo\"]))", "all_input_output_value": "\ninput1: n=5, k=2, arr=[\"apple\", \"banana\", \"kiwi\", \"grape\", \"plum\"]\noutput1: 3\n--------\ninput2: n=3, k=1, arr=[\"sky\", \"by\", \"a\"]\noutput2: 1\n--------\ninput3: n=4, k=3, arr=[\"beautiful\", \"melody\", \"song\", \"a\"]\noutput3: 0\n--------\ninput4: n=2, k=5, arr=[\"queue\", \"aaeei\"]\noutput4: 1\n--------\ninput5: n=6, k=0, arr=[\"\", \"b\", \"c\", \"d\", \"f\", \"g\"]\noutput5: 6\n--------\ninput6: n=3, k=2, arr=[\"aeiou\", \"xyz\", \"pqrst\"]\noutput6: 0\n--------\ninput7: n=4, k=2, arr=[\"ooii\", \"tttt\", \"ae\", \"aaa\"]\noutput7: 1\n--------\ninput8: n=1, k=6, arr=[\"aeeeee\"]\noutput8: 1\n--------\ninput9: n=2, k=3, arr=[\"uuuuuu\", \"aeio\"]\noutput9: 0\n--------\ninput10: n=3, k=4, arr=[\"iouae\", \"bdfghjkl\", \"eaiuo\"]\noutput10: 0\n", "input_output_value": ["\ninput1: n=5, k=2, arr=[\"apple\", \"banana\", \"kiwi\", \"grape\", \"plum\"]\noutput1: 3\n", "\ninput2: n=3, k=1, arr=[\"sky\", \"by\", \"a\"]\noutput2: 1\n", "\ninput3: n=4, k=3, arr=[\"beautiful\", \"melody\", \"song\", \"a\"]\noutput3: 0\n"], "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <string>\n// TOFILL\nint main() {\n    vector<string> arr1 = {\"apple\", \"banana\", \"kiwi\", \"grape\", \"plum\"};\n    cout << validStrings(5, 2, arr1) << endl;\n\n    vector<string> arr2 = {\"sky\", \"by\", \"a\"};\n    cout << validStrings(3, 1, arr2) << endl;\n\n    vector<string> arr3 = {\"beautiful\", \"melody\", \"song\", \"a\"};\n    cout << validStrings(4, 3, arr3) << endl;\n\n    vector<string> arr4 = {\"queue\", \"aaeei\"};\n    cout << validStrings(2, 5, arr4) << endl;\n\n    vector<string> arr5 = {\"\", \"b\", \"c\", \"d\", \"f\", \"g\"};\n    cout << validStrings(6, 0, arr5) << endl;\n\n    vector<string> arr6 = {\"aeiou\", \"xyz\", \"pqrst\"};\n    cout << validStrings(3, 2, arr6) << endl;\n\n    vector<string> arr7 = {\"ooii\", \"tttt\", \"ae\", \"aaa\"};\n    cout << validStrings(4, 2, arr7) << endl;\n\n    vector<string> arr8 = {\"aeeeee\"};\n    cout << validStrings(1, 6, arr8) << endl;\n\n    vector<string> arr9 = {\"uuuuuu\", \"aeio\"};\n    cout << validStrings(2, 3, arr9) << endl;\n\n    vector<string> arr10 = {\"iouae\", \"bdfghjkl\", \"eaiuo\"};\n    cout << validStrings(3, 4, arr10) << endl;\n\n    return 0;\n}", "TAG": "Success"}
{"source_Lan": "python###AreEqual.py", "source_code_str": "def AreEqual( a: str, b: str) -> bool:\n    for i in range(len(a) - 1):\n        if (a[i] == b[i] and a[i] == '0' and a[i + 1] == b[i + 1]\n                and a[i + 1] == '1'):\n            return True\n    return False", "source_code_block": "", "target_Lan": "cpp###AreEqual.cpp", "reference_code": "    bool AreEqual(string a, string b) {\n        int n = a.length();\n        bool flag = false;\n        for (int i = 0; i < n - 1; i++) {\n            if (a[i] == '0' && b[i + 1] == '1') {\n                if (a[i] == b[i] && a[i + 1] == b[i + 1]) {\n                    flag = true;\n                }\n            }\n        }\n        return flag;\n    }", "target_method_signature": "AreEqual", "source_method_signature": "AreEqual", "target_allMS": "    bool AreEqual(string a, string b) {", "source_allMS": "def AreEqual( a: str, b: str) -> bool:", "source_import": "", "target_import": "#include <iostream>\nusing namespace std;", "commentTag": "//", "source_code_shell": "# TOFILL\nif __name__ == \"__main__\":\n    print(AreEqual(\"01\", \"11\"))   # should return true\n    print(AreEqual(\"01\", \"01\"))   # should return false\n    print(AreEqual(\"00\", \"10\"))   # should return false\n    print(AreEqual(\"10\", \"01\"))   # should return false\n    print(AreEqual(\"11\", \"10\"))   # should return false\n    print(AreEqual(\"0\", \"1\"))     # should return false\n    print(AreEqual(\"00\", \"01\"))   # should return true\n    print(AreEqual(\"0001\", \"1111\")) # should return true\n    print(AreEqual(\"010\", \"110\"))   # should return true\n    print(AreEqual(\"10\", \"01\"))    # should return false", "all_input_output_value": "\ninput1: a=\"01\", b=\"11\"\noutput1: False\n--------\ninput2: a=\"01\", b=\"01\"\noutput2: True\n--------\ninput3: a=\"00\", b=\"10\"\noutput3: False\n--------\ninput4: a=\"10\", b=\"01\"\noutput4: False\n--------\ninput5: a=\"11\", b=\"10\"\noutput5: False\n--------\ninput6: a=\"0\", b=\"1\"\noutput6: False\n--------\ninput7: a=\"00\", b=\"01\"\noutput7: True\n--------\ninput8: a=\"0001\", b=\"1111\"\noutput8: False\n--------\ninput9: a=\"010\", b=\"110\"\noutput9: False\n--------\ninput10: a=\"10\", b=\"01\"\noutput10: False\n", "input_output_value": ["\ninput1: a=\"01\", b=\"11\"\noutput1: False\n", "\ninput2: a=\"01\", b=\"01\"\noutput2: True\n", "\ninput3: a=\"00\", b=\"10\"\noutput3: False\n"], "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <string>\n// TOFILL\nint main() {\n    cout << AreEqual(\"01\", \"11\") << endl; // Test input 1\n    cout << AreEqual(\"01\", \"01\") << endl; // Test input 2\n    cout << AreEqual(\"00\", \"10\") << endl; // Test input 3\n    cout << AreEqual(\"10\", \"01\") << endl; // Test input 4\n    cout << AreEqual(\"11\", \"10\") << endl; // Test input 5\n    cout << AreEqual(\"0\", \"1\") << endl;   // Test input 6\n    cout << AreEqual(\"00\", \"01\") << endl; // Test input 7\n    cout << AreEqual(\"0001\", \"1111\") << endl; // Test input 8\n    cout << AreEqual(\"010\", \"110\") << endl; // Test input 9\n    cout << AreEqual(\"10\", \"01\") << endl; // Test input 10\n}", "TAG": "Success"}
{"source_Lan": "python###maxPoints.py", "source_code_str": "def maxPoints( n: int, arr: List[List[int]]) -> int:\n    dp = [0] * (200000)\n    for i in range(n - 1, -1, -1):\n        dp[i] = max(arr[i][0] + dp[arr[i][1] + i + 1], dp[i + 1])\n    return dp[0]", "source_code_block": "", "target_Lan": "cpp###maxPoints.cpp", "reference_code": "    long long maxPoints(int n, vector<vector<int>> &arr) {\n        long long dp[200001] = {};\n        for (int i = n - 1; i >= 0; --i)\n            dp[i] = max(arr[i][0] + dp[arr[i][1] + i + 1], dp[i + 1]);\n        return dp[0];\n    }", "target_method_signature": "maxPoints", "source_method_signature": "maxPoints", "target_allMS": "    long long maxPoints(int n, vector<vector<int>> &arr) {", "source_allMS": "def maxPoints( n: int, arr: List[List[int]]) -> int:", "source_import": "from typing import List", "target_import": "#include <iostream>\nusing namespace std;", "commentTag": "//", "source_code_shell": "from typing import List\nfrom typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(maxPoints(0, []))\n    print(maxPoints(1, [[5, 0]]))\n    print(maxPoints(3, [[2, 0], [3, 1], [4, 0]]))\n    print(maxPoints(4, [[1, 2], [2, -1], [4, 1], [3, 2]]))\n    print(maxPoints(5, [[0, 0], [0, 0], [0, 0], [0, 0], [0, 0]]))\n    print(maxPoints(10, [[10, 0], [20, 1], [30, 0], [25, 3], [15, 4], [5, 10], [2, 2], [1, 1], [20, 0], [10, 5]]))\n    print(maxPoints(3, [[1, 1], [5, 3], [10, 3]]))", "all_input_output_value": "\ninput1: n=0, arr=[]\noutput1: 0\n--------\ninput2: n=1, arr=[[5, 0]]\noutput2: 5\n--------\ninput3: n=3, arr=[[2, 0], [3, 1], [4, 0]]\noutput3: 6\n--------\ninput4: n=4, arr=[[1, 2], [2, -1], [4, 1], [3, 2]]\noutput4: 4\n--------\ninput5: n=5, arr=[[0, 0], [0, 0], [0, 0], [0, 0], [0, 0]]\noutput5: 0\n--------\ninput6: n=10, arr=[[10, 0], [20, 1], [30, 0], [25, 3], [15, 4], [5, 10], [2, 2], [1, 1], [20, 0], [10, 5]]\noutput6: 95\n--------\ninput7: n=3, arr=[[1, 1], [5, 3], [10, 3]]\noutput7: 11\n", "input_output_value": ["\ninput1: n=0, arr=[]\noutput1: 0\n", "\ninput2: n=1, arr=[[5, 0]]\noutput2: 5\n", "\ninput3: n=3, arr=[[2, 0], [3, 1], [4, 0]]\noutput3: 6\n"], "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    vector<vector<int>> arr1 = {};\n    cout << maxPoints(0, arr1) << endl;\n\n    vector<vector<int>> arr2 = {{5, 0}};\n    cout << maxPoints(1, arr2) << endl;\n\n    vector<vector<int>> arr3 = {{2, 0}, {3, 1}, {4, 0}};\n    cout << maxPoints(3, arr3) << endl;\n\n    vector<vector<int>> arr4 = {{1, 2}, {2, -1}, {4, 1}, {3, 2}};\n    cout << maxPoints(4, arr4) << endl;\n\n    vector<vector<int>> arr5 = {{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}};\n    cout << maxPoints(5, arr5) << endl;\n\n    vector<vector<int>> arr6 = {{10, 0}, {20, 1}, {30, 0}, {25, 3}, {15, 4}, {5, 10}, {2, 2}, {1, 1}, {20, 0}, {10, 5}};\n    cout << maxPoints(10, arr6) << endl;\n\n    vector<vector<int>> arr7 = {{1, 1}, {5, 3}, {10, 3}};\n    cout << maxPoints(3, arr7) << endl;\n\n    return 0;\n}", "TAG": "Success"}
{"source_Lan": "python###matrixConundrum.py", "source_code_str": "def matrixConundrum( n: int, m: int, mat: List[str]) -> bool:\n    check = ['p', 'l', 'a', 'y']\n    idx = 0\n    for j in range(m):\n        for i in range(n):\n            if mat[i][j] == check[idx]:\n                idx += 1\n                if idx == 4:\n                    return True\n                break\n    return False", "source_code_block": "", "target_Lan": "cpp###matrixConundrum.cpp", "reference_code": "    bool matrixConundrum(int n, int m, vector<string> &mat) {\n        string play = \"play\";\n        int fnd = 0;\n        for (int i = 0; i < m; ++i) {\n            bool check = false;\n            for (int j = 0; j < n; ++j) {\n                if (mat[j][i] == play[fnd]) {\n                    check = true;\n                }\n            }\n            if (check) {\n                ++fnd;\n                if (fnd == 4) {\n                    break;\n                }\n            }\n        }\n        if (fnd == 4)\n            return true;\n        return false;\n    }", "target_method_signature": "matrixConundrum", "source_method_signature": "matrixConundrum", "target_allMS": "    bool matrixConundrum(int n, int m, vector<string> &mat) {", "source_allMS": "def matrixConundrum( n: int, m: int, mat: List[str]) -> bool:", "source_import": "from typing import List", "target_import": "#include <iostream>\nusing namespace std;", "commentTag": "//", "source_code_shell": "from typing import List\nfrom typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(matrixConundrum(2, 4, [\"pppp\", \"llll\"]))             # Should return false\n    print(matrixConundrum(3, 3, [\"aaa\", \"bbb\", \"ccc\"]))        # Should return false\n    print(matrixConundrum(1, 1, [\"p\"]))                         # Should return false\n    print(matrixConundrum(4, 4, [\"paaa\", \"lbbb\", \"caaa\", \"yxxx\"]))  # Should return false\n    print(matrixConundrum(2, 2, [\"ap\", \"ly\"]))                  # Should return true\n    print(matrixConundrum(2, 4, [\"paly\", \"xxly\"]))              # Should return true\n    print(matrixConundrum(3, 3, [\"ppl\", \"xax\", \"yyy\"]))        # Should return false", "all_input_output_value": "\ninput1: n=2, m=4, mat=[\"pppp\", \"llll\"]\noutput1: False\n--------\ninput2: n=3, m=3, mat=[\"aaa\", \"bbb\", \"ccc\"]\noutput2: False\n--------\ninput3: n=1, m=1, mat=[\"p\"]\noutput3: False\n--------\ninput4: n=4, m=4, mat=[\"paaa\", \"lbbb\", \"caaa\", \"yxxx\"]\noutput4: False\n--------\ninput5: n=2, m=2, mat=[\"ap\", \"ly\"]\noutput5: False\n--------\ninput6: n=2, m=4, mat=[\"paly\", \"xxly\"]\noutput6: False\n--------\ninput7: n=3, m=3, mat=[\"ppl\", \"xax\", \"yyy\"]\noutput7: False\n", "input_output_value": ["\ninput1: n=2, m=4, mat=[\"pppp\", \"llll\"]\noutput1: False\n", "\ninput2: n=3, m=3, mat=[\"aaa\", \"bbb\", \"ccc\"]\noutput2: False\n", "\ninput3: n=1, m=1, mat=[\"p\"]\noutput3: False\n"], "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <string>\n// TOFILL\nint main() {\n    vector<string> mat1 = {\"pppp\", \"llll\"};\n    cout << matrixConundrum(2, 4, mat1) << endl; // Test input 1\n\n    vector<string> mat2 = {\"aaa\", \"bbb\", \"ccc\"};\n    cout << matrixConundrum(3, 3, mat2) << endl; // Test input 2\n\n    vector<string> mat3 = {\"p\"};\n    cout << matrixConundrum(1, 1, mat3) << endl; // Test input 3\n\n    vector<string> mat4 = {\"paaa\", \"lbbb\", \"caaa\", \"yxxx\"};\n    cout << matrixConundrum(4, 4, mat4) << endl; // Test input 4\n\n    vector<string> mat5 = {\"ap\", \"ly\"};\n    cout << matrixConundrum(2, 2, mat5) << endl; // Test input 5\n\n    vector<string> mat6 = {\"paly\", \"xxly\"};\n    cout << matrixConundrum(2, 4, mat6) << endl; // Test input 6\n\n    vector<string> mat7 = {\"ppl\", \"xax\", \"yyy\"};\n    cout << matrixConundrum(3, 3, mat7) << endl; // Test input 7\n}", "TAG": "Success"}
{"source_Lan": "python###totalCount.py", "source_code_str": "def totalCount( n : int, s : str) -> int:\n    mod=10**9+7\n    ans=0\n    for i in range(n):\n        if s[i]==s[0]:\n            ans+=(n-i)\n            ans%=mod\n    return ans", "source_code_block": "", "target_Lan": "cpp###totalCount.cpp", "reference_code": "    int totalCount(int n, string s) {\n        int answer = 0;\n        int mod = 1e9 + 7;\n        char now = s[0];\n        for(int i = 0; i < n; i ++){\n            if(s[i] == now){\n                answer += n - i;\n                answer %= mod;\n            }\n        }\n        return answer;\n    }", "target_method_signature": "totalCount", "source_method_signature": "totalCount", "target_allMS": "    int totalCount(int n, string s) {", "source_allMS": "def totalCount( n : int, s : str) -> int:", "source_import": "", "target_import": "#include <iostream>\nusing namespace std;", "commentTag": "//", "source_code_shell": "# TOFILL\nif __name__ == \"__main__\":\n    print(totalCount(0, \"\"))\n    print(totalCount(1, \"a\"))\n    print(totalCount(5, \"aaaaa\"))\n    print(totalCount(5, \"abcde\"))\n    print(totalCount(5, \"aabba\"))\n    print(totalCount(4, \"abcd\"))\n    print(totalCount(6, \"aaaabb\"))\n    print(totalCount(3, \"baaa\"))\n    print(totalCount(5, \"aabaaa\"))\n    print(totalCount(7, \"mnopqrs\"))", "all_input_output_value": "\ninput1: n=0, s=\"\"\noutput1: 0\n--------\ninput2: n=1, s=\"a\"\noutput2: 1\n--------\ninput3: n=5, s=\"aaaaa\"\noutput3: 15\n--------\ninput4: n=5, s=\"abcde\"\noutput4: 5\n--------\ninput5: n=5, s=\"aabba\"\noutput5: 10\n--------\ninput6: n=4, s=\"abcd\"\noutput6: 4\n--------\ninput7: n=6, s=\"aaaabb\"\noutput7: 18\n--------\ninput8: n=3, s=\"baaa\"\noutput8: 3\n--------\ninput9: n=5, s=\"aabaaa\"\noutput9: 12\n--------\ninput10: n=7, s=\"mnopqrs\"\noutput10: 7\n", "input_output_value": ["\ninput1: n=0, s=\"\"\noutput1: 0\n", "\ninput2: n=1, s=\"a\"\noutput2: 1\n", "\ninput3: n=5, s=\"aaaaa\"\noutput3: 15\n"], "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <string>\n// TOFILL\nint main() {\n    cout << totalCount(0, \"\") << endl;         // Input 1\n    cout << totalCount(1, \"a\") << endl;        // Input 2\n    cout << totalCount(5, \"aaaaa\") << endl;    // Input 3\n    cout << totalCount(5, \"abcde\") << endl;    // Input 4\n    cout << totalCount(5, \"aabba\") << endl;    // Input 5\n    cout << totalCount(4, \"abcd\") << endl;     // Input 6\n    cout << totalCount(6, \"aaaabb\") << endl;   // Input 7\n    cout << totalCount(3, \"baaa\") << endl;     // Input 8\n    cout << totalCount(5, \"aabaaa\") << endl;   // Input 9\n    cout << totalCount(7, \"mnopqrs\") << endl;  // Input 10\n}", "TAG": "Success"}
{"source_Lan": "python###getSmallestString2.py", "source_code_str": "def getSmallestString2( s: str, k: int) -> str:\n    s = list(s)\n    for i, c in enumerate(map(ord, s)):\n        dis = min(c - ord('a'), ord('z') - c + 1)\n        if dis > k:\n            s[i] = chr(c - k)\n            break\n        s[i] = 'a'\n        k -= dis\n    return ''.join(s)", "source_code_block": "", "target_Lan": "cpp###getSmallestString2.cpp", "reference_code": "    string getSmallestString2(string s, int k) {\n        for (int i = 0; i < s.length(); i++) {\n            int dis = min(s[i] - 'a', 'z' - s[i] + 1);\n            if (dis > k) {\n                s[i] -= k;\n                break;\n            }\n            s[i] = 'a';\n            k -= dis;\n        }\n        return s;\n    }", "target_method_signature": "getSmallestString2", "source_method_signature": "getSmallestString2", "target_allMS": "    string getSmallestString2(string s, int k) {", "source_allMS": "def getSmallestString2( s: str, k: int) -> str:", "source_import": "", "target_import": "#include <iostream>\nusing namespace std;", "commentTag": "//", "source_code_shell": "# TOFILL\nif __name__ == \"__main__\":\n    print(getSmallestString2(\"\", 0))  # Test input 1: Empty string\n    print(getSmallestString2(\"b\", 1))  # Test input 2: Single character that can be turned into 'a'\n    print(getSmallestString2(\"abc\", 2))  # Test input 3: Multiple characters, can turn them into smallest\n    print(getSmallestString2(\"xyz\", 3))  # Test input 4: Not enough `k` to convert all\n    print(getSmallestString2(\"banana\", 10))  # Test input 5: Full conversion possible\n    print(getSmallestString2(\"testcase\", 8))  # Test input 6: Enough to change some letters but not all\n    print(getSmallestString2(\"aaaa\", 4))  # Test input 7: Already all 'a's\n    print(getSmallestString2(\"z\", 1))  # Test input 8: Largest character with limited moves\n    print(getSmallestString2(\"abcd\", 0))  # Test input 9: Cannot change anything, should remain the same\n    print(getSmallestString2(\"xzy\", 6))  # Test input 10: Two characters far from 'a', enough moves", "all_input_output_value": "\ninput1: s=\"\", k=0\noutput1: a\n--------\ninput2: s=\"b\", k=1\noutput2: aab\n--------\ninput3: s=\"abc\", k=2\noutput3: ayz\n--------\ninput4: s=\"xyz\", k=3\noutput4: aaeana\n--------\ninput5: s=\"banana\", k=10\noutput5: adstcase\n--------\ninput6: s=\"testcase\", k=8\noutput6: aaaa\n--------\ninput7: s=\"aaaa\", k=4\noutput7: a\n--------\ninput8: s=\"z\", k=1\noutput8: abcd\n--------\ninput9: s=\"abcd\", k=0\noutput9: aaa\n--------\ninput10: s=\"xzy\", k=6\noutput10: aayz\n", "input_output_value": ["\ninput1: s=\"\", k=0\noutput1: a\n", "\ninput2: s=\"b\", k=1\noutput2: aab\n", "\ninput3: s=\"abc\", k=2\noutput3: ayz\n"], "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <string>\n// TOFILL\nint main() {\n    cout << getSmallestString2(\"\", 0) << endl;          // Test input 1\n    cout << getSmallestString2(\"b\", 1) << endl;         // Test input 2\n    cout << getSmallestString2(\"abc\", 2) << endl;       // Test input 3\n    cout << getSmallestString2(\"xyz\", 3) << endl;       // Test input 4\n    cout << getSmallestString2(\"banana\", 10) << endl;   // Test input 5\n    cout << getSmallestString2(\"testcase\", 8) << endl;  // Test input 6\n    cout << getSmallestString2(\"aaaa\", 4) << endl;      // Test input 7\n    cout << getSmallestString2(\"z\", 1) << endl;         // Test input 8\n    cout << getSmallestString2(\"abcd\", 0) << endl;      // Test input 9\n    cout << getSmallestString2(\"xzy\", 6) << endl;       // Test input 10\n}", "TAG": "Success"}
{"source_Lan": "python###theMaximumAchievableX.py", "source_code_str": "def theMaximumAchievableX( num: int, t: int) -> int:\n    return num + 2 * t", "source_code_block": "", "target_Lan": "cpp###theMaximumAchievableX.cpp", "reference_code": "    int theMaximumAchievableX(int num, int t) {\n        return num + 2 * t;\n    }", "target_method_signature": "theMaximumAchievableX", "source_method_signature": "theMaximumAchievableX", "target_allMS": "    int theMaximumAchievableX(int num, int t) {", "source_allMS": "def theMaximumAchievableX( num: int, t: int) -> int:", "source_import": "", "target_import": "#include <iostream>\nusing namespace std;", "commentTag": "//", "source_code_shell": "# TOFILL\nif __name__ == \"__main__\":\n    print(theMaximumAchievableX(0, 0))\n    print(theMaximumAchievableX(10, 5))\n    print(theMaximumAchievableX(-5, 10))\n    print(theMaximumAchievableX(5, -5))\n    print(theMaximumAchievableX(1000000, 500000))\n    print(theMaximumAchievableX(-100, 0))", "all_input_output_value": "\ninput1: num=0, t=0\noutput1: 0\n--------\ninput2: num=10, t=5\noutput2: 20\n--------\ninput3: num=-5, t=10\noutput3: 15\n--------\ninput4: num=5, t=-5\noutput4: -5\n--------\ninput5: num=1000000, t=500000\noutput5: 2000000\n--------\ninput6: num=-100, t=0\noutput6: -100\n", "input_output_value": ["\ninput1: num=0, t=0\noutput1: 0\n", "\ninput2: num=10, t=5\noutput2: 20\n", "\ninput3: num=-5, t=10\noutput3: 15\n"], "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n// TOFILL\nint main() {\n    cout << theMaximumAchievableX(0, 0) << endl;\n    cout << theMaximumAchievableX(10, 5) << endl;\n    cout << theMaximumAchievableX(-5, 10) << endl;\n    cout << theMaximumAchievableX(5, -5) << endl;\n    cout << theMaximumAchievableX(1000000, 500000) << endl;\n    cout << theMaximumAchievableX(-100, 0) << endl;\n}", "TAG": "Success"}
{"source_Lan": "python###numberOfEmployeesWhoMetTarget.py", "source_code_str": "def numberOfEmployeesWhoMetTarget( hours, target):\n    ans = 0\n    for i in range(0, len(hours)):\n        if hours[i] >= target:\n            ans += 1\n    return ans", "source_code_block": "", "target_Lan": "cpp###numberOfEmployeesWhoMetTarget.cpp", "reference_code": "    int numberOfEmployeesWhoMetTarget(vector<int>& hours, int target) {\n        int ans = 0;\n        for (int i = 0; i < hours.size(); i++) {\n            if (hours[i] >= target) {\n                ans++;\n            }\n        }\n        return ans;\n    }", "target_method_signature": "numberOfEmployeesWhoMetTarget", "source_method_signature": "numberOfEmployeesWhoMetTarget", "target_allMS": "    int numberOfEmployeesWhoMetTarget(vector<int>& hours, int target) {", "source_allMS": "def numberOfEmployeesWhoMetTarget( hours, target):", "source_import": "", "target_import": "#include <iostream>\nusing namespace std;", "commentTag": "//", "source_code_shell": "# TOFILL\nif __name__ == \"__main__\":\n    print(numberOfEmployeesWhoMetTarget([], 5))\n    print(numberOfEmployeesWhoMetTarget([4, 5, 6], 5))\n    print(numberOfEmployeesWhoMetTarget([1, 2, 3], 5))\n    print(numberOfEmployeesWhoMetTarget([6, 5, 4, 3, 2], 5))\n    print(numberOfEmployeesWhoMetTarget([5, 5, 5], 5))\n    print(numberOfEmployeesWhoMetTarget([10, 20, 30], 15))\n    print(numberOfEmployeesWhoMetTarget([0, 0, 0], 0))\n    print(numberOfEmployeesWhoMetTarget([1, 1, 1], 1))\n    print(numberOfEmployeesWhoMetTarget([2, 3, 5, 0, 1], 2))\n    print(numberOfEmployeesWhoMetTarget([9, 10, 15, 5, 7], 8))", "all_input_output_value": "\ninput1: hours=[], target=5\noutput1: 0\n--------\ninput2: hours=[4, 5, 6], target=5\noutput2: 2\n--------\ninput3: hours=[1, 2, 3], target=5\noutput3: 0\n--------\ninput4: hours=[6, 5, 4, 3, 2], target=5\noutput4: 2\n--------\ninput5: hours=[5, 5, 5], target=5\noutput5: 3\n--------\ninput6: hours=[10, 20, 30], target=15\noutput6: 2\n--------\ninput7: hours=[0, 0, 0], target=0\noutput7: 3\n--------\ninput8: hours=[1, 1, 1], target=1\noutput8: 3\n--------\ninput9: hours=[2, 3, 5, 0, 1], target=2\noutput9: 3\n--------\ninput10: hours=[9, 10, 15, 5, 7], target=8\noutput10: 3\n", "input_output_value": ["\ninput1: hours=[], target=5\noutput1: 0\n", "\ninput2: hours=[4, 5, 6], target=5\noutput2: 2\n", "\ninput3: hours=[1, 2, 3], target=5\noutput3: 0\n"], "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    vector<int> hours1 = {};\n    cout << numberOfEmployeesWhoMetTarget(hours1, 5) << endl;\n\n    vector<int> hours2 = {4, 5, 6};\n    cout << numberOfEmployeesWhoMetTarget(hours2, 5) << endl;\n\n    vector<int> hours3 = {1, 2, 3};\n    cout << numberOfEmployeesWhoMetTarget(hours3, 5) << endl;\n\n    vector<int> hours4 = {6, 5, 4, 3, 2};\n    cout << numberOfEmployeesWhoMetTarget(hours4, 5) << endl;\n\n    vector<int> hours5 = {5, 5, 5};\n    cout << numberOfEmployeesWhoMetTarget(hours5, 5) << endl;\n\n    vector<int> hours6 = {10, 20, 30};\n    cout << numberOfEmployeesWhoMetTarget(hours6, 15) << endl;\n\n    vector<int> hours7 = {0, 0, 0};\n    cout << numberOfEmployeesWhoMetTarget(hours7, 0) << endl;\n\n    vector<int> hours8 = {1, 1, 1};\n    cout << numberOfEmployeesWhoMetTarget(hours8, 1) << endl;\n\n    vector<int> hours9 = {2, 3, 5, 0, 1};\n    cout << numberOfEmployeesWhoMetTarget(hours9, 2) << endl;\n\n    vector<int> hours10 = {9, 10, 15, 5, 7};\n    cout << numberOfEmployeesWhoMetTarget(hours10, 8) << endl;\n\n    return 0;\n}", "TAG": "Success"}
{"source_Lan": "python###minimumSteps.py", "source_code_str": "def minimumSteps( s):\n    ans, sum = 0, 0\n    for i in range(len(s)):\n        if s[i] == '1':\n            sum += 1\n        else:\n            ans += sum\n    return ans", "source_code_block": "", "target_Lan": "cpp###minimumSteps.cpp", "reference_code": "    long long minimumSteps(string s) {\n        long long ans = 0;\n        int sum = 0;\n        for (int i = 0; i < s.size(); i++) {\n            if (s[i] == '1') {\n                sum++;\n            } else {\n                ans += sum;\n            }\n        }\n        return ans;\n    }", "target_method_signature": "minimumSteps", "source_method_signature": "minimumSteps", "target_allMS": "    long long minimumSteps(string s) {", "source_allMS": "def minimumSteps( s):", "source_import": "", "target_import": "#include <iostream>\nusing namespace std;", "commentTag": "//", "source_code_shell": "# TOFILL\nif __name__ == \"__main__\":\n    print(minimumSteps(\"1111\"))          # Expect 0\n    print(minimumSteps(\"0000\"))          # Expect 0\n    print(minimumSteps(\"101010\"))        # Expect 6\n    print(minimumSteps(\"00111\"))         # Expect 3\n    print(minimumSteps(\"111000\"))        # Expect 3\n    print(minimumSteps(\"100010\"))        # Expect 1\n    print(minimumSteps(\"\"))               # Expect 0\n    print(minimumSteps(\"11000\"))         # Expect 3\n    print(minimumSteps(\"1011110\"))       # Expect 7\n    print(minimumSteps(\"000111000\"))     # Expect 3", "all_input_output_value": "\ninput1: s=\"1111\"\noutput1: 0\n--------\ninput2: s=\"0000\"\noutput2: 0\n--------\ninput3: s=\"101010\"\noutput3: 6\n--------\ninput4: s=\"00111\"\noutput4: 0\n--------\ninput5: s=\"111000\"\noutput5: 9\n--------\ninput6: s=\"100010\"\noutput6: 5\n--------\ninput7: s=\"\"\noutput7: 0\n--------\ninput8: s=\"11000\"\noutput8: 6\n--------\ninput9: s=\"1011110\"\noutput9: 6\n--------\ninput10: s=\"000111000\"\noutput10: 9\n", "input_output_value": ["\ninput1: s=\"1111\"\noutput1: 0\n", "\ninput2: s=\"0000\"\noutput2: 0\n", "\ninput3: s=\"101010\"\noutput3: 6\n"], "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <string>\n// TOFILL\nint main() {\n    cout << minimumSteps(\"1111\") << endl;\n    cout << minimumSteps(\"0000\") << endl;\n    cout << minimumSteps(\"101010\") << endl;\n    cout << minimumSteps(\"00111\") << endl;\n    cout << minimumSteps(\"111000\") << endl;\n    cout << minimumSteps(\"100010\") << endl;\n    cout << minimumSteps(\"\") << endl;\n    cout << minimumSteps(\"11000\") << endl;\n    cout << minimumSteps(\"1011110\") << endl;\n    cout << minimumSteps(\"000111000\") << endl;\n}", "TAG": "Success"}
{"source_Lan": "python###findChampion.py", "source_code_str": "def findChampion( n: int, edges: List[List[int]]) -> int:\n    degree = [0] * n\n    for x, y in edges:\n        degree[y] += 1\n    champion = -1\n    for i, d in enumerate(degree):\n        if d == 0:\n            if champion == -1:\n                champion = i\n            else:\n                return -1\n    return champion", "source_code_block": "", "target_Lan": "cpp###findChampion.cpp", "reference_code": "    int findChampion(int n, vector<vector<int>>& edges) {\n        vector<int> degree(n);\n        for (auto e : edges) {\n            degree[e[1]]++;\n        }\n        int champion = -1;\n        for (int i = 0; i < n; i++) {\n            if (degree[i] == 0) {\n                if (champion == -1) {\n                    champion = i;\n                } else {\n                    return -1;\n                }\n            }\n        }\n        return champion;\n    }", "target_method_signature": "findChampion", "source_method_signature": "findChampion", "target_allMS": "    int findChampion(int n, vector<vector<int>>& edges) {", "source_allMS": "def findChampion( n: int, edges: List[List[int]]) -> int:", "source_import": "", "target_import": "#include <iostream>\nusing namespace std;", "commentTag": "//", "source_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(findChampion(5, [[1, 0], [2, 0], [3, 1], [4, 3]]))  # Multiple champions (0 has two incoming edges)\n    print(findChampion(5, [[1, 0], [2, 1]]))                  # Node 0 is a champion (no incoming edges) \n    print(findChampion(5, [[0, 1], [0, 2], [1, 3], [2, 3]]))  # No champions (nodes 1 and 2 have incoming edges)\n    print(findChampion(5, [[0, 1], [1, 2], [2, 0]]))          # All nodes have incoming edges (no champion)\n    print(findChampion(3, [[0, 1], [1, 2], [2, 0]]))          # Cycle, no champions\n    print(findChampion(4, [[0, 1], [1, 2], [0, 2]]))          # One node with no incoming edges (node 3 is champion)\n    print(findChampion(6, [[0, 1], [0, 2], [2, 3], [4, 5]])) # Node 3 is champion\n    print(findChampion(3, [[0, 2], [1, 2]]))                  # Node 2 cannot be champion, so return -1", "all_input_output_value": "\ninput1: n=5, edges=[[1, 0], [2, 0], [3, 1], [4, 3]]\noutput1: -1\n--------\ninput2: n=5, edges=[[1, 0], [2, 1]]\noutput2: -1\n--------\ninput3: n=5, edges=[[0, 1], [0, 2], [1, 3], [2, 3]]\noutput3: -1\n--------\ninput4: n=5, edges=[[0, 1], [1, 2], [2, 0]]\noutput4: -1\n--------\ninput5: n=3, edges=[[0, 1], [1, 2], [2, 0]]\noutput5: -1\n--------\ninput6: n=4, edges=[[0, 1], [1, 2], [0, 2]]\noutput6: -1\n--------\ninput7: n=6, edges=[[0, 1], [0, 2], [2, 3], [4, 5]]\noutput7: -1\n--------\ninput8: n=3, edges=[[0, 2], [1, 2]]\noutput8: -1\n", "input_output_value": ["\ninput1: n=5, edges=[[1, 0], [2, 0], [3, 1], [4, 3]]\noutput1: -1\n", "\ninput2: n=5, edges=[[1, 0], [2, 1]]\noutput2: -1\n", "\ninput3: n=5, edges=[[0, 1], [0, 2], [1, 3], [2, 3]]\noutput3: -1\n"], "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    vector<vector<int>> edges1 = {{1, 0}, {2, 0}, {3, 1}, {4, 3}};\n    cout << findChampion(5, edges1) << endl;\n\n    vector<vector<int>> edges2 = {{1, 0}, {2, 1}};\n    cout << findChampion(5, edges2) << endl;\n\n    vector<vector<int>> edges3 = {{0, 1}, {0, 2}, {1, 3}, {2, 3}};\n    cout << findChampion(5, edges3) << endl;\n\n    vector<vector<int>> edges4 = {{0, 1}, {1, 2}, {2, 0}};\n    cout << findChampion(5, edges4) << endl;\n\n    vector<vector<int>> edges5 = {{0, 1}, {1, 2}, {2, 0}};\n    cout << findChampion(3, edges5) << endl;\n\n    vector<vector<int>> edges6 = {{0, 1}, {1, 2}, {0, 2}};\n    cout << findChampion(4, edges6) << endl;\n\n    vector<vector<int>> edges7 = {{0, 1}, {0, 2}, {2, 3}, {4, 5}};\n    cout << findChampion(6, edges7) << endl;\n\n    vector<vector<int>> edges8 = {{0, 2}, {1, 2}};\n    cout << findChampion(3, edges8) << endl;\n\n    return 0;\n}", "TAG": "Success"}
{"source_Lan": "python###BeautifulBits.py", "source_code_str": "def BeautifulBits( n : int, arr : List[int], q : int, queries : List[List[int]]) -> List[int]:\n    pref = [[0] * 32 for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(32):\n            pref[i][j] = pref[i - 1][j] + ((arr[i - 1] >> j) & 1)\n    ans = [0] * q\n    for i in range(q):\n        for j in range(32):\n            if pref[queries[i][1]][j] - pref[queries[i][0] - 1][j] != 0:\n                ans[i] += 1 << j\n    return ans", "source_code_block": "", "target_Lan": "cpp###BeautifulBits.cpp", "reference_code": "    vector<int> BeautifulBits(int n, vector<int> &arr, int q,\n                              vector<vector<int> > &queries) {\n        vector<vector<long long> > pref(n + 1, vector<long long>(32, 0));\n        for (int i = 1; i <= n; i++) {\n            for (int j = 0; j < 32; j++) {\n                pref[i][j] = pref[i - 1][j] + ((arr[i - 1] >> j) & 1);\n            }\n        }\n        vector<int> ans(q, 0);\n        for (int i = 0; i < q; i++) {\n            for (int j = 0; j < 32; j++) {\n                if (pref[queries[i][1]][j] - pref[queries[i][0] - 1][j] != 0) {\n                    ans[i] += 1 << j;\n                }\n            }\n        }\n        return ans;\n    }", "target_method_signature": "BeautifulBits", "source_method_signature": "BeautifulBits", "target_allMS": "    vector<int> BeautifulBits(int n, vector<int> &arr, int q,", "source_allMS": "def BeautifulBits( n : int, arr : List[int], q : int, queries : List[List[int]]) -> List[int]:", "source_import": "from typing import List", "target_import": "#include <iostream>\n#include <vector>\nusing namespace std;", "commentTag": "//", "source_code_shell": "from typing import List\nfrom typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(BeautifulBits(1, [0], 1, [[1, 1]]))\n    print(BeautifulBits(1, [1], 1, [[1, 1]]))\n    print(BeautifulBits(5, [0, 0, 0, 0, 0], 1, [[1, 5]]))\n    print(BeautifulBits(5, [1, 2, 3, 4, 5], 1, [[1, 5]]))\n    print(BeautifulBits(5, [5, 10, 15, 20, 25], 2, [[1, 3], [2, 5]]))\n    print(BeautifulBits(5, [7, 7, 7, 7, 7], 1, [[1, 5]]))\n    print(BeautifulBits(5, [1, 3, 5, 7, 9], 1, [[2, 4]]))\n    print(BeautifulBits(6, [0, 1, 1, 2, 2, 3], 1, [[1, 6]]))\n    print(BeautifulBits(4, [15, 15, 15, 15], 1, [[1, 4]]))", "all_input_output_value": "\ninput1: n=1, arr=[0], q=1, queries=[[1, 1]]\noutput1: [0]\n--------\ninput2: n=1, arr=[1], q=1, queries=[[1, 1]]\noutput2: [1]\n--------\ninput3: n=5, arr=[0, 0, 0, 0, 0], q=1, queries=[[1, 5]]\noutput3: [0]\n--------\ninput4: n=5, arr=[1, 2, 3, 4, 5], q=1, queries=[[1, 5]]\noutput4: [7]\n--------\ninput5: n=5, arr=[5, 10, 15, 20, 25], q=2, queries=[[1, 3], [2, 5]]\noutput5: [15, 31]\n--------\ninput6: n=5, arr=[7, 7, 7, 7, 7], q=1, queries=[[1, 5]]\noutput6: [7]\n--------\ninput7: n=5, arr=[1, 3, 5, 7, 9], q=1, queries=[[2, 4]]\noutput7: [3]\n--------\ninput8: n=6, arr=[0, 1, 1, 2, 2, 3], q=1, queries=[[1, 6]]\noutput8: [15]\n--------\ninput9: n=4, arr=[15, 15, 15, 15], q=1, queries=[[1, 4]]\noutput9: [15]\n", "input_output_value": ["\ninput1: n=1, arr=[0], q=1, queries=[[1, 1]]\noutput1: [0]\n", "\ninput2: n=1, arr=[1], q=1, queries=[[1, 1]]\noutput2: [1]\n", "\ninput3: n=5, arr=[0, 0, 0, 0, 0], q=1, queries=[[1, 5]]\noutput3: [0]\n"], "target_code_shell": "#include <iostream>\n#include <vector>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    vector<int> arr1 = {0};\n    vector<vector<int>> queries1 = {{1, 1}};\n    vector<int> result1 = BeautifulBits(1, arr1, 1, queries1);\n    cout << result1[0] << endl;\n\n    vector<int> arr2 = {1};\n    vector<vector<int>> queries2 = {{1, 1}};\n    vector<int> result2 = BeautifulBits(1, arr2, 1, queries2);\n    cout << result2[0] << endl;\n\n    vector<int> arr3 = {0, 0, 0, 0, 0};\n    vector<vector<int>> queries3 = {{1, 5}};\n    vector<int> result3 = BeautifulBits(5, arr3, 1, queries3);\n    cout << result3[0] << endl;\n\n    vector<int> arr4 = {1, 2, 3, 4, 5};\n    vector<vector<int>> queries4 = {{1, 5}};\n    vector<int> result4 = BeautifulBits(5, arr4, 1, queries4);\n    cout << result4[0] << endl;\n\n    vector<int> arr5 = {5, 10, 15, 20, 25};\n    vector<vector<int>> queries5 = {{1, 3}, {2, 5}};\n    vector<int> result5 = BeautifulBits(5, arr5, 2, queries5);\n    cout << result5[0] << \" \" << result5[1] << endl;\n\n    vector<int> arr6 = {7, 7, 7, 7, 7};\n    vector<vector<int>> queries6 = {{1, 5}};\n    vector<int> result6 = BeautifulBits(5, arr6, 1, queries6);\n    cout << result6[0] << endl;\n\n    vector<int> arr7 = {1, 3, 5, 7, 9};\n    vector<vector<int>> queries7 = {{2, 4}};\n    vector<int> result7 = BeautifulBits(5, arr7, 1, queries7);\n    cout << result7[0] << endl;\n\n    vector<int> arr8 = {0, 1, 1, 2, 2, 3};\n    vector<vector<int>> queries8 = {{1, 6}};\n    vector<int> result8 = BeautifulBits(6, arr8, 1, queries8);\n    cout << result8[0] << endl;\n\n    vector<int> arr9 = {15, 15, 15, 15};\n    vector<vector<int>> queries9 = {{1, 4}};\n    vector<int> result9 = BeautifulBits(4, arr9, 1, queries9);\n    cout << result9[0] << endl;\n\n    return 0;\n}", "TAG": "Success"}
{"source_Lan": "python###maxAlternatingSubstring.py", "source_code_str": "def maxAlternatingSubstring( N: int, S: str) -> int:\n    diff = []\n    i = 0\n    while i < N:\n        j = i + 1\n        while j < N and S[j] != S[j - 1]:\n            j += 1\n        diff.append(j - i)\n        i = j\n    diff.append(0)\n    ans_before = 0\n    for x in diff:\n        ans_before += ((x * (x + 1)) // 2)\n    ans = 0\n    for i in range(len(diff) - 1):\n        a = diff[i]\n        b = diff[i + 1]\n        currAns = (ans_before - ((a * (a + 1)) // 2) -\n                   ((b * (b + 1)) // 2) + ((a + b + 1) * (a + b + 2)) // 2)\n        ans = max(ans, currAns)\n    return ans", "source_code_block": "", "target_Lan": "cpp###maxAlternatingSubstring.cpp", "reference_code": "    long long maxAlternatingSubstring(int N, string S) {\n        vector<long long> diff;\n        for (int i = 0; i < N;) {\n            int j = i + 1;\n            while (j < N && S[j] != S[j - 1])\n                j++;\n            diff.push_back(j - i);\n            i = j;\n        }\n        diff.push_back(0);\n        long long ans_before = 0;\n        for (long long x : diff) {\n            ans_before += ((x * (x + 1)) / 2);\n        }\n        long long ans = 0;\n        for (int i = 0; i < diff.size() - 1; ++i) {\n            long long a = diff[i];\n            long long b = diff[i + 1];\n            long long currAns = ans_before - ((a * (a + 1)) / 2) - ((b * (b + 1)) / 2) +\n                                ((a + b + 1) * (a + b + 2)) / 2;\n            ans = max(ans, currAns);\n        }\n        return ans;\n    }", "target_method_signature": "maxAlternatingSubstring", "source_method_signature": "maxAlternatingSubstring", "target_allMS": "    long long maxAlternatingSubstring(int N, string S) {", "source_allMS": "def maxAlternatingSubstring( N: int, S: str) -> int:", "source_import": "", "target_import": "#include <iostream>\n#include <vector>\nusing namespace std;", "commentTag": "//", "source_code_shell": "# TOFILL\nif __name__ == \"__main__\":\n    print(maxAlternatingSubstring(0, \"\"))              # Edge case: Empty string\n    print(maxAlternatingSubstring(1, \"A\"))             # Single character\n    print(maxAlternatingSubstring(5, \"ABCDE\"))         # Simple alternating pattern\n    print(maxAlternatingSubstring(6, \"AABBAA\"))        # Mixed alternating pattern\n    print(maxAlternatingSubstring(8, \"ABABABAB\"))      # Longer simple alternating pattern\n    print(maxAlternatingSubstring(6, \"AAABBB\"))        # No alternation, two groups\n    print(maxAlternatingSubstring(10, \"AABBABABAB\"))   # Longer complex alternating pattern\n    print(maxAlternatingSubstring(5, \"CCCCC\"))         # All same characters", "all_input_output_value": "\ninput1: N=0, S=\"\"\noutput1: 0\n--------\ninput2: N=1, S=\"A\"\noutput2: 3\n--------\ninput3: N=5, S=\"ABCDE\"\noutput3: 21\n--------\ninput4: N=6, S=\"AABBAA\"\noutput4: 17\n--------\ninput5: N=8, S=\"ABABABAB\"\noutput5: 45\n--------\ninput6: N=6, S=\"AAABBB\"\noutput6: 13\n--------\ninput7: N=10, S=\"AABBABABAB\"\noutput7: 56\n--------\ninput8: N=5, S=\"CCCCC\"\noutput8: 9\n", "input_output_value": ["\ninput1: N=0, S=\"\"\noutput1: 0\n", "\ninput2: N=1, S=\"A\"\noutput2: 3\n", "\ninput3: N=5, S=\"ABCDE\"\noutput3: 21\n"], "target_code_shell": "#include <iostream>\n#include <vector>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <string>\n// TOFILL\nint main() {\n    cout << maxAlternatingSubstring(0, \"\") << endl;          // Input 1\n    cout << maxAlternatingSubstring(1, \"A\") << endl;         // Input 2\n    cout << maxAlternatingSubstring(5, \"ABCDE\") << endl;     // Input 3\n    cout << maxAlternatingSubstring(6, \"AABBAA\") << endl;    // Input 4\n    cout << maxAlternatingSubstring(8, \"ABABABAB\") << endl;   // Input 5\n    cout << maxAlternatingSubstring(6, \"AAABBB\") << endl;    // Input 6\n    cout << maxAlternatingSubstring(10, \"AABBABABAB\") << endl; // Input 7\n    cout << maxAlternatingSubstring(5, \"CCCCC\") << endl;      // Input 8\n}", "TAG": "Success"}
{"source_Lan": "python###canTrade.py", "source_code_str": "def canTrade( n: int, beautifulness: List[int], q: int,\n             queries: List[List[int]]) -> List[int]:\n    par = [i for i in range(n)]\n    for i in range(1, n):\n        if beautifulness[i] == beautifulness[i - 1]:\n            par[i] = par[i - 1]\n        else:\n            pass\n    ans = []\n    for el in queries:\n        a, b = el[0] - 1, el[1] - 1\n        if par[a] == par[b]:\n            ans.append(1)\n        else:\n            ans.append(0)\n    return ans", "source_code_block": "", "target_Lan": "cpp###canTrade.cpp", "reference_code": "    vector<int> canTrade(int n, vector<int>& beautifulness, int q,\n                         vector<vector<int>>& queries) {\n        int prev = beautifulness[0];\n        beautifulness[0] = 0;\n        for (int i = 1; i < n; i++) {\n            int curr = beautifulness[i];\n            if (beautifulness[i] == prev)\n                beautifulness[i] = beautifulness[i - 1];\n            else\n                beautifulness[i] = i;\n            prev = curr;\n        }\n        vector<int> ans(q);\n        for (int i = 0; i < q; i++) {\n            int u = queries[i][0], v = queries[i][1];\n            u--;\n            v--;\n            if (beautifulness[v] <= u)\n                ans[i] = 1;\n        }\n        return ans;\n    }", "target_method_signature": "canTrade", "source_method_signature": "canTrade", "target_allMS": "    vector<int> canTrade(int n, vector<int>& beautifulness, int q,", "source_allMS": "def canTrade( n: int, beautifulness: List[int], q: int,", "source_import": "from typing import List\nfrom typing import List", "target_import": "#include <iostream>\n#include <vector>\nusing namespace std;", "commentTag": "//", "source_code_shell": "from typing import List\nfrom typing import List\nfrom typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    # Test Input 1\n    print(canTrade(5, [1, 1, 2, 3, 3], 1, [[3, 5]]))  # expected_output=[1]\n    # Test Input 2\n    print(canTrade(5, [3, 3, 3, 3, 3], 2, [[1, 5], [2, 4]]))  # expected_output=[1, 1]\n    # Test Input 3\n    print(canTrade(5, [0, 0, 0, 0, 0], 2, [[1, 1], [1, 5]]))  # expected_output=[1, 1]\n    # Test Input 4\n    print(canTrade(4, [6, 2, 2, 5], 1, [[1, 2]]))  # expected_output=[0]\n    # Test Input 5\n    print(canTrade(3, [1, 2, 1], 1, [[1, 3]]))  # expected_output=[1]", "all_input_output_value": "\ninput1: n=5, beautifulness=[1, 1, 2, 3, 3], q=1, queries=[[3, 5]]\noutput1: [0]\n--------\ninput2: n=5, beautifulness=[3, 3, 3, 3, 3], q=2, queries=[[1, 5], [2, 4]]\noutput2: [1, 1]\n--------\ninput3: n=5, beautifulness=[0, 0, 0, 0, 0], q=2, queries=[[1, 1], [1, 5]]\noutput3: [1, 1]\n--------\ninput4: n=4, beautifulness=[6, 2, 2, 5], q=1, queries=[[1, 2]]\noutput4: [0]\n--------\ninput5: n=3, beautifulness=[1, 2, 1], q=1, queries=[[1, 3]]\noutput5: [1]\n", "input_output_value": ["\ninput1: n=5, beautifulness=[1, 1, 2, 3, 3], q=1, queries=[[3, 5]]\noutput1: [0]\n", "\ninput2: n=5, beautifulness=[3, 3, 3, 3, 3], q=2, queries=[[1, 5], [2, 4]]\noutput2: [1, 1]\n", "\ninput3: n=5, beautifulness=[0, 0, 0, 0, 0], q=2, queries=[[1, 1], [1, 5]]\noutput3: [1, 1]\n"], "target_code_shell": "#include <iostream>\n#include <vector>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    vector<int> beautifulness1 = {1, 1, 2, 3, 3};\n    vector<vector<int>> queries1 = {{3, 5}};\n    vector<int> result1 = canTrade(5, beautifulness1, 1, queries1);\n    for(int res : result1) cout << res << \" \";\n    cout << endl;\n\n    vector<int> beautifulness2 = {3, 3, 3, 3, 3};\n    vector<vector<int>> queries2 = {{1, 5}, {2, 4}};\n    vector<int> result2 = canTrade(5, beautifulness2, 2, queries2);\n    for(int res : result2) cout << res << \" \";\n    cout << endl;\n\n    vector<int> beautifulness3 = {0, 0, 0, 0, 0};\n    vector<vector<int>> queries3 = {{1, 1}, {1, 5}};\n    vector<int> result3 = canTrade(5, beautifulness3, 2, queries3);\n    for(int res : result3) cout << res << \" \";\n    cout << endl;\n\n    vector<int> beautifulness4 = {6, 2, 2, 5};\n    vector<vector<int>> queries4 = {{1, 2}};\n    vector<int> result4 = canTrade(4, beautifulness4, 1, queries4);\n    for(int res : result4) cout << res << \" \";\n    cout << endl;\n\n    vector<int> beautifulness5 = {1, 2, 1};\n    vector<vector<int>> queries5 = {{1, 3}};\n    vector<int> result5 = canTrade(3, beautifulness5, 1, queries5);\n    for(int res : result5) cout << res << \" \";\n    cout << endl;\n\n    return 0;\n}", "TAG": "Success"}
{"source_Lan": "python###countCompleteDayPairs.py", "source_code_str": "def countCompleteDayPairs( hours: List[int]) -> int:\n    ans = 0\n    cnt = [0] * 24\n    for t in hours:\n        \n        \n        ans += cnt[(24 - t % 24) % 24]\n        cnt[t % 24] += 1\n    return ans", "source_code_block": "", "target_Lan": "cpp###countCompleteDayPairs.cpp", "reference_code": "    long long countCompleteDayPairs(vector<int> &hours) {\n        long long ans = 0;\n        int cnt[24]{};\n        for (int t : hours) {\n            \n            \n            ans += cnt[(24 - t % 24) % 24];\n            cnt[t % 24]++;\n        }\n        return ans;\n    }", "target_method_signature": "countCompleteDayPairs", "source_method_signature": "countCompleteDayPairs", "target_allMS": "    long long countCompleteDayPairs(vector<int> &hours) {", "source_allMS": "def countCompleteDayPairs( hours: List[int]) -> int:", "source_import": "", "target_import": "#include <iostream>\n#include <vector>\nusing namespace std;", "commentTag": "//", "source_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(countCompleteDayPairs([0, 1, 2, 3, 4, 5]))  # All different hours\n    print(countCompleteDayPairs([24, 24, 24, 24]))     # All hours that are the same, expecting 0 pairs\n    print(countCompleteDayPairs([23, 1, 1, 1, 23]))    # Edge case with complements and duplicates\n    print(countCompleteDayPairs([12, 12, 12, 12]))      # Multiple pairs that can be formed\n    print(countCompleteDayPairs([5, 19, 11, 13, 5]))    # Mixed input to form several pairs\n    print(countCompleteDayPairs([0, 12]))               # One pair complements\n    print(countCompleteDayPairs([3, 21]))               # Another viable pair completion\n    print(countCompleteDayPairs([20, 4, 8, 24]))        # Mixed, some pairs formed\n    print(countCompleteDayPairs([15, 9, 3, 21, 18]))    # Multiple complements\n    print(countCompleteDayPairs([6, 18, 6]))             # Duplicates that form pairs", "all_input_output_value": "\ninput1: hours=[0, 1, 2, 3, 4, 5]\noutput1: 0\n--------\ninput2: hours=[24, 24, 24, 24]\noutput2: 6\n--------\ninput3: hours=[23, 1, 1, 1, 23]\noutput3: 6\n--------\ninput4: hours=[12, 12, 12, 12]\noutput4: 6\n--------\ninput5: hours=[5, 19, 11, 13, 5]\noutput5: 3\n--------\ninput6: hours=[0, 12]\noutput6: 0\n--------\ninput7: hours=[3, 21]\noutput7: 1\n--------\ninput8: hours=[20, 4, 8, 24]\noutput8: 1\n--------\ninput9: hours=[15, 9, 3, 21, 18]\noutput9: 2\n--------\ninput10: hours=[6, 18, 6]\noutput10: 2\n", "input_output_value": ["\ninput1: hours=[0, 1, 2, 3, 4, 5]\noutput1: 0\n", "\ninput2: hours=[24, 24, 24, 24]\noutput2: 6\n", "\ninput3: hours=[23, 1, 1, 1, 23]\noutput3: 6\n"], "target_code_shell": "#include <iostream>\n#include <vector>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    // Test Inputs\n    vector<int> hours1 = {0, 1, 2, 3, 4, 5};\n    vector<int> hours2 = {24, 24, 24, 24};\n    vector<int> hours3 = {23, 1, 1, 1, 23};\n    vector<int> hours4 = {12, 12, 12, 12};\n    vector<int> hours5 = {5, 19, 11, 13, 5};\n    vector<int> hours6 = {0, 12};\n    vector<int> hours7 = {3, 21};\n    vector<int> hours8 = {20, 4, 8, 24};\n    vector<int> hours9 = {15, 9, 3, 21, 18};\n    vector<int> hours10 = {6, 18, 6};\n\n    cout << countCompleteDayPairs(hours1) << endl;\n    cout << countCompleteDayPairs(hours2) << endl;\n    cout << countCompleteDayPairs(hours3) << endl;\n    cout << countCompleteDayPairs(hours4) << endl;\n    cout << countCompleteDayPairs(hours5) << endl;\n    cout << countCompleteDayPairs(hours6) << endl;\n    cout << countCompleteDayPairs(hours7) << endl;\n    cout << countCompleteDayPairs(hours8) << endl;\n    cout << countCompleteDayPairs(hours9) << endl;\n    cout << countCompleteDayPairs(hours10) << endl;\n\n    return 0;\n}", "TAG": "Success"}
{"source_Lan": "python###satisfiesConditions.py", "source_code_str": "def satisfiesConditions( grid: List[List[int]]) -> bool:\n    for i, row in enumerate(grid):\n        for j, x in enumerate(row):\n            if j and x == row[j - 1] or i and x != grid[i - 1][j]:\n                return False\n    return True", "source_code_block": "", "target_Lan": "cpp###satisfiesConditions.cpp", "reference_code": "    bool satisfiesConditions(vector<vector<int>>& grid) {\n        for (int i = 0; i < grid.size(); i++) {\n            for (int j = 0; j < grid[i].size(); j++) {\n                if (j && grid[i][j] == grid[i][j - 1] || i && grid[i][j] != grid[i - 1][j]) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }", "target_method_signature": "satisfiesConditions", "source_method_signature": "satisfiesConditions", "target_allMS": "    bool satisfiesConditions(vector<vector<int>>& grid) {", "source_allMS": "def satisfiesConditions( grid: List[List[int]]) -> bool:", "source_import": "", "target_import": "#include <iostream>\n#include <vector>\nusing namespace std;", "commentTag": "//", "source_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(satisfiesConditions([[1, 1], [1, 1]]))   # Input 1: True\n    print(satisfiesConditions([[1, 2], [1, 1]]))   # Input 2: False\n    print(satisfiesConditions([[1, 1], [2, 1]]))   # Input 3: False\n    print(satisfiesConditions([[]]))                # Input 4: True\n    print(satisfiesConditions([[1]]))              # Input 5: True\n    print(satisfiesConditions([[1, 1, 1], [1, 1, 1], [1, 1, 1]]))  # Input 6: True\n    print(satisfiesConditions([[1, 2, 3], [1, 2, 3], [1, 2, 3]]))  # Input 7: False\n    print(satisfiesConditions([[1, 1], [1, 2]]))   # Input 8: False\n    print(satisfiesConditions([[0, 0, 0], [0, 0, 0], [0, 0, 0]]))  # Input 9: True\n    print(satisfiesConditions([[1, -1, 1], [1, -1, 1]]))  # Input 10: False", "all_input_output_value": "\ninput1: grid=[[1, 1], [1, 1]]\noutput1: False\n--------\ninput2: grid=[[1, 2], [1, 1]]\noutput2: False\n--------\ninput3: grid=[[1, 1], [2, 1]]\noutput3: False\n--------\ninput4: grid=[[]]\noutput4: True\n--------\ninput5: grid=[[1]]\noutput5: True\n--------\ninput6: grid=[[1, 1, 1], [1, 1, 1], [1, 1, 1]]\noutput6: False\n--------\ninput7: grid=[[1, 2, 3], [1, 2, 3], [1, 2, 3]]\noutput7: False\n--------\ninput8: grid=[[1, 1], [1, 2]]\noutput8: False\n--------\ninput9: grid=[[0, 0, 0], [0, 0, 0], [0, 0, 0]]\noutput9: True\n--------\ninput10: grid=[[1, -1, 1], [1, -1, 1]]\noutput10: False\n", "input_output_value": ["\ninput1: grid=[[1, 1], [1, 1]]\noutput1: False\n", "\ninput2: grid=[[1, 2], [1, 1]]\noutput2: False\n", "\ninput3: grid=[[1, 1], [2, 1]]\noutput3: False\n"], "target_code_shell": "#include <iostream>\n#include <vector>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    vector<vector<vector<int>>> testInputs = {\n        {{1, 1}, {1, 1}},\n        {{1, 2}, {1, 1}},\n        {{1, 1}, {2, 1}},\n        {{}},\n        {{1}},\n        {{1, 1, 1}, {1, 1, 1}, {1, 1, 1}},\n        {{1, 2, 3}, {1, 2, 3}, {1, 2, 3}},\n        {{1, 1}, {1, 2}},\n        {{0, 0, 0}, {0, 0, 0}, {0, 0, 0}},\n        {{1, -1, 1}, {1, -1, 1}}\n    };\n    \n    for(const auto& grid : testInputs) {\n        cout << satisfiesConditions(const_cast<vector<vector<int>>&>(grid)) << endl;\n    }\n    return 0;\n}", "TAG": "Success"}
{"source_Lan": "python###MaxDiff.py", "source_code_str": "def MaxDiff( A: List[int], n: int) -> int:\n    \n    mx = [-1] * 1001\n    mn = [n + 1] * 1001\n    \n    for i in range(n):\n        mx[A[i]] = max(mx[A[i]], i)\n        mn[A[i]] = min(mn[A[i]], i)\n    ans = -1\n    \n    for i in range(1, 1001):\n        for j in range(i, 1001):\n            era = gcd(i, j)\n            if era != 1:\n                continue\n            if mx[i] != -1 and mx[j] != -1:\n                ans = max(ans, abs(mx[i] - mn[j]))\n                ans = max(ans, abs(mx[j] - mn[i]))\n    return ans", "source_code_block": "", "target_Lan": "cpp###MaxDiff.cpp", "reference_code": "    int MaxDiff(vector<int> &A, int n) {\n        vector<int> mx(1001, -1), mn(1001, n + 1);\n        for (int i = 0; i < n; i++) {\n            mx[A[i]] = max(mx[A[i]], i);\n            mn[A[i]] = min(mn[A[i]], i);\n        }\n        int ans = -1;\n        for (int i = 1; i <= 1000; i++) {\n            for (int j = i; j <= 1000; j++) {\n                int era = __gcd(i, j);\n                if (era != 1)\n                    continue;\n                if (mx[i] != -1 && mx[j] != -1) {\n                    ans = max(ans, abs(mx[i] - mn[j]));\n                    ans = max(ans, abs(mx[j] - mn[i]));\n                }\n            }\n        }\n        return ans;\n    }", "target_method_signature": "MaxDiff", "source_method_signature": "MaxDiff", "target_allMS": "    int MaxDiff(vector<int> &A, int n) {", "source_allMS": "def MaxDiff( A: List[int], n: int) -> int:", "source_import": "from typing import List\nfrom math import gcd", "target_import": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;", "commentTag": "//", "source_code_shell": "from typing import List\nfrom math import gcd\nfrom typing import List\nfrom math import gcd\n# TOFILL\nif __name__ == \"__main__\":\n    print(MaxDiff([1, 2, 3, 4, 5], 5))\n    print(MaxDiff([1, 1, 2, 2, 3, 3], 6))\n    print(MaxDiff([1, 3, 5, 7], 4))\n    print(MaxDiff([2, 4, 6, 8], 4))\n    print(MaxDiff([], 0))\n    print(MaxDiff([1, 10, 100, 1000], 4))\n    print(MaxDiff([2, 3, 1, 5, 7, 11], 6))\n    print(MaxDiff([14, 21, 28], 3))\n    print(MaxDiff([2, 3, 5, 7, 11, 13], 6))\n    print(MaxDiff([20, 30, 50, 10], 4))", "all_input_output_value": "\ninput1: A=[1, 2, 3, 4, 5], n=5\noutput1: 4\n--------\ninput2: A=[1, 1, 2, 2, 3, 3], n=6\noutput2: 5\n--------\ninput3: A=[1, 3, 5, 7], n=4\noutput3: 3\n--------\ninput4: A=[2, 4, 6, 8], n=4\noutput4: -1\n--------\ninput5: A=[], n=0\noutput5: -1\n--------\ninput6: A=[1, 10, 100, 1000], n=4\noutput6: 3\n--------\ninput7: A=[2, 3, 1, 5, 7, 11], n=6\noutput7: 5\n--------\ninput8: A=[14, 21, 28], n=3\noutput8: -1\n--------\ninput9: A=[2, 3, 5, 7, 11, 13], n=6\noutput9: 5\n--------\ninput10: A=[20, 30, 50, 10], n=4\noutput10: -1\n", "input_output_value": ["\ninput1: A=[1, 2, 3, 4, 5], n=5\noutput1: 4\n", "\ninput2: A=[1, 1, 2, 2, 3, 3], n=6\noutput2: 5\n", "\ninput3: A=[1, 3, 5, 7], n=4\noutput3: 3\n"], "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <algorithm>\n// TOFILL\nint main() {\n    vector<int> input1 = {1, 2, 3, 4, 5};\n    cout << MaxDiff(input1, 5) << endl;\n\n    vector<int> input2 = {1, 1, 2, 2, 3, 3};\n    cout << MaxDiff(input2, 6) << endl;\n\n    vector<int> input3 = {1, 3, 5, 7};\n    cout << MaxDiff(input3, 4) << endl;\n\n    vector<int> input4 = {2, 4, 6, 8};\n    cout << MaxDiff(input4, 4) << endl;\n\n    vector<int> input5 = {};\n    cout << MaxDiff(input5, 0) << endl;\n\n    vector<int> input6 = {1, 10, 100, 1000};\n    cout << MaxDiff(input6, 4) << endl;\n\n    vector<int> input7 = {2, 3, 1, 5, 7, 11};\n    cout << MaxDiff(input7, 6) << endl;\n\n    vector<int> input8 = {14, 21, 28};\n    cout << MaxDiff(input8, 3) << endl;\n\n    vector<int> input9 = {2, 3, 5, 7, 11, 13};\n    cout << MaxDiff(input9, 6) << endl;\n\n    vector<int> input10 = {20, 30, 50, 10};\n    cout << MaxDiff(input10, 4) << endl;\n\n    return 0;\n}", "TAG": "Success"}
{"source_Lan": "python###findFun.py", "source_code_str": "def findFun( n : int) -> int:\n    dp = [2,5,9,7]\n    if n<=3:\n        return dp[n]\n    mod = 10**9+7\n    for i in range(4,n+1):\n        if i&1==0:\n            z = dp[2]*(i-2) + dp[0]*(i-4)\n        else:\n            z = dp[3]*(i-1) + dp[1]*(i-3)\n        z = z%mod  \n        dp[0] = dp[1]\n        dp[1] = dp[2]\n        dp[2] = dp[3]\n        dp[3] = z\n    return dp[-1]", "source_code_block": "", "target_Lan": "cpp###findFun.cpp", "reference_code": "    int findFun(int n){\n        int mod=1000000007;\n        vector<long long>dp={2,5,9,7};\n        if (n<=3) return dp[n];\n        long long p1=2;\n        long long p2=5;\n        long long p3=9;\n        long long p4=7;\n        for (int i=4;i<=n;i++){\n            if (i%2==0){\n                int a=(p3*(i-2))%mod;\n                int b=(p1*(i-4))%mod;\n                int ele=(a+b)%mod;\n                p1=p2;\n                p2=p3;\n                p3=p4;\n                p4=ele;\n            }\n            else{\n                int a=(p4*(i-1))%mod;\n                int b=(p2*(i-3))%mod;\n                int ele=(a+b)%mod;\n                p1=p2;\n                p2=p3;\n                p3=p4;\n                p4=ele;\n            }\n        }\n        return p4;\n    }", "target_method_signature": "findFun", "source_method_signature": "findFun", "target_allMS": "    int findFun(int n){", "source_allMS": "def findFun( n : int) -> int:", "source_import": "", "target_import": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;", "commentTag": "//", "source_code_shell": "# TOFILL\nif __name__ == \"__main__\":\n    print(findFun(1))\n    print(findFun(2))\n    print(findFun(3))\n    print(findFun(4))\n    print(findFun(5))\n    print(findFun(6))\n    print(findFun(7))\n    print(findFun(8))\n    print(findFun(9))\n    print(findFun(10))", "all_input_output_value": "\ninput1: n=1\noutput1: 5\n--------\ninput2: n=2\noutput2: 9\n--------\ninput3: n=3\noutput3: 7\n--------\ninput4: n=4\noutput4: 18\n--------\ninput5: n=5\noutput5: 90\n--------\ninput6: n=6\noutput6: 90\n--------\ninput7: n=7\noutput7: 612\n--------\ninput8: n=8\noutput8: 612\n--------\ninput9: n=9\noutput9: 5436\n--------\ninput10: n=10\noutput10: 5436\n", "input_output_value": ["\ninput1: n=1\noutput1: 5\n", "\ninput2: n=2\noutput2: 9\n", "\ninput3: n=3\noutput3: 7\n"], "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    cout << findFun(1) << endl;\n    cout << findFun(2) << endl;\n    cout << findFun(3) << endl;\n    cout << findFun(4) << endl;\n    cout << findFun(5) << endl;\n    cout << findFun(6) << endl;\n    cout << findFun(7) << endl;\n    cout << findFun(8) << endl;\n    cout << findFun(9) << endl;\n    cout << findFun(10) << endl;\n\n    return 0;\n}", "TAG": "Success"}
{"source_Lan": "python###CompatibleStrings.py", "source_code_str": "def CompatibleStrings( N : int, A1 : List[str], A2 : List[str]) -> List[int]:\n    ans = [0]*N\n    for i in range(N):\n        s1 = A1[i]\n        s2 = A2[i]\n        if len(s1)!=len(s2):\n            continue\n        mp1 = Counter(s1)\n        mp2 = Counter(s2)\n        f = True\n        c2 = 0\n        c3 = 0\n        g = 0\n        r = 0\n        for c in range(97,123):\n            c = chr(c)\n            if mp1[c]==mp2[c]:\n                continue\n            d = abs(mp1[c]-mp2[c])\n            if mp2[c]>mp1[c]:\n                if r<d:\n                    f = False\n                    break\n                else:\n                    r-=d\n            else:\n                r += d\n            g = gcd(g,d)\n            if g==1:\n                f = False\n                break\n        if f:\n            ans[i] = 1\n    return ans", "source_code_block": "", "target_Lan": "cpp###CompatibleStrings.cpp", "reference_code": "    vector<int> CompatibleStrings(int N, vector<string> &A1, vector<string> &A2) {\n        \n        \n        \n        vector<int> ans(N);\n        for(int j=0;j<N;j++){\n            vector<int> v1(26),v2(26);\n            for(auto i:A1[j]){\n                v1[i-'a']++;\n            }\n            for(auto i:A2[j]){\n                v2[i-'a']++;\n            }\n            vector<int> temp;\n            int p = 0;\n            int l = 0;\n            while(l<25){\n                p+=v1[l];\n                if(p<v2[l]){\n                    break;\n                }\n                else{\n                    p-=v2[l];\n                }\n                if(p!=0)\n                temp.push_back(p);\n                l++;\n            }\n            if(l!=25) ans[j]=0;\n            else if(p+v1[l]!=v2[l]) ans[j]=0;\n            else{\n                if(temp.size()==0){\n                    ans[j] = 1;\n                    continue;\n                }\n                int x = temp[0];\n                for(auto i:temp){\n                    x = __gcd(i,x);\n                }\n                if(x==1){\n                    ans[j] = 0;\n                }\n                else{\n                    ans[j] = 1;\n                }\n            }\n        }\n        return ans;\n    }", "target_method_signature": "CompatibleStrings", "source_method_signature": "CompatibleStrings", "target_allMS": "    vector<int> CompatibleStrings(int N, vector<string> &A1, vector<string> &A2) {", "source_allMS": "def CompatibleStrings( N : int, A1 : List[str], A2 : List[str]) -> List[int]:", "source_import": "from typing import List\nfrom typing import List\nfrom collections import Counter\nfrom math import gcd", "target_import": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;", "commentTag": "//", "source_code_shell": "from typing import List\nfrom typing import List\nfrom collections import Counter\nfrom math import gcd\nfrom typing import List\nfrom collections import Counter\nfrom math import gcd\n# TOFILL\nif __name__ == \"__main__\":\n    test_inputs = [\n        (3, [\"abc\", \"abcd\", \"aabb\"], [\"abc\", \"xyz\", \"aabbcc\"]),\n        (2, [\"a\", \"b\"], [\"a\", \"c\"]),\n        (2, [\"aaa\", \"aabb\"], [\"aa\", \"ab\"]),\n        (3, [\"abcde\", \"aaaaa\", \"xyz\"], [\"edcba\", \"aaaaa\", \"zyx\"]),\n        (1, [\"\"], [\"\"]),\n        (2, [\"hello\", \"world\"], [\"hello\", \"world\"]),\n        (1, [\"abc\"], [\"cba\"]),\n        (3, [\"abc\", \"ace\", \"acd\"], [\"bac\", \"ec\", \"cad\"]),\n        (1, [\"abcdef\"], [\"ab\"]),\n        (1, [\"abc\"], [\"xyz\"]),\n    ]\n    for inputs in test_inputs:\n        N, A1, A2 = inputs\n        result = CompatibleStrings(N, A1, A2)\n        print(result)", "all_input_output_value": "\ninput1: N=3, A1=[\"abc\", \"abcd\", \"aabb\"], A2=[\"abc\", \"xyz\", \"aabbcc\"]\noutput1: [1, 0, 0]\n--------\ninput2: N=2, A1=[\"a\", \"b\"], A2=[\"a\", \"c\"]\noutput2: [1, 0]\n--------\ninput3: N=2, A1=[\"aaa\", \"aabb\"], A2=[\"aa\", \"ab\"]\noutput3: [0, 0]\n--------\ninput4: N=3, A1=[\"abcde\", \"aaaaa\", \"xyz\"], A2=[\"edcba\", \"aaaaa\", \"zyx\"]\noutput4: [1, 1, 1]\n--------\ninput5: N=1, A1=[\"\"], A2=[\"\"]\noutput5: [1]\n--------\ninput6: N=2, A1=[\"hello\", \"world\"], A2=[\"hello\", \"world\"]\noutput6: [1, 1]\n--------\ninput7: N=1, A1=[\"abc\"], A2=[\"cba\"]\noutput7: [1]\n--------\ninput8: N=3, A1=[\"abc\", \"ace\", \"acd\"], A2=[\"bac\", \"ec\", \"cad\"]\noutput8: [1, 0, 1]\n--------\ninput9: N=1, A1=[\"abcdef\"], A2=[\"ab\"]\noutput9: [0]\n--------\ninput10: N=1, A1=[\"abc\"], A2=[\"xyz\"]\noutput10: [0]\n", "input_output_value": ["\ninput1: N=3, A1=[\"abc\", \"abcd\", \"aabb\"], A2=[\"abc\", \"xyz\", \"aabbcc\"]\noutput1: [1, 0, 0]\n", "\ninput2: N=2, A1=[\"a\", \"b\"], A2=[\"a\", \"c\"]\noutput2: [1, 0]\n", "\ninput3: N=2, A1=[\"aaa\", \"aabb\"], A2=[\"aa\", \"ab\"]\noutput3: [0, 0]\n"], "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n// TOFILL\nint main() {\n    vector<string> A1_1 = {\"abc\", \"abcd\", \"aabb\"};\n    vector<string> A2_1 = {\"abc\", \"xyz\", \"aabbcc\"};\n    vector<int> result1 = CompatibleStrings(3, A1_1, A2_1);\n    for(int r : result1) cout << r << \" \"; // Output for test case 1\n    \n    vector<string> A1_2 = {\"a\", \"b\"};\n    vector<string> A2_2 = {\"a\", \"c\"};\n    vector<int> result2 = CompatibleStrings(2, A1_2, A2_2);\n    for(int r : result2) cout << r << \" \"; // Output for test case 2\n    \n    vector<string> A1_3 = {\"aaa\", \"aabb\"};\n    vector<string> A2_3 = {\"aa\", \"ab\"};\n    vector<int> result3 = CompatibleStrings(2, A1_3, A2_3);\n    for(int r : result3) cout << r << \" \"; // Output for test case 3\n    \n    vector<string> A1_4 = {\"abcde\", \"aaaaa\", \"xyz\"};\n    vector<string> A2_4 = {\"edcba\", \"aaaaa\", \"zyx\"};\n    vector<int> result4 = CompatibleStrings(3, A1_4, A2_4);\n    for(int r : result4) cout << r << \" \"; // Output for test case 4\n    \n    vector<string> A1_5 = {\"\"};\n    vector<string> A2_5 = {\"\"};\n    vector<int> result5 = CompatibleStrings(1, A1_5, A2_5);\n    for(int r : result5) cout << r << \" \"; // Output for test case 5\n    \n    vector<string> A1_6 = {\"hello\", \"world\"};\n    vector<string> A2_6 = {\"hello\", \"world\"};\n    vector<int> result6 = CompatibleStrings(2, A1_6, A2_6);\n    for(int r : result6) cout << r << \" \"; // Output for test case 6\n\n    vector<string> A1_7 = {\"abc\"};\n    vector<string> A2_7 = {\"cba\"};\n    vector<int> result7 = CompatibleStrings(1, A1_7, A2_7);\n    for(int r : result7) cout << r << \" \"; // Output for test case 7\n    \n    vector<string> A1_8 = {\"abc\", \"ace\", \"acd\"};\n    vector<string> A2_8 = {\"bac\", \"ec\", \"cad\"};\n    vector<int> result8 = CompatibleStrings(3, A1_8, A2_8);\n    for(int r : result8) cout << r << \" \"; // Output for test case 8\n    \n    vector<string> A1_9 = {\"abcdef\"};\n    vector<string> A2_9 = {\"ab\"};\n    vector<int> result9 = CompatibleStrings(1, A1_9, A2_9);\n    for(int r : result9) cout << r << \" \"; // Output for test case 9\n\n    vector<string> A1_10 = {\"abc\"};\n    vector<string> A2_10 = {\"xyz\"};\n    vector<int> result10 = CompatibleStrings(1, A1_10, A2_10);\n    for(int r : result10) cout << r << \" \"; // Output for test case 10\n\n    return 0;\n}", "TAG": "Success"}
{"source_Lan": "python###createString.py", "source_code_str": "def createString( n : int, k : int, s : str) -> str:\n    c=Counter(s)\n    t=[(c[el],el) for el in c]\n    t.sort(key=lambda x:(x[1]))\n    ans=\"\"\n    while t:\n        ca,cb=t.pop()\n        if ca>k:\n            ca-=k\n            ans+=cb*k\n            if len(t)==0:\n                return ans\n            else:\n                da,db=t.pop()\n                if da>1:\n                    ans+=db\n                    t.append((da-1,db))\n                else:\n                    ans+=db\n            t.append((ca,cb))\n        else:\n            ans+=cb*ca\n    return ans", "source_code_block": "", "target_Lan": "cpp###createString.cpp", "reference_code": "    string createString(int n, int k, string s) {\n        string answer = \"\";\n        unordered_map<char, int> m;\n        for(auto i : s){\n            m[i] += 1;\n        }\n        set<pair<char, int>> st;\n        for(auto i : m){\n            st.insert({i.first, i.second});\n        }\n        int curr = 0;\n        while(st.size()){\n            auto largest = st.end();\n            largest--;\n            if(curr == k){\n                if(st.size() == 1){\n                    break;\n                }else{\n                    largest--;\n                }\n                curr = -1;\n            }\n            char now = largest->first;\n            int count = largest->second;\n            st.erase({now, count});\n            count -= 1;\n            if(count){\n                st.insert({now, count});\n                curr += 1;\n            }else{\n                curr = 0;\n            }\n            answer += now;\n        }\n        return answer;\n    }", "target_method_signature": "createString", "source_method_signature": "createString", "target_allMS": "    string createString(int n, int k, string s) {", "source_allMS": "def createString( n : int, k : int, s : str) -> str:", "source_import": "from collections import Counter", "target_import": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;", "commentTag": "//", "source_code_shell": "from collections import Counter\nfrom collections import Counter\n# TOFILL\nif __name__ == \"__main__\":\n    print(createString(0, 1, \"\"))\n    print(createString(5, 1, \"aaaaa\"))\n    print(createString(6, 2, \"aabbcc\"))\n    print(createString(6, 1, \"abcabc\"))\n    print(createString(7, 2, \"aabbbaa\"))\n    print(createString(5, 3, \"abcde\"))\n    print(createString(4, 1, \"aaaa\"))\n    print(createString(10, 5, \"ababababab\"))\n    print(createString(8, 2, \"abcdabcd\"))\n    print(createString(5, 10, \"aaabb\"))", "all_input_output_value": "\ninput1: n=0, k=1, s=\"\"\noutput1: a\n--------\ninput2: n=5, k=1, s=\"aaaaa\"\noutput2: ccbbaa\n--------\ninput3: n=6, k=2, s=\"aabbcc\"\noutput3: cbcba\n--------\ninput4: n=6, k=1, s=\"abcabc\"\noutput4: bbabaa\n--------\ninput5: n=7, k=2, s=\"aabbbaa\"\noutput5: edcba\n--------\ninput6: n=5, k=3, s=\"abcde\"\noutput6: a\n--------\ninput7: n=4, k=1, s=\"aaaa\"\noutput7: bbbbbbaaaaa\n--------\ninput8: n=10, k=5, s=\"ababababab\"\noutput8: ddccbbaa\n--------\ninput9: n=8, k=2, s=\"abcdabcd\"\noutput9: bbaaa\n--------\ninput10: n=5, k=10, s=\"aaabb\"\noutput10: a\n", "input_output_value": ["\ninput1: n=0, k=1, s=\"\"\noutput1: a\n", "\ninput2: n=5, k=1, s=\"aaaaa\"\noutput2: ccbbaa\n", "\ninput3: n=6, k=2, s=\"aabbcc\"\noutput3: cbcba\n"], "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <set>\n// TOFILL\nint main() {\n    cout << createString(0, 1, \"\") << endl;\n    cout << createString(5, 1, \"aaaaa\") << endl;\n    cout << createString(6, 2, \"aabbcc\") << endl;\n    cout << createString(6, 1, \"abcabc\") << endl;\n    cout << createString(7, 2, \"aabbbaa\") << endl;\n    cout << createString(5, 3, \"abcde\") << endl;\n    cout << createString(4, 1, \"aaaa\") << endl;\n    cout << createString(10, 5, \"ababababab\") << endl;\n    cout << createString(8, 2, \"abcdabcd\") << endl;\n    cout << createString(5, 10, \"aaabb\") << endl;\n}", "TAG": "Success"}
{"source_Lan": "python###minimumDis.py", "source_code_str": "def minimumDis( N: int, X: List[int]) -> int:\n    X.sort()\n    return X[(N - 1) // 2]", "source_code_block": "", "target_Lan": "cpp###minimumDis.cpp", "reference_code": "    int minimumDis(int N, vector<int> X) {\n        sort(X.begin(), X.end());\n        return X[(N - 1) / 2];\n    }", "target_method_signature": "minimumDis", "source_method_signature": "minimumDis", "target_allMS": "    int minimumDis(int N, vector<int> X) {", "source_allMS": "def minimumDis( N: int, X: List[int]) -> int:", "source_import": "from typing import List", "target_import": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;", "commentTag": "//", "source_code_shell": "from typing import List\nfrom typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(minimumDis(1, [10, 1, 5, 3]))  # Simple odd number of values - covers typical median situation\n    print(minimumDis(2, [8, 2, 5, 7]))   # Simple even number of values - tests even case\n    print(minimumDis(3, [5, 10, -10, 0]))  # Complex list with negative, positive, and zero values\n    print(minimumDis(4, [4, 7, 7, 7, 7]))  # Test with duplicate values\n    print(minimumDis(5, [1, 1, 1, 1, 1]))  # Case where all same values - testing uniformity\n    print(minimumDis(1, [0, 0, 0]))        # Edge case - single element (0)\n    print(minimumDis(2, [2, 1, 1, 1]))     # Edge case with duplicates but even N\n    print(minimumDis(2, [6, 0, -1, 1, 2])) # Mixed values with zero and negative - checking sorting\n    print(minimumDis(3, [7, 8, 9, 6, 5]))  # Normal case moving in descending order\n    print(minimumDis(1, [0, 3, 4, 5, 6]))  # Single element of two values testing", "all_input_output_value": "\ninput1: N=1, X=[10, 1, 5, 3]\noutput1: 1\n--------\ninput2: N=2, X=[8, 2, 5, 7]\noutput2: 2\n--------\ninput3: N=3, X=[5, 10, -10, 0]\noutput3: 0\n--------\ninput4: N=4, X=[4, 7, 7, 7, 7]\noutput4: 7\n--------\ninput5: N=5, X=[1, 1, 1, 1, 1]\noutput5: 1\n--------\ninput6: N=1, X=[0, 0, 0]\noutput6: 0\n--------\ninput7: N=2, X=[2, 1, 1, 1]\noutput7: 1\n--------\ninput8: N=2, X=[6, 0, -1, 1, 2]\noutput8: -1\n--------\ninput9: N=3, X=[7, 8, 9, 6, 5]\noutput9: 6\n--------\ninput10: N=1, X=[0, 3, 4, 5, 6]\noutput10: 0\n", "input_output_value": ["\ninput1: N=1, X=[10, 1, 5, 3]\noutput1: 1\n", "\ninput2: N=2, X=[8, 2, 5, 7]\noutput2: 2\n", "\ninput3: N=3, X=[5, 10, -10, 0]\noutput3: 0\n"], "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <algorithm>\n// TOFILL\nint main() {\n    cout << minimumDis(1, {10, 1, 5, 3}) << endl;\n    cout << minimumDis(2, {8, 2, 5, 7}) << endl;\n    cout << minimumDis(3, {5, 10, -10, 0}) << endl;\n    cout << minimumDis(4, {4, 7, 7, 7}) << endl;\n    cout << minimumDis(5, {1, 1, 1, 1, 1}) << endl;\n    cout << minimumDis(1, {0, 0, 0}) << endl;\n    cout << minimumDis(2, {2, 1, 1, 1}) << endl;\n    cout << minimumDis(2, {6, 0, -1, 1, 2}) << endl;\n    cout << minimumDis(3, {7, 8, 9, 6, 5}) << endl;\n    cout << minimumDis(1, {0, 3, 4, 5, 6}) << endl;\n}", "TAG": "Success"}
{"source_Lan": "python###countSuperPalindrome.py", "source_code_str": "def countSuperPalindrome( l: int, r: int) -> int:\n    count = 0\n    start = ceil(sqrt(l))\n    while start * start <= r:\n        s = str(start * start)\n        \n        if s == s[::-1]:\n            count += 1\n        start += 1\n    return count", "source_code_block": "", "target_Lan": "cpp###countSuperPalindrome.cpp", "reference_code": "    int countSuperPalindrome(int l, int r) {\n        int count = 0;\n        \n        int start = static_cast<int>(ceil(sqrt(l)));\n        \n        while (start * start <= r) {\n            \n            int square = start * start;\n            string s = to_string(square);\n            \n            if (s == string(s.rbegin(), s.rend())) {\n                count++;\n            }\n            start++;\n        }\n        return count;\n    }", "target_method_signature": "countSuperPalindrome", "source_method_signature": "countSuperPalindrome", "target_allMS": "    int countSuperPalindrome(int l, int r) {", "source_allMS": "def countSuperPalindrome( l: int, r: int) -> int:", "source_import": "from math import sqrt, ceil", "target_import": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;", "commentTag": "//", "source_code_shell": "from math import sqrt, ceil\nimport math\n# TOFILL\nif __name__ == \"__main__\":\n    print(countSuperPalindrome(1, 1))\n    print(countSuperPalindrome(4, 9))\n    print(countSuperPalindrome(0, 20))\n    print(countSuperPalindrome(21, 40))\n    print(countSuperPalindrome(100, 200))\n    print(countSuperPalindrome(1, 100000))\n    print(countSuperPalindrome(8, 25))\n    print(countSuperPalindrome(36, 49))\n    print(countSuperPalindrome(1, int(1e5)))", "all_input_output_value": "\ninput1: l=1, r=1\noutput1: 1\n--------\ninput2: l=4, r=9\noutput2: 2\n--------\ninput3: l=0, r=20\noutput3: 4\n--------\ninput4: l=21, r=40\noutput4: 0\n--------\ninput5: l=100, r=200\noutput5: 1\n--------\ninput6: l=1, r=100000\noutput6: 13\n--------\ninput7: l=8, r=25\noutput7: 1\n--------\ninput8: l=36, r=49\noutput8: 0\n--------\ninput9: l=1, r=100000\noutput9: 13\n", "input_output_value": ["\ninput1: l=1, r=1\noutput1: 1\n", "\ninput2: l=4, r=9\noutput2: 2\n", "\ninput3: l=0, r=20\noutput3: 4\n"], "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <cmath>\n#include <string>\n// TOFILL\nint main() {\n    cout << countSuperPalindrome(1, 1) << endl;\n    cout << countSuperPalindrome(4, 9) << endl;\n    cout << countSuperPalindrome(0, 20) << endl;\n    cout << countSuperPalindrome(21, 40) << endl;\n    cout << countSuperPalindrome(100, 200) << endl;\n    cout << countSuperPalindrome(1, 100000) << endl;\n    cout << countSuperPalindrome(8, 25) << endl;\n    cout << countSuperPalindrome(36, 49) << endl;\n    cout << countSuperPalindrome(1, 100000) << endl;\n}", "TAG": "Success"}
{"source_Lan": "python###maximumSetSize.py", "source_code_str": "def maximumSetSize( nums1: List[int], nums2: List[int]) -> int:\n    set1 = set(nums1)\n    set2 = set(nums2)\n    common = len(set1 & set2)\n    n1 = len(set1)\n    n2 = len(set2)\n    ans = n1 + n2 - common\n    m = len(nums1) // 2\n    if n1 > m:\n        mn = min(n1 - m, common)\n        ans -= n1 - mn - m\n        common -= mn\n    if n2 > m:\n        n2 -= min(n2 - m, common)\n        ans -= n2 - m\n    return ans", "source_code_block": "", "target_Lan": "cpp###maximumSetSize.cpp", "reference_code": "    int maximumSetSize(vector<int> &nums1, vector<int> &nums2) {\n        unordered_set<int> set1(nums1.begin(), nums1.end());\n        unordered_set<int> set2(nums2.begin(), nums2.end());\n        int common = 0;\n        for (int x : set1) {\n            common += set2.count(x);\n        }\n        int n1 = set1.size();\n        int n2 = set2.size();\n        int ans = n1 + n2 - common;\n        int m = nums1.size() / 2;\n        if (n1 > m) {\n            int mn = min(n1 - m, common);\n            ans -= n1 - mn - m;\n            common -= mn;\n        }\n        if (n2 > m) {\n            n2 -= min(n2 - m, common);\n            ans -= n2 - m;\n        }\n        return ans;\n    }", "target_method_signature": "maximumSetSize", "source_method_signature": "maximumSetSize", "target_allMS": "    int maximumSetSize(vector<int> &nums1, vector<int> &nums2) {", "source_allMS": "def maximumSetSize( nums1: List[int], nums2: List[int]) -> int:", "source_import": "", "target_import": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;", "commentTag": "//", "source_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(maximumSetSize([1, 2, 3], [4, 5, 6]))  # No overlap\n    print(maximumSetSize([1, 2, 3], [1, 2, 3]))  # Full overlap\n    print(maximumSetSize([1, 2], [2, 3]))        # One element in common\n    print(maximumSetSize([1, 2, 3, 4, 5], [1, 2, 3]))  # n1 > m, common = 3\n    print(maximumSetSize([], []))                 # Both empty\n    print(maximumSetSize([1, 2], []))             # One empty, one non-empty\n    print(maximumSetSize([1, 2, 3, 4, 5], [3, 4, 5]))  # Multiple overlaps, no removal condition triggered\n    print(maximumSetSize([1, 2], [3, 4, 5, 6]))  # Different sizes, disjoint sets\n    print(maximumSetSize([1, 2] * 100, [2, 3] * 100)) # Large input with duplicates", "all_input_output_value": "\ninput1: nums1=[1, 2, 3], nums2=[4, 5, 6]\noutput1: 2\n--------\ninput2: nums1=[1, 2, 3], nums2=[1, 2, 3]\noutput2: 2\n--------\ninput3: nums1=[1, 2], nums2=[2, 3]\noutput3: 2\n--------\ninput4: nums1=[1, 2, 3, 4, 5], nums2=[1, 2, 3]\noutput4: 4\n--------\ninput5: nums1=[], nums2=[]\noutput5: 0\n--------\ninput6: nums1=[1, 2], nums2=[]\noutput6: 1\n--------\ninput7: nums1=[1, 2, 3, 4, 5], nums2=[3, 4, 5]\noutput7: 4\n--------\ninput8: nums1=[1, 2], nums2=[3, 4, 5, 6]\noutput8: 2\n--------\ninput9: nums1=[1, 2] * 100, nums2=[2, 3] * 100\noutput9: 3\n", "input_output_value": ["\ninput1: nums1=[1, 2, 3], nums2=[4, 5, 6]\noutput1: 2\n", "\ninput2: nums1=[1, 2, 3], nums2=[1, 2, 3]\noutput2: 2\n", "\ninput3: nums1=[1, 2], nums2=[2, 3]\noutput3: 2\n"], "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <unordered_set>\n// TOFILL\nint main() {\n    vector<int> nums1_1 = {1, 2, 3}, nums2_1 = {4, 5, 6};\n    vector<int> nums1_2 = {1, 2, 3}, nums2_2 = {1, 2, 3};\n    vector<int> nums1_3 = {1, 2}, nums2_3 = {2, 3};\n    vector<int> nums1_4 = {1, 2, 3, 4, 5}, nums2_4 = {1, 2, 3};\n    vector<int> nums1_5 = {}, nums2_5 = {};\n    vector<int> nums1_6 = {1, 2}, nums2_6 = {};\n    vector<int> nums1_7 = {1, 2, 3, 4, 5}, nums2_7 = {3, 4, 5};\n    vector<int> nums1_8 = {1, 2}, nums2_8 = {3, 4, 5, 6};\n    vector<int> nums1_9(200, 1), nums2_9(200, 2);\n    for(int i = 0; i < 100; ++i) {\n        nums1_9[i * 2 + 1] = 2;\n        nums2_9[i * 2 + 1] = 3;\n    }\n\n    cout << maximumSetSize(nums1_1, nums2_1) << endl;\n    cout << maximumSetSize(nums1_2, nums2_2) << endl;\n    cout << maximumSetSize(nums1_3, nums2_3) << endl;\n    cout << maximumSetSize(nums1_4, nums2_4) << endl;\n    cout << maximumSetSize(nums1_5, nums2_5) << endl;\n    cout << maximumSetSize(nums1_6, nums2_6) << endl;\n    cout << maximumSetSize(nums1_7, nums2_7) << endl;\n    cout << maximumSetSize(nums1_8, nums2_8) << endl;\n    cout << maximumSetSize(nums1_9, nums2_9) << endl;\n}", "TAG": "Success"}
{"source_Lan": "python###minimumOperationsToMakeKPeriodic.py", "source_code_str": "def minimumOperationsToMakeKPeriodic( word: str, k: int) -> int:\n    n = len(word)\n    cnt = Counter(word[i - k: i] for i in range(k, n + 1, k))\n    mx = max(cnt.values())\n    return n // k - mx", "source_code_block": "", "target_Lan": "cpp###minimumOperationsToMakeKPeriodic.cpp", "reference_code": "    int minimumOperationsToMakeKPeriodic(string word, int k) {\n        int n = word.size(), mx = 0;\n        unordered_map<string, int> cnt;\n        for (int i = k; i <= n; i += k) {\n            mx = max(mx, ++cnt[word.substr(i - k, k)]);\n        }\n        return n / k - mx;\n    }", "target_method_signature": "minimumOperationsToMakeKPeriodic", "source_method_signature": "minimumOperationsToMakeKPeriodic", "target_allMS": "    int minimumOperationsToMakeKPeriodic(string word, int k) {", "source_allMS": "def minimumOperationsToMakeKPeriodic( word: str, k: int) -> int:", "source_import": "", "target_import": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;", "commentTag": "//", "source_code_shell": "from collections import Counter\n# TOFILL\nif __name__ == \"__main__\":\n    print(minimumOperationsToMakeKPeriodic(\"abcabcabc\", 3))\n    print(minimumOperationsToMakeKPeriodic(\"aaaaaa\", 1))\n    print(minimumOperationsToMakeKPeriodic(\"ababab\", 2))\n    print(minimumOperationsToMakeKPeriodic(\"aaaaabbbb\", 4))\n    print(minimumOperationsToMakeKPeriodic(\"xyzxyzxyz\", 3))\n    print(minimumOperationsToMakeKPeriodic(\"abcdefghijk\", 2))\n    print(minimumOperationsToMakeKPeriodic(\"mno\", 1))\n    print(minimumOperationsToMakeKPeriodic(\"dedededed\", 3))\n    print(minimumOperationsToMakeKPeriodic(\"bbbbccccc\", 2))", "all_input_output_value": "\ninput1: word=\"abcabcabc\", k=3\noutput1: 0\n--------\ninput2: word=\"aaaaaa\", k=1\noutput2: 0\n--------\ninput3: word=\"ababab\", k=2\noutput3: 0\n--------\ninput4: word=\"aaaaabbbb\", k=4\noutput4: 1\n--------\ninput5: word=\"xyzxyzxyz\", k=3\noutput5: 0\n--------\ninput6: word=\"abcdefghijk\", k=2\noutput6: 4\n--------\ninput7: word=\"mno\", k=1\noutput7: 2\n--------\ninput8: word=\"dedededed\", k=3\noutput8: 1\n--------\ninput9: word=\"bbbbccccc\", k=2\noutput9: 2\n", "input_output_value": ["\ninput1: word=\"abcabcabc\", k=3\noutput1: 0\n", "\ninput2: word=\"aaaaaa\", k=1\noutput2: 0\n", "\ninput3: word=\"ababab\", k=2\noutput3: 0\n"], "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <unordered_map>\n// TOFILL\nint main() {\n    cout << minimumOperationsToMakeKPeriodic(\"abcabcabc\", 3) << endl;\n    cout << minimumOperationsToMakeKPeriodic(\"aaaaaa\", 1) << endl;\n    cout << minimumOperationsToMakeKPeriodic(\"ababab\", 2) << endl;\n    cout << minimumOperationsToMakeKPeriodic(\"aaaaabbbb\", 4) << endl;\n    cout << minimumOperationsToMakeKPeriodic(\"xyzxyzxyz\", 3) << endl;\n    cout << minimumOperationsToMakeKPeriodic(\"abcdefghijk\", 2) << endl;\n    cout << minimumOperationsToMakeKPeriodic(\"mno\", 1) << endl;\n    cout << minimumOperationsToMakeKPeriodic(\"dedededed\", 3) << endl;\n    cout << minimumOperationsToMakeKPeriodic(\"bbbbccccc\", 2) << endl;\n}", "TAG": "Success"}
{"source_Lan": "python###maxScore.py", "source_code_str": "def maxScore( grid: List[List[int]]) -> int:\n    ans = -inf\n    m, n = len(grid), len(grid[0])\n    f = [[inf] * (n + 1) for _ in range(m + 1)]\n    for i, row in enumerate(grid):\n        for j, x in enumerate(row):\n            mn = min(f[i + 1][j], f[i][j + 1])\n            ans = max(ans, x - mn)\n            f[i + 1][j + 1] = min(mn, x)\n    return ans", "source_code_block": "", "target_Lan": "cpp###maxScore.cpp", "reference_code": "    int maxScore(vector<vector<int>>& grid) {\n        int ans = INT_MIN;\n        int m = grid.size(), n = grid[0].size();\n        vector<vector<int>> f(m + 1, vector<int>(n + 1, INT_MAX));\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                int mn = min(f[i + 1][j], f[i][j + 1]);\n                ans = max(ans, grid[i][j] - mn);\n                f[i + 1][j + 1] = min(mn, grid[i][j]);\n            }\n        }\n        return ans;\n    }", "target_method_signature": "maxScore", "source_method_signature": "maxScore", "target_allMS": "    int maxScore(vector<vector<int>>& grid) {", "source_allMS": "def maxScore( grid: List[List[int]]) -> int:", "source_import": "", "target_import": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;", "commentTag": "//", "source_code_shell": "from typing import List\nfrom math import inf\n# TOFILL\nif __name__ == \"__main__\":\n    test_inputs = [\n        [[]],\n        [[5]],\n        [[3, 3], [3, 3]],\n        [[-1, 2], [1, -2]],\n        [[1, 2, 3], [4, 5, 6], [7, 8, 9]],\n        [[-1, -2, -3], [-4, -5, -6]],\n        [[1, -1, 2], [-2, 3, 0]],\n        [[0, 0], [0, 0]],\n        [[10, 20, 30], [5, 15, 25]],\n        [[1, -10], [-2, -3]]\n    ]\n    for grid in test_inputs:\n        print(maxScore(grid))", "all_input_output_value": "\ninput1: grid=[[]]\noutput1: -inf\n--------\ninput2: grid=[[5]]\noutput2: -inf\n--------\ninput3: grid=[[3, 3], [3, 3]]\noutput3: 0\n--------\ninput4: grid=[[-1, 2], [1, -2]]\noutput4: 3\n--------\ninput5: grid=[[1, 2, 3], [4, 5, 6], [7, 8, 9]]\noutput5: 8\n--------\ninput6: grid=[[-1, -2, -3], [-4, -5, -6]]\noutput6: -1\n--------\ninput7: grid=[[1, -1, 2], [-2, 3, 0]]\noutput7: 5\n--------\ninput8: grid=[[0, 0], [0, 0]]\noutput8: 0\n--------\ninput9: grid=[[10, 20, 30], [5, 15, 25]]\noutput9: 20\n--------\ninput10: grid=[[1, -10], [-2, -3]]\noutput10: 7\n", "input_output_value": ["\ninput1: grid=[[]]\noutput1: -inf\n", "\ninput2: grid=[[5]]\noutput2: -inf\n", "\ninput3: grid=[[3, 3], [3, 3]]\noutput3: 0\n"], "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n// TOFILL\nint main() {\n    vector<vector<int>> grid1 = {{}};\n    vector<vector<int>> grid2 = {{5}};\n    vector<vector<int>> grid3 = {{3, 3}, {3, 3}};\n    vector<vector<int>> grid4 = {{-1, 2}, {1, -2}};\n    vector<vector<int>> grid5 = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};\n    vector<vector<int>> grid6 = {{-1, -2, -3}, {-4, -5, -6}};\n    vector<vector<int>> grid7 = {{1, -1, 2}, {-2, 3, 0}};\n    vector<vector<int>> grid8 = {{0, 0}, {0, 0}};\n    vector<vector<int>> grid9 = {{10, 20, 30}, {5, 15, 25}};\n    vector<vector<int>> grid10 = {{1, -10}, {-2, -3}};\n\n    cout << maxScore(grid1) << endl;\n    cout << maxScore(grid2) << endl;\n    cout << maxScore(grid3) << endl;\n    cout << maxScore(grid4) << endl;\n    cout << maxScore(grid5) << endl;\n    cout << maxScore(grid6) << endl;\n    cout << maxScore(grid7) << endl;\n    cout << maxScore(grid8) << endl;\n    cout << maxScore(grid9) << endl;\n    cout << maxScore(grid10) << endl;\n\n    return 0;\n}", "TAG": "Success"}
{"source_Lan": "python###minimumCost.py", "source_code_str": "def minimumCost( nums: List[int]) -> int:\n    return nums[0] + sum(sorted(nums[1:])[:2])", "source_code_block": "", "target_Lan": "cpp###minimumCost.cpp", "reference_code": "    int minimumCost(vector<int> &nums) {\n        sort(nums.begin() + 1, nums.end());\n        return accumulate(nums.begin(), nums.begin() + 3, 0);\n    }", "target_method_signature": "minimumCost", "source_method_signature": "minimumCost", "target_allMS": "    int minimumCost(vector<int> &nums) {", "source_allMS": "def minimumCost( nums: List[int]) -> int:", "source_import": "", "target_import": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;", "commentTag": "//", "source_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(minimumCost([5, 3, 8, 2, 1]))       # Normal case with enough elements\n    print(minimumCost([10, 20, 30]))           # Exactly three elements\n    print(minimumCost([1, 2]))                 # Less than three elements (should handle gracefully)\n    print(minimumCost([0]))                     # Single element case\n    print(minimumCost([-1, -2, -3, -4]))       # All negative numbers\n    print(minimumCost([5, 5, 5]))               # All elements the same\n    print(minimumCost([10, 0, 5]))              # Mixed positive and zero\n    print(minimumCost([-5, -10, 0, 2]))        # Mixed negative and positive numbers\n    print(minimumCost([100, 10, 1, 0, -10]))  # Diverse range of numbers", "all_input_output_value": "\ninput1: nums=[5, 3, 8, 2, 1]\noutput1: 8\n--------\ninput2: nums=[10, 20, 30]\noutput2: 60\n--------\ninput3: nums=[1, 2]\noutput3: 3\n--------\ninput4: nums=[0]\noutput4: 0\n--------\ninput5: nums=[-1, -2, -3, -4]\noutput5: -8\n--------\ninput6: nums=[5, 5, 5]\noutput6: 15\n--------\ninput7: nums=[10, 0, 5]\noutput7: 15\n--------\ninput8: nums=[-5, -10, 0, 2]\noutput8: -15\n--------\ninput9: nums=[100, 10, 1, 0, -10]\noutput9: 90\n", "input_output_value": ["\ninput1: nums=[5, 3, 8, 2, 1]\noutput1: 8\n", "\ninput2: nums=[10, 20, 30]\noutput2: 60\n", "\ninput3: nums=[1, 2]\noutput3: 3\n"], "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n// TOFILL\nint main() {\n    vector<int> nums1 = {5, 3, 8, 2, 1};\n    vector<int> nums2 = {10, 20, 30};\n    vector<int> nums3 = {1, 2};\n    vector<int> nums4 = {0};\n    vector<int> nums5 = {-1, -2, -3, -4};\n    vector<int> nums6 = {5, 5, 5};\n    vector<int> nums7 = {10, 0, 5};\n    vector<int> nums8 = {-5, -10, 0, 2};\n    vector<int> nums9 = {100, 10, 1, 0, -10};\n\n    cout << minimumCost(nums1) << endl;\n    cout << minimumCost(nums2) << endl;\n    cout << minimumCost(nums3) << endl;\n    cout << minimumCost(nums4) << endl;\n    cout << minimumCost(nums5) << endl;\n    cout << minimumCost(nums6) << endl;\n    cout << minimumCost(nums7) << endl;\n    cout << minimumCost(nums8) << endl;\n    cout << minimumCost(nums9) << endl;\n\n    return 0;\n}", "TAG": "Success"}
{"source_Lan": "python###numberGame.py", "source_code_str": "def numberGame( nums: List[int]) -> List[int]:\n    nums.sort()\n    for i in range(0, len(nums), 2):\n        nums[i], nums[i + 1] = nums[i + 1], nums[i]\n    return nums", "source_code_block": "", "target_Lan": "cpp###numberGame.cpp", "reference_code": "    vector<int> numberGame(vector<int>& nums) {\n        sort(nums.begin(), nums.end());\n        for (int i = 0; i < nums.size(); i += 2) {\n            swap(nums[i], nums[i + 1]);\n        }\n        return nums;\n    }", "target_method_signature": "numberGame", "source_method_signature": "numberGame", "target_allMS": "    vector<int> numberGame(vector<int>& nums) {", "source_allMS": "def numberGame( nums: List[int]) -> List[int]:", "source_import": "", "target_import": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;", "commentTag": "//", "source_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(numberGame([]))  # Empty vector\n    print(numberGame([1, 2, 3, 4]))  # Even-length vector, all positive\n    print(numberGame([4, 3, 2, 1]))  # Even-length vector, reverse order\n    print(numberGame([7, 3, 5, 1, 9, 6]))  # Even-length with random numbers\n    print(numberGame([8, -3, 4, 0]))  # Mix of positive, negative, and zero\n    print(numberGame([10, 100, 1000, 10000]))  # Larger numbers in an even-length vector", "all_input_output_value": "\ninput1: nums=[]\noutput1: []\n--------\ninput2: nums=[1, 2, 3, 4]\noutput2: [2, 1, 4, 3]\n--------\ninput3: nums=[4, 3, 2, 1]\noutput3: [2, 1, 4, 3]\n--------\ninput4: nums=[7, 3, 5, 1, 9, 6]\noutput4: [3, 1, 6, 5, 9, 7]\n--------\ninput5: nums=[8, -3, 4, 0]\noutput5: [0, -3, 8, 4]\n--------\ninput6: nums=[10, 100, 1000, 10000]\noutput6: [100, 10, 10000, 1000]\n", "input_output_value": ["\ninput1: nums=[]\noutput1: []\n", "\ninput2: nums=[1, 2, 3, 4]\noutput2: [2, 1, 4, 3]\n", "\ninput3: nums=[4, 3, 2, 1]\noutput3: [2, 1, 4, 3]\n"], "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <algorithm>\n// TOFILL\nint main() {\n    vector<int> nums1 = {};\n    vector<int> result1 = numberGame(nums1);\n    for(int num : result1) cout << num << \" \";\n    cout << endl;\n\n    vector<int> nums2 = {1, 2, 3, 4};\n    vector<int> result2 = numberGame(nums2);\n    for(int num : result2) cout << num << \" \";\n    cout << endl;\n\n    vector<int> nums3 = {4, 3, 2, 1};\n    vector<int> result3 = numberGame(nums3);\n    for(int num : result3) cout << num << \" \";\n    cout << endl;\n\n    vector<int> nums4 = {7, 3, 5, 1, 9, 6};\n    vector<int> result4 = numberGame(nums4);\n    for(int num : result4) cout << num << \" \";\n    cout << endl;\n\n    vector<int> nums5 = {8, -3, 4, 0};\n    vector<int> result5 = numberGame(nums5);\n    for(int num : result5) cout << num << \" \";\n    cout << endl;\n\n    vector<int> nums6 = {10, 100, 1000, 10000};\n    vector<int> result6 = numberGame(nums6);\n    for(int num : result6) cout << num << \" \";\n    cout << endl;\n\n    return 0;\n}", "TAG": "Success"}
{"source_Lan": "python###findMinimumTime.py", "source_code_str": "def findMinimumTime( tasks: List[List[int]]) -> int:\n    tasks.sort(key = lambda task: task[1])\n    run, res = [False] * (tasks[-1][1] + 1), 0\n    for start, end, duration in tasks:\n        duration -= sum(run[start : end+1])\n        res += max(duration, 0)\n        for j in range(end, -1, -1):\n            if duration <= 0:\n                break\n            if not run[j]:\n                run[j], duration = True, duration - 1\n    return res", "source_code_block": "", "target_Lan": "cpp###findMinimumTime.cpp", "reference_code": "    int findMinimumTime(vector<vector<int>>& tasks) {\n        int n = tasks.size();\n        sort(tasks.begin(), tasks.end(), [&](const vector<int> &t1, const vector<int> &t2) -> bool {\n            return t1[1] < t2[1];\n        });\n        vector<int> run(tasks[n - 1][1] + 1);\n        int res = 0;\n        for (int i = 0; i < n; i++) {\n            int start = tasks[i][0], end = tasks[i][1], duration = tasks[i][2];\n            duration -= accumulate(run.begin() + start, run.begin() + end + 1, 0);\n            res += max(duration, 0);\n            for (int j = end; j >= 0 && duration > 0; j--) {\n                if (run[j] == 0) {\n                    duration--;\n                    run[j] = 1;\n                }\n            }\n        }\n        return res;\n    }", "target_method_signature": "findMinimumTime", "source_method_signature": "findMinimumTime", "target_allMS": "    int findMinimumTime(vector<vector<int>>& tasks) {", "source_allMS": "def findMinimumTime( tasks: List[List[int]]) -> int:", "source_import": "", "target_import": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;", "commentTag": "//", "source_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(findMinimumTime([[0, 1, 1], [1, 3, 2], [3, 4, 1]]))  # Non-overlapping tasks\n    print(findMinimumTime([[0, 2, 2], [1, 3, 1], [2, 4, 2]]))  # Overlapping tasks\n    print(findMinimumTime([[0, 5, 5], [0, 3, 3], [1, 2, 1]]))  # Full overlap with precedence\n    print(findMinimumTime([[0, 4, 3], [2, 4, 2], [4, 6, 1]]))  # Partial overlap\n    print(findMinimumTime([[0, 1, 1], [1, 2, 1], [3, 4, 1]]))  # Tasks with gaps in between\n    print(findMinimumTime([[0, 1, 1], [1, 1, 1]]))  # Edge case where tasks end at the same time\n    print(findMinimumTime([[0, 10, 5], [5, 10, 3]]))  # Overlapping but fulfilling each requirement\n    print(findMinimumTime([[2, 5, 3], [1, 4, 4], [0, 2, 1]]))  # Tasks with varying timings\n    print(findMinimumTime([[0, 0, 1], [0, 1, 1], [0, 2, 1]]))  # Single moment tasks", "all_input_output_value": "\ninput1: tasks=[[0, 1, 1], [1, 3, 2]]\noutput1: 2\n--------\ninput2: tasks=[[0, 2, 2], [1, 3, 1], [2, 4, 2]]\noutput2: 3\n--------\ninput3: tasks=[[0, 5, 5], [0, 3, 3], [1, 2, 1]]\noutput3: 5\n--------\ninput4: tasks=[[0, 4, 3], [2, 4, 2], [4, 6, 1]]\noutput4: 3\n--------\ninput5: tasks=[[0, 1, 1], [1, 2, 1], [3, 4, 1]]\noutput5: 2\n--------\ninput6: tasks=[[0, 1, 1], [1, 1, 1]]\noutput6: 1\n--------\ninput7: tasks=[[0, 10, 5], [5, 10, 3]]\noutput7: 5\n--------\ninput8: tasks=[[2, 5, 3], [1, 4, 4], [0, 2, 1]]\noutput8: 4\n--------\ninput9: tasks=[[0, 0, 1], [0, 1, 1], [0, 2, 1]]\noutput9: 1\n", "input_output_value": ["\ninput1: tasks=[[0, 1, 1], [1, 3, 2]]\noutput1: 2\n", "\ninput2: tasks=[[0, 2, 2], [1, 3, 1], [2, 4, 2]]\noutput2: 3\n", "\ninput3: tasks=[[0, 5, 5], [0, 3, 3], [1, 2, 1]]\noutput3: 5\n"], "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n// TOFILL\nint main() {\n    vector<vector<int>> tasks1 = {{0, 1, 1}, {1, 3, 2}};\n    vector<vector<int>> tasks2 = {{0, 2, 2}, {1, 3, 1}, {2, 4, 2}};\n    vector<vector<int>> tasks3 = {{0, 5, 5}, {0, 3, 3}, {1, 2, 1}};\n    vector<vector<int>> tasks4 = {{0, 4, 3}, {2, 4, 2}, {4, 6, 1}};\n    vector<vector<int>> tasks5 = {{0, 1, 1}, {1, 2, 1}, {3, 4, 1}};\n    vector<vector<int>> tasks6 = {{0, 1, 1}, {1, 1, 1}};\n    vector<vector<int>> tasks7 = {{0, 10, 5}, {5, 10, 3}};\n    vector<vector<int>> tasks8 = {{2, 5, 3}, {1, 4, 4}, {0, 2, 1}};\n    vector<vector<int>> tasks9 = {{0, 0, 1}, {0, 1, 1}, {0, 2, 1}};\n\n    cout << findMinimumTime(tasks1) << endl;\n    cout << findMinimumTime(tasks2) << endl;\n    cout << findMinimumTime(tasks3) << endl;\n    cout << findMinimumTime(tasks4) << endl;\n    cout << findMinimumTime(tasks5) << endl;\n    cout << findMinimumTime(tasks6) << endl;\n    cout << findMinimumTime(tasks7) << endl;\n    cout << findMinimumTime(tasks8) << endl;\n    cout << findMinimumTime(tasks9) << endl;\n\n    return 0;\n}", "TAG": "Success"}
{"source_Lan": "python###minLength.py", "source_code_str": "def minLength( s: str) -> int:\n    stack = []\n    for c in s:\n        stack.append(c)\n        if len(stack) >= 2 and ((stack[-2] == 'A' and stack[-1] == 'B') or (stack[-2] == 'C' and stack[-1] == 'D')):\n            stack.pop()\n            stack.pop()\n    return len(stack)", "source_code_block": "", "target_Lan": "cpp###minLength.cpp", "reference_code": "    int minLength(string s) {\n        vector<int> st;\n        for (char c : s) {\n            st.push_back(c);\n            int m = st.size();\n            if (m >= 2 &&\n                (st[m - 2] == 'A' && st[m - 1] == 'B' ||\n                st[m - 2] == 'C' && st[m - 1] == 'D')) {\n                st.pop_back();\n                st.pop_back();\n            }\n        }\n        return st.size();\n    }", "target_method_signature": "minLength", "source_method_signature": "minLength", "target_allMS": "    int minLength(string s) {", "source_allMS": "def minLength( s: str) -> int:", "source_import": "", "target_import": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;", "commentTag": "//", "source_code_shell": "# TOFILL\nif __name__ == \"__main__\":\n    print(minLength(\"\"))            # Test Input 1\n    print(minLength(\"ABCD\"))        # Test Input 2\n    print(minLength(\"AABBCDD\"))     # Test Input 3\n    print(minLength(\"AABBCCDD\"))    # Test Input 4\n    print(minLength(\"ABABCDCD\"))     # Test Input 5\n    print(minLength(\"ACBDAB\"))      # Test Input 6\n    print(minLength(\"CDAA\"))        # Test Input 7\n    print(minLength(\"ABABAB\"))      # Test Input 8\n    print(minLength(\"ABCDABCDCD\"))  # Test Input 9\n    print(minLength(\"XYZ\"))         # Test Input 10", "all_input_output_value": "\ninput1: s=\"\"\noutput1: 0\n--------\ninput2: s=\"ABCD\"\noutput2: 0\n--------\ninput3: s=\"AABBCDD\"\noutput3: 1\n--------\ninput4: s=\"AABBCCDD\"\noutput4: 0\n--------\ninput5: s=\"ABABCDCD\"\noutput5: 0\n--------\ninput6: s=\"ACBDAB\"\noutput6: 4\n--------\ninput7: s=\"CDAA\"\noutput7: 2\n--------\ninput8: s=\"ABABAB\"\noutput8: 0\n--------\ninput9: s=\"ABCDABCDCD\"\noutput9: 0\n--------\ninput10: s=\"XYZ\"\noutput10: 3\n", "input_output_value": ["\ninput1: s=\"\"\noutput1: 0\n", "\ninput2: s=\"ABCD\"\noutput2: 0\n", "\ninput3: s=\"AABBCDD\"\noutput3: 1\n"], "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <string>\n// TOFILL\nint main() {\n    cout << minLength(\"\") << endl;\n    cout << minLength(\"ABCD\") << endl;\n    cout << minLength(\"AABBCDD\") << endl;\n    cout << minLength(\"AABBCCDD\") << endl;\n    cout << minLength(\"ABABCDCD\") << endl;\n    cout << minLength(\"ACBDAB\") << endl;\n    cout << minLength(\"CDAA\") << endl;\n    cout << minLength(\"ABABAB\") << endl;\n    cout << minLength(\"ABCDABCDCD\") << endl;\n    cout << minLength(\"XYZ\") << endl;\n}", "TAG": "Success"}
{"source_Lan": "python###addMinimum.py", "source_code_str": "def addMinimum( word: str) -> int:\n    n = len(word)\n    d = [0] * (n + 1)\n    for i in range(1, n + 1):\n        d[i] = d[i - 1] + 2\n        if i > 1 and word[i - 1] > word[i - 2]:\n            d[i] = d[i - 1] - 1\n    return d[n]", "source_code_block": "", "target_Lan": "cpp###addMinimum.cpp", "reference_code": "    int addMinimum(string word) {\n        int n = word.size();\n        vector<int> d(n + 1);\n        for (int i = 1; i <= n; i++) {\n            d[i] = d[i - 1] + 2;\n            if (i > 1 && word[i - 1] > word[i - 2]) {\n                d[i] = d[i - 1] - 1;\n            }\n        }\n        return d[n];\n    }", "target_method_signature": "addMinimum", "source_method_signature": "addMinimum", "target_allMS": "    int addMinimum(string word) {", "source_allMS": "def addMinimum( word: str) -> int:", "source_import": "", "target_import": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;", "commentTag": "//", "source_code_shell": "# TOFILL\nif __name__ == \"__main__\":\n    print(addMinimum(\"\"))                # Test case for empty string\n    print(addMinimum(\"a\"))               # Test case for single character\n    print(addMinimum(\"abc\"))             # Test case for increasing order\n    print(addMinimum(\"cba\"))             # Test case for decreasing order\n    print(addMinimum(\"aba\"))             # Test case for mixed order\n    print(addMinimum(\"aaa\"))             # Test case for all same characters\n    print(addMinimum(\"aaac\"))            # Test case for almost increasing\n    print(addMinimum(\"zac\"))             # Test case for random order\n    print(addMinimum(\"aaaabb\"))          # Test case for mostly identical with slight variation\n    print(addMinimum(\"abcba\"))           # Test case for palindrome", "all_input_output_value": "\ninput1: word=\"\"\noutput1: 0\n--------\ninput2: word=\"a\"\noutput2: 2\n--------\ninput3: word=\"abc\"\noutput3: 0\n--------\ninput4: word=\"cba\"\noutput4: 6\n--------\ninput5: word=\"aba\"\noutput5: 3\n--------\ninput6: word=\"aaa\"\noutput6: 6\n--------\ninput7: word=\"aaac\"\noutput7: 5\n--------\ninput8: word=\"zac\"\noutput8: 3\n--------\ninput9: word=\"aaaabb\"\noutput9: 9\n--------\ninput10: word=\"abcba\"\noutput10: 4\n", "input_output_value": ["\ninput1: word=\"\"\noutput1: 0\n", "\ninput2: word=\"a\"\noutput2: 2\n", "\ninput3: word=\"abc\"\noutput3: 0\n"], "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <string>\n// TOFILL\nint main() {\n    cout << addMinimum(\"\") << endl;          // Test input 1\n    cout << addMinimum(\"a\") << endl;         // Test input 2\n    cout << addMinimum(\"abc\") << endl;       // Test input 3\n    cout << addMinimum(\"cba\") << endl;       // Test input 4\n    cout << addMinimum(\"aba\") << endl;       // Test input 5\n    cout << addMinimum(\"aaa\") << endl;       // Test input 6\n    cout << addMinimum(\"aaac\") << endl;      // Test input 7\n    cout << addMinimum(\"zac\") << endl;       // Test input 8\n    cout << addMinimum(\"aaaabb\") << endl;    // Test input 9\n    cout << addMinimum(\"abcba\") << endl;     // Test input 10\n}", "TAG": "Success"}
{"source_Lan": "python###prefixDistinct.py", "source_code_str": "def prefixDistinct(n,arr):\n    ans=[]\n    s=set()\n    for el in arr:\n        s.add(el)\n        ans.append(len(s))\n    return ans", "source_code_block": "", "target_Lan": "cpp###prefixDistinct.cpp", "reference_code": "    vector<int> prefixDistinct(int n, vector<int> &arr)\n    {\n        vector<int>ans(n);\n        set<int>s;\n        for(int i=0;i<n;i++)\n        {\n            s.insert(arr[i]);\n            ans[i]=s.size();\n        }\n        return ans;\n    }", "target_method_signature": "prefixDistinct", "source_method_signature": "prefixDistinct", "target_allMS": "    vector<int> prefixDistinct(int n, vector<int> &arr)", "source_allMS": "def prefixDistinct(n,arr):", "source_import": "", "target_import": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;", "commentTag": "//", "source_code_shell": "# TOFILL\nif __name__ == \"__main__\":\n    print(prefixDistinct(0, []))\n    print(prefixDistinct(5, [1, 1, 1, 1, 1]))\n    print(prefixDistinct(5, [1, 2, 3, 4, 5]))\n    print(prefixDistinct(6, [1, 2, 1, 2, 3, 1]))\n    print(prefixDistinct(5, [-1, -1, 0, 2, 3]))\n    print(prefixDistinct(3, [1, 2, 1]))\n    print(prefixDistinct(4, [2, 2, 3, 4]))\n    print(prefixDistinct(5, [5, 5, 5, 5, 5]))\n    print(prefixDistinct(7, [10, 20, 10, 30, 30, 40, 50]))\n    print(prefixDistinct(10, [1, 2, 3, 4, 5, 1, 2, 3, 4, 5]))", "all_input_output_value": "\ninput1: n=0, arr=[]\noutput1: []\n--------\ninput2: n=5, arr=[1, 1, 1, 1, 1]\noutput2: [1, 1, 1, 1, 1]\n--------\ninput3: n=5, arr=[1, 2, 3, 4, 5]\noutput3: [1, 2, 3, 4, 5]\n--------\ninput4: n=6, arr=[1, 2, 1, 2, 3, 1]\noutput4: [1, 2, 2, 2, 3, 3]\n--------\ninput5: n=5, arr=[-1, -1, 0, 2, 3]\noutput5: [1, 1, 2, 3, 4]\n--------\ninput6: n=3, arr=[1, 2, 1]\noutput6: [1, 2, 2]\n--------\ninput7: n=4, arr=[2, 2, 3, 4]\noutput7: [1, 1, 2, 3]\n--------\ninput8: n=5, arr=[5, 5, 5, 5, 5]\noutput8: [1, 1, 1, 1, 1]\n--------\ninput9: n=7, arr=[10, 20, 10, 30, 30, 40, 50]\noutput9: [1, 2, 2, 3, 3, 4, 5]\n--------\ninput10: n=10, arr=[1, 2, 3, 4, 5, 1, 2, 3, 4, 5]\noutput10: [1, 2, 3, 4, 5, 5, 5, 5, 5, 5]\n", "input_output_value": ["\ninput1: n=0, arr=[]\noutput1: []\n", "\ninput2: n=5, arr=[1, 1, 1, 1, 1]\noutput2: [1, 1, 1, 1, 1]\n", "\ninput3: n=5, arr=[1, 2, 3, 4, 5]\noutput3: [1, 2, 3, 4, 5]\n"], "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <set>\n// TOFILL\nint main() {\n    // Test Input 1: n=0, arr=[]\n    vector<int> arr1;\n    vector<int> result1 = prefixDistinct(0, arr1);\n    for(int x : result1) cout << x << \" \";\n    cout << endl;\n\n    // Test Input 2: n=5, arr=[1, 1, 1, 1, 1]\n    vector<int> arr2 = {1, 1, 1, 1, 1};\n    vector<int> result2 = prefixDistinct(5, arr2);\n    for(int x : result2) cout << x << \" \";\n    cout << endl;\n\n    // Test Input 3: n=5, arr=[1, 2, 3, 4, 5]\n    vector<int> arr3 = {1, 2, 3, 4, 5};\n    vector<int> result3 = prefixDistinct(5, arr3);\n    for(int x : result3) cout << x << \" \";\n    cout << endl;\n\n    // Test Input 4: n=6, arr=[1, 2, 1, 2, 3, 1]\n    vector<int> arr4 = {1, 2, 1, 2, 3, 1};\n    vector<int> result4 = prefixDistinct(6, arr4);\n    for(int x : result4) cout << x << \" \";\n    cout << endl;\n\n    // Test Input 5: n=5, arr=[-1, -1, 0, 2, 3]\n    vector<int> arr5 = {-1, -1, 0, 2, 3};\n    vector<int> result5 = prefixDistinct(5, arr5);\n    for(int x : result5) cout << x << \" \";\n    cout << endl;\n\n    // Test Input 6: n=3, arr=[1, 2, 1]\n    vector<int> arr6 = {1, 2, 1};\n    vector<int> result6 = prefixDistinct(3, arr6);\n    for(int x : result6) cout << x << \" \";\n    cout << endl;\n\n    // Test Input 7: n=4, arr=[2, 2, 3, 4]\n    vector<int> arr7 = {2, 2, 3, 4};\n    vector<int> result7 = prefixDistinct(4, arr7);\n    for(int x : result7) cout << x << \" \";\n    cout << endl;\n\n    // Test Input 8: n=5, arr=[5, 5, 5, 5, 5]\n    vector<int> arr8 = {5, 5, 5, 5, 5};\n    vector<int> result8 = prefixDistinct(5, arr8);\n    for(int x : result8) cout << x << \" \";\n    cout << endl;\n\n    // Test Input 9: n=7, arr=[10, 20, 10, 30, 30, 40, 50]\n    vector<int> arr9 = {10, 20, 10, 30, 30, 40, 50};\n    vector<int> result9 = prefixDistinct(7, arr9);\n    for(int x : result9) cout << x << \" \";\n    cout << endl;\n\n    // Test Input 10: n=10, arr=[1, 2, 3, 4, 5, 1, 2, 3, 4, 5]\n    vector<int> arr10 = {1, 2, 3, 4, 5, 1, 2, 3, 4, 5};\n    vector<int> result10 = prefixDistinct(10, arr10);\n    for(int x : result10) cout << x << \" \";\n    cout << endl;\n\n    return 0;\n}", "TAG": "Success"}
{"source_Lan": "python###stoneGameVI.py", "source_code_str": "def stoneGameVI( aliceValues: List[int], bobValues: List[int]) -> int:\n    values = [[a+b, a, b] for a, b in zip(aliceValues, bobValues)]\n    values.sort(reverse=True)\n    aliceSum, bobSum = sum(value[1] for value in values[::2]), sum(value[2] for value in values[1::2])\n    if aliceSum > bobSum:\n        return 1\n    elif aliceSum == bobSum:\n        return 0\n    else:\n        return -1", "source_code_block": "", "target_Lan": "cpp###stoneGameVI.cpp", "reference_code": "    int stoneGameVI(vector<int>& aliceValues, vector<int>& bobValues) {\n        int n = aliceValues.size();\n        vector<tuple<int, int, int>> values;\n        for (int i = 0; i < aliceValues.size(); i++) {\n            values.emplace_back(aliceValues[i] + bobValues[i], aliceValues[i], bobValues[i]);\n        }\n        sort(values.begin(), values.end(), [](tuple<int, int, int> &a, tuple<int, int, int> &b) {\n            return get<0>(a) > get<0>(b);\n        });\n        int aliceSum = 0, bobSum = 0;\n        for (int i = 0; i < n; i++) {\n            if (i % 2 == 0) {\n                aliceSum += get<1>(values[i]);\n            } else {\n                bobSum += get<2>(values[i]);\n            }\n        }\n        if (aliceSum > bobSum) {\n            return 1;\n        } else if (aliceSum == bobSum) {\n            return 0;\n        } else {\n            return -1;\n        }\n    }", "target_method_signature": "stoneGameVI", "source_method_signature": "stoneGameVI", "target_allMS": "    int stoneGameVI(vector<int>& aliceValues, vector<int>& bobValues) {", "source_allMS": "def stoneGameVI( aliceValues: List[int], bobValues: List[int]) -> int:", "source_import": "", "target_import": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;", "commentTag": "//", "source_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(stoneGameVI([], []))                          # Edge case: Both vectors empty\n    print(stoneGameVI([1], [2]))                        # Single element where Bob wins\n    print(stoneGameVI([2], [1]))                        # Single element where Alice wins\n    print(stoneGameVI([3, 5], [2, 1]))                  # Multiple elements where Alice wins\n    print(stoneGameVI([1, 1], [1, 1]))                  # Multiple elements where it's a tie\n    print(stoneGameVI([4, 4], [1, 2]))                  # Multiple elements where Alice wins\n    print(stoneGameVI([5, 1], [3, 3]))                  # Multiple elements where Bob wins\n    print(stoneGameVI([], [10]))                         # Edge case: Alice has no stones, Bob has one\n    print(stoneGameVI([0, 0, 0, 0], [0, 0, 0, 0]))     # All zero values, should be a tie\n    print(stoneGameVI([10, 20, 30], [30, 20, 10]))      # Upper case where Alice can win", "all_input_output_value": "\ninput1: aliceValues=[], bobValues=[]\noutput1: 0\n--------\ninput2: aliceValues=[1], bobValues=[2]\noutput2: 1\n--------\ninput3: aliceValues=[2], bobValues=[1]\noutput3: 1\n--------\ninput4: aliceValues=[3, 5], bobValues=[2, 1]\noutput4: 1\n--------\ninput5: aliceValues=[1, 1], bobValues=[1, 1]\noutput5: 0\n--------\ninput6: aliceValues=[4, 4], bobValues=[1, 2]\noutput6: 1\n--------\ninput7: aliceValues=[5, 1], bobValues=[3, 3]\noutput7: 1\n--------\ninput8: aliceValues=[], bobValues=[10]\noutput8: 0\n--------\ninput9: aliceValues=[0, 0, 0, 0], bobValues=[0, 0, 0, 0]\noutput9: 0\n--------\ninput10: aliceValues=[10, 20, 30], bobValues=[30, 20, 10]\noutput10: 1\n", "input_output_value": ["\ninput1: aliceValues=[], bobValues=[]\noutput1: 0\n", "\ninput2: aliceValues=[1], bobValues=[2]\noutput2: 1\n", "\ninput3: aliceValues=[2], bobValues=[1]\noutput3: 1\n"], "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <tuple>\n#include <algorithm>\n// TOFILL\nint main() {\n    vector<int> aliceValues1 = {};\n    vector<int> bobValues1 = {};\n    cout << stoneGameVI(aliceValues1, bobValues1) << endl;\n\n    vector<int> aliceValues2 = {1};\n    vector<int> bobValues2 = {2};\n    cout << stoneGameVI(aliceValues2, bobValues2) << endl;\n\n    vector<int> aliceValues3 = {2};\n    vector<int> bobValues3 = {1};\n    cout << stoneGameVI(aliceValues3, bobValues3) << endl;\n\n    vector<int> aliceValues4 = {3, 5};\n    vector<int> bobValues4 = {2, 1};\n    cout << stoneGameVI(aliceValues4, bobValues4) << endl;\n\n    vector<int> aliceValues5 = {1, 1};\n    vector<int> bobValues5 = {1, 1};\n    cout << stoneGameVI(aliceValues5, bobValues5) << endl;\n\n    vector<int> aliceValues6 = {4, 4};\n    vector<int> bobValues6 = {1, 2};\n    cout << stoneGameVI(aliceValues6, bobValues6) << endl;\n\n    vector<int> aliceValues7 = {5, 1};\n    vector<int> bobValues7 = {3, 3};\n    cout << stoneGameVI(aliceValues7, bobValues7) << endl;\n\n    vector<int> aliceValues8 = {};\n    vector<int> bobValues8 = {10};\n    cout << stoneGameVI(aliceValues8, bobValues8) << endl;\n\n    vector<int> aliceValues9 = {0, 0, 0, 0};\n    vector<int> bobValues9 = {0, 0, 0, 0};\n    cout << stoneGameVI(aliceValues9, bobValues9) << endl;\n\n    vector<int> aliceValues10 = {10, 20, 30};\n    vector<int> bobValues10 = {30, 20, 10};\n    cout << stoneGameVI(aliceValues10, bobValues10) << endl;\n}", "TAG": "Success"}
{"source_Lan": "python###distinctDifferenceArray.py", "source_code_str": "def distinctDifferenceArray( nums: List[int]) -> List[int]:\n    st = set()\n    sufCnt = [0] * (len(nums) + 1)\n    for i in range(len(nums) - 1, 0, -1):\n        st.add(nums[i])\n        sufCnt[i] = len(st)\n    res = []\n    st.clear()\n    for i in range(len(nums)):\n        st.add(nums[i])\n        res.append(len(st) - sufCnt[i + 1])\n    return res", "source_code_block": "", "target_Lan": "cpp###distinctDifferenceArray.cpp", "reference_code": "    vector<int> distinctDifferenceArray(vector<int>& nums) {\n        int n = nums.size();\n        unordered_set<int> st;\n        vector<int> sufCnt(n + 1, 0);\n        for (int i = n - 1; i > 0; i--) {\n            st.insert(nums[i]);\n            sufCnt[i] = st.size();\n        }\n        vector<int> res;\n        st.clear();\n        for (int i = 0; i < n; i++) {\n            st.insert(nums[i]);\n            res.push_back(int(st.size()) - sufCnt[i + 1]);\n        }\n        return res;\n    }", "target_method_signature": "distinctDifferenceArray", "source_method_signature": "distinctDifferenceArray", "target_allMS": "    vector<int> distinctDifferenceArray(vector<int>& nums) {", "source_allMS": "def distinctDifferenceArray( nums: List[int]) -> List[int]:", "source_import": "", "target_import": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;", "commentTag": "//", "source_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(distinctDifferenceArray([]))  # Test case 1: Empty vector\n    print(distinctDifferenceArray([1]))  # Test case 2: Single element vector\n    print(distinctDifferenceArray([1, 2, 3, 4, 5]))  # Test case 3: All distinct elements\n    print(distinctDifferenceArray([2, 2, 2, 2]))  # Test case 4: All identical elements\n    print(distinctDifferenceArray([1, 2, 2, 3, 4]))  # Test case 5: Mix of distinct and identical elements\n    print(distinctDifferenceArray([-1, -2, -3, -4]))  # Test case 6: All negative elements\n    print(distinctDifferenceArray([1, -1, 1, -1]))  # Test case 7: Mix of positive and negative elements\n    print(distinctDifferenceArray([1, 2, 2, 1, 3]))  # Test case 8: More complex mix\n    print(distinctDifferenceArray([5, -5, 5, -5, 5]))  # Test case 9: Alternating patterns\n    print(distinctDifferenceArray([7, 7, 8, 8, 9, 9]))  # Test case 10: Duplicates with slight variation", "all_input_output_value": "\ninput1: nums=[]\noutput1: []\n--------\ninput2: nums=[1]\noutput2: [1]\n--------\ninput3: nums=[1, 2, 3, 4, 5]\noutput3: [-3, -1, 1, 3, 5]\n--------\ninput4: nums=[2, 2, 2, 2]\noutput4: [0, 0, 0, 1]\n--------\ninput5: nums=[1, 2, 2, 3, 4]\noutput5: [-2, -1, 0, 2, 4]\n--------\ninput6: nums=[-1, -2, -3, -4]\noutput6: [-2, 0, 2, 4]\n--------\ninput7: nums=[1, -1, 1, -1]\noutput7: [-1, 0, 1, 2]\n--------\ninput8: nums=[1, 2, 2, 1, 3]\noutput8: [-2, -1, 0, 1, 3]\n--------\ninput9: nums=[5, -5, 5, -5, 5]\noutput9: [-1, 0, 0, 1, 2]\n--------\ninput10: nums=[7, 7, 8, 8, 9, 9]\noutput10: [-2, -1, 0, 1, 2, 3]\n", "input_output_value": ["\ninput1: nums=[]\noutput1: []\n", "\ninput2: nums=[1]\noutput2: [1]\n", "\ninput3: nums=[1, 2, 3, 4, 5]\noutput3: [-3, -1, 1, 3, 5]\n"], "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <unordered_set>\n// TOFILL\nint main() {\n    // Test input 1: Empty array\n    vector<int> input1 = {};\n    vector<int> output1 = distinctDifferenceArray(input1);\n    for(int i : output1) cout << i << \" \";\n    cout << endl;\n\n    // Test input 2: Single element\n    vector<int> input2 = {1};\n    vector<int> output2 = distinctDifferenceArray(input2);\n    for(int i : output2) cout << i << \" \";\n    cout << endl;\n\n    // Test input 3: Multiple distinct elements\n    vector<int> input3 = {1, 2, 3, 4, 5};\n    vector<int> output3 = distinctDifferenceArray(input3);\n    for(int i : output3) cout << i << \" \";\n    cout << endl;\n\n    // Test input 4: All identical elements\n    vector<int> input4 = {2, 2, 2, 2};\n    vector<int> output4 = distinctDifferenceArray(input4);\n    for(int i : output4) cout << i << \" \";\n    cout << endl;\n\n    // Test input 5: Some duplicates, some unique\n    vector<int> input5 = {1, 2, 2, 3, 4};\n    vector<int> output5 = distinctDifferenceArray(input5);\n    for(int i : output5) cout << i << \" \";\n    cout << endl;\n\n    // Test input 6: Negative numbers\n    vector<int> input6 = {-1, -2, -3, -4};\n    vector<int> output6 = distinctDifferenceArray(input6);\n    for(int i : output6) cout << i << \" \";\n    cout << endl;\n\n    // Test input 7: Alternating duplicates\n    vector<int> input7 = {1, -1, 1, -1};\n    vector<int> output7 = distinctDifferenceArray(input7);\n    for(int i : output7) cout << i << \" \";\n    cout << endl;\n\n    // Test input 8: Mixed duplicates\n    vector<int> input8 = {1, 2, 2, 1, 3};\n    vector<int> output8 = distinctDifferenceArray(input8);\n    for(int i : output8) cout << i << \" \";\n    cout << endl;\n\n    // Test input 9: Alternating large and small with duplicates\n    vector<int> input9 = {5, -5, 5, -5, 5};\n    vector<int> output9 = distinctDifferenceArray(input9);\n    for(int i : output9) cout << i << \" \";\n    cout << endl;\n\n    // Test input 10: Close duplicates\n    vector<int> input10 = {7, 7, 8, 8, 9, 9};\n    vector<int> output10 = distinctDifferenceArray(input10);\n    for(int i : output10) cout << i << \" \";\n    cout << endl;\n\n    return 0;\n}", "TAG": "Success"}
{"source_Lan": "python###Towerheight.py", "source_code_str": "def Towerheight( n: int, k: int, arr: List[int]) -> int:\n    \n    st = []\n    total_height = 0\n    i = 0\n    \n    for j in range(n):\n        total_height += arr[j]\n        st.append(arr[j])\n        \n        if total_height > k:\n            \n            remove_boxes = i + 1\n            while remove_boxes > 0 and st:\n                total_height -= st.pop()\n                remove_boxes -= 1\n            i += 1\n    \n    return total_height", "source_code_block": "", "target_Lan": "cpp###Towerheight.cpp", "reference_code": "    int Towerheight(int n, int k, vector<int>& a) {\n        \n        stack<int> st;\n        int totalHeight = 0;\n        int i = 0;\n        \n        for (int j = 0; j < n; j++) {\n            totalHeight += a[j];\n            st.push(a[j]);\n            \n            if (totalHeight > k) {\n                \n                int removeBoxes = i + 1;\n                while (removeBoxes > 0 && !st.empty()) {\n                    totalHeight -= st.top();\n                    st.pop();\n                    removeBoxes--;\n                }\n                i++;\n            }\n        }\n        \n        return totalHeight;\n    }", "target_method_signature": "Towerheight", "source_method_signature": "Towerheight", "target_allMS": "    int Towerheight(int n, int k, vector<int>& a) {", "source_allMS": "def Towerheight( n: int, k: int, arr: List[int]) -> int:", "source_import": "from typing import List", "target_import": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;", "commentTag": "//", "source_code_shell": "from typing import List\nfrom typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(Towerheight(1, 1, [1]))\n    print(Towerheight(2, 5, [1, 3]))\n    print(Towerheight(3, 5, [2, 2, 2]))\n    print(Towerheight(5, 10, [2, 2, 2, 2, 2]))\n    print(Towerheight(4, 6, [1, 2, 3, 4]))\n    print(Towerheight(5, 8, [2, 2, 3, 4, 5]))\n    print(Towerheight(4, 7, [5, 3, 2, 6]))\n    print(Towerheight(3, 0, [1, 1, 1]))\n    print(Towerheight(5, 10, [2, 5, 6, 1, 2]))\n    print(Towerheight(3, 3, [0, 0, 0]))", "all_input_output_value": "\ninput1: n=1, k=1, arr=[1]\noutput1: 1\n--------\ninput2: n=2, k=5, arr=[1, 3]\noutput2: 4\n--------\ninput3: n=3, k=5, arr=[2, 2, 2]\noutput3: 4\n--------\ninput4: n=5, k=10, arr=[2, 2, 2, 2, 2]\noutput4: 10\n--------\ninput5: n=4, k=6, arr=[1, 2, 3, 4]\noutput5: 6\n--------\ninput6: n=5, k=8, arr=[2, 2, 3, 4, 5]\noutput6: 4\n--------\ninput7: n=4, k=7, arr=[5, 3, 2, 6]\noutput7: 5\n--------\ninput8: n=3, k=0, arr=[1, 1, 1]\noutput8: 0\n--------\ninput9: n=5, k=10, arr=[2, 5, 6, 1, 2]\noutput9: 10\n--------\ninput10: n=3, k=3, arr=[0, 0, 0]\noutput10: 0\n", "input_output_value": ["\ninput1: n=1, k=1, arr=[1]\noutput1: 1\n", "\ninput2: n=2, k=5, arr=[1, 3]\noutput2: 4\n", "\ninput3: n=3, k=5, arr=[2, 2, 2]\noutput3: 4\n"], "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <stack>\n// TOFILL\nint main() {\n    vector<int> arr1 = {1};\n    cout << Towerheight(1, 1, arr1) << endl;\n\n    vector<int> arr2 = {1, 3};\n    cout << Towerheight(2, 5, arr2) << endl;\n\n    vector<int> arr3 = {2, 2, 2};\n    cout << Towerheight(3, 5, arr3) << endl;\n\n    vector<int> arr4 = {2, 2, 2, 2, 2};\n    cout << Towerheight(5, 10, arr4) << endl;\n\n    vector<int> arr5 = {1, 2, 3, 4};\n    cout << Towerheight(4, 6, arr5) << endl;\n\n    vector<int> arr6 = {2, 2, 3, 4, 5};\n    cout << Towerheight(5, 8, arr6) << endl;\n\n    vector<int> arr7 = {5, 3, 2, 6};\n    cout << Towerheight(4, 7, arr7) << endl;\n\n    vector<int> arr8 = {1, 1, 1};\n    cout << Towerheight(3, 0, arr8) << endl;\n\n    vector<int> arr9 = {2, 5, 6, 1, 2};\n    cout << Towerheight(5, 10, arr9) << endl;\n\n    vector<int> arr10 = {0, 0, 0};\n    cout << Towerheight(3, 3, arr10) << endl;\n\n    return 0;\n}", "TAG": "Success"}
{"source_Lan": "python###arrangingHorses.py", "source_code_str": "def arrangingHorses( n: int, m: int,\n                    data: List[List[int]]) -> List[int]:\n    deg = [0] * (n)\n    g = [[] for _ in range(n)]\n    for el in data:\n        deg[el[0]] += 1\n        g[el[1]].append(el[0])\n    q = []\n    ans = []\n    for i in range(n):\n        if deg[i] == 0:\n            heappush(q, i)\n    while q:\n        node = heappop(q)\n        ans.append(node)\n        for el in g[node]:\n            deg[el] -= 1\n            if deg[el] == 0:\n                heappush(q, el)\n    return ans", "source_code_block": "", "target_Lan": "cpp###arrangingHorses.cpp", "reference_code": "    vector<int> arrangingHorses(int n, int m, vector<vector<int>>& data) {\n        vector<int> inDegree(n, 0);\n        vector<vector<int>> adjList(n);\n        for (const auto& edge : data) {\n            int a = edge[0], b = edge[1];\n            adjList[b].push_back(a); \n            ++inDegree[a];\n        }\n        priority_queue<int, vector<int>, greater<int>> pq; \n        for (int i = 0; i < n; ++i) {\n            if (inDegree[i] == 0)\n                pq.push(i);\n        }\n        vector<int> order;\n        while (!pq.empty()) {\n            int horse = pq.top();\n            pq.pop();\n            order.push_back(horse);\n            for (int neigh : adjList[horse]) {\n                --inDegree[neigh];\n                if (inDegree[neigh] == 0)\n                    pq.push(neigh);\n            }\n        }\n        return order;\n    }", "target_method_signature": "arrangingHorses", "source_method_signature": "arrangingHorses", "target_allMS": "    vector<int> arrangingHorses(int n, int m, vector<vector<int>>& data) {", "source_allMS": "def arrangingHorses( n: int, m: int,", "source_import": "from typing import List\nfrom heapq import *\nfrom typing import List", "target_import": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;", "commentTag": "//", "source_code_shell": "from typing import List\nfrom heapq import *\nfrom typing import List\nfrom typing import List\nfrom heapq import heappush, heappop\n# TOFILL\nif __name__ == \"__main__\":\n    print(arrangingHorses(0, 0, []))\n    print(arrangingHorses(1, 0, []))\n    print(arrangingHorses(3, 2, [[0, 1], [1, 2]]))\n    print(arrangingHorses(4, 3, [[0, 1], [1, 2], [2, 3]]))\n    print(arrangingHorses(5, 4, [[0, 1], [0, 2], [1, 3], [2, 4]]))\n    print(arrangingHorses(3, 3, [[0, 1], [1, 2], [2, 0]]))  # This input creates a cycle\n    print(arrangingHorses(5, 5, [[0, 1], [0, 2], [1, 3], [1, 4], [2, 4]]))\n    print(arrangingHorses(6, 6, [[0, 1], [0, 2], [1, 3], [3, 4], [4, 5], [2, 5]]))\n    print(arrangingHorses(4, 2, [[2, 0], [2, 1]]))  # Disconnected components\n    print(arrangingHorses(2, 1, [[1, 0]]))", "all_input_output_value": "\ninput1: n=0, m=0, edges=[]\noutput1: []\n--------\ninput2: n=1, m=0, edges=[]\noutput2: [0]\n--------\ninput3: n=3, m=2, edges=[[0, 1], [1, 2]]\noutput3: [2, 1, 0]\n--------\ninput4: n=4, m=3, edges=[[0, 1], [1, 2], [2, 3]]\noutput4: [3, 2, 1, 0]\n--------\ninput5: n=5, m=4, edges=[[0, 1], [0, 2], [1, 3], [2, 4]]\noutput5: [3, 1, 4, 2, 0]\n--------\ninput6: n=3, m=3, edges=[[0, 1], [1, 2], [2, 0]]\noutput6: []\n--------\ninput7: n=5, m=5, edges=[[0, 1], [0, 2], [1, 3], [1, 4], [2, 4]]\noutput7: [3, 4, 1, 2, 0]\n--------\ninput8: n=6, m=6, edges=[[0, 1], [0, 2], [1, 3], [3, 4], [4, 5], [2, 5]]\noutput8: [5, 2, 4, 3, 1, 0]\n--------\ninput9: n=4, m=2, edges=[[2, 0], [2, 1]]\noutput9: [0, 1, 2, 3]\n--------\ninput10: n=2, m=1, edges=[[1, 0]]\noutput10: [0, 1]\n", "input_output_value": ["\ninput1: n=0, m=0, edges=[]\noutput1: []\n", "\ninput2: n=1, m=0, edges=[]\noutput2: [0]\n", "\ninput3: n=3, m=2, edges=[[0, 1], [1, 2]]\noutput3: [2, 1, 0]\n"], "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <queue>\n// TOFILL\nint main() {\n    vector<vector<int>> edges1 = {};\n    vector<vector<int>> edges2 = {};\n    vector<vector<int>> edges3 = {{0, 1}, {1, 2}};\n    vector<vector<int>> edges4 = {{0, 1}, {1, 2}, {2, 3}};\n    vector<vector<int>> edges5 = {{0, 1}, {0, 2}, {1, 3}, {2, 4}};\n    vector<vector<int>> edges6 = {{0, 1}, {1, 2}, {2, 0}};\n    vector<vector<int>> edges7 = {{0, 1}, {0, 2}, {1, 3}, {1, 4}, {2, 4}};\n    vector<vector<int>> edges8 = {{0, 1}, {0, 2}, {1, 3}, {3, 4}, {4, 5}, {2, 5}};\n    vector<vector<int>> edges9 = {{2, 0}, {2, 1}};\n    vector<vector<int>> edges10 = {{1, 0}};\n\n    cout << \"Test Input 1: \";\n    vector<int> result1 = arrangingHorses(0, 0, edges1);\n    for(int horse : result1) cout << horse << \" \";\n    cout << endl;\n\n    cout << \"Test Input 2: \";\n    vector<int> result2 = arrangingHorses(1, 0, edges2);\n    for(int horse : result2) cout << horse << \" \";\n    cout << endl;\n\n    cout << \"Test Input 3: \";\n    vector<int> result3 = arrangingHorses(3, 2, edges3);\n    for(int horse : result3) cout << horse << \" \";\n    cout << endl;\n\n    cout << \"Test Input 4: \";\n    vector<int> result4 = arrangingHorses(4, 3, edges4);\n    for(int horse : result4) cout << horse << \" \";\n    cout << endl;\n\n    cout << \"Test Input 5: \";\n    vector<int> result5 = arrangingHorses(5, 4, edges5);\n    for(int horse : result5) cout << horse << \" \";\n    cout << endl;\n\n    cout << \"Test Input 6: \";\n    vector<int> result6 = arrangingHorses(3, 3, edges6);\n    for(int horse : result6) cout << horse << \" \";\n    cout << endl;\n\n    cout << \"Test Input 7: \";\n    vector<int> result7 = arrangingHorses(5, 5, edges7);\n    for(int horse : result7) cout << horse << \" \";\n    cout << endl;\n\n    cout << \"Test Input 8: \";\n    vector<int> result8 = arrangingHorses(6, 6, edges8);\n    for(int horse : result8) cout << horse << \" \";\n    cout << endl;\n\n    cout << \"Test Input 9: \";\n    vector<int> result9 = arrangingHorses(4, 2, edges9);\n    for(int horse : result9) cout << horse << \" \";\n    cout << endl;\n\n    cout << \"Test Input 10: \";\n    vector<int> result10 = arrangingHorses(2, 1, edges10);\n    for(int horse : result10) cout << horse << \" \";\n    cout << endl;\n\n    return 0;\n}", "TAG": "Success"}
{"source_Lan": "python###findAnswer.py", "source_code_str": "def findAnswer( n : int, A : List[int]) -> List[int]:\n    pref=[A[0]]\n    for i in range(1,n):\n        pref.append(pref[-1]+A[i])\n    s=[]\n    res=[0]*(n+1)\n    for i in range(n):\n        if pref[i]>0:\n            res[0]=i+1\n            break\n    for i in range(n-1,-1,-1):\n        while s and pref[s[-1]]<=pref[i]:\n            s.pop()\n        if not s:\n            res[i+1]=0\n        elif i<n-1:\n            res[i+1]=s[-1]-i\n        s.append(i)\n    res.pop()\n    return res", "source_code_block": "", "target_Lan": "cpp###findAnswer.cpp", "reference_code": "  vector<int> findAnswer(int n, vector<int> &A)\n  {\n    vector<long long> pref(n, A[0]);\n    for (int i = 1; i < n; i++)\n    {\n      pref[i] = pref[i - 1] + A[i];\n    }\n    stack<int> s;\n    vector<int> res(n+1, 0);\n    for (int i = 0; i < n; i++)\n    {\n      if (pref[i] > 0)\n      {\n        res[0] = i + 1;\n        break;\n      }\n    }\n    for (int i = n - 1; i >= 0; i--)\n    {\n      while (!s.empty() && pref[s.top()] <= pref[i])\n        s.pop();\n      if (s.empty())\n        res[i+1] = 0;\n      else if (i < n - 1)\n        res[i + 1] = s.top() - i;\n      s.push(i);\n    }\n    res.pop_back();\n    return res;\n  }", "target_method_signature": "findAnswer", "source_method_signature": "findAnswer", "target_allMS": "  vector<int> findAnswer(int n, vector<int> &A)", "source_allMS": "def findAnswer( n : int, A : List[int]) -> List[int]:", "source_import": "from typing import List", "target_import": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;", "commentTag": "//", "source_code_shell": "from typing import List\nfrom typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    test_inputs = [\n        [4, [0, 0, 0, 0]],              # Test with all zeroes\n        [4, [1, -1, 2, -2]],            # Mix of positive and negative numbers\n        [3, [3, -1, 4]],                # Case with positive prefix sums\n        [3, [-3, -1, -2]],              # All negative numbers\n        [4, [5, 6, 7, 8]],              # All positive numbers\n        [5, [0, 2, 3, -1, -5]],         # Mix including zero and negatives\n        [1, [1]],                       # Single positive element\n        [1, [-1]],                      # Single negative element\n        [3, [1e6, -1e5, 1e6]],          # Large positive and negative numbers\n        [5, [1, -1, 1, -1, 1]]          # Alternating positive and negative\n    ]\n    for n, A in test_inputs:\n        print(findAnswer(n, A))", "all_input_output_value": "\ninput1: n=4, A=[0, 0, 0, 0]\noutput1: [0, 0, 0, 0]\n--------\ninput2: n=4, A=[1, -1, 2, -2]\noutput2: [1, 2, 1, 0]\n--------\ninput3: n=3, A=[3, -1, 4]\noutput3: [1, 2, 1]\n--------\ninput4: n=3, A=[-3, -1, -2]\noutput4: [0, 0, 0]\n--------\ninput5: n=4, A=[5, 6, 7, 8]\noutput5: [1, 1, 1, 1]\n--------\ninput6: n=5, A=[0, 2, 3, -1, -5]\noutput6: [2, 1, 1, 0, 0]\n--------\ninput7: n=1, A=[1]\noutput7: [1]\n--------\ninput8: n=1, A=[-1]\noutput8: [0]\n--------\ninput9: n=3, A=[1e6, -1e5, 1e6]\noutput9: [1, 2, 1]\n--------\ninput10: n=5, A=[1, -1, 1, -1, 1]\noutput10: [1, 0, 1, 0, 1]\n", "input_output_value": ["\ninput1: n=4, A=[0, 0, 0, 0]\noutput1: [0, 0, 0, 0]\n", "\ninput2: n=4, A=[1, -1, 2, -2]\noutput2: [1, 2, 1, 0]\n", "\ninput3: n=3, A=[3, -1, 4]\noutput3: [1, 2, 1]\n"], "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <stack>\n// TOFILL\nint main() {\n    vector<int> result;\n\n    // Test input 1\n    vector<int> A1 = {0, 0, 0, 0};\n    result = findAnswer(4, A1);\n    for(int val : result) cout << val << \" \";\n    cout << endl;\n\n    // Test input 2\n    vector<int> A2 = {1, -1, 2, -2};\n    result = findAnswer(4, A2);\n    for(int val : result) cout << val << \" \";\n    cout << endl;\n\n    // Test input 3\n    vector<int> A3 = {3, -1, 4};\n    result = findAnswer(3, A3);\n    for(int val : result) cout << val << \" \";\n    cout << endl;\n\n    // Test input 4\n    vector<int> A4 = {-3, -1, -2};\n    result = findAnswer(3, A4);\n    for(int val : result) cout << val << \" \";\n    cout << endl;\n\n    // Test input 5\n    vector<int> A5 = {5, 6, 7, 8};\n    result = findAnswer(4, A5);\n    for(int val : result) cout << val << \" \";\n    cout << endl;\n\n    // Test input 6\n    vector<int> A6 = {0, 2, 3, -1, -5};\n    result = findAnswer(5, A6);\n    for(int val : result) cout << val << \" \";\n    cout << endl;\n\n    // Test input 7\n    vector<int> A7 = {1};\n    result = findAnswer(1, A7);\n    for(int val : result) cout << val << \" \";\n    cout << endl;\n\n    // Test input 8\n    vector<int> A8 = {-1};\n    result = findAnswer(1, A8);\n    for(int val : result) cout << val << \" \";\n    cout << endl;\n\n    // Test input 9\n    vector<int> A9 = {1000000, -100000, 1000000};\n    result = findAnswer(3, A9);\n    for(int val : result) cout << val << \" \";\n    cout << endl;\n\n    // Test input 10\n    vector<int> A10 = {1, -1, 1, -1, 1};\n    result = findAnswer(5, A10);\n    for(int val : result) cout << val << \" \";\n    cout << endl;\n\n    return 0;\n}", "TAG": "Success"}
{"source_Lan": "python###paintWalls.py", "source_code_str": "def paintWalls( cost: List[int], time: List[int]) -> int:\n    n = len(cost)\n    f = [inf] * (n * 2 + 1)\n    f[n] = 0\n    for (cost_i, time_i) in zip(cost, time):\n        g = [inf] * (n * 2 + 1)\n        for j in range(n * 2 + 1):\n            \n            g[min(j + time_i, n * 2)] = min(g[min(j + time_i, n * 2)], f[j] + cost_i)\n            \n            if j > 0:\n                g[j - 1] = min(g[j - 1], f[j])\n        f = g\n    return min(f[n:])", "source_code_block": "", "target_Lan": "cpp###paintWalls.cpp", "reference_code": "    int paintWalls(vector<int>& cost, vector<int>& time) {\n        int n = cost.size();\n        vector<int> f(n * 2 + 1, INT_MAX / 2);\n        f[n] = 0;\n        for (int i = 0; i < n; ++i) {\n            vector<int> g(n * 2 + 1, INT_MAX / 2);\n            for (int j = 0; j <= n * 2; ++j) {\n                \n                g[min(j + time[i], n * 2)] = min(g[min(j + time[i], n * 2)], f[j] + cost[i]);\n                \n                if (j > 0) {\n                    g[j - 1] = min(g[j - 1], f[j]);\n                }\n            }\n            f = move(g);\n        }\n        return *min_element(f.begin() + n, f.end());\n    }", "target_method_signature": "paintWalls", "source_method_signature": "paintWalls", "target_allMS": "    int paintWalls(vector<int>& cost, vector<int>& time) {", "source_allMS": "def paintWalls( cost: List[int], time: List[int]) -> int:", "source_import": "", "target_import": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;", "commentTag": "//", "source_code_shell": "from typing import List\nfrom math import inf\n# TOFILL\nif __name__ == \"__main__\":\n    print(paintWalls([10, 20, 30], [1, 2, 3]))\n    print(paintWalls([0, 5, 15], [0, 0, 0]))\n    print(paintWalls([100, 200], [2, 3]))\n    print(paintWalls([1, 2, 3, 4, 5], [1, 1, 1, 1, 1]))\n    print(paintWalls([5], [1]))\n    print(paintWalls([20, 15, 10], [3, 2, 1]))\n    print(paintWalls([0], [0]))\n    print(paintWalls([50, 60], [0, 0]))\n    print(paintWalls([30, 20, 10, 40], [1, 1, 1, 1]))\n    print(paintWalls([1000, 500, 300, 1500], [5, 5, 5, 5]))", "all_input_output_value": "\ninput1: cost=[10, 20, 30], time=[1, 2, 3]\noutput1: 20\n--------\ninput2: cost=[0, 5, 15], time=[0, 0, 0]\noutput2: 20\n--------\ninput3: cost=[100, 200], time=[2, 3]\noutput3: 100\n--------\ninput4: cost=[1, 2, 3, 4, 5], time=[1, 1, 1, 1, 1]\noutput4: 6\n--------\ninput5: cost=[5], time=[1]\noutput5: 5\n--------\ninput6: cost=[20, 15, 10], time=[3, 2, 1]\noutput6: 15\n--------\ninput7: cost=[0], time=[0]\noutput7: 0\n--------\ninput8: cost=[50, 60], time=[0, 0]\noutput8: 110\n--------\ninput9: cost=[30, 20, 10, 40], time=[1, 1, 1, 1]\noutput9: 30\n--------\ninput10: cost=[1000, 500, 300, 1500], time=[5, 5, 5, 5]\noutput10: 300\n", "input_output_value": ["\ninput1: cost=[10, 20, 30], time=[1, 2, 3]\noutput1: 20\n", "\ninput2: cost=[0, 5, 15], time=[0, 0, 0]\noutput2: 20\n", "\ninput3: cost=[100, 200], time=[2, 3]\noutput3: 100\n"], "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n// TOFILL\nint main() {\n    vector<int> cost1 = {10, 20, 30}, time1 = {1, 2, 3};\n    cout << paintWalls(cost1, time1) << endl;\n\n    vector<int> cost2 = {0, 5, 15}, time2 = {0, 0, 0};\n    cout << paintWalls(cost2, time2) << endl;\n\n    vector<int> cost3 = {100, 200}, time3 = {2, 3};\n    cout << paintWalls(cost3, time3) << endl;\n\n    vector<int> cost4 = {1, 2, 3, 4, 5}, time4 = {1, 1, 1, 1, 1};\n    cout << paintWalls(cost4, time4) << endl;\n\n    vector<int> cost5 = {5}, time5 = {1};\n    cout << paintWalls(cost5, time5) << endl;\n\n    vector<int> cost6 = {20, 15, 10}, time6 = {3, 2, 1};\n    cout << paintWalls(cost6, time6) << endl;\n\n    vector<int> cost7 = {0}, time7 = {0};\n    cout << paintWalls(cost7, time7) << endl;\n\n    vector<int> cost8 = {50, 60}, time8 = {0, 0};\n    cout << paintWalls(cost8, time8) << endl;\n\n    vector<int> cost9 = {30, 20, 10, 40}, time9 = {1, 1, 1, 1};\n    cout << paintWalls(cost9, time9) << endl;\n\n    vector<int> cost10 = {1000, 500, 300, 1500}, time10 = {5, 5, 5, 5};\n    cout << paintWalls(cost10, time10) << endl;\n\n    return 0;\n}", "TAG": "Success"}
{"source_Lan": "python###maxResult.py", "source_code_str": "def maxResult( nums: List[int], k: int) -> int:\n    n = len(nums)\n    dp = [0] * n\n    dp[0] = nums[0]\n    queue = deque([0])\n    for i in range(1, n):\n        while queue and queue[0] < i - k:\n            queue.popleft()\n        dp[i] = dp[queue[0]] + nums[i]\n        while queue and dp[queue[-1]] <= dp[i]:\n            queue.pop()\n        queue.append(i)\n    return dp[n - 1]", "source_code_block": "", "target_Lan": "cpp###maxResult.cpp", "reference_code": "    int maxResult(vector<int>& nums, int k) {\n        int n = nums.size();\n        vector<int> dp(n);\n        dp[0] = nums[0];\n        deque<int> queue;\n        queue.push_back(0);\n        for (int i = 1; i < n; i++) {\n            while (!queue.empty() && queue.front() < i - k) {\n                queue.pop_front();\n            }\n            dp[i] = dp[queue.front()] + nums[i];\n            while (!queue.empty() && dp[queue.back()] <= dp[i]) {\n                queue.pop_back();\n            }\n            queue.push_back(i);\n        }\n        return dp[n - 1];\n    }", "target_method_signature": "maxResult", "source_method_signature": "maxResult", "target_allMS": "    int maxResult(vector<int>& nums, int k) {", "source_allMS": "def maxResult( nums: List[int], k: int) -> int:", "source_import": "", "target_import": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;", "commentTag": "//", "source_code_shell": "from typing import List\nfrom collections import deque\n# TOFILL\nif __name__ == \"__main__\":\n    print(maxResult([10], 1))\n    print(maxResult([-1, -2, -3, -4], 2))\n    print(maxResult([1, 2, 3, 4, 5, 6], 10))\n    print(maxResult([5, -1, 2, 3, 4], 3))\n    print(maxResult([1, 2, 3, 4, 5], 1))\n    print(maxResult([100, 200, 300], 2))\n    print(maxResult([-5, 10, -20, 5, 10, 15], 3))\n    print(maxResult([1], 5))", "all_input_output_value": "\ninput1: nums=[10], k=1\noutput1: 10\n--------\ninput2: nums=[-1, -2, -3, -4], k=2\noutput2: -7\n--------\ninput3: nums=[1, 2, 3, 4, 5, 6], k=10\noutput3: 21\n--------\ninput4: nums=[5, -1, 2, 3, 4], k=3\noutput4: 14\n--------\ninput5: nums=[1, 2, 3, 4, 5], k=1\noutput5: 15\n--------\ninput6: nums=[100, 200, 300], k=2\noutput6: 600\n--------\ninput7: nums=[-5, 10, -20, 5, 10, 15], k=3\noutput7: 35\n--------\ninput8: nums=[1], k=5\noutput8: 1\n", "input_output_value": ["\ninput1: nums=[10], k=1\noutput1: 10\n", "\ninput2: nums=[-1, -2, -3, -4], k=2\noutput2: -7\n", "\ninput3: nums=[1, 2, 3, 4, 5, 6], k=10\noutput3: 21\n"], "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <deque>\n// TOFILL\nint main() {\n    vector<int> input1 = {10};\n    cout << maxResult(input1, 1) << endl;\n\n    vector<int> input2 = {-1, -2, -3, -4};\n    cout << maxResult(input2, 2) << endl;\n\n    vector<int> input3 = {1, 2, 3, 4, 5, 6};\n    cout << maxResult(input3, 10) << endl;\n\n    vector<int> input4 = {5, -1, 2, 3, 4};\n    cout << maxResult(input4, 3) << endl;\n\n    vector<int> input5 = {1, 2, 3, 4, 5};\n    cout << maxResult(input5, 1) << endl;\n\n    vector<int> input6 = {100, 200, 300};\n    cout << maxResult(input6, 2) << endl;\n\n    vector<int> input7 = {-5, 10, -20, 5, 10, 15};\n    cout << maxResult(input7, 3) << endl;\n\n    vector<int> input8 = {1};\n    cout << maxResult(input8, 5) << endl;\n\n    return 0;\n}", "TAG": "Success"}
{"source_Lan": "python###numberOfRightTriangles.py", "source_code_str": "def numberOfRightTriangles( grid: List[List[int]]) -> int:\n        n, m = len(grid), len(grid[0])\n        col = [0] * m\n        for j in range(m):\n            for i in range(n):\n                col[j] += grid[i][j]\n        res = 0\n        for i in range(n):\n            row = sum(grid[i])\n            for j in range(m):\n                if grid[i][j] == 1:\n                    res += (row - 1) * (col[j] - 1)\n        return res", "source_code_block": "", "target_Lan": "cpp###numberOfRightTriangles.cpp", "reference_code": "long long numberOfRightTriangles(vector<vector<int>>& grid) {\n        int n = grid.size(), m = grid[0].size();\n        vector<int> col(m);\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                col[j] += grid[i][j];\n            }\n        }\n        long long res = 0;\n        for (int i = 0; i < n; i++) {\n            int row = accumulate(grid[i].begin(), grid[i].end(), 0);\n            for (int j = 0; j < m; j++) {\n                if (grid[i][j] == 1) {\n                    res += (row - 1) * (col[j] - 1);\n                }\n            }\n        }\n        return res;\n    }", "target_method_signature": "numberOfRightTriangles", "source_method_signature": "numberOfRightTriangles", "target_allMS": "", "source_allMS": "", "source_import": "from typing import List", "target_import": "#include <iostream>\n#include <vector>\n#include <numeric> // for accumulate\nusing namespace std;", "commentTag": "", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <numeric> // for accumulate\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <numeric>\n// TOFILL\nint main() {\n    vector<vector<int>> input1 = {{0}};\n    vector<vector<int>> input2 = {{1}};\n    vector<vector<int>> input3 = {{1, 0}, {0, 1}};\n    vector<vector<int>> input4 = {{1, 0}, {1, 1}};\n    vector<vector<int>> input5 = {{1, 1}, {1, 0}};\n    vector<vector<int>> input6 = {{0, 0}, {0, 0}};\n    vector<vector<int>> input7 = {{1, 1}, {1, 1}};\n    vector<vector<int>> input8 = {{1, 0, 1}, {1, 1, 0}};\n    vector<vector<int>> input9 = {{0, 1, 0}, {1, 1, 0}, {0, 0, 0}};\n    vector<vector<int>> input10 = {{1, 1, 1}, {0, 1, 0}, {1, 1, 1}};\n\n    cout << numberOfRightTriangles(input1) << endl;\n    cout << numberOfRightTriangles(input2) << endl;\n    cout << numberOfRightTriangles(input3) << endl;\n    cout << numberOfRightTriangles(input4) << endl;\n    cout << numberOfRightTriangles(input5) << endl;\n    cout << numberOfRightTriangles(input6) << endl;\n    cout << numberOfRightTriangles(input7) << endl;\n    cout << numberOfRightTriangles(input8) << endl;\n    cout << numberOfRightTriangles(input9) << endl;\n    cout << numberOfRightTriangles(input10) << endl;\n\n    return 0;\n}", "all_input_output_value": "\ninput1: [[0]]\noutput1: 0\n--------\ninput2: [[1]]\noutput2: 0\n--------\ninput3: [[1, 0], [0, 1]]\noutput3: 0\n--------\ninput4: [[1, 0], [1, 1]]\noutput4: 1\n--------\ninput5: [[1, 1], [1, 0]]\noutput5: 1\n--------\ninput6: [[0, 0], [0, 0]]\noutput6: 0\n--------\ninput7: [[1, 1], [1, 1]]\noutput7: 4\n--------\ninput8: [[1, 0, 1], [1, 1, 0]]\noutput8: 2\n--------\ninput9: [[0, 1, 0], [1, 1, 0], [0, 0, 0]]\noutput9: 1\n--------\ninput10: [[1, 1, 1], [0, 1, 0], [1, 1, 1]]\noutput10: 16\n", "input_output_value": ["\ninput1: [[0]]\noutput1: 0\n", "\ninput2: [[1]]\noutput2: 0\n", "\ninput3: [[1, 0], [0, 1]]\noutput3: 0\n"], "TAG": "Success", "source_code_shell": "from typing import List\nfrom typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(numberOfRightTriangles([[0]]))                   # Single cell, zero\n    print(numberOfRightTriangles([[1]]))                   # Single cell, one\n    print(numberOfRightTriangles([[1, 0], [0, 1]]))       # Small grid with no right triangles\n    print(numberOfRightTriangles([[1, 0], [1, 1]]))       # Small grid with one right triangle\n    print(numberOfRightTriangles([[1, 1], [1, 0]]))       # Small grid with one right triangle\n    print(numberOfRightTriangles([[0, 0], [0, 0]]))       # All zeros\n    print(numberOfRightTriangles([[1, 1], [1, 1]]))       # All ones, maximal triangles\n    print(numberOfRightTriangles([[1, 0, 1], [1, 1, 0]])) # Mixed grid with two right triangles\n    print(numberOfRightTriangles([[0, 1, 0], [1, 1, 0], [0, 0, 0]])) # Mixed grid with at least one triangle\n    print(numberOfRightTriangles([[1, 1, 1], [0, 1, 0], [1, 1, 1]])) # Larger grid with multiple triangles"}
{"source_Lan": "python###maxmiumScore.py", "source_code_str": "def maxmiumScore( cards: List[int], cnt: int) -> int:\n        cards.sort(reverse=True)\n        ans = 0\n        tmp = 0\n        odd = even = -1\n        end = len(cards) - cnt\n        for i in range(cnt):\n            tmp += cards[i]\n            if cards[i] % 2 == 1:\n                odd = cards[i]\n            else:\n                even = cards[i]\n        if tmp % 2 == 0:\n            return tmp\n        for i in range(cnt, len(cards)):\n            if cards[i] % 2 == 1:\n                if even != -1:\n                    ans = max(ans, tmp - even + cards[i])\n            else:\n                if odd != -1:\n                    ans = max(ans, tmp - odd + cards[i])\n\n        return ans", "source_code_block": "", "target_Lan": "cpp###maxmiumScore.cpp", "reference_code": "int maxmiumScore(vector<int>& cards, int cnt) {\n        sort(cards.begin(), cards.end());\n        \n        int ans = 0;\n        int tmp = 0;\n        int odd, even = -1;\n        int end = cards.size() - cnt;\n        for (int i = cards.size() - 1; i >= end; i--) {\n            tmp += cards[i];\n            if (cards[i] & 1) {\n                odd = cards[i];\n            } else {\n                even = cards[i];\n            }\n        }\n\n        if (!(tmp & 1)) {\n            return tmp;\n        }\n\n        for (int i = cards.size() - cnt - 1; i >= 0; i--) {\n            if (cards[i] & 1) {\n                if (even != -1) {\n                    ans = max(ans, tmp - even + cards[i]);\n                }\n            } else {\n                if (odd != -1) {\n                    ans = max(ans, tmp - odd + cards[i]);\n                }\n            }\n        }\n        return ans;\n    }", "target_method_signature": "maxmiumScore", "source_method_signature": "maxmiumScore", "target_allMS": "", "source_allMS": "", "source_import": "from typing import List", "target_import": "#include <iostream>\n#include <vector>\n#include <algorithm> // for sort and max\nusing namespace std;", "commentTag": "", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <algorithm> // for sort and max\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <algorithm>\n// TOFILL\nint main() {\n    vector<int> arr1 = {1, 2, 3, 4, 5};\n    cout << maxmiumScore(arr1, 3) << endl;\n\n    vector<int> arr2 = {2, 4, 6, 8, 10};\n    cout << maxmiumScore(arr2, 5) << endl;\n\n    vector<int> arr3 = {1, 3, 5, 7};\n    cout << maxmiumScore(arr3, 4) << endl;\n\n    vector<int> arr4 = {2, 3, 4, 5};\n    cout << maxmiumScore(arr4, 2) << endl;\n\n    vector<int> arr5 = {-1, -2, -3, -4};\n    cout << maxmiumScore(arr5, 4) << endl;\n\n    vector<int> arr6 = {0, 0, 0, 0};\n    cout << maxmiumScore(arr6, 3) << endl;\n\n    vector<int> arr7 = {};\n    cout << maxmiumScore(arr7, 0) << endl;\n\n    vector<int> arr8 = {7};\n    cout << maxmiumScore(arr8, 1) << endl;\n\n    vector<int> arr9 = {99999999, 88888888, 77777777};\n    cout << maxmiumScore(arr9, 2) << endl;\n\n    vector<int> arr10 = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n    cout << maxmiumScore(arr10, 5) << endl;\n\n    return 0;\n}", "all_input_output_value": "\ninput1: arr=[1, 2, 3, 4, 5], k=3\noutput1: 12\n--------\ninput2: arr=[2, 4, 6, 8, 10], k=5\noutput2: 30\n--------\ninput3: arr=[1, 3, 5, 7], k=4\noutput3: 16\n--------\ninput4: arr=[2, 3, 4, 5], k=2\noutput4: 8\n--------\ninput5: arr=[-1, -2, -3, -4], k=4\noutput5: -10\n--------\ninput6: arr=[0, 0, 0, 0], k=3\noutput6: 0\n--------\ninput7: arr=[], k=0\noutput7: 0\n--------\ninput8: arr=[7], k=1\noutput8: 0\n--------\ninput9: arr=[99999999, 88888888, 77777777], k=2\noutput9: 177777776\n--------\ninput10: arr=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10], k=5\noutput10: 40\n", "input_output_value": ["\ninput1: arr=[1, 2, 3, 4, 5], k=3\noutput1: 12\n", "\ninput2: arr=[2, 4, 6, 8, 10], k=5\noutput2: 30\n", "\ninput3: arr=[1, 3, 5, 7], k=4\noutput3: 16\n"], "TAG": "Success", "source_code_shell": "from typing import List\nfrom typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(maxmiumScore([1, 2, 3, 4, 5], 3))\n    print(maxmiumScore([2, 4, 6, 8, 10], 5))\n    print(maxmiumScore([1, 3, 5, 7], 4))\n    print(maxmiumScore([2, 3, 4, 5], 2))\n    print(maxmiumScore([-1, -2, -3, -4], 4))\n    print(maxmiumScore([0, 0, 0, 0], 3))\n    print(maxmiumScore([], 0))\n    print(maxmiumScore([7], 1))\n    print(maxmiumScore([99999999, 88888888, 77777777], 2))\n    print(maxmiumScore([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 5))"}
{"source_Lan": "python###getSmallestString.py", "source_code_str": "def getSmallestString( s: str, k: int) -> str:\n        ans = list(s)\n        for i, ch in enumerate(s):\n            dis = min(ord(s[i]) - ord('a'), ord('z') - ord(s[i]) + 1)\n            if dis <= k:\n                ans[i] = 'a'\n                k -= dis\n            else:\n                ans[i] = chr(ord(ans[i]) - k)\n                break\n        return \"\".join(ans)", "source_code_block": "", "target_Lan": "cpp###getSmallestString.cpp", "reference_code": "string getSmallestString(string s, int k) {\n        for (int i = 0; i < s.size(); ++i) {\n            int dis = min(s[i] - 'a', 'z' - s[i] + 1);\n            if (dis <= k) {\n                s[i] = 'a';\n                k -= dis;\n            }\n            else {\n                s[i] -= k;\n                break;\n            }\n        }\n        return s;\n    }", "target_method_signature": "getSmallestString", "source_method_signature": "getSmallestString", "target_allMS": "", "source_allMS": "", "source_import": "", "target_import": "#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;", "commentTag": "", "target_code_shell": "#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\n#include <iostream>\n#include <string>\n// TOFILL\nint main() {\n    cout << getSmallestString(\"abcd\", 3) << endl;\n    cout << getSmallestString(\"xyz\", 6) << endl;\n    cout << getSmallestString(\"a\", 1) << endl;\n    cout << getSmallestString(\"\", 5) << endl;\n    cout << getSmallestString(\"abcdefg\", 5) << endl;\n    cout << getSmallestString(\"xyz\", 1) << endl;\n    cout << getSmallestString(\"aaaaa\", 0) << endl;\n    cout << getSmallestString(\"zzz\", 2) << endl;\n    cout << getSmallestString(\"baaa\", 2) << endl;\n    cout << getSmallestString(\"fedcba\", 10) << endl;\n}", "all_input_output_value": "\ninput1: getSmallestString(\"abcd\", 3)\noutput1: \"aaad\"\n--------\ninput2: getSmallestString(\"xyz\", 6)\noutput2: \"aaa\"\n--------\ninput3: getSmallestString(\"a\", 1)\noutput3: \"a\"\n--------\ninput4: getSmallestString(\"\", 5)\noutput4: \"\"\n--------\ninput5: getSmallestString(\"abcdefg\", 5)\noutput5: \"aaabefg\"\n--------\ninput6: getSmallestString(\"xyz\", 1)\noutput6: \"wyz\"\n--------\ninput7: getSmallestString(\"aaaaa\", 0)\noutput7: \"aaaaa\"\n--------\ninput8: getSmallestString(\"zzz\", 2)\noutput8: \"aaz\"\n--------\ninput9: getSmallestString(\"baaa\", 2)\noutput9: \"aaaa\"\n--------\ninput10: getSmallestString(\"fedcba\", 10)\noutput10: \"aaccba\"\n", "input_output_value": ["\ninput1: getSmallestString(\"abcd\", 3)\noutput1: \"aaad\"\n", "\ninput2: getSmallestString(\"xyz\", 6)\noutput2: \"aaa\"\n", "\ninput3: getSmallestString(\"a\", 1)\noutput3: \"a\"\n"], "TAG": "Success", "source_code_shell": "# TOFILL\nif __name__ == \"__main__\":\n    print(getSmallestString(\"abcd\", 3))    # Expected output: \"aabc\"\n    print(getSmallestString(\"xyz\", 6))     # Expected output: \"aaa\"\n    print(getSmallestString(\"a\", 1))       # Expected output: \"a\"\n    print(getSmallestString(\"\", 5))        # Expected output: \"\"\n    print(getSmallestString(\"abcdefg\", 5)) # Expected output: \"aaaaaa\"\n    print(getSmallestString(\"xyz\", 1))     # Expected output: \"xyw\"\n    print(getSmallestString(\"aaaaa\", 0))   # Expected output: \"aaaaa\"\n    print(getSmallestString(\"zzz\", 2))     # Expected output: \"aaz\"\n    print(getSmallestString(\"baaa\", 2))    # Expected output: \"aaaa\"\n    print(getSmallestString(\"fedcba\", 10)) # Expected output: \"aaaaaa\""}
{"source_Lan": "python###findValueOfPartition.py", "source_code_str": "def findValueOfPartition( nums: List[int]) -> int:\n        nums.sort()\n        res = float('inf')\n        for i in range(1, len(nums)):\n            res = min(res, nums[i] - nums[i - 1])\n        return res", "source_code_block": "", "target_Lan": "cpp###findValueOfPartition.cpp", "reference_code": "int findValueOfPartition(vector<int>& nums) {\n        sort(nums.begin(), nums.end());\n        int res = INT_MAX;\n        for (int i = 1; i < nums.size(); i++) {\n            res = min(res, nums[i] - nums[i - 1]);\n        }\n        return res;\n    }", "target_method_signature": "findValueOfPartition", "source_method_signature": "findValueOfPartition", "target_allMS": "", "source_allMS": "", "source_import": "from typing import List\nimport sys", "target_import": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\nusing namespace std;", "commentTag": "", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <limits.h>\n// TOFILL\nint main() {\n    vector<int> input1 = {};\n    vector<int> input2 = {1};\n    vector<int> input3 = {5, 10};\n    vector<int> input4 = {3, 1, 2};\n    vector<int> input5 = {-3, -1, -2};\n    vector<int> input6 = {-5, 0, 5};\n    vector<int> input7 = {1, 1, 2, 2, 2};\n    vector<int> input8 = {1000000000, 999999999};\n    vector<int> input9 = {1, 2, 3, 10, 20};\n    vector<int> input10 = {1000, 500, 5000};\n\n    cout << findValueOfPartition(input1) << endl;\n    cout << findValueOfPartition(input2) << endl;\n    cout << findValueOfPartition(input3) << endl;\n    cout << findValueOfPartition(input4) << endl;\n    cout << findValueOfPartition(input5) << endl;\n    cout << findValueOfPartition(input6) << endl;\n    cout << findValueOfPartition(input7) << endl;\n    cout << findValueOfPartition(input8) << endl;\n    cout << findValueOfPartition(input9) << endl;\n    cout << findValueOfPartition(input10) << endl;\n\n    return 0;\n}", "all_input_output_value": "\ninput1: a=[]\noutput1: inf\n--------\ninput2: a=[1]\noutput2: inf\n--------\ninput3: a=[5, 10]\noutput3: 5\n--------\ninput4: a=[3, 1, 2]\noutput4: 1\n--------\ninput5: a=[-3, -1, -2]\noutput5: 1\n--------\ninput6: a=[-5, 0, 5]\noutput6: 5\n--------\ninput7: a=[1, 1, 2, 2, 2]\noutput7: 0\n--------\ninput8: a=[1000000000, 999999999]\noutput8: 1\n--------\ninput9: a=[1, 2, 3, 10, 20]\noutput9: 1\n--------\ninput10: a=[1000, 500, 5000]\noutput10: 500\n", "input_output_value": ["\ninput1: a=[]\noutput1: inf\n", "\ninput2: a=[1]\noutput2: inf\n", "\ninput3: a=[5, 10]\noutput3: 5\n"], "TAG": "Success", "source_code_shell": "from typing import List\nimport sys\nfrom typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(findValueOfPartition([]))                          # Empty array\n    print(findValueOfPartition([1]))                        # Single element\n    print(findValueOfPartition([5, 10]))                    # Two elements\n    print(findValueOfPartition([3, 1, 2]))                  # Three elements, unsorted\n    print(findValueOfPartition([-3, -1, -2]))               # All negative numbers\n    print(findValueOfPartition([-5, 0, 5]))                 # Mixed negative and positive\n    print(findValueOfPartition([1, 1, 2, 2, 2]))            # Duplicate elements\n    print(findValueOfPartition([1000000000, 999999999]))    # Large integers with minimal difference\n    print(findValueOfPartition([1, 2, 3, 10, 20]))          # General case\n    print(findValueOfPartition([1000, 500, 5000]))          # General case with larger numbers"}
{"source_Lan": "python###maximumSubarraySum.py", "source_code_str": "def maximumSubarraySum( nums: List[int], k: int) -> int:\n    ans = -inf\n    min_s = defaultdict(lambda: inf)\n    s = 0\n    for x in nums:\n        ans = max(ans, s + x - min(min_s[x - k], min_s[x + k]))\n        min_s[x] = min(min_s[x], s)\n        s += x\n    return ans if ans > -inf else 0", "source_code_block": "", "target_Lan": "cpp###maximumSubarraySum.cpp", "reference_code": "    long long maximumSubarraySum(vector<int> nums, int k) {\n        long long ans = LLONG_MIN, sum = 0;\n        unordered_map<int, long long> min_s;\n        for (int x: nums) {\n            auto it = min_s.find(x + k);\n            if (it != min_s.end()) {\n                ans = max(ans, sum + x - it->second);\n            }\n            it = min_s.find(x - k);\n            if (it != min_s.end()) {\n                ans = max(ans, sum + x - it->second);\n            }\n            it = min_s.find(x);\n            if (it == min_s.end() || sum < it->second) {\n                min_s[x] = sum;\n            }\n            sum += x;\n        }\n        return ans == LLONG_MIN ? 0 : ans;\n    }", "target_method_signature": "maximumSubarraySum", "source_method_signature": "maximumSubarraySum", "target_allMS": "    long long maximumSubarraySum(vector<int> nums, int k) {", "source_allMS": "def maximumSubarraySum( nums: List[int], k: int) -> int:", "source_import": "", "target_import": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;", "commentTag": "//", "source_code_shell": "from typing import List\nfrom collections import defaultdict\nfrom math import inf\n# TOFILL\nif __name__ == \"__main__\":\n    print(maximumSubarraySum([], 0))  # Test Input 1\n    print(maximumSubarraySum([10, 5, 1, 6, 9], 5))  # Test Input 2\n    print(maximumSubarraySum([-1, -2, -3, -4, -5], 1))  # Test Input 3\n    print(maximumSubarraySum([0, 0, 0, 0], 0))  # Test Input 4\n    print(maximumSubarraySum([1, 2, 3, 4], 1))  # Test Input 5\n    print(maximumSubarraySum([5, 3, 2, 5], 2))  # Test Input 6\n    print(maximumSubarraySum([-1, 2, 3, -1, 2], 2))  # Test Input 7\n    print(maximumSubarraySum([1, 2, 3, 0, 0], 3))  # Test Input 8\n    print(maximumSubarraySum([1, -1, 1, -1, 1], 1))  # Test Input 9\n    print(maximumSubarraySum([1, 2, 3, -1, -2], 2))  # Test Input 10", "all_input_output_value": "\ninput1: nums=[], k=0\noutput1: 0\n--------\ninput2: nums=[10, 5, 1, 6, 9], k=5\noutput2: 15\n--------\ninput3: nums=[-1, -2, -3, -4, -5], k=1\noutput3: -3\n--------\ninput4: nums=[0, 0, 0, 0], k=0\noutput4: 0\n--------\ninput5: nums=[1, 2, 3, 4], k=1\noutput5: 7\n--------\ninput6: nums=[5, 3, 2, 5], k=2\noutput6: 10\n--------\ninput7: nums=[-1, 2, 3, -1, 2], k=2\noutput7: 0\n--------\ninput8: nums=[1, 2, 3, 0, 0], k=3\noutput8: 3\n--------\ninput9: nums=[1, -1, 1, -1, 1], k=1\noutput9: 0\n--------\ninput10: nums=[1, 2, 3, -1, -2], k=2\noutput10: 6\n", "input_output_value": ["\ninput1: nums=[], k=0\noutput1: 0\n", "\ninput2: nums=[10, 5, 1, 6, 9], k=5\noutput2: 15\n", "\ninput3: nums=[-1, -2, -3, -4, -5], k=1\noutput3: -3\n"], "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <limits.h>\n// TOFILL\nint main() {\n    cout << maximumSubarraySum({}, 0) << endl;\n    cout << maximumSubarraySum({10, 5, 1, 6, 9}, 5) << endl;\n    cout << maximumSubarraySum({-1, -2, -3, -4, -5}, 1) << endl;\n    cout << maximumSubarraySum({0, 0, 0, 0}, 0) << endl;\n    cout << maximumSubarraySum({1, 2, 3, 4}, 1) << endl;\n    cout << maximumSubarraySum({5, 3, 2, 5}, 2) << endl;\n    cout << maximumSubarraySum({-1, 2, 3, -1, 2}, 2) << endl;\n    cout << maximumSubarraySum({1, 2, 3, 0, 0}, 3) << endl;\n    cout << maximumSubarraySum({1, -1, 1, -1, 1}, 1) << endl;\n    cout << maximumSubarraySum({1, 2, 3, -1, -2}, 2) << endl;\n}", "TAG": "Success"}
{"source_Lan": "python###minimumAddedCoins.py", "source_code_str": "def minimumAddedCoins( coins: List[int], target: int) -> int:\n        coins.sort()\n        ans, x = 0, 1\n        length, index = len(coins), 0\n        while x <= target:\n            if index < length and coins[index] <= x:\n                x += coins[index]\n                index += 1\n            else:\n                x <<= 1\n                ans += 1\n        return ans", "source_code_block": "", "target_Lan": "cpp###minimumAddedCoins.cpp", "reference_code": "int minimumAddedCoins(vector<int>& coins, int target) {\n        sort(coins.begin(), coins.end());\n        int ans = 0;\n        int x = 1;\n        int length = coins.size(), index = 0;\n        while (x <= target) {\n            if (index < length && coins[index] <= x) {\n                x += coins[index];\n                index++;\n            } else {\n                x <<= 1;\n                ans++;\n            }\n        }\n        return ans;\n    }", "target_method_signature": "minimumAddedCoins", "source_method_signature": "minimumAddedCoins", "target_allMS": "int minimumAddedCoins(vector<int>& coins, int target) {", "source_allMS": "def minimumAddedCoins( coins: List[int], target: int) -> int:", "source_import": "from typing import List", "target_import": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <algorithm>", "commentTag": "//", "source_code_shell": "from typing import List\nfrom typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    coins = [0, 10, 5, 20, 1, 15, 50, 100, 200, 33]\n    target = 100  # You can change this value to test with different targets\n    print(minimumAddedCoins(coins, target))", "all_input_output_value": "\ninput1: coins=[0, 10, 5, 20, 1, 15, 50, 100, 200, 33], target=100\noutput1: 2\n", "input_output_value": ["\ninput1: coins=[0, 10, 5, 20, 1, 15, 50, 100, 200, 33], target=100\noutput1: 2\n"], "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n// TOFILL\nint main() {\n    vector<int> coins = {0, 10, 5, 20, 1, 15, 50, 100, 200, 33};\n    int target = 100;\n    cout << minimumAddedCoins(coins, target) << endl;\n}", "TAG": "Success"}
{"source_Lan": "python###isAcronym.py", "source_code_str": "def isAcronym( words: List[str], s: str) -> bool:\n        return len(words) == len(s) and all(words[i][0] == s[i] for i in range(len(s)))", "source_code_block": "", "target_Lan": "cpp###isAcronym.cpp", "reference_code": "bool isAcronym(vector<string>& words, string s) {\n        if (s.size() != words.size()) {\n            return false;\n        }\n        for (int i = 0; i < s.size(); i++) {\n            if (words[i][0] != s[i]) {\n                return false;\n            }\n        }\n        return true;\n    }", "target_method_signature": "isAcronym", "source_method_signature": "isAcronym", "target_allMS": "bool isAcronym(vector<string>& words, string s) {", "source_allMS": "def isAcronym( words: List[str], s: str) -> bool:", "source_import": "from typing import List", "target_import": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <string>", "commentTag": "//", "source_code_shell": "from typing import List\nfrom typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(isAcronym([\"hello\", \"world\"], \"hw\"))                          # True\n    print(isAcronym([\"hello\"], \"h\"))                                   # True\n    print(isAcronym([\"one\", \"two\", \"three\"], \"fw\"))                   # False\n    print(isAcronym([\"good\", \"morning\"], \"gm\"))                        # True\n    print(isAcronym([\"this\", \"is\", \"a\", \"test\"], \"ttt\"))              # False\n    print(isAcronym([], \"\"))                                            # True\n    print(isAcronym([\"a\", \"b\", \"c\"], \"abc\"))                           # True\n    print(isAcronym([\"dog\", \"cat\"], \"dc\"))                             # False\n    print(isAcronym([\"multiple\", \"words\", \"here\"], \"mwh\"))            # True\n    print(isAcronym([\"single\"], \"\"))                                   # False", "all_input_output_value": "\ninput1: words=[\"hello\", \"world\"], s=\"hw\"\noutput1: True\n--------\ninput2: words=[\"hello\"], s=\"h\"\noutput2: True\n--------\ninput3: words=[\"one\", \"two\", \"three\"], s=\"fw\"\noutput3: False\n--------\ninput4: words=[\"good\", \"morning\"], s=\"gm\"\noutput4: True\n--------\ninput5: words=[\"this\", \"is\", \"a\", \"test\"], s=\"ttt\"\noutput5: False\n--------\ninput6: words=[], s=\"\"\noutput6: True\n--------\ninput7: words=[\"a\", \"b\", \"c\"], s=\"abc\"\noutput7: True\n--------\ninput8: words=[\"dog\", \"cat\"], s=\"dc\"\noutput8: False\n--------\ninput9: words=[\"multiple\", \"words\", \"here\"], s=\"mwh\"\noutput9: True\n--------\ninput10: words=[\"single\"], s=\"\"\noutput10: False\n", "input_output_value": ["\ninput1: words=[\"hello\", \"world\"], s=\"hw\"\noutput1: True\n", "\ninput2: words=[\"hello\"], s=\"h\"\noutput2: True\n", "\ninput3: words=[\"one\", \"two\", \"three\"], s=\"fw\"\noutput3: False\n"], "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <vector>\n#include <string>\n// TOFILL\nint main() {\n    vector<string> words1 = {\"hello\", \"world\"};\n    cout <<(isAcronym(words1, \"hw\") ? \"true\" : \"false\") << endl;\n\n    vector<string> words2 = {\"hello\"};\n    cout <<(isAcronym(words2, \"h\") ? \"true\" : \"false\") << endl;\n\n    vector<string> words3 = {\"one\", \"two\", \"three\"};\n    cout <<(isAcronym(words3, \"fw\") ? \"true\" : \"false\") << endl;\n\n    vector<string> words4 = {\"good\", \"morning\"};\n    cout <<(isAcronym(words4, \"gm\") ? \"true\" : \"false\") << endl;\n\n    vector<string> words5 = {\"this\", \"is\", \"a\", \"test\"};\n    cout <<(isAcronym(words5, \"ttt\") ? \"true\" : \"false\") << endl;\n\n    vector<string> words6 = {};\n    cout <<(isAcronym(words6, \"\") ? \"true\" : \"false\") << endl;\n\n    vector<string> words7 = {\"a\", \"b\", \"c\"};\n    cout <<(isAcronym(words7, \"abc\") ? \"true\" : \"false\") << endl;\n\n    vector<string> words8 = {\"dog\", \"cat\"};\n    cout <<(isAcronym(words8, \"dc\") ? \"true\" : \"false\") << endl;\n\n    vector<string> words9 = {\"multiple\", \"words\", \"here\"};\n    cout <<(isAcronym(words9, \"mwh\") ? \"true\" : \"false\") << endl;\n\n    vector<string> words10 = {\"single\"};\n    cout <<(isAcronym(words10, \"\") ? \"true\" : \"false\") << endl;\n\n    return 0;\n}", "TAG": "Success"}
{"source_Lan": "python###possibleToStamp.py", "source_code_str": "def possibleToStamp( grid: List[List[int]], stampHeight: int, stampWidth: int) -> bool:\n        m, n = len(grid), len(grid[0])\n        psum = [[0] * (n + 2) for _ in range(m + 2)]\n        diff = [[0] * (n + 2) for _ in range(m + 2)]\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                psum[i][j] = psum[i - 1][j] + psum[i][j - 1] - psum[i - 1][j - 1] + grid[i - 1][j - 1]\n        for i in range(1, m + 2 - stampHeight):\n            for j in range(1, n + 2 - stampWidth):\n                x = i + stampHeight - 1\n                y = j + stampWidth - 1\n                if psum[x][y] - psum[x][j - 1] - psum[i - 1][y] + psum[i - 1][j - 1] == 0:\n                    diff[i][j] += 1\n                    diff[i][y + 1] -= 1\n                    diff[x + 1][j] -= 1\n                    diff[x + 1][y + 1] += 1\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                diff[i][j] += diff[i - 1][j] + diff[i][j - 1] - diff[i - 1][j - 1]\n                if diff[i][j] == 0 and grid[i - 1][j - 1] == 0:\n                    return False\n        return True", "source_code_block": "", "target_Lan": "cpp###possibleToStamp.cpp", "reference_code": "bool possibleToStamp(vector<vector<int>>& grid, int stampHeight, int stampWidth) {\n        int m = grid.size(), n = grid[0].size();\n        vector<vector<int>> sum(m + 2, vector<int>(n + 2, 0));\n        vector<vector<int>> diff(m + 2, vector<int>(n + 2, 0));\n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                sum[i][j] = sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1] + grid[i - 1][j - 1];\n            }\n        }\n        for (int i = 1; i + stampHeight - 1 <= m; i++) {\n            for (int j = 1; j + stampWidth - 1 <= n; j++) {\n                int x = i + stampHeight - 1;\n                int y = j + stampWidth - 1;\n                if (sum[x][y] - sum[x][j - 1] - sum[i - 1][y] + sum[i - 1][j - 1] == 0) {\n                    diff[i][j]++;\n                    diff[i][y + 1]--;\n                    diff[x + 1][j]--;\n                    diff[x + 1][y + 1]++;\n                }\n            }\n        }\n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                diff[i][j] += diff[i - 1][j] + diff[i][j - 1] - diff[i - 1][j - 1];\n                if (diff[i][j] == 0 && grid[i - 1][j - 1] == 0) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }", "target_method_signature": "possibleToStamp", "source_method_signature": "possibleToStamp", "target_allMS": "bool possibleToStamp(vector<vector<int>>& grid, int stampHeight, int stampWidth) {", "source_allMS": "def possibleToStamp( grid: List[List[int]], stampHeight: int, stampWidth: int) -> bool:", "source_import": "from typing import List", "target_import": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>", "commentTag": "//", "source_code_shell": "from typing import List\nfrom typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(possibleToStamp([[0]], 1, 1))\n    print(possibleToStamp([[0, 0], [0, 0]], 2, 2))\n    print(possibleToStamp([[0, 1], [1, 0]], 1, 1))\n    print(possibleToStamp([[0, 0], [1, 1]], 2, 1))\n    print(possibleToStamp([[0, 0, 0]], 1, 3))\n    print(possibleToStamp([[0], [0], [0]], 3, 1))\n    print(possibleToStamp([[1, 1], [1, 1]], 1, 1))\n    print(possibleToStamp([[0, 0, 0], [1, 0, 1]], 2, 2))\n    print(possibleToStamp([[0, 0, 1, 0],[1, 0, 0, 0],[0, 1, 1, 0]], 2, 2))", "all_input_output_value": "\ninput1: grid=[[0]], stampHeight=1, stampWidth=1\noutput1: True\n--------\ninput2: grid=[[0, 0], [0, 0]], stampHeight=2, stampWidth=2\noutput2: True\n--------\ninput3: grid=[[0, 1], [1, 0]], stampHeight=1, stampWidth=1\noutput3: True\n--------\ninput4: grid=[[0, 0], [1, 1]], stampHeight=2, stampWidth=1\noutput4: False\n--------\ninput5: grid=[[0, 0, 0]], stampHeight=1, stampWidth=3\noutput5: True\n--------\ninput6: grid=[[0], [0], [0]], stampHeight=3, stampWidth=1\noutput6: True\n--------\ninput7: grid=[[1, 1], [1, 1]], stampHeight=1, stampWidth=1\noutput7: True\n--------\ninput8: grid=[[0, 0, 0], [1, 0, 1]], stampHeight=2, stampWidth=2\noutput8: False\n--------\ninput9: grid=[[0, 0, 1, 0],[1, 0, 0, 0],[0, 1, 1, 0]], stampHeight=2, stampWidth=2\noutput9: False\n", "input_output_value": ["\ninput1: grid=[[0]], stampHeight=1, stampWidth=1\noutput1: True\n", "\ninput2: grid=[[0, 0], [0, 0]], stampHeight=2, stampWidth=2\noutput2: True\n", "\ninput3: grid=[[0, 1], [1, 0]], stampHeight=1, stampWidth=1\noutput3: True\n"], "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    // Test Input 1\n    vector<vector<int>> grid1 = {{0}};\n    cout << possibleToStamp(grid1, 1, 1) << endl;\n\n    // Test Input 2\n    vector<vector<int>> grid2 = {{0, 0}, {0, 0}};\n    cout << possibleToStamp(grid2, 2, 2) << endl;\n\n    // Test Input 3\n    vector<vector<int>> grid3 = {{0, 1}, {1, 0}};\n    cout << possibleToStamp(grid3, 1, 1) << endl;\n\n    // Test Input 4\n    vector<vector<int>> grid4 = {{0, 0}, {1, 1}};\n    cout << possibleToStamp(grid4, 2, 1) << endl;\n\n    // Test Input 5\n    vector<vector<int>> grid5 = {{0, 0, 0}};\n    cout << possibleToStamp(grid5, 1, 3) << endl;\n\n    // Test Input 6\n    vector<vector<int>> grid6 = {{0}, {0}, {0}};\n    cout << possibleToStamp(grid6, 3, 1) << endl;\n\n    // Test Input 7\n    vector<vector<int>> grid7 = {{1, 1}, {1, 1}};\n    cout << possibleToStamp(grid7, 1, 1) << endl;\n\n    // Test Input 8\n    vector<vector<int>> grid8 = {{0, 0, 0}, {1, 0, 1}};\n    cout << possibleToStamp(grid8, 2, 2) << endl;\n\n    // Test Input 9\n    vector<vector<int>> grid9 = {{0, 0, 1, 0}, {1, 0, 0, 0}, {0, 1, 1, 0}};\n    cout << possibleToStamp(grid9, 2, 2) << endl;\n\n    return 0;\n}", "TAG": "Success"}
{"source_Lan": "python###closeStrings.py", "source_code_str": "def closeStrings( word1: str, word2: str) -> bool:\n        return Counter(word1).keys() == Counter(word2).keys() and sorted(Counter(word1).values()) == sorted(Counter(word2).values())", "source_code_block": "", "target_Lan": "cpp###closeStrings.cpp", "reference_code": "bool closeStrings(string word1, string word2) {\n        vector<int> count1(26), count2(26);\n        for (char c : word1) {\n            count1[c - 'a']++;\n        }\n        for (char c : word2) {\n            count2[c - 'a']++;\n        }\n        for (int i = 0; i < 26; i++) {\n            if (count1[i] > 0 && count2[i] == 0 || count1[i] == 0 && count2[i] > 0) {\n                return false;\n            }\n        }\n        sort(count1.begin(), count1.end());\n        sort(count2.begin(), count2.end());\n        return count1 == count2;\n    }", "target_method_signature": "closeStrings", "source_method_signature": "closeStrings", "target_allMS": "bool closeStrings(string word1, string word2) {", "source_allMS": "def closeStrings( word1: str, word2: str) -> bool:", "source_import": "from collections import Counter", "target_import": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <algorithm>", "commentTag": "//", "source_code_shell": "from collections import Counter\nfrom collections import Counter\n# TOFILL\nif __name__ == \"__main__\":\n    print(closeStrings(\"abc\", \"cab\"))        # Should return true: same characters, can rearrange\n    print(closeStrings(\"abc\", \"def\"))        # Should return false: different characters\n    print(closeStrings(\"aabbcc\", \"abcabc\"))  # Should return true: same characters with same counts\n    print(closeStrings(\"aabb\", \"abab\"))      # Should return true: same characters with same counts\n    print(closeStrings(\"abc\", \"abcd\"))       # Should return false: unequal length\n    print(closeStrings(\"abcd\", \"abca\"))      # Should return false: unequal character set\n    print(closeStrings(\"a\", \"a\"))            # Should return true: identical single characters\n    print(closeStrings(\"\", \"\"))               # Should return true: both are empty\n    print(closeStrings(\"abc\", \"cba\"))        # Should return true: same characters, can rearrange\n    print(closeStrings(\"abc\", \"aabb\"))       # Should return false: different character counts", "all_input_output_value": "\ninput1: word1=\"abc\", word2=\"cab\"\noutput1: True\n--------\ninput2: word1=\"abc\", word2=\"def\"\noutput2: False\n--------\ninput3: word1=\"aabbcc\", word2=\"abcabc\"\noutput3: True\n--------\ninput4: word1=\"aabb\", word2=\"abab\"\noutput4: True\n--------\ninput5: word1=\"abc\", word2=\"abcd\"\noutput5: False\n--------\ninput6: word1=\"abcd\", word2=\"abca\"\noutput6: False\n--------\ninput7: word1=\"a\", word2=\"a\"\noutput7: True\n--------\ninput8: word1=\"\", word2=\"\"\noutput8: True\n--------\ninput9: word1=\"abc\", word2=\"cba\"\noutput9: True\n--------\ninput10: word1=\"abc\", word2=\"aabb\"\noutput10: False\n", "input_output_value": ["\ninput1: word1=\"abc\", word2=\"cab\"\noutput1: True\n", "\ninput2: word1=\"abc\", word2=\"def\"\noutput2: False\n", "\ninput3: word1=\"aabbcc\", word2=\"abcabc\"\noutput3: True\n"], "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n// TOFILL\nint main() {\n    cout << closeStrings(\"abc\", \"cab\") << endl; // 1(true)\n    cout << closeStrings(\"abc\", \"def\") << endl; // 0(false)\n    cout << closeStrings(\"aabbcc\", \"abcabc\") << endl; // 1(true)\n    cout << closeStrings(\"aabb\", \"abab\") << endl; // 1(true)\n    cout << closeStrings(\"abc\", \"abcd\") << endl; // 0(false)\n    cout << closeStrings(\"abcd\", \"abca\") << endl; // 0(false)\n    cout << closeStrings(\"a\", \"a\") << endl; // 1(true)\n    cout << closeStrings(\"\", \"\") << endl; // 1(true)\n    cout << closeStrings(\"abc\", \"cba\") << endl; // 1(true)\n    cout << closeStrings(\"abc\", \"aabb\") << endl; // 0(false)\n}", "TAG": "Success"}
{"source_Lan": "python###maximizeSum.py", "source_code_str": "def maximizeSum( nums: List[int], k: int) -> int:\n        return (2 * max(nums) + k - 1) * k // 2", "source_code_block": "", "target_Lan": "cpp###maximizeSum.cpp", "reference_code": "int maximizeSum(vector<int>& nums, int k) {\n        int m = *max_element(nums.begin(), nums.end());\n        return (2 * m + k - 1) * k / 2;\n    }", "target_method_signature": "maximizeSum", "source_method_signature": "maximizeSum", "target_allMS": "int maximizeSum(vector<int>& nums, int k) {", "source_allMS": "def maximizeSum( nums: List[int], k: int) -> int:", "source_import": "from typing import List", "target_import": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;", "commentTag": "//", "source_code_shell": "from typing import List\nfrom typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(maximizeSum([1, 10, 5, 3, 0], 10))        # Test case 1\n    print(maximizeSum([2, 1, 100, 99, -1], 1))      # Test case 2\n    print(maximizeSum([5, -1, 2], 0))                # Test case 4\n    print(maximizeSum([0, 0, 0], 3))                 # Test case 5\n    print(maximizeSum([-10, -1, -5], 4))             # Test case 6\n    print(maximizeSum([100, 200, 300], 3))           # Test case 7\n    print(maximizeSum([1, 2, 3, 4, 5], 10000))      # Test case 8\n    print(maximizeSum([10, 20, 30], -5))             # Test case 9\n    print(maximizeSum([10, 20, 30], 0))              # Test case 10", "all_input_output_value": "\ninput1: nums=[1, 10, 5, 3, 0], k=10\noutput1: 145\n--------\ninput2: nums=[2, 1, 100, 99, -1], k=1\noutput2: 100\n--------\ninput3: nums=[5, -1, 2], k=0\noutput3: 0\n--------\ninput4: nums=[0, 0, 0], k=3\noutput4: 3\n--------\ninput5: nums=[-10, -1, -5], k=4\noutput5: 2\n--------\ninput6: nums=[100, 200, 300], k=3\noutput6: 903\n--------\ninput7: nums=[1, 2, 3, 4, 5], k=10000\noutput7: 50045000\n--------\ninput8: nums=[10, 20, 30], k=-5\noutput8: -135\n--------\ninput9: nums=[10, 20, 30], k=0\noutput9: 0\n", "input_output_value": ["\ninput1: nums=[1, 10, 5, 3, 0], k=10\noutput1: 145\n", "\ninput2: nums=[2, 1, 100, 99, -1], k=1\noutput2: 100\n", "\ninput3: nums=[5, -1, 2], k=0\noutput3: 0\n"], "target_code_shell": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <algorithm>\n// TOFILL\nint main() {\n    vector<int> nums1 = {1, 10, 5, 3, 0};\n    int k1 = 10;\n    cout << maximizeSum(nums1, k1) << endl;\n\n    vector<int> nums2 = {2, 1, 100, 99, -1};\n    int k2 = 1;\n    cout << maximizeSum(nums2, k2) << endl;\n\n    vector<int> nums3 = {5, -1, 2};\n    int k3 = 0;\n    cout << maximizeSum(nums3, k3) << endl;\n\n    vector<int> nums4 = {0, 0, 0};\n    int k4 = 3;\n    cout << maximizeSum(nums4, k4) << endl;\n\n    vector<int> nums5 = {-10, -1, -5};\n    int k5 = 4;\n    cout << maximizeSum(nums5, k5) << endl;\n\n    vector<int> nums6 = {100, 200, 300};\n    int k6 = 3;\n    cout << maximizeSum(nums6, k6) << endl;\n\n    vector<int> nums7 = {1, 2, 3, 4, 5};\n    int k7 = 10000;\n    cout << maximizeSum(nums7, k7) << endl;\n\n    vector<int> nums8 = {10, 20, 30};\n    int k8 = -5;\n    cout << maximizeSum(nums8, k8) << endl;\n\n    vector<int> nums9 = {10, 20, 30};\n    int k9 = 0;\n    cout << maximizeSum(nums9, k9) << endl;\n}", "TAG": "Success"}
{"source_Lan": "python###longestAlternatingSubarray.py", "source_code_str": "def longestAlternatingSubarray( nums: List[int], threshold: int) -> int:\n        res, dp = 0, 0\n        for l in range(len(nums) - 1, -1, -1):\n            if nums[l] > threshold:\n                dp = 0\n            elif l == len(nums) - 1 or nums[l] % 2 != nums[l + 1] % 2:\n                dp = dp + 1\n            else:\n                dp = 1\n            res = dp if nums[l] % 2 == 0 and dp > res else res\n        return res", "source_code_block": "", "target_Lan": "cpp###longestAlternatingSubarray.cpp", "reference_code": "int longestAlternatingSubarray(vector<int>& nums, int threshold) {\n        int res = 0, dp = 0, n = nums.size();\n        for (int l = n - 1; l >= 0; l--) {\n            if (nums[l] > threshold) {\n                dp = 0;\n            } else if (l == n - 1 || nums[l] % 2 != nums[l + 1] % 2) {\n                dp++;\n            } else {\n                dp = 1;\n            }\n            if (nums[l] % 2 == 0) {\n                res = max(res, dp);\n            }\n        }\n        return res;\n    }", "target_method_signature": "longestAlternatingSubarray", "source_method_signature": "longestAlternatingSubarray", "target_allMS": "int longestAlternatingSubarray(vector<int>& nums, int threshold) {", "source_allMS": "def longestAlternatingSubarray( nums: List[int], threshold: int) -> int:", "source_import": "from typing import List", "target_import": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>", "commentTag": "//", "source_code_shell": "from typing import List\nfrom typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    inputs = [\n        ([1, 5, 3, 4, 2, 1, 7, 8, 10, 0], 10),\n        ([1, 2, 3, 4, 5, 6, 7, 8, 9, 30], 15),\n        ([1, 3, 5, 7, 9], 5),\n        ([2, 4, 6, 8, 10], 10),\n        ([5, 2, 7, 4, 9], 4),\n        ([1, 6, 3], 6),\n        ([10], 10),\n        ([15], 15),\n        ([2, 3, 2, 5], 5)\n    ]\n    for nums, threshold in inputs:\n        print(longestAlternatingSubarray(nums, threshold))", "all_input_output_value": "\ninput1: nums=[1, 5, 3, 4, 2, 1, 7, 8, 10, 0], threshold=10\noutput1: 2\n--------\ninput2: nums=[1, 2, 3, 4, 5, 6, 7, 8, 9, 30], threshold=15\noutput2: 8\n--------\ninput3: nums=[1, 3, 5, 7, 9], threshold=5\noutput3: 0\n--------\ninput4: nums=[2, 4, 6, 8, 10], threshold=10\noutput4: 1\n--------\ninput5: nums=[5, 2, 7, 4, 9], threshold=4\noutput5: 1\n--------\ninput6: nums=[1, 6, 3], threshold=6\noutput6: 2\n--------\ninput7: nums=[10], threshold=10\noutput7: 1\n--------\ninput8: nums=[15], threshold=15\noutput8: 0\n--------\ninput9: nums=[2, 3, 2, 5], threshold=5\noutput9: 4\n", "input_output_value": ["\ninput1: nums=[1, 5, 3, 4, 2, 1, 7, 8, 10, 0], threshold=10\noutput1: 2\n", "\ninput2: nums=[1, 2, 3, 4, 5, 6, 7, 8, 9, 30], threshold=15\noutput2: 8\n", "\ninput3: nums=[1, 3, 5, 7, 9], threshold=5\noutput3: 0\n"], "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    vector<int> input1 = {1, 5, 3, 4, 2, 1, 7, 8, 10, 0};\n    cout << longestAlternatingSubarray(input1, 10) << endl;\n\n    vector<int> input2 = {1, 2, 3, 4, 5, 6, 7, 8, 9, 30};\n    cout << longestAlternatingSubarray(input2, 15) << endl;\n\n    vector<int> input3 = {1, 3, 5, 7, 9};\n    cout << longestAlternatingSubarray(input3, 5) << endl;\n\n    vector<int> input4 = {2, 4, 6, 8, 10};\n    cout << longestAlternatingSubarray(input4, 10) << endl;\n\n    vector<int> input5 = {5, 2, 7, 4, 9};\n    cout << longestAlternatingSubarray(input5, 4) << endl;\n\n    vector<int> input6 = {1, 6, 3};\n    cout << longestAlternatingSubarray(input6, 6) << endl;\n\n    vector<int> input7 = {10};\n    cout << longestAlternatingSubarray(input7, 10) << endl;\n\n    vector<int> input8 = {15};\n    cout << longestAlternatingSubarray(input8, 15) << endl;\n\n    vector<int> input9 = {2, 3, 2, 5};\n    cout << longestAlternatingSubarray(input9, 5) << endl;\n\n    return 0;\n}", "TAG": "Success"}
{"source_Lan": "python###findTheLongestBalancedSubstring.py", "source_code_str": "def findTheLongestBalancedSubstring( s: str) -> int:\n        res = 0\n        n = len(s)\n        count = [0, 0]\n        for i in range(n):\n            if s[i] == '1':\n                count[1] += 1\n                res = max(res, 2 * min(count))\n            elif i == 0 or s[i-1] == '1':\n                count[0] = 1\n                count[1] = 0\n            else:\n                count[0] += 1\n        return res", "source_code_block": "", "target_Lan": "cpp###findTheLongestBalancedSubstring.cpp", "reference_code": "int findTheLongestBalancedSubstring(string s) {\n        int res = 0, n = s.size();\n        vector<int> count(2);\n        for (int i = 0; i < n; i++) {\n            if (s[i] == '1') {\n                count[1]++;\n                res = max(res, 2 * min(count[0], count[1]));\n            } else if (i == 0 || s[i - 1] == '1') {\n                count[0] = 1;\n                count[1] = 0;\n            } else {\n                count[0]++;\n            }\n        }\n        return res;            \n    }", "target_method_signature": "findTheLongestBalancedSubstring", "source_method_signature": "findTheLongestBalancedSubstring", "target_allMS": "int findTheLongestBalancedSubstring(string s) {", "source_allMS": "def findTheLongestBalancedSubstring( s: str) -> int:", "source_import": "", "target_import": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <string>", "commentTag": "//", "source_code_shell": "# TOFILL\nif __name__ == \"__main__\":\n    test_inputs = [\n        \"\",         # Test empty string\n        \"0000\",    # All zeros\n        \"1111\",    # All ones\n        \"0101\",    # Balanced string\n        \"0011\",    # Balanced string\n        \"1100\",    # Unbalanced but ends in a balanced pair\n        \"000111\",  # Balanced string\n        \"110011\",  # Balanced chunk in the middle\n        \"1001\",    # Balanced but has zeros leading\n        \"101010\"   # Alternating sequence (multiple balanced chunks)\n    ]\n    for test_input in test_inputs:\n        print(findTheLongestBalancedSubstring(test_input))", "all_input_output_value": "\ninput1: s=\"\"\noutput1: 0\n--------\ninput2: s=\"0000\"\noutput2: 0\n--------\ninput3: s=\"1111\"\noutput3: 0\n--------\ninput4: s=\"0101\"\noutput4: 2\n--------\ninput5: s=\"0011\"\noutput5: 4\n--------\ninput6: s=\"1100\"\noutput6: 0\n--------\ninput7: s=\"000111\"\noutput7: 6\n--------\ninput8: s=\"110011\"\noutput8: 4\n--------\ninput9: s=\"1001\"\noutput9: 2\n--------\ninput10: s=\"101010\"\noutput10: 2\n", "input_output_value": ["\ninput1: s=\"\"\noutput1: 0\n", "\ninput2: s=\"0000\"\noutput2: 0\n", "\ninput3: s=\"1111\"\noutput3: 0\n"], "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <vector>\n#include <string>\n// TOFILL\nint main() {\n    cout << findTheLongestBalancedSubstring(\"\") << endl;\n    cout << findTheLongestBalancedSubstring(\"0000\") << endl;\n    cout << findTheLongestBalancedSubstring(\"1111\") << endl;\n    cout << findTheLongestBalancedSubstring(\"0101\") << endl;\n    cout << findTheLongestBalancedSubstring(\"0011\") << endl;\n    cout << findTheLongestBalancedSubstring(\"1100\") << endl;\n    cout << findTheLongestBalancedSubstring(\"000111\") << endl;\n    cout << findTheLongestBalancedSubstring(\"110011\") << endl;\n    cout << findTheLongestBalancedSubstring(\"1001\") << endl;\n    cout << findTheLongestBalancedSubstring(\"101010\") << endl;\n}", "TAG": "Success"}
{"source_Lan": "python###vowelStrings.py", "source_code_str": "def vowelStrings( words: List[str], left: int, right: int) -> int:\n        vowels = set(\"aeiou\")\n        ans = 0\n        for i in range(left, right + 1):\n            word = words[i]\n            if word[0] in vowels and word[-1] in vowels:\n                ans += 1\n        return ans", "source_code_block": "", "target_Lan": "cpp###vowelStrings.cpp", "reference_code": "int vowelStrings(vector<string>& words, int left, int right) {\n        unordered_set<char> vowels = {'a', 'e', 'i', 'o', 'u'};\n        int ans = 0;\n        for (int i = left; i <= right; ++i) {\n            const string& word = words[i];\n            if (vowels.count(word[0]) && vowels.count(word.back())) {\n                ++ans;\n            }\n        }\n        return ans;\n    }", "target_method_signature": "vowelStrings", "source_method_signature": "vowelStrings", "target_allMS": "int vowelStrings(vector<string>& words, int left, int right) {", "source_allMS": "def vowelStrings( words: List[str], left: int, right: int) -> int:", "source_import": "from typing import List", "target_import": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <unordered_set>", "commentTag": "//", "source_code_shell": "from typing import List\nfrom typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(vowelStrings([\"apple\", \"banana\", \"orange\", \"pear\"], 0, 3))\n    print(vowelStrings([\"cherry\", \"banana\", \"kiwi\"], 0, 2))\n    print(vowelStrings([\"a\", \"b\", \"c\", \"d\", \"e\"], 0, 4))\n    print(vowelStrings([\"apple\", \"banana\", \"kiwi\", \"egg\"], 2, 3))\n    print(vowelStrings([\"is\", \"an\", \"input\", \"output\"], 0, 3))\n    print(vowelStrings([\"umbrella\", \"tree\", \"rain\", \"cloud\"], 1, 1))\n    print(vowelStrings([\"x\", \"y\", \"z\"], 0, 2))\n    print(vowelStrings([\"oat\", \"nut\", \"ure\"], 0, 2))", "all_input_output_value": "\ninput1: words=[\"apple\", \"banana\", \"orange\", \"pear\"], left=0, right=3\noutput1: 2\n--------\ninput2: words=[\"cherry\", \"banana\", \"kiwi\"], left=0, right=2\noutput2: 0\n--------\ninput3: words=[\"a\", \"b\", \"c\", \"d\", \"e\"], left=0, right=4\noutput3: 2\n--------\ninput4: words=[\"apple\", \"banana\", \"kiwi\", \"egg\"], left=2, right=3\noutput4: 0\n--------\ninput5: words=[\"is\", \"an\", \"input\", \"output\"], left=0, right=3\noutput5: 0\n--------\ninput6: words=[\"umbrella\", \"tree\", \"rain\", \"cloud\"], left=1, right=1\noutput6: 0\n--------\ninput7: words=[\"x\", \"y\", \"z\"], left=0, right=2\noutput7: 0\n--------\ninput8: words=[\"oat\", \"nut\", \"ure\"], left=0, right=2\noutput8: 1\n", "input_output_value": ["\ninput1: words=[\"apple\", \"banana\", \"orange\", \"pear\"], left=0, right=3\noutput1: 2\n", "\ninput2: words=[\"cherry\", \"banana\", \"kiwi\"], left=0, right=2\noutput2: 0\n", "\ninput3: words=[\"a\", \"b\", \"c\", \"d\", \"e\"], left=0, right=4\noutput3: 2\n"], "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <unordered_set>\n#include <iostream>\n#include <vector>\n#include <unordered_set>\n// TOFILL\nint main() {\n    vector<string> words1 = {\"apple\", \"banana\", \"orange\", \"pear\"};\n    cout << vowelStrings(words1, 0, 3) << endl;\n    \n    vector<string> words2 = {\"cherry\", \"banana\", \"kiwi\"};\n    cout << vowelStrings(words2, 0, 2) << endl;\n    \n    vector<string> words3 = {\"a\", \"b\", \"c\", \"d\", \"e\"};\n    cout << vowelStrings(words3, 0, 4) << endl;\n    \n    vector<string> words4 = {\"apple\", \"banana\", \"kiwi\", \"egg\"};\n    cout << vowelStrings(words4, 2, 3) << endl;\n    \n    vector<string> words5 = {\"is\", \"an\", \"input\", \"output\"};\n    cout << vowelStrings(words5, 0, 3) << endl;\n    \n    vector<string> words6 = {\"umbrella\", \"tree\", \"rain\", \"cloud\"};\n    cout << vowelStrings(words6, 1, 1) << endl;\n    \n    vector<string> words7 = {\"x\", \"y\", \"z\"};\n    cout << vowelStrings(words7, 0, 2) << endl;\n    \n    vector<string> words8 = {\"oat\", \"nut\", \"ure\"};\n    cout << vowelStrings(words8, 0, 2) << endl;\n\n    return 0;\n}", "TAG": "Success"}
{"source_Lan": "python###categorizeBox.py", "source_code_str": "def categorizeBox( length, width, height, mass):\n        maxd = max(length, width, height)\n        vol = length * width * height\n        isBulky = maxd >= 10000 or vol >= 10**9\n        isHeavy = mass >= 100\n        if isBulky and isHeavy:\n            return 'Both'\n        if isBulky:\n            return 'Bulky'\n        if isHeavy:\n            return 'Heavy'\n        return 'Neither'", "source_code_block": "", "target_Lan": "cpp###categorizeBox.cpp", "reference_code": "string categorizeBox(int length, int width, int height, int mass) {\n        long long maxd = max(length, max(width, height)), vol = 1L * length * width * height;\n        bool isBulky = maxd >= 10000 || vol >= 1000000000, isHeavy = mass >= 100;\n        if (isBulky && isHeavy) {\n             return \"Both\";\n        } else if (isBulky) {\n            return \"Bulky\";\n        } else if (isHeavy) {\n            return \"Heavy\";\n        } else {\n            return \"Neither\";\n        }\n    }", "target_method_signature": "categorizeBox", "source_method_signature": "categorizeBox", "target_allMS": "string categorizeBox(int length, int width, int height, int mass) {", "source_allMS": "def categorizeBox( length, width, height, mass):", "source_import": "", "target_import": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <string>", "commentTag": "//", "source_code_shell": "# TOFILL\nif __name__ == \"__main__\":\n    print(categorizeBox(10000, 10000, 10000, 101))  # Both\n    print(categorizeBox(10000, 100, 100, 50))       # Bulky\n    print(categorizeBox(1, 1, 1, 150))               # Heavy\n    print(categorizeBox(1, 1, 1, 50))                # Neither\n    print(categorizeBox(9999, 9999, 9999, 100))     # Neither\n    print(categorizeBox(100, 100, 100, 99))          # Neither\n    print(categorizeBox(10000, 1, 1, 100))           # Bulky\n    print(categorizeBox(1, 1, 1, 100))                # Heavy\n    print(categorizeBox(10001, 10001, 10001, 150))   # Both\n    print(categorizeBox(100, 100, 100, 101))          # Heavy", "all_input_output_value": "\ninput1: length=10000, width=10000, height=10000, mass=101\noutput1: Both\n--------\ninput2: length=10000, width=100, height=100, mass=50\noutput2: Bulky\n--------\ninput3: length=1, width=1, height=1, mass=150\noutput3: Heavy\n--------\ninput4: length=1, width=1, height=1, mass=50\noutput4: Neither\n--------\ninput5: length=9999, width=9999, height=9999, mass=100\noutput5: Both\n--------\ninput6: length=100, width=100, height=100, mass=99\noutput6: Neither\n--------\ninput7: length=10000, width=1, height=1, mass=100\noutput7: Bulky\n--------\ninput8: length=1, width=1, height=1, mass=100\noutput8: Heavy\n--------\ninput9: length=10001, width=10001, height=10001, mass=150\noutput9: Both\n--------\ninput10: length=100, width=100, height=100, mass=101\noutput10: Heavy\n", "input_output_value": ["\ninput1: length=10000, width=10000, height=10000, mass=101\noutput1: Both\n", "\ninput2: length=10000, width=100, height=100, mass=50\noutput2: Bulky\n", "\ninput3: length=1, width=1, height=1, mass=150\noutput3: Heavy\n"], "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <string>\n#include <iostream>\n#include <string>\n// TOFILL\nint main() {\n    cout << categorizeBox(10000, 10000, 10000, 101) << endl;\n    cout << categorizeBox(10000, 100, 100, 50) << endl;\n    cout << categorizeBox(1, 1, 1, 150) << endl;\n    cout << categorizeBox(1, 1, 1, 50) << endl;\n    cout << categorizeBox(9999, 9999, 9999, 100) << endl;\n    cout << categorizeBox(100, 100, 100, 99) << endl;\n    cout << categorizeBox(10000, 1, 1, 100) << endl;\n    cout << categorizeBox(1, 1, 1, 100) << endl;\n    cout << categorizeBox(10001, 10001, 10001, 150) << endl;\n    cout << categorizeBox(100, 100, 100, 101) << endl;\n}", "TAG": "Success"}
{"source_Lan": "python###maxKelements.py", "source_code_str": "def maxKelements(nums: List[int], k: int) -> int:\n    q = [-x for x in nums]\n    heapify(q)\n    ans = 0\n    for _ in range(k):\n        x = heappop(q)\n        ans += -x\n        heappush(q, -((-x + 2) // 3))\n    return ans\n", "source_code_block": "", "target_Lan": "cpp###maxKelements.cpp", "reference_code": "long long maxKelements(vector<int>& nums, int k) {\n        priority_queue<int> q(nums.begin(), nums.end());\n        long long ans = 0;\n        for (int _ = 0; _ < k; ++_) {\n            int x = q.top();\n            q.pop();\n            ans += x;\n            q.push((x + 2) / 3);\n        }\n        return ans;\n    }", "target_method_signature": "maxKelements", "source_method_signature": "maxKelements", "target_allMS": "long long maxKelements(vector<int>& nums, int k) {", "source_allMS": "def maxKelements( nums: List[int], k: int) -> int:", "source_import": "from typing import List\nfrom heapq import heappop, heappush, heapify", "target_import": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <queue>", "commentTag": "//", "source_code_shell": "from typing import List\nfrom heapq import heappop, heappush, heapify\nfrom typing import List\nfrom heapq import heapify, heappop, heappush\n# TOFILL\nif __name__ == \"__main__\":\n    print(maxKelements([1, 3, 3, 5, 2], 3))  # Test case with distinct positive numbers and k < size of nums\n    print(maxKelements([1, 1, 1, 1, 1], 5))  # Test case with all elements the same\n    print(maxKelements([5, 2, 1, 9, 4], 2))  # Large numbers where k < size of nums\n    print(maxKelements([-1, -2, -3, -4, -5], 3))  # Test case with negative numbers and k values\n    print(maxKelements([10, 100, 2, 3, 5], 5))  # Large k compared to nums size\n    print(maxKelements([0, 0, 0, 0], 5))  # Test case with zeroes and k = 5\n    print(maxKelements([6, 5, 4, 3, 2], 2))  # All descending elements\n    print(maxKelements([7, 1, 8, 2, 9, 10], 1))  # Some large numbers, 1 for k to pick the max\n    print(maxKelements([10, 10, 10, 10, 10], 5))  # All the same large numbers with k equal to size\n    print(maxKelements([2, 2, 2, 1, 0], 3))  # Use of minimum positive and zero elements", "all_input_output_value": "\ninput1: nums=[1, 3, 3, 5, 2], k=3\noutput1: 11\n--------\ninput2: nums=[1, 1, 1, 1, 1], k=5\noutput2: 5\n--------\ninput3: nums=[5, 2, 1, 9, 4], k=2\noutput3: 14\n--------\ninput4: nums=[-1, -2, -3, -4, -5], k=3\noutput4: -1\n--------\ninput5: nums=[10, 100, 2, 3, 5], k=5\noutput5: 161\n--------\ninput6: nums=[0, 0, 0, 0], k=5\noutput6: 0\n--------\ninput7: nums=[6, 5, 4, 3, 2], k=2\noutput7: 11\n--------\ninput8: nums=[7, 1, 8, 2, 9, 10], k=1\noutput8: 10\n--------\ninput9: nums=[10, 10, 10, 10, 10], k=5\noutput9: 50\n--------\ninput10: nums=[2, 2, 2, 1, 0], k=3\noutput10: 6\n", "input_output_value": ["\ninput1: nums=[1, 3, 3, 5, 2], k=3\noutput1: 11\n", "\ninput2: nums=[1, 1, 1, 1, 1], k=5\noutput2: 5\n", "\ninput3: nums=[5, 2, 1, 9, 4], k=2\noutput3: 14\n"], "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <iostream>\n#include <vector>\n#include <queue>\n// TOFILL\nint main() {\n    vector<int> nums1 = {1, 3, 3, 5, 2};\n    int k1 = 3;\n    cout << maxKelements(nums1, k1) << endl;\n\n    vector<int> nums2 = {1, 1, 1, 1, 1};\n    int k2 = 5;\n    cout << maxKelements(nums2, k2) << endl;\n\n    vector<int> nums3 = {5, 2, 1, 9, 4};\n    int k3 = 2;\n    cout << maxKelements(nums3, k3) << endl;\n\n    vector<int> nums4 = {-1, -2, -3, -4, -5};\n    int k4 = 3;\n    cout << maxKelements(nums4, k4) << endl;\n\n    vector<int> nums5 = {10, 100, 2, 3, 5};\n    int k5 = 5;\n    cout << maxKelements(nums5, k5) << endl;\n\n    vector<int> nums6 = {0, 0, 0, 0};\n    int k6 = 5;\n    cout << maxKelements(nums6, k6) << endl;\n\n    vector<int> nums7 = {6, 5, 4, 3, 2};\n    int k7 = 2;\n    cout << maxKelements(nums7, k7) << endl;\n\n    vector<int> nums8 = {7, 1, 8, 2, 9, 10};\n    int k8 = 1;\n    cout << maxKelements(nums8, k8) << endl;\n\n    vector<int> nums9 = {10, 10, 10, 10, 10};\n    int k9 = 5;\n    cout << maxKelements(nums9, k9) << endl;\n\n    vector<int> nums10 = {2, 2, 2, 1, 0};\n    int k10 = 3;\n    cout << maxKelements(nums10, k10) << endl;\n\n    return 0;\n}", "TAG": "Success"}
{"source_Lan": "python###minimumOneBitOperations.py", "source_code_str": "def minimumOneBitOperations( n: int) -> int:\n        ans = 0\n        sign = 1\n        for i in range(29, -1, -1):\n            if n & (1 << i):\n                ans += sign * ((1 << (i + 1)) - 1)\n                sign = -sign\n        return ans", "source_code_block": "", "target_Lan": "cpp###minimumOneBitOperations.cpp", "reference_code": "int minimumOneBitOperations(int n) {\n        int ans = 0;\n        int sign = 1;\n        for (int i = 29; i >= 0; --i) {\n            if (n & (1 << i)) {\n                ans += sign * ((1 << (i + 1)) - 1);\n                sign = -sign;\n            }\n        }\n        return ans;\n    }", "target_method_signature": "minimumOneBitOperations", "source_method_signature": "minimumOneBitOperations", "target_allMS": "int minimumOneBitOperations(int n) {", "source_allMS": "def minimumOneBitOperations( n: int) -> int:", "source_import": "", "target_import": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>", "commentTag": "//", "source_code_shell": "# TOFILL\nif __name__ == \"__main__\":\n    print(minimumOneBitOperations(0))\n    print(minimumOneBitOperations(1))\n    print(minimumOneBitOperations(2))\n    print(minimumOneBitOperations(3))\n    print(minimumOneBitOperations(5))\n    print(minimumOneBitOperations(8))\n    print(minimumOneBitOperations(15))\n    print(minimumOneBitOperations(16))\n    print(minimumOneBitOperations(31))\n    print(minimumOneBitOperations(1023))", "all_input_output_value": "\ninput1: n=0\noutput1: 0\n--------\ninput2: n=1\noutput2: 1\n--------\ninput3: n=2\noutput3: 3\n--------\ninput4: n=3\noutput4: 2\n--------\ninput5: n=5\noutput5: 6\n--------\ninput6: n=8\noutput6: 15\n--------\ninput7: n=15\noutput7: 10\n--------\ninput8: n=16\noutput8: 31\n--------\ninput9: n=31\noutput9: 21\n--------\ninput10: n=1023\noutput10: 682\n", "input_output_value": ["\ninput1: n=0\noutput1: 0\n", "\ninput2: n=1\noutput2: 1\n", "\ninput3: n=2\noutput3: 3\n"], "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <iostream>\n// TOFILL\nint main() {\n    cout << minimumOneBitOperations(0) << endl;\n    cout << minimumOneBitOperations(1) << endl;\n    cout << minimumOneBitOperations(2) << endl;\n    cout << minimumOneBitOperations(3) << endl;\n    cout << minimumOneBitOperations(5) << endl;\n    cout << minimumOneBitOperations(8) << endl;\n    cout << minimumOneBitOperations(15) << endl;\n    cout << minimumOneBitOperations(16) << endl;\n    cout << minimumOneBitOperations(31) << endl;\n    cout << minimumOneBitOperations(1023) << endl;\n}", "TAG": "Success"}
{"source_Lan": "python###tupleSameProduct.py", "source_code_str": "def tupleSameProduct( nums: List[int]) -> int:\n        n = len(nums)\n        cnt = Counter([nums[i] * nums[j] for i in range(n) for j in range(i + 1, n)])\n        ans = 0\n        for _, v in cnt.items():\n            ans += v * (v - 1) * 4\n        return ans", "source_code_block": "", "target_Lan": "cpp###tupleSameProduct.cpp", "reference_code": "int tupleSameProduct(vector<int>& nums) {\n        int n = nums.size();\n        int ans = 0;\n        unordered_map<int, int> cnt;\n        for (int i = 0; i < n; i++) {\n            for(int j = i + 1; j < n; j++) {\n                cnt[nums[i] * nums[j]]++;\n            }\n        }\n        for (auto &[k, v] : cnt) {\n            ans += v * (v - 1) * 4;\n        }\n        return ans;\n    }", "target_method_signature": "tupleSameProduct", "source_method_signature": "tupleSameProduct", "target_allMS": "int tupleSameProduct(vector<int>& nums) {", "source_allMS": "def tupleSameProduct( nums: List[int]) -> int:", "source_import": "from typing import List\nfrom collections import Counter", "target_import": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <unordered_map>", "commentTag": "//", "source_code_shell": "from typing import List\nfrom collections import Counter\nfrom collections import Counter\nfrom typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(tupleSameProduct([])) \n    print(tupleSameProduct([1])) \n    print(tupleSameProduct([1, 2, 3])) \n    print(tupleSameProduct([1, 2, 2, 3])) \n    print(tupleSameProduct([1, -1, -2, 2])) \n    print(tupleSameProduct([0, 1, 2, 2])) \n    print(tupleSameProduct([1, 1, 1, 1])) \n    print(tupleSameProduct([2, 2, 3, 3])) \n    print(tupleSameProduct([1, 0, 0, 1])) \n    print(tupleSameProduct([0, -1, -1, 0]))", "all_input_output_value": "\ninput1: nums=[]\noutput1: 0\n--------\ninput2: nums=[1]\noutput2: 0\n--------\ninput3: nums=[1, 2, 3]\noutput3: 0\n--------\ninput4: nums=[1, 2, 2, 3]\noutput4: 16\n--------\ninput5: nums=[1, -1, -2, 2]\noutput5: 16\n--------\ninput6: nums=[0, 1, 2, 2]\noutput6: 32\n--------\ninput7: nums=[1, 1, 1, 1]\noutput7: 120\n--------\ninput8: nums=[2, 2, 3, 3]\noutput8: 48\n--------\ninput9: nums=[1, 0, 0, 1]\noutput9: 80\n--------\ninput10: nums=[0, -1, -1, 0]\noutput10: 80\n", "input_output_value": ["\ninput1: nums=[]\noutput1: 0\n", "\ninput2: nums=[1]\noutput2: 0\n", "\ninput3: nums=[1, 2, 3]\noutput3: 0\n"], "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n// TOFILL\nint main() {\n    vector<vector<int>> testInputs = {\n        {},\n        {1},\n        {1, 2, 3},\n        {1, 2, 2, 3},\n        {1, -1, -2, 2},\n        {0, 1, 2, 2},\n        {1, 1, 1, 1},\n        {2, 2, 3, 3},\n        {1, 0, 0, 1},\n        {0, -1, -1, 0}\n    };\n\n    for(auto& input : testInputs) {\n        cout << tupleSameProduct(input) << endl;\n    }\n\n    return 0;\n}", "TAG": "Success"}
{"source_Lan": "python###sumOfMultiples.py", "source_code_str": "def sumOfMultiples( n: int) -> int:\n        return sum(i for i in range(1, n + 1) if i % 3 == 0 or i % 5 == 0 or i % 7 == 0)", "source_code_block": "", "target_Lan": "cpp###sumOfMultiples.cpp", "reference_code": "int sumOfMultiples(int n) {\n        int res = 0;\n        for (int i = 1; i <= n; i++) {\n            if (i % 3 == 0 || i % 5 == 0 || i % 7 == 0) {\n                res += i;\n            }\n        }\n        return res;\n    }", "target_method_signature": "sumOfMultiples", "source_method_signature": "sumOfMultiples", "target_allMS": "int sumOfMultiples(int n) {", "source_allMS": "def sumOfMultiples( n: int) -> int:", "source_import": "", "target_import": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>", "commentTag": "//", "source_code_shell": "# TOFILL\nif __name__ == \"__main__\":\n    print(sumOfMultiples(0))\n    print(sumOfMultiples(1))\n    print(sumOfMultiples(3))\n    print(sumOfMultiples(5))\n    print(sumOfMultiples(7))\n    print(sumOfMultiples(10))\n    print(sumOfMultiples(15))\n    print(sumOfMultiples(20))\n    print(sumOfMultiples(30))\n    print(sumOfMultiples(100))", "all_input_output_value": "\ninput1: n=0\noutput1: 0\n--------\ninput2: n=1\noutput2: 0\n--------\ninput3: n=3\noutput3: 3\n--------\ninput4: n=5\noutput4: 8\n--------\ninput5: n=7\noutput5: 21\n--------\ninput6: n=10\noutput6: 40\n--------\ninput7: n=15\noutput7: 81\n--------\ninput8: n=20\noutput8: 119\n--------\ninput9: n=30\noutput9: 274\n--------\ninput10: n=100\noutput10: 2838\n", "input_output_value": ["\ninput1: n=0\noutput1: 0\n", "\ninput2: n=1\noutput2: 0\n", "\ninput3: n=3\noutput3: 3\n"], "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <iostream>\n// TOFILL\nint main() {\n    cout << sumOfMultiples(0) << endl;\n    cout << sumOfMultiples(1) << endl;\n    cout << sumOfMultiples(3) << endl;\n    cout << sumOfMultiples(5) << endl;\n    cout << sumOfMultiples(7) << endl;\n    cout << sumOfMultiples(10) << endl;\n    cout << sumOfMultiples(15) << endl;\n    cout << sumOfMultiples(20) << endl;\n    cout << sumOfMultiples(30) << endl;\n    cout << sumOfMultiples(100) << endl;\n}", "TAG": "Success"}
{"source_Lan": "python###filterRestaurants.py", "source_code_str": "def filterRestaurants( restaurants: List[List[int]], veganFriendly: int, maxPrice: int, maxDistance: int) -> List[int]:\n        filtered = [r for r in restaurants if r[3] <= maxPrice and r[4] <= maxDistance and not (veganFriendly and not r[2])]\n        filtered.sort(key=lambda r: (-r[1], -r[0]))\n        return [r[0] for r in filtered]", "source_code_block": "", "target_Lan": "cpp###filterRestaurants.cpp", "reference_code": "vector<int> filterRestaurants(vector<vector<int>>& restaurants, int veganFriendly, int maxPrice, int maxDistance) {\n        int n = restaurants.size();\n        vector<vector<int>> filtered;\n        for (int i = 0; i < n; i++) {\n            if (restaurants[i][3] <= maxPrice && restaurants[i][4] <= maxDistance && !(veganFriendly && !restaurants[i][2])) {\n                filtered.push_back(restaurants[i]);\n            }\n        }\n        sort(filtered.begin(), filtered.end(), [](vector<int> &v1, vector<int> &v2) -> bool {\n            return v1[1] > v2[1] || (v1[1] == v2[1] && v1[0] > v2[0]);\n        });\n        vector<int> res;\n        for (auto &v : filtered) {\n            res.push_back(v[0]);\n        }\n        return res;\n    }", "target_method_signature": "filterRestaurants", "source_method_signature": "filterRestaurants", "target_allMS": "vector<int> filterRestaurants(vector<vector<int>>& restaurants, int veganFriendly, int maxPrice, int maxDistance) {", "source_allMS": "def filterRestaurants( restaurants: List[List[int]], veganFriendly: int, maxPrice: int, maxDistance: int) -> List[int]:", "source_import": "from typing import List", "target_import": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <algorithm>", "commentTag": "//", "source_code_shell": "from typing import List\nfrom typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(filterRestaurants([[1, 5, 1, 10, 2], [2, 3, 0, 15, 5], [3, 4, 1, 30, 4]], veganFriendly=1, maxPrice=20, maxDistance=5))\n    print(filterRestaurants([[1, 5, 1, 10, 2], [2, 3, 0, 15, 5], [3, 4, 1, 30, 4]], veganFriendly=0, maxPrice=5, maxDistance=10))\n    print(filterRestaurants([[1, 5, 1, 10, 2], [2, 3, 0, 15, 5], [3, 4, 0, 100, 10]], veganFriendly=1, maxPrice=25, maxDistance=10))\n    print(filterRestaurants([[1, 5, 0, 10, 3]], veganFriendly=1, maxPrice=5, maxDistance=3))\n    print(filterRestaurants([[1, 5, 0, 10, 3], [2, 8, 1, 20, 1]], veganFriendly=1, maxPrice=15, maxDistance=2))\n    print(filterRestaurants([[1, 3, 1, 10, 2], [2, 5, 1, 20, 4], [3, 2, 0, 30, 6]], veganFriendly=0, maxPrice=25, maxDistance=10))\n    print(filterRestaurants([], veganFriendly=0, maxPrice=10, maxDistance=5))\n    print(filterRestaurants([[1, 4, 1, 50, 5]], veganFriendly=1, maxPrice=40, maxDistance=10))\n    print(filterRestaurants([[1, 3, 1, 20, 3], [2, 2, 1, 5, 1]], veganFriendly=1, maxPrice=5, maxDistance=2))\n    print(filterRestaurants([[1, 10, 0, 5, 5], [2, 7, 0, 0, 10]], veganFriendly=0, maxPrice=10, maxDistance=10))", "all_input_output_value": "\ninput1: restaurants=[[1, 5, 1, 10, 2], [2, 3, 0, 15, 5], [3, 4, 1, 30, 4]], veganFriendly=1, maxPrice=20, maxDistance=5\noutput1: [1]\n--------\ninput2: restaurants=[[1, 5, 1, 10, 2], [2, 3, 0, 15, 5], [3, 4, 1, 30, 4]], veganFriendly=0, maxPrice=5, maxDistance=10\noutput2: []\n--------\ninput3: restaurants=[[1, 5, 1, 10, 2], [2, 3, 0, 15, 5], [3, 4, 0, 100, 10]], veganFriendly=1, maxPrice=25, maxDistance=10\noutput3: [1]\n--------\ninput4: restaurants=[[1, 5, 0, 10, 3]], veganFriendly=1, maxPrice=5, maxDistance=3\noutput4: []\n--------\ninput5: restaurants=[[1, 5, 0, 10, 3], [2, 8, 1, 20, 1]], veganFriendly=1, maxPrice=15, maxDistance=2\noutput5: []\n--------\ninput6: restaurants=[[1, 3, 1, 10, 2], [2, 5, 1, 20, 4], [3, 2, 0, 30, 6]], veganFriendly=0, maxPrice=25, maxDistance=10\noutput6: [2, 1]\n--------\ninput7: restaurants=[], veganFriendly=0, maxPrice=10, maxDistance=5\noutput7: []\n--------\ninput8: restaurants=[[1, 4, 1, 50, 5]], veganFriendly=1, maxPrice=40, maxDistance=10\noutput8: []\n--------\ninput9: restaurants=[[1, 3, 1, 20, 3], [2, 2, 1, 5, 1]], veganFriendly=1, maxPrice=5, maxDistance=2\noutput9: [2]\n--------\ninput10: restaurants=[[1, 10, 0, 5, 5], [2, 7, 0, 0, 10]], veganFriendly=0, maxPrice=10, maxDistance=10\noutput10: [1, 2]\n", "input_output_value": ["\ninput1: restaurants=[[1, 5, 1, 10, 2], [2, 3, 0, 15, 5], [3, 4, 1, 30, 4]], veganFriendly=1, maxPrice=20, maxDistance=5\noutput1: [1]\n", "\ninput2: restaurants=[[1, 5, 1, 10, 2], [2, 3, 0, 15, 5], [3, 4, 1, 30, 4]], veganFriendly=0, maxPrice=5, maxDistance=10\noutput2: []\n", "\ninput3: restaurants=[[1, 5, 1, 10, 2], [2, 3, 0, 15, 5], [3, 4, 0, 100, 10]], veganFriendly=1, maxPrice=25, maxDistance=10\noutput3: [1]\n"], "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n// TOFILL\nint main() {\n    vector<vector<int>> restaurants1 = {{1, 5, 1, 10, 2}, {2, 3, 0, 15, 5}, {3, 4, 1, 30, 4}};\n    vector<int> result1 = filterRestaurants(restaurants1, 1, 20, 5);\n    for(int id : result1) cout << id << \" \";\n    cout << endl;\n\n    vector<vector<int>> restaurants2 = {{1, 5, 1, 10, 2}, {2, 3, 0, 15, 5}, {3, 4, 1, 30, 4}};\n    vector<int> result2 = filterRestaurants(restaurants2, 0, 5, 10);\n    for(int id : result2) cout << id << \" \";\n    cout << endl;\n\n    vector<vector<int>> restaurants3 = {{1, 5, 1, 10, 2}, {2, 3, 0, 15, 5}, {3, 4, 0, 100, 10}};\n    vector<int> result3 = filterRestaurants(restaurants3, 1, 25, 10);\n    for(int id : result3) cout << id << \" \";\n    cout << endl;\n\n    vector<vector<int>> restaurants4 = {{1, 5, 0, 10, 3}};\n    vector<int> result4 = filterRestaurants(restaurants4, 1, 5, 3);\n    for(int id : result4) cout << id << \" \";\n    cout << endl;\n\n    vector<vector<int>> restaurants5 = {{1, 5, 0, 10, 3}, {2, 8, 1, 20, 1}};\n    vector<int> result5 = filterRestaurants(restaurants5, 1, 15, 2);\n    for(int id : result5) cout << id << \" \";\n    cout << endl;\n\n    vector<vector<int>> restaurants6 = {{1, 3, 1, 10, 2}, {2, 5, 1, 20, 4}, {3, 2, 0, 30, 6}};\n    vector<int> result6 = filterRestaurants(restaurants6, 0, 25, 10);\n    for(int id : result6) cout << id << \" \";\n    cout << endl;\n\n    vector<vector<int>> restaurants7 = {};\n    vector<int> result7 = filterRestaurants(restaurants7, 0, 10, 5);\n    for(int id : result7) cout << id << \" \";\n    cout << endl;\n\n    vector<vector<int>> restaurants8 = {{1, 4, 1, 50, 5}};\n    vector<int> result8 = filterRestaurants(restaurants8, 1, 40, 10);\n    for(int id : result8) cout << id << \" \";\n    cout << endl;\n\n    vector<vector<int>> restaurants9 = {{1, 3, 1, 20, 3}, {2, 2, 1, 5, 1}};\n    vector<int> result9 = filterRestaurants(restaurants9, 1, 5, 2);\n    for(int id : result9) cout << id << \" \";\n    cout << endl;\n\n    vector<vector<int>> restaurants10 = {{1, 10, 0, 5, 5}, {2, 7, 0, 0, 10}};\n    vector<int> result10 = filterRestaurants(restaurants10, 0, 10, 10);\n    for(int id : result10) cout << id << \" \";\n    cout << endl;\n\n    return 0;\n}", "TAG": "Success"}
{"source_Lan": "python###collectTheCoins.py", "source_code_str": "def collectTheCoins( coins: List[int], edges: List[List[int]]) -> int:\n        n = len(coins)\n        g = defaultdict(list)\n        degree = [0] * n\n        for x, y in edges:\n            g[x].append(y)\n            g[y].append(x)\n            degree[x] += 1\n            degree[y] += 1\n        rest = n\n        \n        q = deque(i for i in range(n) if degree[i] == 1 and coins[i] == 0)\n        while q:\n            u = q.popleft()\n            degree[u] -= 1\n            rest -= 1\n            for v in g[u]:\n                degree[v] -= 1\n                if degree[v] == 1 and coins[v] == 0:\n                    q.append(v)\n        \n        for _ in range(2):\n            q = deque(i for i in range(n) if degree[i] == 1)\n            while q:\n                u = q.popleft()\n                degree[u] -= 1\n                rest -= 1\n                for v in g[u]:\n                    degree[v] -= 1\n        return 0 if rest == 0 else (rest - 1) * 2", "source_code_block": "", "target_Lan": "cpp###collectTheCoins.cpp", "reference_code": "int collectTheCoins(vector<int>& coins, vector<vector<int>>& edges) {\n        int n = coins.size();\n        vector<vector<int>> g(n);\n        vector<int> degree(n);\n        for (const auto& edge: edges) {\n            int x = edge[0], y = edge[1];\n            g[x].push_back(y);\n            g[y].push_back(x);\n            ++degree[x];\n            ++degree[y];\n        }\n        int rest = n;\n        {\n            \n            queue<int> q;\n            for (int i = 0; i < n; ++i) {\n                if (degree[i] == 1 && !coins[i]) {\n                    q.push(i);\n                }\n            }\n            while (!q.empty()) {\n                int u = q.front();\n                --degree[u];\n                q.pop();\n                --rest;\n                for (int v: g[u]) {\n                    --degree[v];\n                    if (degree[v] == 1 && !coins[v]) {\n                        q.push(v);\n                    }\n                }\n            }\n        }\n        {\n            \n            for (int _ = 0; _ < 2; ++_) {\n                queue<int> q;\n                for (int i = 0; i < n; ++i) {\n                    if (degree[i] == 1) {\n                        q.push(i);\n                    }\n                }\n                while (!q.empty()) {\n                    int u = q.front();\n                    --degree[u];\n                    q.pop();\n                    --rest;\n                    for (int v: g[u]) {\n                        --degree[v];\n                    }\n                }\n            }\n        }\n        return rest == 0 ? 0 : (rest - 1) * 2;\n    }", "target_method_signature": "collectTheCoins", "source_method_signature": "collectTheCoins", "target_allMS": "int collectTheCoins(vector<int>& coins, vector<vector<int>>& edges) {", "source_allMS": "def collectTheCoins( coins: List[int], edges: List[List[int]]) -> int:", "source_import": "from collections import defaultdict, deque\nfrom typing import List", "target_import": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <queue>", "commentTag": "//", "source_code_shell": "from collections import defaultdict, deque\nfrom typing import List\nfrom collections import defaultdict, deque\nfrom typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(collectTheCoins([], []))\n    print(collectTheCoins([1, 0, 1, 0], [[0, 1], [1, 2], [2, 3]]))\n    print(collectTheCoins([1, 0, 0], [[0, 1], [0, 2]]))\n    print(collectTheCoins([1, 1, 1], [[0, 1], [1, 2]]))\n    print(collectTheCoins([0, 1, 0, 0], [[0, 1], [0, 2], [0, 3]]))\n    print(collectTheCoins([1, 1, 1, 1], [[0, 1], [1, 2], [2, 3], [3, 0]]))\n    print(collectTheCoins([0], []))\n    print(collectTheCoins([1, 1, 1, 1], [[0, 1], [0, 2], [0, 3], [1, 2], [1, 3], [2, 3]]))", "all_input_output_value": "\ninput1: coins=[], edges=[]\noutput1: 0\n--------\ninput2: coins=[1, 0, 1, 0], edges=[[0, 1], [1, 2], [2, 3]]\noutput2: 0\n--------\ninput3: coins=[1, 0, 0], edges=[[0, 1], [0, 2]]\noutput3: 0\n--------\ninput4: coins=[1, 1, 1], edges=[[0, 1], [1, 2]]\noutput4: 0\n--------\ninput5: coins=[0, 1, 0, 0], edges=[[0, 1], [0, 2], [0, 3]]\noutput5: 0\n--------\ninput6: coins=[1, 1, 1, 1], edges=[[0, 1], [1, 2], [2, 3], [3, 0]]\noutput6: 6\n--------\ninput7: coins=[0], edges=[]\noutput7: 0\n--------\ninput8: coins=[1, 1, 1, 1], edges=[[0, 1], [0, 2], [0, 3], [1, 2], [1, 3], [2, 3]]\noutput8: 6\n", "input_output_value": ["\ninput1: coins=[], edges=[]\noutput1: 0\n", "\ninput2: coins=[1, 0, 1, 0], edges=[[0, 1], [1, 2], [2, 3]]\noutput2: 0\n", "\ninput3: coins=[1, 0, 0], edges=[[0, 1], [0, 2]]\noutput3: 0\n"], "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <iostream>\n#include <vector>\n#include <queue>\n// TOFILL\nint main() {\n    vector<vector<int>> inputs = {\n        {},\n        {1, 0, 1, 0},\n        {1, 0, 0},\n        {1, 1, 1},\n        {0, 1, 0, 0},\n        {1, 1, 1, 1},\n        {0},\n        {1, 1, 1, 1}\n    };\n\n    vector<vector<vector<int>>> edges = {\n        {},\n        {{0, 1}, {1, 2}, {2, 3}},\n        {{0, 1}, {0, 2}},\n        {{0, 1}, {1, 2}},\n        {{0, 1}, {0, 2}, {0, 3}},\n        {{0, 1}, {1, 2}, {2, 3}, {3, 0}},\n        {},\n        {{0, 1}, {0, 2}, {0, 3}, {1, 2}, {1, 3}, {2, 3}}\n    };\n\n    for(size_t i = 0; i < inputs.size(); ++i) {\n        cout << collectTheCoins(inputs[i], edges[i]) << endl;\n    }\n\n    return 0;\n}", "TAG": "Success"}
{"source_Lan": "python###distMoney.py", "source_code_str": "def distMoney( money: int, children: int) -> int:\n        if money < children:\n            return -1\n        money -= children\n        cnt = min(money // 7, children)\n        money -= cnt * 7\n        children -= cnt\n        if (children == 0 and money > 0) or (children == 1 and money == 3):\n            cnt -= 1\n        return cnt", "source_code_block": "", "target_Lan": "cpp###distMoney.cpp", "reference_code": "int distMoney(int money, int children) {\n        if (money < children) {\n            return -1;\n        }\n        money -= children;\n        int cnt = min(money / 7, children);\n        money -= cnt * 7;\n        children -= cnt;\n        if ((children == 0 && money > 0) || (children == 1 && money == 3)) {\n            cnt--;\n        }\n        return cnt;\n    }", "target_method_signature": "distMoney", "source_method_signature": "distMoney", "target_allMS": "int distMoney(int money, int children) {", "source_allMS": "def distMoney( money: int, children: int) -> int:", "source_import": "", "target_import": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <algorithm>", "commentTag": "//", "source_code_shell": "# TOFILL\nif __name__ == \"__main__\":\n    print(distMoney(10, 5))\n    print(distMoney(5, 10))\n    print(distMoney(30, 5))\n    print(distMoney(8, 2))\n    print(distMoney(4, 3))\n    print(distMoney(24, 4))\n    print(distMoney(3, 1))\n    print(distMoney(20, 3))\n    print(distMoney(9, 2))\n    print(distMoney(15, 5))", "all_input_output_value": "\ninput1: money=10, children=5\noutput1: 0\n--------\ninput2: money=5, children=10\noutput2: -1\n--------\ninput3: money=30, children=5\noutput3: 3\n--------\ninput4: money=8, children=2\noutput4: 0\n--------\ninput5: money=4, children=3\noutput5: 0\n--------\ninput6: money=24, children=4\noutput6: 2\n--------\ninput7: money=3, children=1\noutput7: 0\n--------\ninput8: money=20, children=3\noutput8: 1\n--------\ninput9: money=9, children=2\noutput9: 1\n--------\ninput10: money=15, children=5\noutput10: 1\n", "input_output_value": ["\ninput1: money=10, children=5\noutput1: 0\n", "\ninput2: money=5, children=10\noutput2: -1\n", "\ninput3: money=30, children=5\noutput3: 3\n"], "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <algorithm>\n#include <iostream>\n// TOFILL\nint main() {\n    cout << distMoney(10, 5) << endl;\n    cout << distMoney(5, 10) << endl;\n    cout << distMoney(30, 5) << endl;\n    cout << distMoney(8, 2) << endl;\n    cout << distMoney(4, 3) << endl;\n    cout << distMoney(24, 4) << endl;\n    cout << distMoney(3, 1) << endl;\n    cout << distMoney(20, 3) << endl;\n    cout << distMoney(9, 2) << endl;\n    cout << distMoney(15, 5) << endl;\n}", "TAG": "Success"}
{"source_Lan": "python###queensAttacktheKing.py", "source_code_str": "def queensAttacktheKing( queens: List[List[int]], king: List[int]) -> List[List[int]]:\n        queen_pos = set((x, y) for x, y in queens)\n        ans = list()\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == dy == 0:\n                    continue\n                kx, ky = king[0] + dx, king[1] + dy\n                while 0 <= kx < 8 and 0 <= ky < 8:\n                    if (kx, ky) in queen_pos:\n                        ans.append([kx, ky])\n                        break\n                    kx += dx\n                    ky += dy\n        return ans", "source_code_block": "", "target_Lan": "cpp###queensAttacktheKing.cpp", "reference_code": "vector<vector<int>> queensAttacktheKing(vector<vector<int>>& queens, vector<int>& king) {\n        unordered_set<int> queen_pos;\n        for (const auto& queen: queens) {\n            int x = queen[0], y = queen[1];\n            queen_pos.insert(x * 8 + y);\n        }\n        vector<vector<int>> ans;\n        for (int dx = -1; dx <= 1; ++dx) {\n            for (int dy = -1; dy <= 1; ++dy) {\n                if (dx == 0 && dy == 0) {\n                    continue;\n                }\n                int kx = king[0] + dx, ky = king[1] + dy;\n                while (kx >= 0 && kx < 8 && ky >= 0 && ky < 8) {\n                    int pos = kx * 8 + ky;\n                    if (queen_pos.count(pos)) {\n                        ans.push_back({kx, ky});\n                        break;\n                    }\n                    kx += dx;\n                    ky += dy;\n                }\n            }\n        }\n        return ans;\n    }", "target_method_signature": "queensAttacktheKing", "source_method_signature": "queensAttacktheKing", "target_allMS": "vector<vector<int>> queensAttacktheKing(vector<vector<int>>& queens, vector<int>& king) {", "source_allMS": "def queensAttacktheKing( queens: List[List[int]], king: List[int]) -> List[List[int]]:", "source_import": "from typing import List", "target_import": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <unordered_set>", "commentTag": "//", "source_code_shell": "from typing import List\nfrom typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(queensAttacktheKing([], [4, 4]))                           # No queens - edge case\n    print(queensAttacktheKing([[4, 5], [5, 4]], [4, 4]))            # Queens attacking the king from different directions\n    print(queensAttacktheKing([[0, 0], [0, 7], [7, 0], [7, 7]], [4, 4]))  # Queens at corners, not affecting the king\n    print(queensAttacktheKing([[3, 3], [3, 5], [5, 3], [5, 5]], [4, 4]))  # Queens surrounding the king\n    print(queensAttacktheKing([[0, 1], [1, 0], [1, 2], [2, 1]], [1, 1]))  # Queens close to the king but cannot hit\n    print(queensAttacktheKing([[0, 0], [2, 2], [3, 1], [6, 6]], [2, 1]))  # Mixed positions with direct attack\n    print(queensAttacktheKing([[1, 1], [3, 1], [1, 3], [5, 5]], [3, 3]))  # Only one queen attacking directly\n    print(queensAttacktheKing([[1, 2], [2, 2], [2, 1], [2, 3]], [2, 2]))  # Multiple queens attacking directly\n    print(queensAttacktheKing([[4, 4], [3, 5], [6, 6]], [5, 5]))        # King position is safe\n    print(queensAttacktheKing([[5, 5], [6, 5], [7, 5]], [6, 6]))        # Queens in vertical against the king", "all_input_output_value": "\ninput1: queens=[], king=[4, 4]\noutput1: []\n--------\ninput2: queens=[[4, 5], [5, 4]], king=[4, 4]\noutput2: [[4, 5], [5, 4]]\n--------\ninput3: queens=[[0, 0], [0, 7], [7, 0], [7, 7]], king=[4, 4]\noutput3: [[0, 0], [7, 7]]\n--------\ninput4: queens=[[3, 3], [3, 5], [5, 3], [5, 5]], king=[4, 4]\noutput4: [[3, 3], [3, 5], [5, 3], [5, 5]]\n--------\ninput5: queens=[[0, 1], [1, 0], [1, 2], [2, 1]], king=[1, 1]\noutput5: [[0, 1], [1, 0], [1, 2], [2, 1]]\n--------\ninput6: queens=[[0, 0], [2, 2], [3, 1], [6, 6]], king=[2, 1]\noutput6: [[2, 2], [3, 1]]\n--------\ninput7: queens=[[1, 1], [3, 1], [1, 3], [5, 5]], king=[3, 3]\noutput7: [[1, 1], [1, 3], [3, 1], [5, 5]]\n--------\ninput8: queens=[[1, 2], [2, 2], [2, 1], [2, 3]], king=[2, 2]\noutput8: [[1, 2], [2, 1], [2, 3]]\n--------\ninput9: queens=[[4, 4], [3, 5], [6, 6]], king=[5, 5]\noutput9: [[4, 4], [3, 5], [6, 6]]\n--------\ninput10: queens=[[5, 5], [6, 5], [7, 5]], king=[6, 6]\noutput10: [[5, 5], [6, 5], [7, 5]]\n", "input_output_value": ["\ninput1: queens=[], king=[4, 4]\noutput1: []\n", "\ninput2: queens=[[4, 5], [5, 4]], king=[4, 4]\noutput2: [[4, 5], [5, 4]]\n", "\ninput3: queens=[[0, 0], [0, 7], [7, 0], [7, 7]], king=[4, 4]\noutput3: [[0, 0], [7, 7]]\n"], "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <unordered_set>\n#include <iostream>\n#include <vector>\n#include <unordered_set>\n// TOFILL\nint main() {\n    vector<vector<int>> queens1 = {};\n    vector<int> king1 = {4, 4};\n    vector<vector<int>> res1 = queensAttacktheKing(queens1, king1);\n    for(const auto& pos : res1) {\n        cout << \"[\" << pos[0] << \", \" << pos[1] << \"] \";\n    }\n    cout << endl;\n\n    vector<vector<int>> queens2 = {{4, 5}, {5, 4}};\n    vector<int> king2 = {4, 4};\n    vector<vector<int>> res2 = queensAttacktheKing(queens2, king2);\n    for(const auto& pos : res2) {\n        cout << \"[\" << pos[0] << \", \" << pos[1] << \"] \";\n    }\n    cout << endl;\n\n    vector<vector<int>> queens3 = {{0, 0}, {0, 7}, {7, 0}, {7, 7}};\n    vector<int> king3 = {4, 4};\n    vector<vector<int>> res3 = queensAttacktheKing(queens3, king3);\n    for(const auto& pos : res3) {\n        cout << \"[\" << pos[0] << \", \" << pos[1] << \"] \";\n    }\n    cout << endl;\n\n    vector<vector<int>> queens4 = {{3, 3}, {3, 5}, {5, 3}, {5, 5}};\n    vector<int> king4 = {4, 4};\n    vector<vector<int>> res4 = queensAttacktheKing(queens4, king4);\n    for(const auto& pos : res4) {\n        cout << \"[\" << pos[0] << \", \" << pos[1] << \"] \";\n    }\n    cout << endl;\n\n    vector<vector<int>> queens5 = {{0, 1}, {1, 0}, {1, 2}, {2, 1}};\n    vector<int> king5 = {1, 1};\n    vector<vector<int>> res5 = queensAttacktheKing(queens5, king5);\n    for(const auto& pos : res5) {\n        cout << \"[\" << pos[0] << \", \" << pos[1] << \"] \";\n    }\n    cout << endl;\n\n    vector<vector<int>> queens6 = {{0, 0}, {2, 2}, {3, 1}, {6, 6}};\n    vector<int> king6 = {2, 1};\n    vector<vector<int>> res6 = queensAttacktheKing(queens6, king6);\n    for(const auto& pos : res6) {\n        cout << \"[\" << pos[0] << \", \" << pos[1] << \"] \";\n    }\n    cout << endl;\n\n    vector<vector<int>> queens7 = {{1, 1}, {3, 1}, {1, 3}, {5, 5}};\n    vector<int> king7 = {3, 3};\n    vector<vector<int>> res7 = queensAttacktheKing(queens7, king7);\n    for(const auto& pos : res7) {\n        cout << \"[\" << pos[0] << \", \" << pos[1] << \"] \";\n    }\n    cout << endl;\n\n    vector<vector<int>> queens8 = {{1, 2}, {2, 2}, {2, 1}, {2, 3}};\n    vector<int> king8 = {2, 2};\n    vector<vector<int>> res8 = queensAttacktheKing(queens8, king8);\n    for(const auto& pos : res8) {\n        cout << \"[\" << pos[0] << \", \" << pos[1] << \"] \";\n    }\n    cout << endl;\n\n    vector<vector<int>> queens9 = {{4, 4}, {3, 5}, {6, 6}};\n    vector<int> king9 = {5, 5};\n    vector<vector<int>> res9 = queensAttacktheKing(queens9, king9);\n    for(const auto& pos : res9) {\n        cout << \"[\" << pos[0] << \", \" << pos[1] << \"] \";\n    }\n    cout << endl;\n\n    vector<vector<int>> queens10 = {{5, 5}, {6, 5}, {7, 5}};\n    vector<int> king10 = {6, 6};\n    vector<vector<int>> res10 = queensAttacktheKing(queens10, king10);\n    for(const auto& pos : res10) {\n        cout << \"[\" << pos[0] << \", \" << pos[1] << \"] \";\n    }\n    cout << endl;\n\n    return 0;\n}", "TAG": "Success"}
{"source_Lan": "python###checkValidGrid.py", "source_code_str": "def checkValidGrid( grid: List[List[int]]) -> bool:\n        if grid[0][0] != 0:\n            return False\n        n = len(grid)\n        indices = [[] for _ in range(n * n)]\n        for i in range(n):\n            for j in range(n):\n                indices[grid[i][j]] = [i, j]\n        for i in range(1, n * n, 1):\n            dx = abs(indices[i][0] - indices[i - 1][0])\n            dy = abs(indices[i][1] - indices[i - 1][1])\n            if dx * dy != 2:\n                return False\n        return True", "source_code_block": "", "target_Lan": "cpp###checkValidGrid.cpp", "reference_code": "bool checkValidGrid(vector<vector<int>>& grid) {\n        if (grid[0][0] != 0) {\n            return false;\n        }\n        int n = grid.size();\n        vector<array<int, 2>> indices(n * n);\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                indices[grid[i][j]] = {i, j};\n            }\n        }\n        for (int i = 1; i < indices.size(); i++) {\n            int dx = abs(indices[i][0] - indices[i - 1][0]);\n            int dy = abs(indices[i][1] - indices[i - 1][1]);\n            if (dx * dy != 2) {\n                return false;\n            }\n        }\n        return true;\n    }", "target_method_signature": "checkValidGrid", "source_method_signature": "checkValidGrid", "target_allMS": "bool checkValidGrid(vector<vector<int>>& grid) {", "source_allMS": "def checkValidGrid( grid: List[List[int]]) -> bool:", "source_import": "from typing import List", "target_import": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <array>", "commentTag": "//", "source_code_shell": "from typing import List\nfrom typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(checkValidGrid([[0, 1], [3, 2]]))  # Valid grid\n    print(checkValidGrid([[1, 0], [2, 3]]))  # Invalid (first element is non-zero)\n    print(checkValidGrid([[0, 1], [0, 3]]))  # Invalid (duplicate of 0)\n    print(checkValidGrid([[0]]))             # Edge case (1x1 grid)\n    print(checkValidGrid([[0, 1, 3], [2, 4, 5], [6, 7, 8]]))  # Invalid (invalid movement)\n    print(checkValidGrid([[0, 3], [1, 2]]))  # Invalid (non-adjacent movement)\n    print(checkValidGrid([[0, 2], [1, 3]]))  # Invalid (2 is in the wrong position)\n    print(checkValidGrid([[0, 1, 2], [3, 4, 5], [6, 8, 7]]))  # Invalid (8 and 7 in wrong positions)", "all_input_output_value": "\ninput1: grid=[[0, 1], [3, 2]]\noutput1: False\n--------\ninput2: grid=[[1, 0], [2, 3]]\noutput2: False\n--------\ninput3: grid=[[0, 1], [0, 3]]\noutput3: False\n--------\ninput4: grid=[[0]]\noutput4: True\n--------\ninput5: grid=[[0, 1, 3], [2, 4, 5], [6, 7, 8]]\noutput5: False\n--------\ninput6: grid=[[0, 3], [1, 2]]\noutput6: False\n--------\ninput7: grid=[[0, 2], [1, 3]]\noutput7: False\n--------\ninput8: grid=[[0, 1, 2], [3, 4, 5], [6, 8, 7]]\noutput8: False\n", "input_output_value": ["\ninput1: grid=[[0, 1], [3, 2]]\noutput1: False\n", "\ninput2: grid=[[1, 0], [2, 3]]\noutput2: False\n", "\ninput3: grid=[[0, 1], [0, 3]]\noutput3: False\n"], "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <array>\n#include <iostream>\n#include <vector>\n#include <array>\n// TOFILL\nint main() {\n    vector<vector<int>> grid1 = {{0, 1}, {3, 2}};\n    vector<vector<int>> grid2 = {{1, 0}, {2, 3}};\n    vector<vector<int>> grid3 = {{0, 1}, {0, 3}};\n    vector<vector<int>> grid4 = {{0}};\n    vector<vector<int>> grid5 = {{0, 1, 3}, {2, 4, 5}, {6, 7, 8}};\n    vector<vector<int>> grid6 = {{0, 3}, {1, 2}};\n    vector<vector<int>> grid7 = {{0, 2}, {1, 3}};\n    vector<vector<int>> grid8 = {{0, 1, 2}, {3, 4, 5}, {6, 8, 7}};\n\n    cout << checkValidGrid(grid1) << endl; // Expected output: 1(true)\n    cout << checkValidGrid(grid2) << endl; // Expected output: 0(false)\n    cout << checkValidGrid(grid3) << endl; // Expected output: 0(false)\n    cout << checkValidGrid(grid4) << endl; // Expected output: 1(true)\n    cout << checkValidGrid(grid5) << endl; // Expected output: 1(true)\n    cout << checkValidGrid(grid6) << endl; // Expected output: 1(true)\n    cout << checkValidGrid(grid7) << endl; // Expected output: 1(true)\n    cout << checkValidGrid(grid8) << endl; // Expected output: 0(false)\n}", "TAG": "Success"}
{"source_Lan": "python###findDelayedArrivalTime.py", "source_code_str": "def findDelayedArrivalTime( arrivalTime: int, delayedTime: int) -> int:\n        return (arrivalTime + delayedTime) % 24", "source_code_block": "", "target_Lan": "cpp###findDelayedArrivalTime.cpp", "reference_code": "    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\n        return (arrivalTime + delayedTime) % 24;\n    }", "target_method_signature": "findDelayedArrivalTime", "source_method_signature": "findDelayedArrivalTime", "target_allMS": "    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {", "source_allMS": "def findDelayedArrivalTime( arrivalTime: int, delayedTime: int) -> int:", "source_import": "", "target_import": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>", "commentTag": "//", "source_code_shell": "# TOFILL\nif __name__ == \"__main__\":\n    print(findDelayedArrivalTime(0, 1))\n    print(findDelayedArrivalTime(23, 10))\n    print(findDelayedArrivalTime(5, 15))\n    print(findDelayedArrivalTime(24, -1))\n    print(findDelayedArrivalTime(12, 20))", "all_input_output_value": "\ninput1: arrivalTime=0, delayedTime=1\noutput1: 1\n--------\ninput2: arrivalTime=23, delayedTime=10\noutput2: 9\n--------\ninput3: arrivalTime=5, delayedTime=15\noutput3: 20\n--------\ninput4: arrivalTime=24, delayedTime=-1\noutput4: 23\n--------\ninput5: arrivalTime=12, delayedTime=20\noutput5: 8\n", "input_output_value": ["\ninput1: arrivalTime=0, delayedTime=1\noutput1: 1\n", "\ninput2: arrivalTime=23, delayedTime=10\noutput2: 9\n", "\ninput3: arrivalTime=5, delayedTime=15\noutput3: 20\n"], "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <iostream>\n// TOFILL\nint main() {\n    cout << findDelayedArrivalTime(0, 1) << endl;      // Test input 1\n    cout << findDelayedArrivalTime(23, 10) << endl;     // Test input 2\n    cout << findDelayedArrivalTime(5, 15) << endl;      // Test input 3\n    cout << findDelayedArrivalTime(24, -1) << endl;     // Test input 4\n    cout << findDelayedArrivalTime(12, 20) << endl;     // Test input 5\n}", "TAG": "Success"}
{"source_Lan": "python###minTrioDegree.py", "source_code_str": "def minTrioDegree( n: int, edges: List[List[int]]) -> int:\n        \n        g = defaultdict(set)\n        \n        h = defaultdict(list)\n        degree = [0] * n\n        for x, y in edges:\n            x, y = x - 1, y - 1\n            g[x].add(y)\n            g[y].add(x)\n            degree[x] += 1\n            degree[y] += 1\n        for x, y in edges:\n            x, y = x - 1, y - 1\n            if degree[x] < degree[y] or (degree[x] == degree[y] and x < y):\n                h[x].append(y)\n            else:\n                h[y].append(x)\n        ans = inf\n        for i in range(n):\n            for j in h[i]:\n                for k in h[j]:\n                    if k in g[i]:\n                        ans = min(ans, degree[i] + degree[j] + degree[k] - 6)\n        return -1 if ans == inf else ans", "source_code_block": "", "target_Lan": "cpp###minTrioDegree.cpp", "reference_code": "int minTrioDegree(int n, vector<vector<int>>& edges) {\n        \n        vector<unordered_set<int>> g(n);\n        \n        vector<vector<int>> h(n);\n        vector<int> degree(n);\n        for (auto&& edge: edges) {\n            int x = edge[0] - 1, y = edge[1] - 1;\n            g[x].insert(y);\n            g[y].insert(x);\n            ++degree[x];\n            ++degree[y];\n        }\n        for (auto&& edge: edges) {\n            int x = edge[0] - 1, y = edge[1] - 1;\n            if (degree[x] < degree[y] || (degree[x] == degree[y] && x < y)) {\n                h[x].push_back(y);\n            }\n            else {\n                h[y].push_back(x);\n            }\n        }\n        int ans = INT_MAX;\n        for (int i = 0; i < n; ++i) {\n            for (int j: h[i]) {\n                for (int k: h[j]) {\n                    if (g[i].count(k)) {\n                        ans = min(ans, degree[i] + degree[j] + degree[k] - 6);\n                    }\n                }\n            }\n        }\n        return ans == INT_MAX ? -1 : ans;\n    }", "target_method_signature": "minTrioDegree", "source_method_signature": "minTrioDegree", "target_allMS": "int minTrioDegree(int n, vector<vector<int>>& edges) {", "source_allMS": "def minTrioDegree( n: int, edges: List[List[int]]) -> int:", "source_import": "from typing import List\nfrom collections import defaultdict\nfrom math import inf", "target_import": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <unordered_set>\n#include <climits>", "commentTag": "//", "source_code_shell": "from typing import List\nfrom collections import defaultdict\nfrom math import inf\nfrom collections import defaultdict\nfrom typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(minTrioDegree(3, [[1, 2], [2, 3], [3, 1]]))     # Complete graph\n    print(minTrioDegree(4, [[1, 2], [2, 3]]))              # Graph with no trio\n    print(minTrioDegree(0, []))                             # Empty graph\n    print(minTrioDegree(2, [[1, 2]]))                       # Only one edge\n    print(minTrioDegree(5, [[1, 2], [2, 3], [3, 1], [1, 4]]))  # Partially connected graph\n    print(minTrioDegree(5, [[1, 2], [2, 3], [3, 1], [1, 4], [4, 5]]))  # Graph with a trio\n    print(minTrioDegree(6, [[1, 2], [2, 3], [3, 1], [4, 5], [5, 6], [4, 6]]))  # Two separate trios\n    print(minTrioDegree(5, [[1, 2], [3, 4], [4, 5], [1, 5]]))  # No trios, connected components\n    print(minTrioDegree(5, [[1, 2], [2, 3], [3, 4], [4, 5], [1, 3]]))  # Cycle graph\n    print(minTrioDegree(7, [[1, 2], [2, 3], [3, 1], [4, 5], [5, 6], [6, 4], [6, 7]]))  # Complex with multiple connections", "all_input_output_value": "\ninput1: n=3, edges=[[1, 2], [2, 3], [3, 1]]\noutput1: 0\n--------\ninput2: n=4, edges=[[1, 2], [2, 3]]\noutput2: -1\n--------\ninput3: n=0, edges=[]\noutput3: -1\n--------\ninput4: n=2, edges=[[1, 2]]\noutput4: -1\n--------\ninput5: n=5, edges=[[1, 2], [2, 3], [3, 1], [1, 4]]\noutput5: 1\n--------\ninput6: n=5, edges=[[1, 2], [2, 3], [3, 1], [1, 4], [4, 5]]\noutput6: 1\n--------\ninput7: n=6, edges=[[1, 2], [2, 3], [3, 1], [4, 5], [5, 6], [4, 6]]\noutput7: 0\n--------\ninput8: n=5, edges=[[1, 2], [3, 4], [4, 5], [1, 5]]\noutput8: -1\n--------\ninput9: n=5, edges=[[1, 2], [2, 3], [3, 4], [4, 5], [1, 3]]\noutput9: 1\n--------\ninput10: n=7, edges=[[1, 2], [2, 3], [3, 1], [4, 5], [5, 6], [6, 4], [6, 7]]\noutput10: 0\n", "input_output_value": ["\ninput1: n=3, edges=[[1, 2], [2, 3], [3, 1]]\noutput1: 0\n", "\ninput2: n=4, edges=[[1, 2], [2, 3]]\noutput2: -1\n", "\ninput3: n=0, edges=[]\noutput3: -1\n"], "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <unordered_set>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <unordered_set>\n#include <climits>\n// TOFILL\nint main() {\n    vector<vector<int>> edges1 = {{1, 2}, {2, 3}, {3, 1}};\n    cout << minTrioDegree(3, edges1) << endl;\n\n    vector<vector<int>> edges2 = {{1, 2}, {2, 3}};\n    cout << minTrioDegree(4, edges2) << endl;\n\n    vector<vector<int>> edges3 = {};\n    cout << minTrioDegree(0, edges3) << endl;\n\n    vector<vector<int>> edges4 = {{1, 2}};\n    cout << minTrioDegree(2, edges4) << endl;\n\n    vector<vector<int>> edges5 = {{1, 2}, {2, 3}, {3, 1}, {1, 4}};\n    cout << minTrioDegree(5, edges5) << endl;\n\n    vector<vector<int>> edges6 = {{1, 2}, {2, 3}, {3, 1}, {1, 4}, {4, 5}};\n    cout << minTrioDegree(5, edges6) << endl;\n\n    vector<vector<int>> edges7 = {{1, 2}, {2, 3}, {3, 1}, {4, 5}, {5, 6}, {4, 6}};\n    cout << minTrioDegree(6, edges7) << endl;\n\n    vector<vector<int>> edges8 = {{1, 2}, {3, 4}, {4, 5}, {1, 5}};\n    cout << minTrioDegree(5, edges8) << endl;\n\n    vector<vector<int>> edges9 = {{1, 2}, {2, 3}, {3, 4}, {4, 5}, {1, 3}};\n    cout << minTrioDegree(5, edges9) << endl;\n\n    vector<vector<int>> edges10 = {{1, 2}, {2, 3}, {3, 1}, {4, 5}, {5, 6}, {6, 4}, {6, 7}};\n    cout << minTrioDegree(7, edges10) << endl;\n\n    return 0;\n}", "TAG": "Success"}
{"source_Lan": "python###minimumJumps.py", "source_code_str": "def minimumJumps( forbidden: List[int], a: int, b: int, x: int) -> int:\n        q, visited = deque([[0, 1, 0]]), set([0])\n        lower, upper = 0, max(max(forbidden) + a, x) + b\n        forbiddenSet = set(forbidden)\n        while q:\n            position, direction, step = q.popleft()\n            if position == x:\n                return step\n            nextPosition = position + a\n            nextDirection = 1\n            if lower <= nextPosition <= upper and nextPosition * nextDirection not in visited and nextPosition not in forbiddenSet:\n                visited.add(nextPosition * nextDirection)\n                q.append([nextPosition, nextDirection, step + 1])\n            if direction == 1:\n                nextPosition = position - b\n                nextDirection = -1\n                if lower <= nextPosition <= upper and nextPosition * nextDirection not in visited and nextPosition not in forbiddenSet:\n                    visited.add(nextPosition * nextDirection)\n                    q.append([nextPosition, nextDirection, step + 1])\n        return -1", "source_code_block": "", "target_Lan": "cpp###minimumJumps.cpp", "reference_code": "int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\n        queue<tuple<int, int, int>> q;\n        unordered_set<int> visited;\n        q.emplace(0, 1, 0);\n        visited.emplace(0);\n        int lower = 0, upper = max(*max_element(forbidden.begin(), forbidden.end()) + a, x) + b;\n        unordered_set<int> forbiddenSet(forbidden.begin(), forbidden.end());\n        while (!q.empty()) {\n            auto [position, direction, step] = q.front();\n            q.pop();\n            if (position == x) {\n                return step;\n            }\n            int nextPosition = position + a;\n            int nextDirection = 1;\n            if (lower <= nextPosition && nextPosition <= upper && !visited.count(nextPosition * nextDirection) && !forbiddenSet.count(nextPosition)) {\n                visited.emplace(nextPosition * nextDirection);\n                q.emplace(nextPosition, nextDirection, step + 1);\n            }\n            if (direction == 1) {\n                nextPosition = position - b;\n                nextDirection = -1;\n                if (lower <= nextPosition && nextPosition <= upper && !visited.count(nextPosition * nextDirection) && !forbiddenSet.count(nextPosition)) {\n                    visited.emplace(nextPosition * nextDirection);\n                    q.emplace(nextPosition, nextDirection, step + 1);\n                }\n            }\n        }\n        return -1;\n    }", "target_method_signature": "minimumJumps", "source_method_signature": "minimumJumps", "target_allMS": "int minimumJumps(vector<int>& forbidden, int a, int b, int x) {", "source_allMS": "def minimumJumps( forbidden: List[int], a: int, b: int, x: int) -> int:", "source_import": "from collections import deque\nfrom typing import List", "target_import": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <unordered_set>\n#include <queue>\n#include <tuple>\n#include <algorithm>", "commentTag": "//", "source_code_shell": "from collections import deque\nfrom typing import List\nfrom collections import deque\nfrom typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(minimumJumps([3], 2, 1, 5))  # Expected output: -1\n    print(minimumJumps([4], 2, 1, 7))  # Expected output: 5\n    print(minimumJumps([1, 3, 5], 1, 1, 4))  # Expected output: 6\n    print(minimumJumps([0], 1, 1, 2))  # Expected output: -1\n    print(minimumJumps([2, 3, 6], 3, 2, 8))  # Expected output: 3\n    print(minimumJumps([1, 5, 9], 7, 4, 10))  # Expected output: 2\n    print(minimumJumps([1, 2, 3, 4, 5], 3, 1, 10))  # Expected output: -1\n    print(minimumJumps([6, 7], 10, 2, 15))  # Expected output: 2", "all_input_output_value": "\ninput1: forbidden=[3], a=2, b=1, x=5\noutput1: 4\n--------\ninput2: forbidden=[4], a=2, b=1, x=7\noutput2: 5\n--------\ninput3: forbidden=[1, 3, 5], a=1, b=1, x=4\noutput3: -1\n--------\ninput4: forbidden=[0], a=1, b=1, x=2\noutput4: 2\n--------\ninput5: forbidden=[2, 3, 6], a=3, b=2, x=8\noutput5: -1\n--------\ninput6: forbidden=[1, 5, 9], a=7, b=4, x=10\noutput6: 3\n--------\ninput7: forbidden=[1, 2, 3, 4, 5], a=3, b=1, x=10\noutput7: -1\n--------\ninput8: forbidden=[6, 7], a=10, b=2, x=15\noutput8: -1\n", "input_output_value": ["\ninput1: forbidden=[3], a=2, b=1, x=5\noutput1: 4\n", "\ninput2: forbidden=[4], a=2, b=1, x=7\noutput2: 5\n", "\ninput3: forbidden=[1, 3, 5], a=1, b=1, x=4\noutput3: -1\n"], "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <unordered_set>\n#include <queue>\n#include <tuple>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <unordered_set>\n#include <tuple>\n#include <algorithm>\n// TOFILL\nint main() {\n    vector<int> forbidden1 = {3}; cout << minimumJumps(forbidden1, 2, 1, 5) << endl;\n    vector<int> forbidden2 = {4}; cout << minimumJumps(forbidden2, 2, 1, 7) << endl;\n    vector<int> forbidden3 = {1, 3, 5}; cout << minimumJumps(forbidden3, 1, 1, 4) << endl;\n    vector<int> forbidden4 = {0}; cout << minimumJumps(forbidden4, 1, 1, 2) << endl;\n    vector<int> forbidden5 = {2, 3, 6}; cout << minimumJumps(forbidden5, 3, 2, 8) << endl;\n    vector<int> forbidden6 = {1, 5, 9}; cout << minimumJumps(forbidden6, 7, 4, 10) << endl;\n    vector<int> forbidden7 = {1, 2, 3, 4, 5}; cout << minimumJumps(forbidden7, 3, 1, 10) << endl;\n    vector<int> forbidden8 = {6, 7}; cout << minimumJumps(forbidden8, 10, 2, 15) << endl;\n}", "TAG": "Success"}
{"source_Lan": "python###circularGameLosers.py", "source_code_str": "def circularGameLosers( n: int, k: int) -> List[int]:\n        visit = [False] * n\n        i = k\n        j = 0\n        while not visit[j]:\n            visit[j] = True\n            j = (j + i) % n\n            i += k\n        ans = []\n        for i in range(n):\n            if not visit[i]:\n                ans.append(i + 1)\n        return ans", "source_code_block": "", "target_Lan": "cpp###circularGameLosers.cpp", "reference_code": "vector<int> circularGameLosers(int n, int k) {\n        vector<bool> visit(n, false);\n        for (int i = k, j = 0; !visit[j]; i += k) {\n            visit[j] = true;\n            j = (j + i) % n;\n        }\n        vector<int> ans;\n        for (int i = 0; i < n; i++) {\n            if (!visit[i]) {\n                ans.emplace_back(i + 1);\n            }\n        }\n        return ans;\n    }", "target_method_signature": "circularGameLosers", "source_method_signature": "circularGameLosers", "target_allMS": "vector<int> circularGameLosers(int n, int k) {", "source_allMS": "def circularGameLosers( n: int, k: int) -> List[int]:", "source_import": "from typing import List", "target_import": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>", "commentTag": "//", "source_code_shell": "from typing import List\nfrom typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    test_inputs = [\n        (1, 1),\n        (5, 2),\n        (5, 10),\n        (7, 3)\n    ]\n    for n, k in test_inputs:\n        print(circularGameLosers(n, k))", "all_input_output_value": "\ninput1: n=1, k=1\noutput1: []\n--------\ninput2: n=5, k=2\noutput2: [4, 5]\n--------\ninput3: n=5, k=10\noutput3: [2, 3, 4, 5]\n--------\ninput4: n=7, k=3\noutput4: [2, 6, 7]\n", "input_output_value": ["\ninput1: n=1, k=1\noutput1: []\n", "\ninput2: n=5, k=2\noutput2: [4, 5]\n", "\ninput3: n=5, k=10\noutput3: [2, 3, 4, 5]\n"], "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    vector<int> result1 = circularGameLosers(1, 1);\n    for(int num : result1) cout << num << \" \";\n    cout << endl;\n\n    vector<int> result2 = circularGameLosers(5, 2);\n    for(int num : result2) cout << num << \" \";\n    cout << endl;\n\n    vector<int> result3 = circularGameLosers(5, 10);\n    for(int num : result3) cout << num << \" \";\n    cout << endl;\n\n    vector<int> result4 = circularGameLosers(7, 3);\n    for(int num : result4) cout << num << \" \";\n    cout << endl;\n\n    return 0;\n}", "TAG": "Success"}
{"source_Lan": "python###isArraySpecial.py", "source_code_str": "def isArraySpecial( nums: List[int], queries: List[List[int]]) -> List[bool]:\n       n = len(nums)\n       dp = [1] * n\n       for i in range(1, n):\n           if (nums[i] ^ nums[i - 1]) & 1 == 1:\n               dp[i] = dp[i - 1] + 1\n       return [dp[y] >= y - x + 1 for x, y in queries]", "source_code_block": "", "target_Lan": "cpp###isArraySpecial.cpp", "reference_code": "vector<bool> isArraySpecial(vector<int>& nums, vector<vector<int>>& queries) {\n        int n = nums.size();\n        vector<int> dp(n, 1);\n        for (int i = 1; i < n; i++) {\n            if ((nums[i] ^ nums[i - 1]) & 1) {\n                dp[i] = dp[i - 1] + 1;\n            }\n        }\n        vector<bool> res;\n        for (auto &q : queries) {\n            int x = q[0], y = q[1];\n            res.emplace_back(dp[y] >= y - x + 1);\n        }\n        return res;\n    }", "target_method_signature": "isArraySpecial", "source_method_signature": "isArraySpecial", "target_allMS": "vector<bool> isArraySpecial(vector<int>& nums, vector<vector<int>>& queries) {", "source_allMS": "def isArraySpecial( nums: List[int], queries: List[List[int]]) -> List[bool]:", "source_import": "from typing import List", "target_import": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>", "commentTag": "//", "source_code_shell": "from typing import List\nfrom typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(isArraySpecial([], []))                            # Test for empty input case\n    print(isArraySpecial([1, 2, 3], [[0, 2]]))              # Basic case, all elements differ in parity\n    print(isArraySpecial([1, 3, 5], [[0, 2]]))              # All elements of the same parity\n    print(isArraySpecial([2, 4, 6, 7], [[0, 3]]))           # Mixed parity with last odd\n    print(isArraySpecial([0, -1, 2], [[0, 2]]))             # Including zero and negative numbers\n    print(isArraySpecial([1, 2, 1, 2], [[0, 3]]))           # Even-length array, alternating parity\n    print(isArraySpecial([3, 5, 7], [[0, 2], [0, 1]]))      # Odd parity elements, different queries\n    print(isArraySpecial([10, 11], [[0, 1], [1, 1]]))       # Simple case with two elements\n    print(isArraySpecial([-5, -10, -3, 2], [[0, 2], [1, 3]]))  # Mix of negative and positive\n    print(isArraySpecial([1, 0, 2, 3, 4], [[1, 3], [2, 4]])) # Mixed numbers", "all_input_output_value": "\ninput1: nums=[], queries=[]\noutput1: []\n--------\ninput2: nums=[1, 2, 3], queries=[[0, 2]]\noutput2: [True]\n--------\ninput3: nums=[1, 3, 5], queries=[[0, 2]]\noutput3: [False]\n--------\ninput4: nums=[2, 4, 6, 7], queries=[[0, 3]]\noutput4: [False]\n--------\ninput5: nums=[0, -1, 2], queries=[[0, 2]]\noutput5: [True]\n--------\ninput6: nums=[1, 2, 1, 2], queries=[[0, 3]]\noutput6: [True]\n--------\ninput7: nums=[3, 5, 7], queries=[[0, 2], [0, 1]]\noutput7: [False, False]\n--------\ninput8: nums=[10, 11], queries=[[0, 1], [1, 1]]\noutput8: [True, True]\n--------\ninput9: nums=[-5, -10, -3, 2], queries=[[0, 2], [1, 3]]\noutput9: [True, True]\n--------\ninput10: nums=[1, 0, 2, 3, 4], queries=[[1, 3], [2, 4]]\noutput10: [False, True]\n", "input_output_value": ["\ninput1: nums=[], queries=[]\noutput1: []\n", "\ninput2: nums=[1, 2, 3], queries=[[0, 2]]\noutput2: [True]\n", "\ninput3: nums=[1, 3, 5], queries=[[0, 2]]\noutput3: [False]\n"], "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    vector<int> nums1 = {};\n    vector<vector<int>> queries1 = {};\n    vector<bool> result1 = isArraySpecial(nums1, queries1);\n    for(bool res : result1) cout << res << \" \";\n    cout << endl;\n\n    vector<int> nums2 = {1, 2, 3};\n    vector<vector<int>> queries2 = {{0, 2}};\n    vector<bool> result2 = isArraySpecial(nums2, queries2);\n    for(bool res : result2) cout << res << \" \";\n    cout << endl;\n\n    vector<int> nums3 = {1, 3, 5};\n    vector<vector<int>> queries3 = {{0, 2}};\n    vector<bool> result3 = isArraySpecial(nums3, queries3);\n    for(bool res : result3) cout << res << \" \";\n    cout << endl;\n\n    vector<int> nums4 = {2, 4, 6, 7};\n    vector<vector<int>> queries4 = {{0, 3}};\n    vector<bool> result4 = isArraySpecial(nums4, queries4);\n    for(bool res : result4) cout << res << \" \";\n    cout << endl;\n\n    vector<int> nums5 = {0, -1, 2};\n    vector<vector<int>> queries5 = {{0, 2}};\n    vector<bool> result5 = isArraySpecial(nums5, queries5);\n    for(bool res : result5) cout << res << \" \";\n    cout << endl;\n\n    vector<int> nums6 = {1, 2, 1, 2};\n    vector<vector<int>> queries6 = {{0, 3}};\n    vector<bool> result6 = isArraySpecial(nums6, queries6);\n    for(bool res : result6) cout << res << \" \";\n    cout << endl;\n\n    vector<int> nums7 = {3, 5, 7};\n    vector<vector<int>> queries7 = {{0, 2}, {0, 1}};\n    vector<bool> result7 = isArraySpecial(nums7, queries7);\n    for(bool res : result7) cout << res << \" \";\n    cout << endl;\n\n    vector<int> nums8 = {10, 11};\n    vector<vector<int>> queries8 = {{0, 1}, {1, 1}};\n    vector<bool> result8 = isArraySpecial(nums8, queries8);\n    for(bool res : result8) cout << res << \" \";\n    cout << endl;\n\n    vector<int> nums9 = {-5, -10, -3, 2};\n    vector<vector<int>> queries9 = {{0, 2}, {1, 3}};\n    vector<bool> result9 = isArraySpecial(nums9, queries9);\n    for(bool res : result9) cout << res << \" \";\n    cout << endl;\n\n    vector<int> nums10 = {1, 0, 2, 3, 4};\n    vector<vector<int>> queries10 = {{1, 3}, {2, 4}};\n    vector<bool> result10 = isArraySpecial(nums10, queries10);\n    for(bool res : result10) cout << res << \" \";\n    cout << endl;\n\n    return 0;\n}", "TAG": "Success"}
{"source_Lan": "python###countOfPairs.py", "source_code_str": "def countOfPairs( nums):\n        MOD = 1_000_000_007\n        m = len(nums)\n        n = max(nums)\n        f = [0] * (n + 1)\n        \n        for v in range(nums[0] + 1):\n            f[v] = 1\n        preSums = []\n        \n        for i in range(1, m + 1):\n            \n            preSums.clear()\n            preSum = 0\n            for v in f:\n                preSum += v\n                preSum %= MOD\n                preSums.append(preSum)\n            \n            if i == m:\n                return preSums[-1]\n            \n            for j in range(nums[i] + 1):\n                ceil = min(j, nums[i-1] - nums[i] + j)\n                if ceil >= 0:\n                    f[j] = preSums[ceil]\n                else:  \n                    f[j] = 0\n            for j in range(nums[i] + 1, len(f)):\n                f[j] = 0\n        \n        return 0", "source_code_block": "", "target_Lan": "cpp###countOfPairs.cpp", "reference_code": "int countOfPairs(vector<int>& nums) {\n        const int MOD = 1e9 + 7;\n        int m = nums.size();\n        int n = *max_element(nums.begin(), nums.end());\n        vector<int> f(n + 1);\n        \n        for (int v = 0; v <= nums[0]; ++v)\n            f[v] = 1;\n        vector<int> preSums;\n        \n        for (int i = 1; i <= m; ++i) {\n            \n            preSums.clear();\n            int preSum = 0;\n            for(int v : f){\n                preSum += v;\n                preSum %= MOD; \n                preSums.push_back(preSum);\n            }\n            \n            if (i == m) return preSums.back();\n            \n            for (int j = 0; j <= nums[i]; ++j) {\n                int ceil = min(j, nums[i-1] - nums[i] + j);\n                if (ceil >= 0)\n                    f[j] = preSums[ceil];\n                else \n                    f[j] = 0;\n            }\n            for (int j = nums[i] + 1; j < f.size(); ++j) {\n                f[j] = 0;\n            }\n        }\n        \n        return 0;\n    }", "target_method_signature": "countOfPairs", "source_method_signature": "countOfPairs", "target_allMS": "int countOfPairs(vector<int>& nums) {", "source_allMS": "def countOfPairs( nums):", "source_import": "from typing import List", "target_import": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;", "commentTag": "//", "TAG": "Success", "source_code_shell": "from typing import List\n\n# TOFILL\nif __name__ == \"__main__\":\n    print(countOfPairs([0]))                                  # Test with one element set to zero\n    print(countOfPairs([1, 2, 3]))                           # Test with a small set of positive integers\n    print(countOfPairs([2, 2, 2]))                           # Test with duplicate values\n    print(countOfPairs([5, 3, 4]))                           # Mixed values to test non-sequential cases\n    print(countOfPairs([10, 5, 5, 10, 10]))                  # More complex case with larger numbers\n    print(countOfPairs([-1, 0, 1]))                          # Negative and positive values\n    print(countOfPairs([100000, 200000]))                    # Testing with large values\n    print(countOfPairs([1, 3, 6, 8]))                        # Non-contiguous values\n    print(countOfPairs([1, 0, 2, 3, 4, 5, 6, 7]))          # Extended range with a mix of values", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <algorithm>\n// TOFILL\nint main() {\n    vector<vector<int>> testInputs = {\n        {0},\n        {1, 2, 3},\n        {2, 2, 2},\n        {5, 3, 4},\n        {10, 5, 5, 10, 10},\n        {-1, 0, 1},\n        {100000, 200000},\n        {1, 3, 6, 8},\n        {1, 0, 2, 3, 4, 5, 6, 7}\n    };\n\n    for(auto& nums : testInputs) {\n        cout << countOfPairs(nums) << endl;\n    }\n}", "input_output_value": ["\ninput1: nums=[0]\noutput1: 1\n", "\ninput2: nums=[1, 2, 3]\noutput2: 4\n", "\ninput3: nums=[2, 2, 2]\noutput3: 10\n"], "all_input_output_value": "\ninput1: nums=[0]\noutput1: 1\n--------\ninput2: nums=[1, 2, 3]\noutput2: 4\n--------\ninput3: nums=[2, 2, 2]\noutput3: 10\n--------\ninput4: nums=[5, 3, 4]\noutput4: 20\n--------\ninput5: nums=[10, 5, 5, 10, 10]\noutput5: 252\n--------\ninput6: nums=[-1, 0, 1]\noutput6: 0\n--------\ninput7: nums=[100000, 200000]\noutput7: 149966\n--------\ninput8: nums=[1, 3, 6, 8]\noutput8: 5\n--------\ninput9: nums=[1, 0, 2, 3, 4, 5, 6, 7]\noutput9: 1\n"}
{"source_Lan": "python###winningPlayerCount.py", "source_code_str": "def winningPlayerCount( n: int, pick: List[List[int]]) -> int:\n        cnts = [[0] * 11 for _ in range(n)]\n        for x, y in pick:\n            cnts[x][y] += 1\n        ans = 0\n        for i, cnt in enumerate(cnts):\n            if any(c > i for c in cnt):\n                ans += 1\n        return ans", "source_code_block": "", "target_Lan": "cpp###winningPlayerCount.cpp", "reference_code": "int winningPlayerCount(int n, vector<vector<int>>& pick) {\n        vector<array<int, 11>> cnts(n);\n        for (auto& p : pick) {\n            cnts[p[0]][p[1]]++;\n        }\n        int ans = 0;\n        for (int i = 0; i < n; i++) {\n            for (int c : cnts[i]) {\n                if (c > i) {\n                    ans++;\n                    break;\n                }\n            }\n        }\n        return ans;\n    }", "target_method_signature": "winningPlayerCount", "source_method_signature": "winningPlayerCount", "target_allMS": "int winningPlayerCount(int n, vector<vector<int>>& pick) {", "source_allMS": "def winningPlayerCount( n: int, pick: List[List[int]]) -> int:", "source_import": "from typing import List", "target_import": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <array>", "commentTag": "//", "source_code_shell": "from typing import List\nfrom typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(winningPlayerCount(5, [[0, 1], [1, 3], [2, 1], [3, 4], [4, 4]]))\n    print(winningPlayerCount(3, [[0, 0], [1, 0], [2, 1]]))\n    print(winningPlayerCount(4, []))\n    print(winningPlayerCount(2, [[0, 1], [1, 1]]))\n    print(winningPlayerCount(6, [[0, 0], [1, 1], [2, 2], [3, 3], [4, 4], [5, 6]]))\n    print(winningPlayerCount(1, [[0, 0]]))\n    print(winningPlayerCount(2, [[0, 1], [1, 0], [1, 2]]))\n    print(winningPlayerCount(0, []))\n    print(winningPlayerCount(3, [[0, 0], [1, 2], [2, 1], [2, 2]]))", "all_input_output_value": "\ninput1: n=5, pick=[[0, 1], [1, 3], [2, 1], [3, 4], [4, 4]]\noutput1: 1\n--------\ninput2: n=3, pick=[[0, 0], [1, 0], [2, 1]]\noutput2: 1\n--------\ninput3: n=4, pick=[]\noutput3: 0\n--------\ninput4: n=2, pick=[[0, 1], [1, 1]]\noutput4: 1\n--------\ninput5: n=6, pick=[[0, 0], [1, 1], [2, 2], [3, 3], [4, 4], [5, 6]]\noutput5: 1\n--------\ninput6: n=1, pick=[[0, 0]]\noutput6: 1\n--------\ninput7: n=2, pick=[[0, 1], [1, 0], [1, 2]]\noutput7: 1\n--------\ninput8: n=0, pick=[]\noutput8: 0\n--------\ninput9: n=3, pick=[[0, 0], [1, 2], [2, 1], [2, 2]]\noutput9: 1\n", "input_output_value": ["\ninput1: n=5, pick=[[0, 1], [1, 3], [2, 1], [3, 4], [4, 4]]\noutput1: 1\n", "\ninput2: n=3, pick=[[0, 0], [1, 0], [2, 1]]\noutput2: 1\n", "\ninput3: n=4, pick=[]\noutput3: 0\n"], "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <array>\n#include <iostream>\n#include <vector>\n#include <array>\n// TOFILL\nint main() {\n    vector<vector<int>> pick1 = {{0, 1}, {1, 3}, {2, 1}, {3, 4}, {4, 4}};\n    cout << winningPlayerCount(5, pick1) << endl;\n\n    vector<vector<int>> pick2 = {{0, 0}, {1, 0}, {2, 1}};\n    cout << winningPlayerCount(3, pick2) << endl;\n\n    vector<vector<int>> pick3 = {};\n    cout << winningPlayerCount(4, pick3) << endl;\n\n    vector<vector<int>> pick4 = {{0, 1}, {1, 1}};\n    cout << winningPlayerCount(2, pick4) << endl;\n\n    vector<vector<int>> pick5 = {{0, 0}, {1, 1}, {2, 2}, {3, 3}, {4, 4}, {5, 6}};\n    cout << winningPlayerCount(6, pick5) << endl;\n\n    vector<vector<int>> pick6 = {{0, 0}};\n    cout << winningPlayerCount(1, pick6) << endl;\n\n    vector<vector<int>> pick7 = {{0, 1}, {1, 0}, {1, 2}};\n    cout << winningPlayerCount(2, pick7) << endl;\n\n    vector<vector<int>> pick8 = {};\n    cout << winningPlayerCount(0, pick8) << endl;\n\n    vector<vector<int>> pick9 = {{0, 0}, {1, 2}, {2, 1}, {2, 2}};\n    cout << winningPlayerCount(3, pick9) << endl;\n\n    return 0;\n}", "TAG": "Success"}
{"source_Lan": "python###minFlips.py", "source_code_str": "def minFlips( a: List[List[int]]) -> int:\n        ans = 0\n        m, n = len(a), len(a[0])\n        for i in range(m // 2):\n            row, row2 = a[i], a[-1 - i]\n            for j in range(n // 2):\n                cnt1 = row[j] + row[-1 - j] + row2[j] + row2[-1 - j]\n                ans += min(cnt1, 4 - cnt1)  \n        if m % 2 and n % 2:\n            \n            ans += a[m // 2][n // 2]\n        diff = cnt1 = 0\n        if m % 2:\n            \n            row = a[m // 2]\n            for j in range(n // 2):\n                if row[j] != row[-1 - j]:\n                    diff += 1\n                else:\n                    cnt1 += row[j] * 2\n        if n % 2:\n            \n            for i in range(m // 2):\n                if a[i][n // 2] != a[- 1 - i][n // 2]:\n                    diff += 1\n                else:\n                    cnt1 += a[i][n // 2] * 2\n        return ans + (diff if diff else cnt1 % 4)", "source_code_block": "", "target_Lan": "cpp###minFlips.cpp", "reference_code": "int minFlips(vector<vector<int>>& a) {\n        int m = a.size(), n = a[0].size(), ans = 0;\n        for (int i = 0; i < m / 2; i++) {\n            for (int j = 0; j < n / 2; j++) {\n                int cnt1 = a[i][j] + a[i][n - 1 - j] + a[m - 1 - i][j] + a[m - 1 - i][n - 1 - j];\n                ans += min(cnt1, 4 - cnt1);  \n            }\n        }\n        if (m % 2 && n % 2) {\n            \n            ans += a[m / 2][n / 2];\n        }\n        int diff = 0, cnt1 = 0;\n        if (m % 2) {\n            \n            for (int j = 0; j < n / 2; j++) {\n                if (a[m / 2][j] != a[m / 2][n - 1 - j]) {\n                    diff++;\n                } else {\n                    cnt1 += a[m / 2][j] * 2;\n                }\n            }\n        }\n        if (n % 2) {\n            \n            for (int i = 0; i < m / 2; i++) {\n                if (a[i][n / 2] != a[m - 1 - i][n / 2]) {\n                    diff++;\n                } else {\n                    cnt1 += a[i][n / 2] * 2;\n                }\n            }\n        }\n        return ans + (diff ? diff : cnt1 % 4);\n    }", "target_method_signature": "minFlips", "source_method_signature": "minFlips", "target_allMS": "int minFlips(vector<vector<int>>& a) {", "source_allMS": "def minFlips( a: List[List[int]]) -> int:", "source_import": "from typing import List", "target_import": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>", "commentTag": "//", "source_code_shell": "from typing import List\nfrom typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(minFlips([[0]]))\n    print(minFlips([[0, 0], [0, 0]]))\n    print(minFlips([[0, 1], [1, 0]]))\n    print(minFlips([[0, 1, 0], [1, 1, 1], [0, 1, 0]]))\n    print(minFlips([[1, 0], [0, 1]]))\n    print(minFlips([[0, 0, 0], [1, 0, 1]]))\n    print(minFlips([[1, 0], [0, 0], [1, 1]]))\n    print(minFlips([[1, 0, 1], [0, 0, 0], [1, 1, 0]]))\n    print(minFlips([[0, 1, 0, 0], [1, 0, 1, 1], [0, 1, 0, 0], [1, 1, 1, 1]]))", "all_input_output_value": "\ninput1: a=[[0]]\noutput1: 0\n--------\ninput2: a=[[0, 0], [0, 0]]\noutput2: 0\n--------\ninput3: a=[[0, 1], [1, 0]]\noutput3: 2\n--------\ninput4: a=[[0, 1, 0], [1, 1, 1], [0, 1, 0]]\noutput4: 1\n--------\ninput5: a=[[1, 0], [0, 1]]\noutput5: 2\n--------\ninput6: a=[[0, 0, 0], [1, 0, 1]]\noutput6: 2\n--------\ninput7: a=[[1, 0], [0, 0], [1, 1]]\noutput7: 1\n--------\ninput8: a=[[1, 0, 1], [0, 0, 0], [1, 1, 0]]\noutput8: 2\n--------\ninput9: a=[[0, 1, 0, 0], [1, 0, 1, 1], [0, 1, 0, 0], [1, 1, 1, 1]]\noutput9: 7\n", "input_output_value": ["\ninput1: a=[[0]]\noutput1: 0\n", "\ninput2: a=[[0, 0], [0, 0]]\noutput2: 0\n", "\ninput3: a=[[0, 1], [1, 0]]\noutput3: 2\n"], "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    vector<vector<int>> input1 = {{0}};\n    vector<vector<int>> input2 = {{0, 0}, {0, 0}};\n    vector<vector<int>> input3 = {{0, 1}, {1, 0}};\n    vector<vector<int>> input4 = {{0, 1, 0}, {1, 1, 1}, {0, 1, 0}};\n    vector<vector<int>> input5 = {{1, 0}, {0, 1}};\n    vector<vector<int>> input6 = {{0, 0, 0}, {1, 0, 1}};\n    vector<vector<int>> input7 = {{1, 0}, {0, 0}, {1, 1}};\n    vector<vector<int>> input8 = {{1, 0, 1}, {0, 0, 0}, {1, 1, 0}};\n    vector<vector<int>> input9 = {{0, 1, 0, 0}, {1, 0, 1, 1}, {0, 1, 0, 0}, {1, 1, 1, 1}};\n    \n    cout << minFlips(input1) << endl;\n    cout << minFlips(input2) << endl;\n    cout << minFlips(input3) << endl;\n    cout << minFlips(input4) << endl;\n    cout << minFlips(input5) << endl;\n    cout << minFlips(input6) << endl;\n    cout << minFlips(input7) << endl;\n    cout << minFlips(input8) << endl;\n    cout << minFlips(input9) << endl;\n\n    return 0;\n}", "TAG": "Success"}
{"source_Lan": "python###canAliceWin.py", "source_code_str": "def canAliceWin( nums: List[int]) -> bool:\n        return sum(x if x < 10 else -x for x in nums) != 0", "source_code_block": "", "target_Lan": "cpp###canAliceWin.cpp", "reference_code": "bool canAliceWin(vector<int>& nums) {\n        int s = 0;\n        for (int x : nums) {\n            s += x < 10 ? x : -x;\n        }\n        return s; \n    }", "target_method_signature": "canAliceWin", "source_method_signature": "canAliceWin", "target_allMS": "bool canAliceWin(vector<int>& nums) {", "source_allMS": "def canAliceWin( nums: List[int]) -> bool:", "source_import": "from typing import List", "target_import": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>", "commentTag": "//", "source_code_shell": "from typing import List\nfrom typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(canAliceWin([1, 2, 3]))        # All elements < 10\n    print(canAliceWin([10, 15, 20]))     # All elements >= 10\n    print(canAliceWin([5, 12, 7]))       # Mixed elements\n    print(canAliceWin([10, 10, 10]))     # Edge case with 10\n    print(canAliceWin([0, -5, -10]))     # Includes negative numbers\n    print(canAliceWin([9, 8, 7, 20, 30])) # Mostly < 10 but some >= 10\n    print(canAliceWin([5]))               # Single element < 10\n    print(canAliceWin([15]))              # Single element >= 10\n    print(canAliceWin([0]))               # Single element 0\n    print(canAliceWin([-1, -2, 11]))     # Mixed with negatives and a large positive", "all_input_output_value": "\ninput1: nums=[1, 2, 3]\noutput1: True\n--------\ninput2: nums=[10, 15, 20]\noutput2: True\n--------\ninput3: nums=[5, 12, 7]\noutput3: False\n--------\ninput4: nums=[10, 10, 10]\noutput4: True\n--------\ninput5: nums=[0, -5, -10]\noutput5: True\n--------\ninput6: nums=[9, 8, 7, 20, 30]\noutput6: True\n--------\ninput7: nums=[5]\noutput7: True\n--------\ninput8: nums=[15]\noutput8: True\n--------\ninput9: nums=[0]\noutput9: False\n--------\ninput10: nums=[-1, -2, 11]\noutput10: True\n", "input_output_value": ["\ninput1: nums=[1, 2, 3]\noutput1: True\n", "\ninput2: nums=[10, 15, 20]\noutput2: True\n", "\ninput3: nums=[5, 12, 7]\noutput3: False\n"], "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    vector<int> input1 = {1, 2, 3};\n    vector<int> input2 = {10, 15, 20};\n    vector<int> input3 = {5, 12, 7};\n    vector<int> input4 = {10, 10, 10};\n    vector<int> input5 = {0, -5, -10};\n    vector<int> input6 = {9, 8, 7, 20, 30};\n    vector<int> input7 = {5};\n    vector<int> input8 = {15};\n    vector<int> input9 = {0};\n    vector<int> input10 = {-1, -2, 11};\n\n    cout << canAliceWin(input1) << endl;\n    cout << canAliceWin(input2) << endl;\n    cout << canAliceWin(input3) << endl;\n    cout << canAliceWin(input4) << endl;\n    cout << canAliceWin(input5) << endl;\n    cout << canAliceWin(input6) << endl;\n    cout << canAliceWin(input7) << endl;\n    cout << canAliceWin(input8) << endl;\n    cout << canAliceWin(input9) << endl;\n    cout << canAliceWin(input10) << endl;\n\n    return 0;\n}", "TAG": "Success"}
{"source_Lan": "python###numberOfSubstrings.py", "source_code_str": "def numberOfSubstrings( s: str) -> int:\n        n = len(s)\n        a = [i for i, b in enumerate(s) if b == '0']\n        tot1 = n - len(a)\n        a.append(n)  \n        ans = i = 0  \n        for left, b in enumerate(s):\n            if b == '1':\n                ans += a[i] - left  \n            for k in range(i, len(a) - 1):\n                cnt0 = k - i + 1\n                if cnt0 * cnt0 > tot1:\n                    break\n                cnt1 = a[k] - left - (k - i)\n                \n                ans += max(a[k + 1] - a[k] - max(cnt0 * cnt0 - cnt1, 0), 0)\n            if b == '0':\n                i += 1  \n        return ans", "source_code_block": "", "target_Lan": "cpp###numberOfSubstrings.cpp", "reference_code": "int numberOfSubstrings(string s) {\n        int n = s.length();\n        vector<int> a;\n        for (int i = 0; i < n; i++) {\n            if (s[i] == '0') {\n                a.push_back(i);\n            }\n        }\n        int tot1 = n - a.size();\n        a.push_back(n); \n        int ans = 0, i = 0; \n        for (int left = 0; left < n; left++) {\n            if (s[left] == '1') {\n                ans += a[i] - left; \n            }\n            for (int k = i; k < a.size() - 1; k++) {\n                int cnt0 = k - i + 1;\n                if (cnt0 * cnt0 > tot1) {\n                    break;\n                }\n                int cnt1 = a[k] - left - (k - i);\n                ans += max(a[k + 1] - a[k] - max(cnt0 * cnt0 - cnt1, 0), 0);\n            }\n            if (s[left] == '0') {\n                i++; \n            }\n        }\n        return ans;\n    }", "target_method_signature": "numberOfSubstrings", "source_method_signature": "numberOfSubstrings", "target_allMS": "int numberOfSubstrings(string s) {", "source_allMS": "def numberOfSubstrings( s: str) -> int:", "source_import": "", "target_import": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <string>", "commentTag": "//", "source_code_shell": "# TOFILL\nif __name__ == \"__main__\":\n    test_inputs = [\"1\", \"0\", \"00\", \"11\", \"101\", \"010\", \"1100\", \"0011\", \"1110\", \"0001\"]\n    for s in test_inputs:\n        print(f\"Input: {s}, Output: {numberOfSubstrings(s)}\")", "all_input_output_value": "\ninput1: s=\"1\"\noutput1: 1\n--------\ninput2: s=\"0\"\noutput2: 0\n--------\ninput3: s=\"00\"\noutput3: 0\n--------\ninput4: s=\"11\"\noutput4: 3\n--------\ninput5: s=\"101\"\noutput5: 5\n--------\ninput6: s=\"010\"\noutput6: 3\n--------\ninput7: s=\"1100\"\noutput7: 5\n--------\ninput8: s=\"0011\"\noutput8: 5\n--------\ninput9: s=\"1110\"\noutput9: 9\n--------\ninput10: s=\"0001\"\noutput10: 2\n", "input_output_value": ["\ninput1: s=\"1\"\noutput1: 1\n", "\ninput2: s=\"0\"\noutput2: 0\n", "\ninput3: s=\"00\"\noutput3: 0\n"], "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <vector>\n#include <string>\n// TOFILL\nint main() {\n    cout << numberOfSubstrings(\"1\") << endl;\n    cout << numberOfSubstrings(\"0\") << endl;\n    cout << numberOfSubstrings(\"00\") << endl;\n    cout << numberOfSubstrings(\"11\") << endl;\n    cout << numberOfSubstrings(\"101\") << endl;\n    cout << numberOfSubstrings(\"010\") << endl;\n    cout << numberOfSubstrings(\"1100\") << endl;\n    cout << numberOfSubstrings(\"0011\") << endl;\n    cout << numberOfSubstrings(\"1110\") << endl;\n    cout << numberOfSubstrings(\"0001\") << endl;\n}", "TAG": "Success"}
{"source_Lan": "python###countUniques.py", "source_code_str": "def countUniques( a, k, l, r):\n        \n        set_ = set()\n        dup = 0\n        for i in a:\n            if i in set_:\n                dup += 1\n            else:\n                set_.add(i)\n        unique = len(set_)\n        for i in range(l, r + 1):\n            if k > 0 and dup > 0 and i not in set_:\n                unique += 1\n                k -= 1\n                dup -= 1\n        return unique", "source_code_block": "", "target_Lan": "cpp###countUniques.cpp", "reference_code": "int countUniques(vector<int> a, int k, int l, int r) {\n        \n        unordered_set<int> set;\n        int dup = 0;\n        for (int i : a) {\n            if (!set.insert(i).second) {\n                dup++;\n            }\n        }\n        int unique = set.size();\n        for (int i = l; i <= r; i++) {\n            if (k > 0 && dup > 0 && set.find(i) == set.end()) {\n                unique++;\n                k--;\n                dup--;\n            }\n        }\n        return unique;\n    }", "target_method_signature": "countUniques", "source_method_signature": "countUniques", "target_allMS": "int countUniques(vector<int> a, int k, int l, int r) {", "source_allMS": "def countUniques( a, k, l, r):", "source_import": "", "target_import": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <unordered_set>", "commentTag": "//", "source_code_shell": "# TOFILL\nif __name__ == \"__main__\":\n    print(countUniques([], 0, 0, 0))             # Output: 0\n    print(countUniques([1, 2, 3], 0, 0, 5))      # Output: 3\n    print(countUniques([1, 1, 1], 1, 0, 2))      # Output: 2\n    print(countUniques([1, 2, 2, 3, 4], 2, 0, 5)) # Output: 5\n    print(countUniques([1, 1, 1], 3, -5, 5))     # Output: 6\n    print(countUniques([10, 10, 10, 11, 12], 2, 9, 15)) # Output: 6\n    print(countUniques([], 5, 0, 10))             # Output: 6\n    print(countUniques([2, 2, 3, 3, 4], 1, 2, 6)) # Output: 4\n    print(countUniques([4, 5, 6, 7, 8], 0, 9, 10)) # Output: 2\n    print(countUniques([5, 5, 6, 6, 7, 8, 8], 3, 5, 6)) # Output: 3", "all_input_output_value": "\ninput1: a=[], k=0, l=0, r=0\noutput1: 0\n--------\ninput2: a=[1, 2, 3], k=0, l=0, r=5\noutput2: 3\n--------\ninput3: a=[1, 1, 1], k=1, l=0, r=2\noutput3: 2\n--------\ninput4: a=[1, 2, 2, 3, 4], k=2, l=0, r=5\noutput4: 5\n--------\ninput5: a=[1, 1, 1], k=3, l=-5, r=5\noutput5: 3\n--------\ninput6: a=[10, 10, 10, 11, 12], k=2, l=9, r=15\noutput6: 5\n--------\ninput7: a=[], k=5, l=0, r=10\noutput7: 0\n--------\ninput8: a=[2, 2, 3, 3, 4], k=1, l=2, r=6\noutput8: 4\n--------\ninput9: a=[4, 5, 6, 7, 8], k=0, l=9, r=10\noutput9: 0\n--------\ninput10: a=[5, 5, 6, 6, 7, 8, 8], k=3, l=5, r=6\noutput10: 3\n", "input_output_value": ["\ninput1: a=[], k=0, l=0, r=0\noutput1: 0\n", "\ninput2: a=[1, 2, 3], k=0, l=0, r=5\noutput2: 3\n", "\ninput3: a=[1, 1, 1], k=1, l=0, r=2\noutput3: 2\n"], "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <unordered_set>\n#include <iostream>\n#include <vector>\n#include <unordered_set>\n// TOFILL\nint main() {\n    cout << countUniques({}, 0, 0, 0) << endl;                  // Test Input 1\n    cout << countUniques({1, 2, 3}, 0, 0, 5) << endl;           // Test Input 2\n    cout << countUniques({1, 1, 1}, 1, 0, 2) << endl;           // Test Input 3\n    cout << countUniques({1, 2, 2, 3, 4}, 2, 0, 5) << endl;     // Test Input 4\n    cout << countUniques({1, 1, 1}, 3, -5, 5) << endl;          // Test Input 5\n    cout << countUniques({10, 10, 10, 11, 12}, 2, 9, 15) << endl; // Test Input 6\n    cout << countUniques({}, 5, 0, 10) << endl;                  // Test Input 7\n    cout << countUniques({2, 2, 3, 3, 4}, 1, 2, 6) << endl;     // Test Input 8\n    cout << countUniques({4, 5, 6, 7, 8}, 0, 9, 10) << endl;    // Test Input 9\n    cout << countUniques({5, 5, 6, 6, 7, 8, 8}, 3, 5, 6) << endl; // Test Input 10\n}", "TAG": "Success"}
{"source_Lan": "python###firstWord.py", "source_code_str": "def firstWord( n: int, dictionary: List[str]) -> str:\n        dictionary.sort()\n        seen_words = set()\n        for word in dictionary:\n            if word in seen_words:\n                return \"Invalid\"\n            seen_words.add(word)\n        return dictionary[0]", "source_code_block": "", "target_Lan": "cpp###firstWord.cpp", "reference_code": "string firstWord(int n, vector<string> &dictionary) {\n        \n        sort(dictionary.begin(), dictionary.end());\n        for(int i=0;i<n;i++) {\n            for(int j=i+1;j<n;j++) {\n                if(dictionary[i]==dictionary[j]){\n                    return \"Invalid\";\n                }\n            }\n        }\n        return dictionary[0];\n    }", "target_method_signature": "firstWord", "source_method_signature": "firstWord", "target_allMS": "string firstWord(int n, vector<string> &dictionary) {", "source_allMS": "def firstWord( n: int, dictionary: List[str]) -> str:", "source_import": "from typing import List", "target_import": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>", "commentTag": "//", "source_code_shell": "from typing import List\nfrom typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(firstWord(1, [\"apple\"]))\n    print(firstWord(3, [\"banana\", \"apple\", \"cherry\"]))\n    print(firstWord(3, [\"grape\", \"apple\", \"apple\"]))\n    print(firstWord(4, [\"apple\", \"banana\", \"cherry\", \"date\"]))\n    print(firstWord(2, [\"apple\", \"banana\"]))\n    print(firstWord(3, [\"banana\", \"Apple\", \"apple\"]))\n    print(firstWord(3, [\"mango\", \"kiwi\", \"Kiwi\"]))\n    print(firstWord(4, [\"pear\", \"peach\", \"plum\", \"peach\"]))\n    print(firstWord(2, [\"a\", \"A\"]))", "all_input_output_value": "\ninput1: n=1, dictionary=[\"apple\"]\noutput1: apple\n--------\ninput2: n=3, dictionary=[\"banana\", \"apple\", \"cherry\"]\noutput2: apple\n--------\ninput3: n=3, dictionary=[\"grape\", \"apple\", \"apple\"]\noutput3: Invalid\n--------\ninput4: n=4, dictionary=[\"apple\", \"banana\", \"cherry\", \"date\"]\noutput4: apple\n--------\ninput5: n=2, dictionary=[\"apple\", \"banana\"]\noutput5: apple\n--------\ninput6: n=3, dictionary=[\"banana\", \"Apple\", \"apple\"]\noutput6: Apple\n--------\ninput7: n=3, dictionary=[\"mango\", \"kiwi\", \"Kiwi\"]\noutput7: Kiwi\n--------\ninput8: n=4, dictionary=[\"pear\", \"peach\", \"plum\", \"peach\"]\noutput8: Invalid\n--------\ninput9: n=2, dictionary=[\"a\", \"A\"]\noutput9: A\n", "input_output_value": ["\ninput1: n=1, dictionary=[\"apple\"]\noutput1: apple\n", "\ninput2: n=3, dictionary=[\"banana\", \"apple\", \"cherry\"]\noutput2: apple\n", "\ninput3: n=3, dictionary=[\"grape\", \"apple\", \"apple\"]\noutput3: Invalid\n"], "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n// TOFILL\nint main() {\n    vector<string> dict1 = {\"apple\"};\n    cout << firstWord(1, dict1) << endl;\n\n    vector<string> dict2 = {\"banana\", \"apple\", \"cherry\"};\n    cout << firstWord(3, dict2) << endl;\n\n    vector<string> dict3 = {\"grape\", \"apple\", \"apple\"};\n    cout << firstWord(3, dict3) << endl;\n\n    vector<string> dict4 = {\"apple\", \"banana\", \"cherry\", \"date\"};\n    cout << firstWord(4, dict4) << endl;\n\n    vector<string> dict5 = {\"apple\", \"banana\"};\n    cout << firstWord(2, dict5) << endl;\n\n    vector<string> dict6 = {\"banana\", \"Apple\", \"apple\"};\n    cout << firstWord(3, dict6) << endl;\n\n    vector<string> dict7 = {\"mango\", \"kiwi\", \"Kiwi\"};\n    cout << firstWord(3, dict7) << endl;\n\n    vector<string> dict8 = {\"pear\", \"peach\", \"plum\", \"peach\"};\n    cout << firstWord(4, dict8) << endl;\n\n    vector<string> dict9 = {\"a\", \"A\"};\n    cout << firstWord(2, dict9) << endl;\n\n    return 0;\n}", "TAG": "Success"}
{"source_Lan": "python###longestSubarray.py", "source_code_str": "def longestSubarray( n: int, arr: List[int]) -> int:\n        ans = -1\n        for i in range(n):\n            count = 0\n            total_sum = 0\n            for j in range(i, n):\n                count += 1\n                total_sum += arr[j]\n                if count == total_sum:\n                    ans = max(ans, count)\n        return ans", "source_code_block": "", "target_Lan": "cpp###longestSubarray.cpp", "reference_code": "int longestSubarray(int n, vector<int> &arr) {\n        \n        int ans=-1;\n        for(int i=0;i<n;i++){\n            int count=0;\n            int sum=0;\n            for(int j=i;j<n;j++) {\n                count++;\n                sum += arr[j];\n                if(count == sum){\n                    ans = max(ans, count);\n                }\n            }\n        }\n        return ans;\n    }", "target_method_signature": "longestSubarray", "source_method_signature": "longestSubarray", "target_allMS": "int longestSubarray(int n, vector<int> &arr) {", "source_allMS": "def longestSubarray( n: int, arr: List[int]) -> int:", "source_import": "from typing import List", "target_import": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>", "commentTag": "//", "source_code_shell": "from typing import List\nfrom typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(longestSubarray(5, [1, 2, 3, 4, 5]))  # no subarray satisfies the condition\n    print(longestSubarray(4, [1, 1, 1, 1]))      # subarray of length 4 satisfies the condition\n    print(longestSubarray(6, [0, 1, 2, 3, 4, 5]))  # subarrays of lengths 1 to 6 exist\n    print(longestSubarray(5, [1, 2, 2, 3, 4]))    # subarray of length 3 satisfies condition\n    print(longestSubarray(7, [1, 2, -3, 3, 1, 2, 0]))  # no valid subarray but mixed values\n    print(longestSubarray(3, [3, 3, 3]))          # subarray of length 3 satisfies the condition\n    print(longestSubarray(4, [1, 2, 3, 1]))       # subarray of length 3 satisfies the condition\n    print(longestSubarray(5, [-1, -1, -1, 1, 1]))  # possible subarrays with negatives\n    print(longestSubarray(5, [1, 2, 3, 0, 0]))    # checking for zeros affecting sums\n    print(longestSubarray(0, []))                   # edge case of an empty array", "all_input_output_value": "\ninput1: n=5, arr=[1, 2, 3, 4, 5]\noutput1: 1\n--------\ninput2: n=4, arr=[1, 1, 1, 1]\noutput2: 4\n--------\ninput3: n=6, arr=[0, 1, 2, 3, 4, 5]\noutput3: 3\n--------\ninput4: n=5, arr=[1, 2, 2, 3, 4]\noutput4: 1\n--------\ninput5: n=7, arr=[1, 2, -3, 3, 1, 2, 0]\noutput5: 6\n--------\ninput6: n=3, arr=[3, 3, 3]\noutput6: -1\n--------\ninput7: n=4, arr=[1, 2, 3, 1]\noutput7: 1\n--------\ninput8: n=5, arr=[-1, -1, -1, 1, 1]\noutput8: 2\n--------\ninput9: n=5, arr=[1, 2, 3, 0, 0]\noutput9: 3\n--------\ninput10: n=0, arr=[]\noutput10: -1\n", "input_output_value": ["\ninput1: n=5, arr=[1, 2, 3, 4, 5]\noutput1: 1\n", "\ninput2: n=4, arr=[1, 1, 1, 1]\noutput2: 4\n", "\ninput3: n=6, arr=[0, 1, 2, 3, 4, 5]\noutput3: 3\n"], "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    vector<int> arr1 = {1, 2, 3, 4, 5};\n    cout << longestSubarray(5, arr1) << endl; // Test input 1\n\n    vector<int> arr2 = {1, 1, 1, 1};\n    cout << longestSubarray(4, arr2) << endl; // Test input 2\n\n    vector<int> arr3 = {0, 1, 2, 3, 4, 5};\n    cout << longestSubarray(6, arr3) << endl; // Test input 3\n\n    vector<int> arr4 = {1, 2, 2, 3, 4};\n    cout << longestSubarray(5, arr4) << endl; // Test input 4\n\n    vector<int> arr5 = {1, 2, -3, 3, 1, 2, 0};\n    cout << longestSubarray(7, arr5) << endl; // Test input 5\n\n    vector<int> arr6 = {3, 3, 3};\n    cout << longestSubarray(3, arr6) << endl; // Test input 6\n\n    vector<int> arr7 = {1, 2, 3, 1};\n    cout << longestSubarray(4, arr7) << endl; // Test input 7\n\n    vector<int> arr8 = {-1, -1, -1, 1, 1};\n    cout << longestSubarray(5, arr8) << endl; // Test input 8\n\n    vector<int> arr9 = {1, 2, 3, 0, 0};\n    cout << longestSubarray(5, arr9) << endl; // Test input 9\n\n    vector<int> arr10 = {};\n    cout << longestSubarray(0, arr10) << endl; // Test input 10\n\n    return 0;\n}", "TAG": "Success"}
{"source_Lan": "python###reachAlice.py", "source_code_str": "def reachAlice(d: int, x: int, y: int, k: int) -> str:\n    p = d // x\n    q = d // y\n    q += k\n    return \"Walk\" if p <= q else \"Bike\"\n    ", "source_code_block": "", "target_Lan": "cpp###reachAlice.cpp", "reference_code": "string reachAlice(int d, int x, int y, int k) {\n        int t1 = d / x;\n        int t2 = d / y + k;\n        if (t1 <= t2)\n            return \"Walk\";\n        return \"Bike\";\n    }", "target_method_signature": "reachAlice", "source_method_signature": "reachAlice", "target_allMS": "string reachAlice(int d, int x, int y, int k) {", "source_allMS": "def reachAlice( d: int, x: int, y: int, k: int) -> str:", "source_import": "", "target_import": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <string>", "commentTag": "//", "source_code_shell": "# TOFILL\nif __name__ == \"__main__\":\n    print(reachAlice(10, 2, 5, 0))  # Walk is faster\n    print(reachAlice(10, 5, 2, 0))  # Bike is faster\n    print(reachAlice(10, 1, 1, 5))  # Both take equal time\n    print(reachAlice(0, 1, 1, 0))   # Edge case, no distance to cover\n    print(reachAlice(20, 5, 10, 1))  # Walking and biking with additional time\n    print(reachAlice(100, 25, 50, 0))  # Bike is faster with more distance\n    print(reachAlice(15, 3, 3, 1))   # Both the same but biking takes longer due to k\n    print(reachAlice(30, 10, 10, 3))  # Equal speeds but k favors walking", "all_input_output_value": "\ninput1: d=10, x=2, y=5, k=0\noutput1: Bike\n--------\ninput2: d=10, x=5, y=2, k=0\noutput2: Walk\n--------\ninput3: d=10, x=1, y=1, k=5\noutput3: Walk\n--------\ninput4: d=0, x=1, y=1, k=0\noutput4: Walk\n--------\ninput5: d=20, x=5, y=10, k=1\noutput5: Bike\n--------\ninput6: d=100, x=25, y=50, k=0\noutput6: Bike\n--------\ninput7: d=15, x=3, y=3, k=1\noutput7: Walk\n--------\ninput8: d=30, x=10, y=10, k=3\noutput8: Walk\n", "input_output_value": ["\ninput1: d=10, x=2, y=5, k=0\noutput1: Bike\n", "\ninput2: d=10, x=5, y=2, k=0\noutput2: Walk\n", "\ninput3: d=10, x=1, y=1, k=5\noutput3: Walk\n"], "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <string>\n#include <iostream>\n#include <string>\n// TOFILL\nint main() {\n    cout << reachAlice(10, 2, 5, 0) << endl;\n    cout << reachAlice(10, 5, 2, 0) << endl;\n    cout << reachAlice(10, 1, 1, 5) << endl;\n    cout << reachAlice(0, 1, 1, 0) << endl;\n    cout << reachAlice(20, 5, 10, 1) << endl;\n    cout << reachAlice(100, 25, 50, 0) << endl;\n    cout << reachAlice(15, 3, 3, 1) << endl;\n    cout << reachAlice(30, 10, 10, 3) << endl;\n}", "TAG": "Success"}
{"source_Lan": "python###splitNum.py", "source_code_str": "def splitNum( num: int) -> int:\n    stnum = \"\".join(sorted(str(num)))\n    num1, num2 = int(stnum[::2]), int(stnum[1::2])\n    return num1 + num2", "source_code_block": "", "target_Lan": "cpp###splitNum.cpp", "reference_code": "int splitNum(int num) {\n        string stnum = to_string(num);\n        sort(stnum.begin(), stnum.end());\n        int num1 = 0, num2 = 0;\n        for (int i = 0; i < stnum.size(); ++i) {\n            if (i % 2 == 0) {\n                num1 = num1 * 10 + (stnum[i] - '0');\n            }\n            else {\n                num2 = num2 * 10 + (stnum[i] - '0');\n            }\n        }\n        return num1 + num2;\n    }", "target_method_signature": "splitNum", "source_method_signature": "splitNum", "target_allMS": "int splitNum(int num) {", "source_allMS": "def splitNum( num: int) -> int:", "source_import": "", "target_import": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <string>\n#include <algorithm>", "commentTag": "//", "source_code_shell": "# TOFILL\nif __name__ == \"__main__\":\n    print(splitNum(12))\n    print(splitNum(321))\n    print(splitNum(4444))\n    print(splitNum(123456))\n    print(splitNum(987654321))\n    print(splitNum(10))\n    print(splitNum(1001))\n    print(splitNum(1000000))", "all_input_output_value": "\ninput1: num=12\noutput1: 3\n--------\ninput2: num=321\noutput2: 15\n--------\ninput3: num=4444\noutput3: 88\n--------\ninput4: num=123456\noutput4: 381\n--------\ninput5: num=987654321\noutput5: 16047\n--------\ninput6: num=10\noutput6: 1\n--------\ninput7: num=1001\noutput7: 2\n--------\ninput8: num=1000000\noutput8: 1\n", "input_output_value": ["\ninput1: num=12\noutput1: 3\n", "\ninput2: num=321\noutput2: 15\n", "\ninput3: num=4444\noutput3: 88\n"], "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <iostream>\n#include <string>\n#include <algorithm>\n// TOFILL\nint main() {\n    cout << splitNum(12) << endl;\n    cout << splitNum(321) << endl;\n    cout << splitNum(4444) << endl;\n    cout << splitNum(123456) << endl;\n    cout << splitNum(987654321) << endl;\n    cout << splitNum(10) << endl;\n    cout << splitNum(1001) << endl;\n    cout << splitNum(1000000) << endl;\n}", "TAG": "Success"}
{"source_Lan": "python###countKConstraintSubstrings.py", "source_code_str": "def countKConstraintSubstrings(s: str, k: int) -> int:\n        ans = left = 0\n        cnt = [0, 0]\n        for i, c in enumerate(s):\n            cnt[ord(c) & 1] += 1\n            while cnt[0] > k and cnt[1] > k:\n                cnt[ord(s[left]) & 1] -= 1\n                left += 1\n            ans += i - left + 1\n        return ans\n\n", "source_code_block": "", "target_Lan": "cpp###countKConstraintSubstrings.cpp", "reference_code": "int countKConstraintSubstrings(string s, int k) {\n        int ans = 0, left = 0, cnt[2]{};\n        for (int i = 0; i < s.length(); i++) {\n            cnt[s[i] & 1]++;\n            while (cnt[0] > k && cnt[1] > k) {\n                cnt[s[left++] & 1]--;\n            }\n            ans += i - left + 1;\n        }\n        return ans;\n    }\n\n", "target_method_signature": "countKConstraintSubstrings", "source_method_signature": "countKConstraintSubstrings", "target_allMS": "", "source_allMS": "", "source_import": "\n", "target_import": "#include <iostream>\n#include <string>\nusing namespace std;\n\n", "commentTag": "", "target_code_shell": "#include <iostream>\n#include <string>\nusing namespace std;\n#include <iostream>\n#include <string>\n// TOFILL\nint main() {\n    cout << countKConstraintSubstrings(\"\", 0) << endl;\n    cout << countKConstraintSubstrings(\"000000\", 2) << endl;\n    cout << countKConstraintSubstrings(\"111111\", 2) << endl;\n    cout << countKConstraintSubstrings(\"0101010101\", 3) << endl;\n    cout << countKConstraintSubstrings(\"110011\", 1) << endl;\n    cout << countKConstraintSubstrings(\"111000\", 1) << endl;\n    cout << countKConstraintSubstrings(\"000111\", 2) << endl;\n    cout << countKConstraintSubstrings(\"1010101010\", 5) << endl;\n    cout << countKConstraintSubstrings(\"0011001100\", 3) << endl;\n    cout << countKConstraintSubstrings(\"00001111\", 4) << endl;\n}", "all_input_output_value": "\ninput1: s=\"\", k=0\noutput1: 0\n--------\ninput2: s=\"000000\", k=2\noutput2: 21\n--------\ninput3: s=\"111111\", k=2\noutput3: 21\n--------\ninput4: s=\"0101010101\", k=3\noutput4: 49\n--------\ninput5: s=\"110011\", k=1\noutput5: 15\n--------\ninput6: s=\"111000\", k=1\noutput6: 17\n--------\ninput7: s=\"000111\", k=2\noutput7: 20\n--------\ninput8: s=\"1010101010\", k=5\noutput8: 55\n--------\ninput9: s=\"0011001100\", k=3\noutput9: 49\n--------\ninput10: s=\"00001111\", k=4\noutput10: 36\n", "input_output_value": ["\ninput1: s=\"\", k=0\noutput1: 0\n", "\ninput2: s=\"000000\", k=2\noutput2: 21\n", "\ninput3: s=\"111111\", k=2\noutput3: 21\n"], "TAG": "Success", "source_code_shell": "# TOFILL\nif __name__ == \"__main__\":\n    print(countKConstraintSubstrings(\"\", 0))\n    print(countKConstraintSubstrings(\"000000\", 2))\n    print(countKConstraintSubstrings(\"111111\", 2))\n    print(countKConstraintSubstrings(\"0101010101\", 3))\n    print(countKConstraintSubstrings(\"110011\", 1))\n    print(countKConstraintSubstrings(\"111000\", 1))\n    print(countKConstraintSubstrings(\"000111\", 2))\n    print(countKConstraintSubstrings(\"1010101010\", 5))\n    print(countKConstraintSubstrings(\"0011001100\", 3))\n    print(countKConstraintSubstrings(\"00001111\", 4))"}
{"source_Lan": "python###resultsArray.py", "source_code_str": "def resultsArray(nums: List[int], k: int) -> List[int]:\n        ans = [-1] * (len(nums) - k + 1)\n        cnt = 0\n        for i, x in enumerate(nums):\n            cnt = cnt + 1 if i == 0 or x == nums[i - 1] + 1 else 1\n            if cnt >= k:\n                ans[i - k + 1] = x\n        return ans\n\n", "source_code_block": "", "target_Lan": "cpp###resultsArray.cpp", "reference_code": "vector<int> resultsArray(vector<int>& nums, int k) {\n        vector<int> ans(nums.size() - k + 1, -1);\n        int cnt = 0;\n        for (int i = 0; i < nums.size(); i++) {\n            cnt = i == 0 || nums[i] == nums[i - 1] + 1 ? cnt + 1 : 1;\n            if (cnt >= k) {\n                ans[i - k + 1] = nums[i];\n            }\n        }\n        return ans;\n    }\n\n", "target_method_signature": "resultsArray", "source_method_signature": "resultsArray", "target_allMS": "", "source_allMS": "", "source_import": "from typing import List\n", "target_import": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n", "commentTag": "", "target_code_shell": "#include <iostream>\n#include <vector>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    vector<int> input1 = {1, 2, 3, 4, 5};\n    vector<int> result1 = resultsArray(input1, 3);\n    for(int i : result1) cout << i << \" \";\n    cout << endl;\n\n    vector<int> input2 = {1, 3, 4, 2, 5};\n    vector<int> result2 = resultsArray(input2, 2);\n    for(int i : result2) cout << i << \" \";\n    cout << endl;\n\n    vector<int> input3 = {5, 6, 7, 8, 9};\n    vector<int> result3 = resultsArray(input3, 5);\n    for(int i : result3) cout << i << \" \";\n    cout << endl;\n\n    vector<int> input4 = {10, 11, 12, 14, 15};\n    vector<int> result4 = resultsArray(input4, 3);\n    for(int i : result4) cout << i << \" \";\n    cout << endl;\n\n    vector<int> input5 = {1, 2, 3};\n    vector<int> result5 = resultsArray(input5, 4);\n    for(int i : result5) cout << i << \" \";\n    cout << endl;\n\n    vector<int> input6 = {};\n    vector<int> result6 = resultsArray(input6, 1);\n    for(int i : result6) cout << i << \" \";\n    cout << endl;\n\n    vector<int> input7 = {1};\n    vector<int> result7 = resultsArray(input7, 1);\n    for(int i : result7) cout << i << \" \";\n    cout << endl;\n\n    vector<int> input8 = {1, 2, 3, 5, 6};\n    vector<int> result8 = resultsArray(input8, 2);\n    for(int i : result8) cout << i << \" \";\n    cout << endl;\n\n    vector<int> input9 = {1, 2, 3, 4, 6, 7};\n    vector<int> result9 = resultsArray(input9, 3);\n    for(int i : result9) cout << i << \" \";\n    cout << endl;\n\n    vector<int> input10 = {1, 3, 5, 7};\n    vector<int> result10 = resultsArray(input10, 2);\n    for(int i : result10) cout << i << \" \";\n    cout << endl;\n\n    return 0;\n}", "all_input_output_value": "\ninput1: resultsArray([1, 2, 3, 4, 5], 3)\noutput1: [3, 4, 5]\n--------\ninput2: resultsArray([1, 3, 4, 2, 5], 2)\noutput2: [-1, 4, -1, -1]\n--------\ninput3: resultsArray([5, 6, 7, 8, 9], 5)\noutput3: [9]\n--------\ninput4: resultsArray([10, 11, 12, 14, 15], 3)\noutput4: [12, -1, -1]\n--------\ninput5: resultsArray([1, 2, 3], 4)\noutput5: []\n--------\ninput6: resultsArray([], 1)\noutput6: []\n--------\ninput7: resultsArray([1], 1)\noutput7: [1]\n--------\ninput8: resultsArray([1, 2, 3, 5, 6], 2)\noutput8: [2, 3, -1, 6]\n--------\ninput9: resultsArray([1, 2, 3, 4, 6, 7], 3)\noutput9: [3, 4, -1, -1]\n--------\ninput10: resultsArray([1, 3, 5, 7], 2)\noutput10: [-1, -1, -1]\n", "input_output_value": ["\ninput1: resultsArray([1, 2, 3, 4, 5], 3)\noutput1: [3, 4, 5]\n", "\ninput2: resultsArray([1, 3, 4, 2, 5], 2)\noutput2: [-1, 4, -1, -1]\n", "\ninput3: resultsArray([5, 6, 7, 8, 9], 5)\noutput3: [9]\n"], "TAG": "Success", "source_code_shell": "from typing import List\nfrom typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(resultsArray([1, 2, 3, 4, 5], 3))\n    print(resultsArray([1, 3, 4, 2, 5], 2))\n    print(resultsArray([5, 6, 7, 8, 9], 5))\n    print(resultsArray([10, 11, 12, 14, 15], 3))\n    print(resultsArray([1, 2, 3], 4))\n    print(resultsArray([], 1))\n    print(resultsArray([1], 1))\n    print(resultsArray([1, 2, 3, 5, 6], 2))\n    print(resultsArray([1, 2, 3, 4, 6, 7], 3))\n    print(resultsArray([1, 3, 5, 7], 2))"}
{"source_Lan": "python###finalPositionOfSnake.py", "source_code_str": "def finalPositionOfSnake(n: int, commands: List[str]) -> int:\n        i = j = 0\n        for s in commands:\n            if s[0] == 'U': i -= 1\n            elif s[0] == 'D': i += 1\n            elif s[0] == 'L': j -= 1\n            else: j += 1\n        return i * n + j\n\n", "source_code_block": "", "target_Lan": "cpp###finalPositionOfSnake.cpp", "reference_code": "int finalPositionOfSnake(int n, vector<string>& commands) {\n        int i = 0, j = 0;\n        for (auto& s : commands) {\n            switch (s[0]) {\n                case 'U': i--; break;\n                case 'D': i++; break;\n                case 'L': j--; break;\n                default:  j++;\n            }\n        }\n        return i * n + j;\n    }\n\n", "target_method_signature": "finalPositionOfSnake", "source_method_signature": "finalPositionOfSnake", "target_allMS": "", "source_allMS": "", "source_import": "from typing import List\n", "target_import": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n", "commentTag": "", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <string>\n// TOFILL\nint main() {\n    vector<string> commands1 = {\"U\"};\n    cout << finalPositionOfSnake(1, commands1) << endl;\n\n    vector<string> commands2 = {\"D\"};\n    cout << finalPositionOfSnake(1, commands2) << endl;\n\n    vector<string> commands3 = {\"L\"};\n    cout << finalPositionOfSnake(1, commands3) << endl;\n\n    vector<string> commands4 = {\"R\"};\n    cout << finalPositionOfSnake(1, commands4) << endl;\n\n    vector<string> commands5 = {\"U\", \"U\", \"D\"};\n    cout << finalPositionOfSnake(2, commands5) << endl;\n\n    vector<string> commands6 = {\"L\", \"R\", \"R\"};\n    cout << finalPositionOfSnake(2, commands6) << endl;\n\n    vector<string> commands7 = {\"U\", \"D\", \"D\", \"L\"};\n    cout << finalPositionOfSnake(3, commands7) << endl;\n\n    vector<string> commands8 = {\"R\", \"R\", \"U\", \"U\"};\n    cout << finalPositionOfSnake(2, commands8) << endl;\n\n    vector<string> commands9 = {\"U\", \"D\", \"L\", \"R\"};\n    cout << finalPositionOfSnake(0, commands9) << endl;\n\n    vector<string> commands10 = {\"U\", \"D\", \"U\", \"L\", \"R\", \"D\"};\n    cout << finalPositionOfSnake(5, commands10) << endl;\n\n    return 0;\n}", "all_input_output_value": "\ninput1: finalPositionOfSnake(1, [\"U\"])\noutput1: -1\n--------\ninput2: finalPositionOfSnake(1, [\"D\"])\noutput2: 1\n--------\ninput3: finalPositionOfSnake(1, [\"L\"])\noutput3: -1\n--------\ninput4: finalPositionOfSnake(1, [\"R\"])\noutput4: 1\n--------\ninput5: finalPositionOfSnake(2, [\"U\", \"U\", \"D\"])\noutput5: -2\n--------\ninput6: finalPositionOfSnake(2, [\"L\", \"R\", \"R\"])\noutput6: 1\n--------\ninput7: finalPositionOfSnake(3, [\"U\", \"D\", \"D\", \"L\"])\noutput7: 2\n--------\ninput8: finalPositionOfSnake(2, [\"R\", \"R\", \"U\", \"U\"])\noutput8: -2\n--------\ninput9: finalPositionOfSnake(0, [\"U\", \"D\", \"L\", \"R\"])\noutput9: 0\n--------\ninput10: finalPositionOfSnake(5, [\"U\", \"D\", \"U\", \"L\", \"R\", \"D\"])\noutput10: 0\n", "input_output_value": ["\ninput1: finalPositionOfSnake(1, [\"U\"])\noutput1: -1\n", "\ninput2: finalPositionOfSnake(1, [\"D\"])\noutput2: 1\n", "\ninput3: finalPositionOfSnake(1, [\"L\"])\noutput3: -1\n"], "TAG": "Success", "source_code_shell": "from typing import List\nfrom typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(finalPositionOfSnake(1, [\"U\"]))                 # Expected output: 0\n    print(finalPositionOfSnake(1, [\"D\"]))                 # Expected output: 2\n    print(finalPositionOfSnake(1, [\"L\"]))                 # Expected output: -1\n    print(finalPositionOfSnake(1, [\"R\"]))                 # Expected output: 1\n    print(finalPositionOfSnake(2, [\"U\", \"U\", \"D\"]))       # Expected output: 0\n    print(finalPositionOfSnake(2, [\"L\", \"R\", \"R\"]))       # Expected output: 1\n    print(finalPositionOfSnake(3, [\"U\", \"D\", \"D\", \"L\"]))  # Expected output: 2\n    print(finalPositionOfSnake(2, [\"R\", \"R\", \"U\", \"U\"]))  # Expected output: 4\n    print(finalPositionOfSnake(0, [\"U\", \"D\", \"L\", \"R\"]))  # Expected output: 0\n    print(finalPositionOfSnake(5, [\"U\", \"D\", \"U\", \"L\", \"R\", \"D\"])) # Expected output: 5"}
{"source_Lan": "python###findEnemies.py", "source_code_str": "def findEnemies( n : int, m : int, k : int, col : List[int], count : List[int]) -> List[List[int]]:\n    arr=[[-1]*(m) for _ in range(n)]\n    ind=0\n    for i in range(n):\n        while count[i]>0:\n            arr[i][col[ind]]=ind\n            ind+=1\n            count[i]-=1\n    return arr", "source_code_block": "", "target_Lan": "cpp###findEnemies.cpp", "reference_code": "    vector<vector<int>> findEnemies(int n, int m, int k, vector<int> &col, vector<int> &count) {\n        vector<vector<int>> answer(n, vector<int>(m, -1));\n        int curr = 0;\n        int ind = 0;\n        while(curr < k && ind < n){\n            int total = count[ind];\n            while(total--){\n                answer[ind][col[curr]] = curr;\n                curr += 1;\n            }\n            ind += 1;\n        }\n        return answer;\n    }", "target_method_signature": "findEnemies", "source_method_signature": "findEnemies", "target_allMS": "    vector<vector<int>> findEnemies(int n, int m, int k, vector<int> &col, vector<int> &count) {", "source_allMS": "def findEnemies( n : int, m : int, k : int, col : List[int], count : List[int]) -> List[List[int]]:", "source_import": "from typing import List\nfrom typing import List", "target_import": "#include <iostream>\nusing namespace std;", "commentTag": "//", "source_code_shell": "from typing import List\nfrom typing import List\nfrom typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(findEnemies(2, 3, 4, [0, 1], [1, 0]))          # Less enemies than needed\n    print(findEnemies(0, 3, 0, [], []))                  # Edge case with zero rows and enemies\n    print(findEnemies(3, 3, 6, [0, 1, 2], [0, 0, 0]))    # No enemies to place", "all_input_output_value": "\ninput1: n=2, m=3, k=4, col=[0, 1], count=[1, 0]\noutput1: [[0, -1, -1], [-1, -1, -1]]\n--------\ninput2: n=0, m=3, k=0, col=[], count=[]\noutput2: []\n--------\ninput3: n=3, m=3, k=6, col=[0, 1, 2], count=[0, 0, 0]\noutput3: [[-1, -1, -1], [-1, -1, -1], [-1, -1, -1]]\n", "input_output_value": ["\ninput1: n=2, m=3, k=4, col=[0, 1], count=[1, 0]\noutput1: [[0, -1, -1], [-1, -1, -1]]\n", "\ninput2: n=0, m=3, k=0, col=[], count=[]\noutput2: []\n", "\ninput3: n=3, m=3, k=6, col=[0, 1, 2], count=[0, 0, 0]\noutput3: [[-1, -1, -1], [-1, -1, -1], [-1, -1, -1]]\n"], "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    vector<int> col1 = {0, 1};\n    vector<int> count1 = {1, 0};\n    vector<vector<int>> result1 = findEnemies(2, 3, 4, col1, count1);\n    \n    vector<int> col2 = {};\n    vector<int> count2 = {};\n    vector<vector<int>> result2 = findEnemies(0, 3, 0, col2, count2);\n\n    vector<int> col3 = {0, 1, 2};\n    vector<int> count3 = {0, 0, 0};\n    vector<vector<int>> result3 = findEnemies(3, 3, 6, col3, count3);\n\n    // Printing the results\n    for(const auto& row : result1) {\n        for(int val : row) {\n            cout << val << \" \";\n        }\n        cout << endl;\n    }\n    \n    for(const auto& row : result2) {\n        for(int val : row) {\n            cout << val << \" \";\n        }\n        cout << endl;\n    }\n\n    for(const auto& row : result3) {\n        for(int val : row) {\n            cout << val << \" \";\n        }\n        cout << endl;\n    }\n\n    return 0;\n}", "TAG": "Success"}
{"source_Lan": "python###maximumStrongIndices.py", "source_code_str": "def maximumStrongIndices( n: int, x: int, y: int, a: List[int],\n                         b: List[int]) -> int:\n    j = 0\n    ans = 0\n    for i in range(n):\n        while j < n and b[j] < a[i] - x:\n            j += 1\n        if j < n and b[j] <= a[i] + y:\n            ans += 1\n            j += 1\n    return ans", "source_code_block": "", "target_Lan": "cpp###maximumStrongIndices.cpp", "reference_code": "    int maximumStrongIndices(int n, int x, int y, vector<int> &a, vector<int> &b) {\n        int j = 0, ans = 0;\n        for (int i = 0; i < n; i++) {\n            while (j < n && b[j] < a[i] - x)\n                j++;\n            if (j < n && b[j] <= a[i] + y) {\n                ans++;\n                j++;\n            }\n        }\n        return ans;\n    }", "target_method_signature": "maximumStrongIndices", "source_method_signature": "maximumStrongIndices", "target_allMS": "    int maximumStrongIndices(int n, int x, int y, vector<int> &a, vector<int> &b) {", "source_allMS": "def maximumStrongIndices( n: int, x: int, y: int, a: List[int],", "source_import": "from typing import List", "target_import": "#include <iostream>\nusing namespace std;", "commentTag": "//", "source_code_shell": "from typing import List\nfrom typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(maximumStrongIndices(5, 2, 3, [1, 2, 3, 4, 5], [2, 3, 4, 5, 6]))\n    print(maximumStrongIndices(3, 1, 1, [1, 2, 3], [5, 6, 7]))\n    print(maximumStrongIndices(4, 2, 2, [5, 6, 7, 8], [1, 2, 3, 4]))\n    print(maximumStrongIndices(5, 0, 0, [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]))\n    print(maximumStrongIndices(0, 1, 1, [], []))", "all_input_output_value": "\ninput1: n=5, x=2, y=3, a=[1, 2, 3, 4, 5], [2, 3, 4, 5, 6]\noutput1: 5\n--------\ninput2: n=3, x=1, y=1, a=[1, 2, 3], [5, 6, 7]\noutput2: 0\n--------\ninput3: n=4, x=2, y=2, a=[5, 6, 7, 8], [1, 2, 3, 4]\noutput3: 2\n--------\ninput4: n=5, x=0, y=0, a=[1, 1, 1, 1, 1], [1, 1, 1, 1, 1]\noutput4: 5\n--------\ninput5: n=0, x=1, y=1, a=[], []\noutput5: 0\n", "input_output_value": ["\ninput1: n=5, x=2, y=3, a=[1, 2, 3, 4, 5], [2, 3, 4, 5, 6]\noutput1: 5\n", "\ninput2: n=3, x=1, y=1, a=[1, 2, 3], [5, 6, 7]\noutput2: 0\n", "\ninput3: n=4, x=2, y=2, a=[5, 6, 7, 8], [1, 2, 3, 4]\noutput3: 2\n"], "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    vector<int> a1 = {1, 2, 3, 4, 5}, b1 = {2, 3, 4, 5, 6};\n    cout << maximumStrongIndices(5, 2, 3, a1, b1) << endl;\n\n    vector<int> a2 = {1, 2, 3}, b2 = {5, 6, 7};\n    cout << maximumStrongIndices(3, 1, 1, a2, b2) << endl;\n\n    vector<int> a3 = {5, 6, 7, 8}, b3 = {1, 2, 3, 4};\n    cout << maximumStrongIndices(4, 2, 2, a3, b3) << endl;\n\n    vector<int> a4 = {1, 1, 1, 1, 1}, b4 = {1, 1, 1, 1, 1};\n    cout << maximumStrongIndices(5, 0, 0, a4, b4) << endl;\n\n    vector<int> a5 = {}, b5 = {};\n    cout << maximumStrongIndices(0, 1, 1, a5, b5) << endl;\n\n    return 0;\n}", "TAG": "Success"}
{"source_Lan": "python###minimumArea.py", "source_code_str": "def minimumArea( grid: List[List[int]]) -> int:\n    left, right = len(grid[0]), 0\n    top, bottom = len(grid), 0\n    for i, row in enumerate(grid):\n        for j, x in enumerate(row):\n            if x:\n                left = min(left, j)\n                right = max(right, j)\n                top = min(top, i)\n                bottom = i\n    return (right - left + 1) * (bottom - top + 1)", "source_code_block": "", "target_Lan": "cpp###minimumArea.cpp", "reference_code": "    int minimumArea(vector<vector<int>>& grid) {\n        int left = grid[0].size(), right = 0, top = grid.size(), bottom = 0;\n        for (int i = 0; i < grid.size(); i++) {\n            for (int j = 0; j < grid[i].size(); j++) {\n                if (grid[i][j]) {\n                    left = min(left, j);\n                    right = max(right, j);\n                    top = min(top, i);\n                    bottom = i;\n                }\n            }\n        }\n        return (right - left + 1) * (bottom - top + 1);\n    }", "target_method_signature": "minimumArea", "source_method_signature": "minimumArea", "target_allMS": "    int minimumArea(vector<vector<int>>& grid) {", "source_allMS": "def minimumArea( grid: List[List[int]]) -> int:", "source_import": "", "target_import": "#include <iostream>\nusing namespace std;", "commentTag": "//", "source_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(minimumArea([[0, 0], [0, 0]]))                    # No 1's\n    print(minimumArea([[1, 0], [0, 0]]))                    # Single 1 in the top left corner\n    print(minimumArea([[0, 1], [0, 0]]))                    # Single 1 in the top right corner\n    print(minimumArea([[0, 0], [1, 0]]))                    # Single 1 in the bottom left corner\n    print(minimumArea([[1, 1], [1, 1]]))                    # All 1's in a 2x2 grid", "all_input_output_value": "\ninput1: grid=[[0, 0], [0, 0]]\noutput1: 1\n--------\ninput2: grid=[[1, 0], [0, 0]]\noutput2: 1\n--------\ninput3: grid=[[0, 1], [0, 0]]\noutput3: 1\n--------\ninput4: grid=[[0, 0], [1, 0]]\noutput4: 1\n--------\ninput5: grid=[[1, 1], [1, 1]]\noutput5: 4\n", "input_output_value": ["\ninput1: grid=[[0, 0], [0, 0]]\noutput1: 1\n", "\ninput2: grid=[[1, 0], [0, 0]]\noutput2: 1\n", "\ninput3: grid=[[0, 1], [0, 0]]\noutput3: 1\n"], "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <algorithm>\n// TOFILL\nint main() {\n    vector<vector<int>> grid1 = {{0, 0}, {0, 0}};\n    vector<vector<int>> grid2 = {{1, 0}, {0, 0}};\n    vector<vector<int>> grid3 = {{0, 1}, {0, 0}};\n    vector<vector<int>> grid4 = {{0, 0}, {1, 0}};\n    vector<vector<int>> grid5 = {{1, 1}, {1, 1}};\n\n    cout << minimumArea(grid1) << endl; // Expected output: 0\n    cout << minimumArea(grid2) << endl; // Expected output: 1\n    cout << minimumArea(grid3) << endl; // Expected output: 1\n    cout << minimumArea(grid4) << endl; // Expected output: 1\n    cout << minimumArea(grid5) << endl; // Expected output: 4\n\n    return 0;\n}", "TAG": "Success"}
{"source_Lan": "python###countAlternatingSubarrays.py", "source_code_str": "def countAlternatingSubarrays( nums: List[int]) -> int:\n    res = cur = 0\n    pre = -1\n    for a in nums:\n        if pre != a:\n            cur += 1\n        else:\n            cur = 1\n        pre = a\n        res += cur\n    return res", "source_code_block": "", "target_Lan": "cpp###countAlternatingSubarrays.cpp", "reference_code": "    long long countAlternatingSubarrays(vector<int>& nums) {\n        long long res = 0, cur = 0;\n        int pre = -1;\n        for (int a : nums) {\n            cur = (pre != a) ? cur + 1 : 1;\n            pre = a;\n            res += cur;\n        }\n        return res;\n    }", "target_method_signature": "countAlternatingSubarrays", "source_method_signature": "countAlternatingSubarrays", "target_allMS": "    long long countAlternatingSubarrays(vector<int>& nums) {", "source_allMS": "def countAlternatingSubarrays( nums: List[int]) -> int:", "source_import": "", "target_import": "#include <iostream>\nusing namespace std;", "commentTag": "//", "source_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(countAlternatingSubarrays([]))                      # Edge case: empty array\n    print(countAlternatingSubarrays([1]))                     # Single element (no alternating pairs)\n    print(countAlternatingSubarrays([1, 2, 1, 2, 1]))         # Multiple alternating elements\n    print(countAlternatingSubarrays([1, 1, 1, 1]))            # All elements are the same (no alternation)\n    print(countAlternatingSubarrays([1, 2, 3, 4, 5]))         # Strictly increasing elements (alternating)", "all_input_output_value": "\ninput1: nums=[]\noutput1: 0\n--------\ninput2: nums=[1]\noutput2: 1\n--------\ninput3: nums=[1, 2, 1, 2, 1]\noutput3: 15\n--------\ninput4: nums=[1, 1, 1, 1]\noutput4: 4\n--------\ninput5: nums=[1, 2, 3, 4, 5]\noutput5: 15\n", "input_output_value": ["\ninput1: nums=[]\noutput1: 0\n", "\ninput2: nums=[1]\noutput2: 1\n", "\ninput3: nums=[1, 2, 1, 2, 1]\noutput3: 15\n"], "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    vector<int> input1 = {};\n    vector<int> input2 = {1};\n    vector<int> input3 = {1, 2, 1, 2, 1};\n    vector<int> input4 = {1, 1, 1, 1};\n    vector<int> input5 = {1, 2, 3, 4, 5};\n\n    cout << countAlternatingSubarrays(input1) << endl;\n    cout << countAlternatingSubarrays(input2) << endl;\n    cout << countAlternatingSubarrays(input3) << endl;\n    cout << countAlternatingSubarrays(input4) << endl;\n    cout << countAlternatingSubarrays(input5) << endl;\n\n    return 0;\n}", "TAG": "Success"}
{"source_Lan": "python###countTestedDevices.py", "source_code_str": "def countTestedDevices( batteryPercentages: List[int]) -> int:\n    n = len(batteryPercentages)\n    need = 0\n    for i in range(n):\n        if batteryPercentages[i] > 0:\n            need += 1\n            for j in range(i + 1, n):\n                batteryPercentages[j] = max(batteryPercentages[j] - 1, 0)\n    return need", "source_code_block": "", "target_Lan": "cpp###countTestedDevices.cpp", "reference_code": "    int countTestedDevices(vector<int>& batteryPercentages) {\n        int n = batteryPercentages.size();\n        int need = 0;\n        for (int i = 0; i < n; i++) {\n            if (batteryPercentages[i] > 0) {\n                need++;\n                for (int j = i + 1; j < n; j++) {\n                    batteryPercentages[j] = max(batteryPercentages[j] - 1, 0);\n                }\n            }\n        }\n        return need;\n    }", "target_method_signature": "countTestedDevices", "source_method_signature": "countTestedDevices", "target_allMS": "    int countTestedDevices(vector<int>& batteryPercentages) {", "source_allMS": "def countTestedDevices( batteryPercentages: List[int]) -> int:", "source_import": "", "target_import": "#include <iostream>\nusing namespace std;", "commentTag": "//", "source_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(countTestedDevices([0, 0, 0, 0, 0]))            # Test input 1: All devices are fully drained\n    print(countTestedDevices([100, 100, 100, 100, 100]))  # Test input 2: All devices are fully charged\n    print(countTestedDevices([0, 10, 0, 10, 0]))           # Test input 3: Mixed devices with some drained\n    print(countTestedDevices([5, 3, 0, 0, 2]))             # Test input 4: Mixed case with some draining others\n    print(countTestedDevices([1, 1, 1, 1, 1]))             # Test input 5: All devices at minimal positive battery", "all_input_output_value": "\ninput1: batteryPercentages=[0, 0, 0, 0, 0]\noutput1: 0\n--------\ninput2: batteryPercentages=[100, 100, 100, 100, 100]\noutput2: 5\n--------\ninput3: batteryPercentages=[0, 10, 0, 10, 0]\noutput3: 2\n--------\ninput4: batteryPercentages=[5, 3, 0, 0, 2]\noutput4: 2\n--------\ninput5: batteryPercentages=[1, 1, 1, 1, 1]\noutput5: 1\n", "input_output_value": ["\ninput1: batteryPercentages=[0, 0, 0, 0, 0]\noutput1: 0\n", "\ninput2: batteryPercentages=[100, 100, 100, 100, 100]\noutput2: 5\n", "\ninput3: batteryPercentages=[0, 10, 0, 10, 0]\noutput3: 2\n"], "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <algorithm>\n// TOFILL\nint main() {\n    vector<int> input1 = {0, 0, 0, 0, 0};\n    vector<int> input2 = {100, 100, 100, 100, 100};\n    vector<int> input3 = {0, 10, 0, 10, 0};\n    vector<int> input4 = {5, 3, 0, 0, 2};\n    vector<int> input5 = {1, 1, 1, 1, 1};\n\n    cout << countTestedDevices(input1) << endl;  // Output for input1\n    cout << countTestedDevices(input2) << endl;  // Output for input2\n    cout << countTestedDevices(input3) << endl;  // Output for input3\n    cout << countTestedDevices(input4) << endl;  // Output for input4\n    cout << countTestedDevices(input5) << endl;  // Output for input5\n\n    return 0;\n}", "TAG": "Success"}
{"source_Lan": "python###findKOr.py", "source_code_str": "def findKOr( nums: List[int], k: int) -> int:\n    ans = 0\n    for i in range(31):\n        cnt = sum(1 for num in nums if ((num >> i) & 1) > 0)\n        if cnt >= k:\n            ans |= 1 << i\n    return ans", "source_code_block": "", "target_Lan": "cpp###findKOr.cpp", "reference_code": "    int findKOr(vector<int>& nums, int k) {\n        int ans = 0;\n        for (int i = 0; i < 31; ++i) {\n            int cnt = 0;\n            for (int num: nums) {\n                if ((num >> i) & 1) {\n                    ++cnt;\n                }\n            }\n            if (cnt >= k) {\n                ans |= 1 << i;\n            }\n        }\n        return ans;\n    }", "target_method_signature": "findKOr", "source_method_signature": "findKOr", "target_allMS": "    int findKOr(vector<int>& nums, int k) {", "source_allMS": "def findKOr( nums: List[int], k: int) -> int:", "source_import": "", "target_import": "#include <iostream>\nusing namespace std;", "commentTag": "//", "source_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(findKOr([0, 0, 0], 1))\n    print(findKOr([1, 2, 3], 1))\n    print(findKOr([1, 2, 3, 4, 5], 2))\n    print(findKOr([7, 8, 9], 3))\n    print(findKOr([15, 0, 5], 2))", "all_input_output_value": "\ninput1: nums=[0, 0, 0], k=1\noutput1: 0\n--------\ninput2: nums=[1, 2, 3], k=1\noutput2: 3\n--------\ninput3: nums=[1, 2, 3, 4, 5], k=2\noutput3: 7\n--------\ninput4: nums=[7, 8, 9], k=3\noutput4: 0\n--------\ninput5: nums=[15, 0, 5], k=2\noutput5: 5\n", "input_output_value": ["\ninput1: nums=[0, 0, 0], k=1\noutput1: 0\n", "\ninput2: nums=[1, 2, 3], k=1\noutput2: 3\n", "\ninput3: nums=[1, 2, 3, 4, 5], k=2\noutput3: 7\n"], "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    vector<int> nums1 = {0, 0, 0};\n    cout << findKOr(nums1, 1) << endl;\n\n    vector<int> nums2 = {1, 2, 3};\n    cout << findKOr(nums2, 1) << endl;\n\n    vector<int> nums3 = {1, 2, 3, 4, 5};\n    cout << findKOr(nums3, 2) << endl;\n\n    vector<int> nums4 = {7, 8, 9};\n    cout << findKOr(nums4, 3) << endl;\n\n    vector<int> nums5 = {15, 0, 5};\n    cout << findKOr(nums5, 2) << endl;\n\n    return 0;\n}", "TAG": "Success"}
{"source_Lan": "python###maximumSumOfHeights.py", "source_code_str": "def maximumSumOfHeights( maxHeights: List[int]) -> int:\n    n = len(maxHeights)\n    res = 0\n    for i in range(n):\n        pre, psum = maxHeights[i], maxHeights[i]\n        for j in range(i - 1, -1, -1):\n            pre = min(pre, maxHeights[j])\n            psum += pre\n        suf = maxHeights[i]\n        for j in range(i + 1, n):\n            suf = min(suf, maxHeights[j])\n            psum += suf\n        res = max(res, psum)\n    return res", "source_code_block": "", "target_Lan": "cpp###maximumSumOfHeights.cpp", "reference_code": "    long long maximumSumOfHeights(vector<int>& maxHeights) {\n        int n = maxHeights.size();\n        long long res = 0;\n        for (int i = 0; i < n; i++) {\n            int pre = maxHeights[i];\n            long long sum = pre;\n            for (int j = i - 1; j >= 0; j--) {\n                pre = min(pre, maxHeights[j]);\n                sum += pre;\n            }\n            int suf = maxHeights[i];\n            for (int j = i + 1; j < n; j++) {\n                suf = min(suf, maxHeights[j]);\n                sum += suf;\n            }\n            res = max(res, sum);\n        }\n        return res;\n    }", "target_method_signature": "maximumSumOfHeights", "source_method_signature": "maximumSumOfHeights", "target_allMS": "    long long maximumSumOfHeights(vector<int>& maxHeights) {", "source_allMS": "def maximumSumOfHeights( maxHeights: List[int]) -> int:", "source_import": "", "target_import": "#include <iostream>\nusing namespace std;", "commentTag": "//", "source_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(maximumSumOfHeights([1, 1, 1, 1, 1]))  # All same heights\n    print(maximumSumOfHeights([1, 2, 3, 4, 5]))  # Strictly increasing heights\n    print(maximumSumOfHeights([5, 4, 3, 2, 1]))  # Strictly decreasing heights\n    print(maximumSumOfHeights([3, 1, 4, 1, 5]))  # Mixed heights\n    print(maximumSumOfHeights([0, 2, 0, 3, 0]))  # Heights with a zero", "all_input_output_value": "\ninput1: maxHeights=[1, 1, 1, 1, 1]\noutput1: 5\n--------\ninput2: maxHeights=[1, 2, 3, 4, 5]\noutput2: 15\n--------\ninput3: maxHeights=[5, 4, 3, 2, 1]\noutput3: 15\n--------\ninput4: maxHeights=[3, 1, 4, 1, 5]\noutput4: 9\n--------\ninput5: maxHeights=[0, 2, 0, 3, 0]\noutput5: 3\n", "input_output_value": ["\ninput1: maxHeights=[1, 1, 1, 1, 1]\noutput1: 5\n", "\ninput2: maxHeights=[1, 2, 3, 4, 5]\noutput2: 15\n", "\ninput3: maxHeights=[5, 4, 3, 2, 1]\noutput3: 15\n"], "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    // Test Inputs\n    vector<int> input1 = {1, 1, 1, 1, 1};\n    vector<int> input2 = {1, 2, 3, 4, 5};\n    vector<int> input3 = {5, 4, 3, 2, 1};\n    vector<int> input4 = {3, 1, 4, 1, 5};\n    vector<int> input5 = {0, 2, 0, 3, 0};\n\n    cout << maximumSumOfHeights(input1) << endl;\n    cout << maximumSumOfHeights(input2) << endl;\n    cout << maximumSumOfHeights(input3) << endl;\n    cout << maximumSumOfHeights(input4) << endl;\n    cout << maximumSumOfHeights(input5) << endl;\n\n    return 0;\n}", "TAG": "Success"}
{"source_Lan": "python###isMagicArray.py", "source_code_str": "def isMagicArray( n : int, arr : List[int]) -> bool:\n    for i in range(n-1):\n        if (arr[i]&1)==(arr[i+1]&1):\n            return 0\n    return 1", "source_code_block": "", "target_Lan": "cpp###isMagicArray.cpp", "reference_code": "    bool isMagicArray(int n, vector<int> &arr) {\n        for (int i=1;i<n;i++){\n            if ((arr[i]%2==0 && arr[i-1]%2==0) || (arr[i]%2!=0 && arr[i-1]%2!=0)) return 0;\n        }\n        return 1;\n    }", "target_method_signature": "isMagicArray", "source_method_signature": "isMagicArray", "target_allMS": "    bool isMagicArray(int n, vector<int> &arr) {", "source_allMS": "def isMagicArray( n : int, arr : List[int]) -> bool:", "source_import": "from typing import List", "target_import": "#include <iostream>\nusing namespace std;", "commentTag": "//", "source_code_shell": "from typing import List\nfrom typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(isMagicArray(5, [2, 3, 4, 5, 6]))\n    print(isMagicArray(4, [2, 4, 6, 8]))\n    print(isMagicArray(4, [1, 3, 5, 7]))\n    print(isMagicArray(1, [42]))\n    print(isMagicArray(0, []))", "all_input_output_value": "\ninput1: n=5, arr=[2, 3, 4, 5, 6]\noutput1: 1\n--------\ninput2: n=4, arr=[2, 4, 6, 8]\noutput2: 0\n--------\ninput3: n=4, arr=[1, 3, 5, 7]\noutput3: 0\n--------\ninput4: n=1, arr=[42]\noutput4: 1\n--------\ninput5: n=0, arr=[]\noutput5: 1\n", "input_output_value": ["\ninput1: n=5, arr=[2, 3, 4, 5, 6]\noutput1: 1\n", "\ninput2: n=4, arr=[2, 4, 6, 8]\noutput2: 0\n", "\ninput3: n=4, arr=[1, 3, 5, 7]\noutput3: 0\n"], "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    vector<int> input1 = {2, 3, 4, 5, 6};\n    cout << isMagicArray(5, input1) << endl; // Test case 1\n\n    vector<int> input2 = {2, 4, 6, 8};\n    cout << isMagicArray(4, input2) << endl; // Test case 2\n\n    vector<int> input3 = {1, 3, 5, 7};\n    cout << isMagicArray(4, input3) << endl; // Test case 3\n\n    vector<int> input4 = {42};\n    cout << isMagicArray(1, input4) << endl; // Test case 4\n\n    vector<int> input5 = {};\n    cout << isMagicArray(0, input5) << endl; // Test case 5\n\n    return 0;\n}", "TAG": "Success"}
{"source_Lan": "python###minOrAfterOperations.py", "source_code_str": "def minOrAfterOperations( nums: List[int], k: int) -> int:\n    ans = mask = 0\n    for b in range(max(nums).bit_length() - 1, -1, -1):\n        mask |= 1 << b\n        cnt = 0  \n        and_res = -1  \n        for x in nums:\n            and_res &= x & mask\n            if and_res:\n                cnt += 1  \n            else:\n                and_res = -1  \n        if cnt > k:\n            ans |= 1 << b  \n            mask ^= 1 << b  \n    return ans", "source_code_block": "", "target_Lan": "cpp###minOrAfterOperations.cpp", "reference_code": "    int minOrAfterOperations(vector<int> &nums, int k) {\n        int ans = 0, mask = 0;\n        for (int b = 29; b >= 0; b--) {\n            mask |= 1 << b;\n            int cnt = 0, and_res = -1; \n            for (int x : nums) {\n                and_res &= x & mask;\n                if (and_res) {\n                    cnt++; \n                } else {\n                    and_res = -1; \n                }\n            }\n            if (cnt > k) {\n                ans |= 1 << b; \n                mask ^= 1 << b; \n            }\n        }\n        return ans;\n    }", "target_method_signature": "minOrAfterOperations", "source_method_signature": "minOrAfterOperations", "target_allMS": "    int minOrAfterOperations(vector<int> &nums, int k) {", "source_allMS": "def minOrAfterOperations( nums: List[int], k: int) -> int:", "source_import": "", "target_import": "#include <iostream>\nusing namespace std;", "commentTag": "//", "source_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(minOrAfterOperations([0, 0, 0], 1))\n    print(minOrAfterOperations([1, 2, 3, 4], 2))\n    print(minOrAfterOperations([5, 6, 7, 8], 3))\n    print(minOrAfterOperations([-1, 0, 1], 1))", "all_input_output_value": "\ninput1: nums=[0, 0, 0], k=1\noutput1: 0\n--------\ninput2: nums=[1, 2, 3, 4], k=2\noutput2: 0\n--------\ninput3: nums=[5, 6, 7, 8], k=3\noutput3: 0\n--------\ninput4: nums=[-1, 0, 1], k=1\noutput4: 1\n", "input_output_value": ["\ninput1: nums=[0, 0, 0], k=1\noutput1: 0\n", "\ninput2: nums=[1, 2, 3, 4], k=2\noutput2: 0\n", "\ninput3: nums=[5, 6, 7, 8], k=3\noutput3: 0\n"], "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    vector<int> nums1 = {0, 0, 0};\n    int k1 = 1;\n    cout << minOrAfterOperations(nums1, k1) << endl;\n    \n    vector<int> nums2 = {1, 2, 3, 4};\n    int k2 = 2;\n    cout << minOrAfterOperations(nums2, k2) << endl;\n\n    vector<int> nums3 = {5, 6, 7, 8};\n    int k3 = 3;\n    cout << minOrAfterOperations(nums3, k3) << endl;\n\n    vector<int> nums4 = {-1, 0, 1};\n    int k4 = 1;\n    cout << minOrAfterOperations(nums4, k4) << endl;\n\n    return 0;\n}", "TAG": "Success"}
{"source_Lan": "python###modifiedMatrix.py", "source_code_str": "def modifiedMatrix( matrix: List[List[int]]) -> List[List[int]]:\n    n, m = len(matrix), len(matrix[0])\n    for j in range(m):\n        zd = -1\n        for i in range(n):\n            zd = max(zd, matrix[i][j])\n        for i in range(n):\n            if matrix[i][j] == -1:\n                matrix[i][j] = zd\n    return matrix", "source_code_block": "", "target_Lan": "cpp###modifiedMatrix.cpp", "reference_code": "    vector<vector<int>> modifiedMatrix(vector<vector<int>>& matrix) {\n        int n = matrix.size();\n        int m = matrix[0].size();\n        for (int j = 0; j < m; j++) {\n            int zd = -1;\n            for (int i = 0; i < n; i++) {\n                zd = max(zd, matrix[i][j]);\n            }\n            for (int i = 0; i < n; i++) {\n                if (matrix[i][j] == -1) {\n                    matrix[i][j] = zd;\n                }\n            }\n        }\n        return matrix;\n    }", "target_method_signature": "modifiedMatrix", "source_method_signature": "modifiedMatrix", "target_allMS": "    vector<vector<int>> modifiedMatrix(vector<vector<int>>& matrix) {", "source_allMS": "def modifiedMatrix( matrix: List[List[int]]) -> List[List[int]]:", "source_import": "", "target_import": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;", "commentTag": "//", "source_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    test_inputs = [\n        [[1, 2, -1], [3, -1, 5], [-1, 4, -1], [6, 7, 8]],\n        [[0, -1, 0], [0, 0, 0], [-1, 0, -1]],\n        [[1, 2, 3], [4, 5, 6]],\n        [[1, -1, 3]],\n        [[]]\n    ]\n    for matrix in test_inputs:\n        print(modifiedMatrix(matrix))", "all_input_output_value": "\ninput1: matrix=[[1, 2, -1], [3, -1, 5], [-1, 4, -1], [6, 7, 8]]\noutput1: [[1, 2, 8], [3, 7, 5], [6, 4, 8], [6, 7, 8]]\n--------\ninput2: matrix=[[0, -1, 0], [0, 0, 0], [-1, 0, -1]]\noutput2: [[0, 0, 0], [0, 0, 0], [0, 0, 0]]\n--------\ninput3: matrix=[[1, 2, 3], [4, 5, 6]]\noutput3: [[1, 2, 3], [4, 5, 6]]\n--------\ninput4: matrix=[[1, -1, 3]]\noutput4: [[1, -1, 3]]\n--------\ninput5: matrix=[[]]\noutput5: [[]]\n", "input_output_value": ["\ninput1: matrix=[[1, 2, -1], [3, -1, 5], [-1, 4, -1], [6, 7, 8]]\noutput1: [[1, 2, 8], [3, 7, 5], [6, 4, 8], [6, 7, 8]]\n", "\ninput2: matrix=[[0, -1, 0], [0, 0, 0], [-1, 0, -1]]\noutput2: [[0, 0, 0], [0, 0, 0], [0, 0, 0]]\n", "\ninput3: matrix=[[1, 2, 3], [4, 5, 6]]\noutput3: [[1, 2, 3], [4, 5, 6]]\n"], "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    vector<vector<int>> matrix1 = {{1, 2, -1}, {3, -1, 5}, {-1, 4, -1}, {6, 7, 8}};\n    vector<vector<int>> matrix2 = {{0, -1, 0}, {0, 0, 0}, {-1, 0, -1}};\n    vector<vector<int>> matrix3 = {{1, 2, 3}, {4, 5, 6}};\n    vector<vector<int>> matrix4 = {{1, -1, 3}};\n    vector<vector<int>> matrix5 = {{}};\n\n    vector<vector<int>> result1 = modifiedMatrix(matrix1);\n    vector<vector<int>> result2 = modifiedMatrix(matrix2);\n    vector<vector<int>> result3 = modifiedMatrix(matrix3);\n    vector<vector<int>> result4 = modifiedMatrix(matrix4);\n    vector<vector<int>> result5 = modifiedMatrix(matrix5);\n\n    for(const auto& row : result1) {\n        for(int val : row) {\n            cout << val << \" \";\n        }\n        cout << endl;\n    }\n    cout << \"------\" << endl;\n\n    for(const auto& row : result2) {\n        for(int val : row) {\n            cout << val << \" \";\n        }\n        cout << endl;\n    }\n    cout << \"------\" << endl;\n\n    for(const auto& row : result3) {\n        for(int val : row) {\n            cout << val << \" \";\n        }\n        cout << endl;\n    }\n    cout << \"------\" << endl;\n\n    for(const auto& row : result4) {\n        for(int val : row) {\n            cout << val << \" \";\n        }\n        cout << endl;\n    }\n    cout << \"------\" << endl;\n\n    for(const auto& row : result5) {\n        for(int val : row) {\n            cout << val << \" \";\n        }\n        cout << endl;\n    }\n    cout << \"------\" << endl;\n\n    return 0;\n}", "TAG": "Success"}
{"source_Lan": "python###findMaximumElegance.py", "source_code_str": "def findMaximumElegance( items: List[List[int]], k: int) -> int:\n    items.sort(key = lambda item: -item[0])\n    categorySet = set()\n    res, profit = 0, 0\n    st = []\n    for i, item in enumerate(items):\n        if i < k:\n            profit += item[0]\n            if item[1] in categorySet:\n                st.append(item[0])\n            else:\n                categorySet.add(item[1])\n        elif item[1] not in categorySet and len(st) > 0:\n            profit += item[0] - st.pop()\n            categorySet.add(item[1])\n        res = max(res, profit + len(categorySet) * len(categorySet))\n    return res", "source_code_block": "", "target_Lan": "cpp###findMaximumElegance.cpp", "reference_code": "    long long findMaximumElegance(vector<vector<int>>& items, int k) {\n        sort(items.begin(), items.end(), [&](const vector<int> &item1, const vector<int> &item2) -> bool {\n            return item1[0] > item2[0];\n        });\n        unordered_set<int> categorySet;\n        long long res = 0, profit = 0;\n        stack<int> st;\n        for (int i = 0; i < items.size(); i++) {\n            if (i < k) {\n                profit += items[i][0];\n                if (categorySet.count(items[i][1]) == 0) {\n                    categorySet.insert(items[i][1]);\n                } else {\n                    st.push(items[i][0]);\n                }\n            } else if (categorySet.count(items[i][1]) == 0 && !st.empty()) {\n                profit += items[i][0] - st.top();\n                st.pop();\n                categorySet.insert(items[i][1]);\n            }\n            res = max(res, (long long)(profit + categorySet.size() * categorySet.size()));\n        }\n        return res;\n    }", "target_method_signature": "findMaximumElegance", "source_method_signature": "findMaximumElegance", "target_allMS": "    long long findMaximumElegance(vector<vector<int>>& items, int k) {", "source_allMS": "def findMaximumElegance( items: List[List[int]], k: int) -> int:", "source_import": "", "target_import": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;", "commentTag": "//", "source_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(findMaximumElegance([[5,1],[3,2],[4,1],[6,3]], 2))  # Normal case where k < number of items and categories overlap.\n    print(findMaximumElegance([[10,1],[20,2],[10,3],[30,4]], 3))  # Normal case where all items are unique categories.\n    print(findMaximumElegance([[5,1],[10,1],[15,2]], 1))  # Edge case with only 1 selection allowed and repeated category.\n    print(findMaximumElegance([[1,1],[2,2],[3,3]], 0))  # Edge case where no items are selected.\n    print(findMaximumElegance([], 5))  # Edge case with empty items list.", "all_input_output_value": "\ninput1: items=[[5,1],[3,2],[4,1],[6,3]], k=2\noutput1: 15\n--------\ninput2: items=[[10,1],[20,2],[10,3],[30,4]], k=3\noutput2: 69\n--------\ninput3: items=[[5,1],[10,1],[15,2]], k=1\noutput3: 16\n--------\ninput4: items=[[1,1],[2,2],[3,3]], k=0\noutput4: 0\n--------\ninput5: items=[], k=5\noutput5: 0\n", "input_output_value": ["\ninput1: items=[[5,1],[3,2],[4,1],[6,3]], k=2\noutput1: 15\n", "\ninput2: items=[[10,1],[20,2],[10,3],[30,4]], k=3\noutput2: 69\n", "\ninput3: items=[[5,1],[10,1],[15,2]], k=1\noutput3: 16\n"], "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <unordered_set>\n#include <stack>\n// TOFILL\nint main() {\n    vector<vector<int>> input1 = {{5,1},{3,2},{4,1},{6,3}};\n    cout << findMaximumElegance(input1, 2) << endl;\n\n    vector<vector<int>> input2 = {{10,1},{20,2},{10,3},{30,4}};\n    cout << findMaximumElegance(input2, 3) << endl;\n\n    vector<vector<int>> input3 = {{5,1},{10,1},{15,2}};\n    cout << findMaximumElegance(input3, 1) << endl;\n\n    vector<vector<int>> input4 = {{1,1},{2,2},{3,3}};\n    cout << findMaximumElegance(input4, 0) << endl;\n\n    vector<vector<int>> input5 = {};\n    cout << findMaximumElegance(input5, 5) << endl;\n\n    return 0;\n}", "TAG": "Success"}
{"source_Lan": "python###findMissingAndRepeatedValues.py", "source_code_str": "def findMissingAndRepeatedValues( grid: List[List[int]]) -> List[int]:\n    n = len(grid)\n    count = [0] * (n * n + 1)\n    count[0] = -1\n    for i in range(n):\n        for j in range(n):\n            count[grid[i][j]] += 1\n    return [count.index(2), count.index(0)]", "source_code_block": "", "target_Lan": "cpp###findMissingAndRepeatedValues.cpp", "reference_code": "    vector<int> findMissingAndRepeatedValues(vector<vector<int>>& grid) {\n        int n = grid.size();\n        vector<int> count(n * n + 1);\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                count[grid[i][j]]++;\n            }\n        }\n        vector<int> res(2);\n        for (int i = 1; i <= n * n; i++) {\n            if (count[i] == 2) {\n                res[0] = i;\n            }\n            if (count[i] == 0) {\n                res[1] = i;\n            }\n        }\n        return res;\n    }", "target_method_signature": "findMissingAndRepeatedValues", "source_method_signature": "findMissingAndRepeatedValues", "target_allMS": "    vector<int> findMissingAndRepeatedValues(vector<vector<int>>& grid) {", "source_allMS": "def findMissingAndRepeatedValues( grid: List[List[int]]) -> List[int]:", "source_import": "", "target_import": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;", "commentTag": "//", "source_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(findMissingAndRepeatedValues([[1, 2], [2, 3]]))   # Output should be [2, 4]\n    print(findMissingAndRepeatedValues([[1, 1], [2, 4]]))   # Output should be [1, 3]\n    print(findMissingAndRepeatedValues([[1, 2, 3], [4, 5, 5], [6, 7, 8]]))  # Output should be [5, 9]\n    print(findMissingAndRepeatedValues([[1, 2, 3], [4, 6, 6], [7, 8, 9]]))   # Output should be [6, 5]", "all_input_output_value": "\ninput1: grid=[[1, 2], [2, 3]]\noutput1: [2, 4]\n--------\ninput2: grid=[[1, 1], [2, 4]]\noutput2: [1, 3]\n--------\ninput3: grid=[[1, 2, 3], [4, 5, 5], [6, 7, 8]]\noutput3: [5, 9]\n--------\ninput4: grid=[[1, 2, 3], [4, 6, 6], [7, 8, 9]]\noutput4: [6, 5]\n", "input_output_value": ["\ninput1: grid=[[1, 2], [2, 3]]\noutput1: [2, 4]\n", "\ninput2: grid=[[1, 1], [2, 4]]\noutput2: [1, 3]\n", "\ninput3: grid=[[1, 2, 3], [4, 5, 5], [6, 7, 8]]\noutput3: [5, 9]\n"], "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    vector<vector<int>> input1 = {{1, 2}, {2, 3}};\n    vector<vector<int>> input2 = {{1, 1}, {2, 4}};\n    vector<vector<int>> input3 = {{1, 2, 3}, {4, 5, 5}, {6, 7, 8}};\n    vector<vector<int>> input4 = {{1, 2, 3}, {4, 6, 6}, {7, 8, 9}};\n\n    vector<int> result1 = findMissingAndRepeatedValues(input1);\n    cout << \"Missing: \" << result1[1] << \", Repeated: \" << result1[0] << endl;\n\n    vector<int> result2 = findMissingAndRepeatedValues(input2);\n    cout << \"Missing: \" << result2[1] << \", Repeated: \" << result2[0] << endl;\n\n    vector<int> result3 = findMissingAndRepeatedValues(input3);\n    cout << \"Missing: \" << result3[1] << \", Repeated: \" << result3[0] << endl;\n\n    vector<int> result4 = findMissingAndRepeatedValues(input4);\n    cout << \"Missing: \" << result4[1] << \", Repeated: \" << result4[0] << endl;\n\n    return 0;\n}", "TAG": "Success"}
{"source_Lan": "python###collectingCoins.py", "source_code_str": "def collectingCoins( N: int, Coins: List[List[int]]) -> int:\n    \n    hor = defaultdict(int)\n    ver = defaultdict(int)\n    diaa = defaultdict(int)\n    diab = defaultdict(int)\n    \n    m = 0\n    \n    for el in Coins:\n        a, b = el[0], el[1]\n        \n        hor[a] += 1\n        ver[b] += 1\n        diaa[a + b] += 1\n        diab[a - b] += 1\n        \n        m = max(m, hor[a], ver[b], diaa[a + b], diab[a - b])\n    \n    return m", "source_code_block": "", "target_Lan": "cpp###collectingCoins.cpp", "reference_code": "    int collectingCoins(int N, std::vector<std::vector<int>>& Coins)\n    {\n        \n        \n        unordered_map<int, int> hor,ver,diaa,diab;\n        int m = 0;\n        \n        for (auto& el : Coins)\n        {\n            \n            int a = el[0];\n            int b = el[1];\n            \n            \n            hor[a]++;\n            ver[b]++;\n            diaa[a + b]++;\n            diab[a - b]++;\n            \n            m = max(m, hor[a]);\n            m = max(m, ver[b]);\n            m = max(m, diaa[a + b]);\n            m = max(m, diab[a - b]);\n        }\n        \n        return m;\n    }", "target_method_signature": "collectingCoins", "source_method_signature": "collectingCoins", "target_allMS": "    int collectingCoins(int N, std::vector<std::vector<int>>& Coins)", "source_allMS": "def collectingCoins( N: int, Coins: List[List[int]]) -> int:", "source_import": "from typing import List\nfrom collections import defaultdict", "target_import": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;", "commentTag": "//", "source_code_shell": "from typing import List\nfrom collections import defaultdict\nfrom collections import defaultdict\nfrom typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(collectingCoins(0, []))\n    print(collectingCoins(5, [[0,0], [1,0], [2,0], [3,0], [4,0]]))\n    print(collectingCoins(5, [[0,0], [0,1], [0,2], [0,3], [0,4]]))\n    print(collectingCoins(5, [[0,0], [1,1], [2,2], [3,3], [4,4]]))\n    print(collectingCoins(4, [[1,1], [1,2], [2,1], [3,3]]))", "all_input_output_value": "\ninput1: N=0, Coins=[]\noutput1: 0\n--------\ninput2: N=5, Coins=[[0,0], [1,0], [2,0], [3,0], [4,0]]\noutput2: 5\n--------\ninput3: N=5, Coins=[[0,0], [0,1], [0,2], [0,3], [0,4]]\noutput3: 5\n--------\ninput4: N=5, Coins=[[0,0], [1,1], [2,2], [3,3], [4,4]]\noutput4: 5\n--------\ninput5: N=4, Coins=[[1,1], [1,2], [2,1], [3,3]]\noutput5: 2\n", "input_output_value": ["\ninput1: N=0, Coins=[]\noutput1: 0\n", "\ninput2: N=5, Coins=[[0,0], [1,0], [2,0], [3,0], [4,0]]\noutput2: 5\n", "\ninput3: N=5, Coins=[[0,0], [0,1], [0,2], [0,3], [0,4]]\noutput3: 5\n"], "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n// TOFILL\nint main() {\n    vector<vector<int>> testInput1 = {};\n    cout << collectingCoins(0, testInput1) << endl;\n\n    vector<vector<int>> testInput2 = {{0,0}, {1,0}, {2,0}, {3,0}, {4,0}};\n    cout << collectingCoins(5, testInput2) << endl;\n\n    vector<vector<int>> testInput3 = {{0,0}, {0,1}, {0,2}, {0,3}, {0,4}};\n    cout << collectingCoins(5, testInput3) << endl;\n\n    vector<vector<int>> testInput4 = {{0,0}, {1,1}, {2,2}, {3,3}, {4,4}};\n    cout << collectingCoins(5, testInput4) << endl;\n\n    vector<vector<int>> testInput5 = {{1,1}, {1,2}, {2,1}, {3,3}};\n    cout << collectingCoins(4, testInput5) << endl;\n\n    return 0;\n}", "TAG": "Success"}
{"source_Lan": "python###ForYou.py", "source_code_str": "def ForYou( n : int, arr : List[int], m : int, order : List[List[int]]) -> int:\n    diff = [0] * (n + 1)\n    for it in order:\n        diff[it[0] - 1] += 1\n        diff[it[1]] -= 1\n    for i in range(1, n):\n        diff[i] += diff[i - 1]\n    diff.pop()\n    diff.sort()\n    arr.sort()\n    ans = 0\n    mod = int(1e9) + 7\n    for i in range(n):\n        ans += diff[i] * arr[i]\n        ans %= mod\n    return ans", "source_code_block": "", "target_Lan": "cpp###ForYou.cpp", "reference_code": "    long long ForYou(int n, vector<int> &arr, int m, vector<vector<int> > &order)\n    {\n        vector<int> diff(n+1,0);\n        for(auto it:order)\n        {\n            diff[it[0]-1]++;\n            diff[it[1]]--;\n        }\n        for(int i=1;i<=n;i++)\n        {\n            diff[i] += diff[i-1];\n        }\n        diff.pop_back();\n        sort(diff.begin(),diff.end());\n        sort(arr.begin(),arr.end());\n        long long ans=0;\n        int mod = 1e9+7;\n        for(int i=0;i<n;i++)\n        {\n            ans += (1ll * diff[i]) * (1ll * arr[i]);\n            ans%=mod;\n        }\n        return ans;\n    }", "target_method_signature": "ForYou", "source_method_signature": "ForYou", "target_allMS": "    long long ForYou(int n, vector<int> &arr, int m, vector<vector<int> > &order)", "source_allMS": "def ForYou( n : int, arr : List[int], m : int, order : List[List[int]]) -> int:", "source_import": "from typing import List", "target_import": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;", "commentTag": "//", "source_code_shell": "from typing import List\nfrom typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(ForYou(1, [5], 1, [[1, 1]]))          # Single element case\n    print(ForYou(3, [0, 0, 0], 1, [[1, 3]]))    # All elements are zero", "all_input_output_value": "\ninput1: n=1, arr=[5], m=1, order=[[1, 1]]\noutput1: 5\n--------\ninput2: n=3, arr=[0, 0, 0], m=1, order=[[1, 3]]\noutput2: 0\n", "input_output_value": ["\ninput1: n=1, arr=[5], m=1, order=[[1, 1]]\noutput1: 5\n", "\ninput2: n=3, arr=[0, 0, 0], m=1, order=[[1, 3]]\noutput2: 0\n"], "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <algorithm>\n// TOFILL\nint main() {\n    vector<int> arr1 = {5};\n    vector<vector<int>> order1 = {{1, 1}};\n    cout << ForYou(1, arr1, 1, order1) << endl;\n\n    vector<int> arr2 = {0, 0, 0};\n    vector<vector<int>> order2 = {{1, 3}};\n    cout << ForYou(3, arr2, 1, order2) << endl;\n}", "TAG": "Success"}
{"source_Lan": "python###maximumBattalions.py", "source_code_str": "def maximumBattalions( N : int, names : List[str]) -> int:\n    d={}\n    for i in range(N):\n        if names[i] not in d:\n            d[names[i]]=[]\n        d[names[i]].append(i)\n    seen=set()\n    ans=0\n    for i in range(N):\n        if names[i] not in seen:\n            seen.add(names[i])\n        if d[names[i]][-1]==i:\n            seen.remove(names[i])\n        if len(seen)==0:\n            ans+=1\n    return ans", "source_code_block": "", "target_Lan": "cpp###maximumBattalions.cpp", "reference_code": "    int maximumBattalions(int N, vector<string> &names) {\n        unordered_map<string, int> m;\n        for(int i = 0; i < N; i++){\n            m[names[i]] = i;\n        }\n        int answer = 0;\n        int maxi = 0;\n        int ind = 0;\n        for(auto i : names){\n            maxi = max(maxi, m[i]);\n            if(maxi == ind){\n                answer += 1;\n            }\n            ind += 1;\n        }\n        return answer;\n    }", "target_method_signature": "maximumBattalions", "source_method_signature": "maximumBattalions", "target_allMS": "    int maximumBattalions(int N, vector<string> &names) {", "source_allMS": "def maximumBattalions( N : int, names : List[str]) -> int:", "source_import": "from typing import List", "target_import": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;", "commentTag": "//", "source_code_shell": "from typing import List\nfrom typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(maximumBattalions(1, [\"A\"]))\n    print(maximumBattalions(5, [\"A\", \"B\", \"B\", \"C\", \"A\"]))\n    print(maximumBattalions(5, [\"A\", \"C\", \"B\", \"D\", \"A\"]))\n    print(maximumBattalions(0, []))\n    print(maximumBattalions(3, [\"X\", \"Y\", \"Z\"]))", "all_input_output_value": "\ninput1: N=1, names=[\"A\"]\noutput1: 1\n--------\ninput2: N=5, names=[\"A\", \"B\", \"B\", \"C\", \"A\"]\noutput2: 1\n--------\ninput3: N=5, names=[\"A\", \"C\", \"B\", \"D\", \"A\"]\noutput3: 1\n--------\ninput4: N=0, names=[]\noutput4: 0\n--------\ninput5: N=3, names=[\"X\", \"Y\", \"Z\"]\noutput5: 3\n", "input_output_value": ["\ninput1: N=1, names=[\"A\"]\noutput1: 1\n", "\ninput2: N=5, names=[\"A\", \"B\", \"B\", \"C\", \"A\"]\noutput2: 1\n", "\ninput3: N=5, names=[\"A\", \"C\", \"B\", \"D\", \"A\"]\noutput3: 1\n"], "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n// TOFILL\nint main() {\n    // Test Inputs\n    vector<string> names1 = {\"A\"};\n    vector<string> names2 = {\"A\", \"B\", \"B\", \"C\", \"A\"};\n    vector<string> names3 = {\"A\", \"C\", \"B\", \"D\", \"A\"};\n    vector<string> names4 = {};\n    vector<string> names5 = {\"X\", \"Y\", \"Z\"};\n\n    cout << maximumBattalions(1, names1) << endl; // Output for first test case\n    cout << maximumBattalions(5, names2) << endl; // Output for second test case\n    cout << maximumBattalions(5, names3) << endl; // Output for third test case\n    cout << maximumBattalions(0, names4) << endl; // Output for fourth test case\n    cout << maximumBattalions(3, names5) << endl; // Output for fifth test case\n\n    return 0;\n}", "TAG": "Success"}
{"source_Lan": "python###substringsAndPermutations.py", "source_code_str": "def substringsAndPermutations( n: int, m: int, s: str,\n                              arr: List[str]) -> List[int]:\n    vec = [[] for _ in range(10)]\n    for i in range(n):\n        vec[int(s[i])].append(i + 1)\n    fans = []\n    for i in range(m):\n        brr = [0] * 10\n        for j in range(len(arr[i])):\n            brr[int(arr[i][j])] += 1\n        ans = -1\n        f = 0\n        for j in range(10):\n            if brr[j] != 0:\n                if len(vec[j]) < brr[j]:\n                    f = 1\n                else:\n                    ans = max(ans, vec[j][brr[j] - 1])\n        if f == 1:\n            ans = -1\n        fans.append(ans)\n    return fans", "source_code_block": "", "target_Lan": "cpp###substringsAndPermutations.cpp", "reference_code": "    vector<int> substringsAndPermutations(int n, int m, string s, vector<string>&arr){\n        map<char,vector<int>>mp;\n        for (int i=0;i<n;i++){\n            char ch=s[i];\n            mp[ch].push_back(i);\n        }\n        vector<int>ans;\n        for (auto j:arr){\n            int ma=0;\n            unordered_map<char,int>ct;\n            for (auto k:j){\n                ct[k]+=1;\n            }\n            for (auto k:j){\n                int ele=ct[k];\n                if (ele>mp[k].size()){\n                    ma=-1;\n                    break;\n                }\n                else {\n                    ma=max(ma,mp[k][ele-1]+1);\n                }\n            }\n            ans.push_back(ma);\n        }\n        return ans;\n    }", "target_method_signature": "substringsAndPermutations", "source_method_signature": "substringsAndPermutations", "target_allMS": "    vector<int> substringsAndPermutations(int n, int m, string s, vector<string>&arr){", "source_allMS": "def substringsAndPermutations( n: int, m: int, s: str,", "source_import": "from typing import List", "target_import": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;", "commentTag": "//", "source_code_shell": "from typing import List\nfrom typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(substringsAndPermutations(0, 0, \"\", [\"\", \"nonempty\"]))", "all_input_output_value": "\ninput1: n=0, m=0, s=\"\"\noutput1: []\n", "input_output_value": ["\ninput1: n=0, m=0, s=\"\"\noutput1: []\n"], "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <map>\n#include <unordered_map>\n#include <string>\n// TOFILL\nint main() {\n    int n = 0;\n    int m = 0;\n    string s = \"\";\n    vector<string> arr; // Empty vector since m = 0\n\n    vector<int> result = substringsAndPermutations(n, m, s, arr);\n    \n    for(int val : result) {\n        cout << val << endl;\n    }\n\n    return 0;\n}", "TAG": "Success"}
{"source_Lan": "python###matchingCnt.py", "source_code_str": "def matchingCnt( n: int, X: List[str]) -> List[int]:\n    mp = []\n    ans = [0] * n\n    for i in range(n - 1, -1, -1):\n        s = X[i]\n        for j in range(len(s)):\n            \n            if len(mp) == j:\n                mp.append([0] * 26)\n            \n            ans[i] += mp[j][ord(s[j]) - 97]\n            mp[j][ord(s[j]) - 97] += 1\n    return ans", "source_code_block": "", "target_Lan": "cpp###matchingCnt.cpp", "reference_code": "    vector<int> matchingCnt(int n, vector<string>& X) {\n        unordered_map<int, array<int, 26>> map;\n        vector<int> ans(n);\n        for (int i = n - 1; i >= 0; i--) {\n            string x = X[i];\n            int cans = 0;\n            for (int j = 0; j < x.length(); j++) {\n                if (map.find(j) == map.end()) {\n                    map[j] = array<int, 26>{};\n                }\n                cans += map[j][x[j] - 'a'];\n                map[j][x[j] - 'a']++;\n            }\n            ans[i] = cans;\n        }\n        return ans;\n    }", "target_method_signature": "matchingCnt", "source_method_signature": "matchingCnt", "target_allMS": "    vector<int> matchingCnt(int n, vector<string>& X) {", "source_allMS": "def matchingCnt( n: int, X: List[str]) -> List[int]:", "source_import": "from typing import List", "target_import": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;", "commentTag": "//", "source_code_shell": "from typing import List\nfrom typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(matchingCnt(0, []))\n    print(matchingCnt(1, [\"a\"]))\n    print(matchingCnt(2, [\"a\", \"b\"]))\n    print(matchingCnt(3, [\"a\", \"a\", \"a\"]))\n    print(matchingCnt(4, [\"abc\", \"ab\", \"a\", \"a\"]))", "all_input_output_value": "\ninput1: n=0, X=[]\noutput1: []\n--------\ninput2: n=1, X=[\"a\"]\noutput2: [0]\n--------\ninput3: n=2, X=[\"a\", \"b\"]\noutput3: [0, 0]\n--------\ninput4: n=3, X=[\"a\", \"a\", \"a\"]\noutput4: [2, 1, 0]\n--------\ninput5: n=4, X=[\"abc\", \"ab\", \"a\", \"a\"]\noutput5: [4, 2, 1, 0]\n", "input_output_value": ["\ninput1: n=0, X=[]\noutput1: []\n", "\ninput2: n=1, X=[\"a\"]\noutput2: [0]\n", "\ninput3: n=2, X=[\"a\", \"b\"]\noutput3: [0, 0]\n"], "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <array>\n// TOFILL\nint main() {\n    vector<string> input1 = {};\n    vector<string> input2 = {\"a\"};\n    vector<string> input3 = {\"a\", \"b\"};\n    vector<string> input4 = {\"a\", \"a\", \"a\"};\n    vector<string> input5 = {\"abc\", \"ab\", \"a\", \"a\"};\n\n    vector<int> result1 = matchingCnt(0, input1);\n    vector<int> result2 = matchingCnt(1, input2);\n    vector<int> result3 = matchingCnt(2, input3);\n    vector<int> result4 = matchingCnt(3, input4);\n    vector<int> result5 = matchingCnt(4, input5);\n\n    for(int r : result1) cout << r << \" \";\n    cout << endl;\n    for(int r : result2) cout << r << \" \";\n    cout << endl;\n    for(int r : result3) cout << r << \" \";\n    cout << endl;\n    for(int r : result4) cout << r << \" \";\n    cout << endl;\n    for(int r : result5) cout << r << \" \";\n    cout << endl;\n\n    return 0;\n}", "TAG": "Success"}
{"source_Lan": "python###candyShop.py", "source_code_str": "def candyShop( n : int, candies : List[int]) -> int:\n    s=set(el for el in candies)\n    t=Counter()\n    l=0\n    p=0\n    ans=float(\"inf\")\n    for el in candies:\n        p+=el\n        t[el]+=1\n        while len(t)==len(s):\n            ans=min(ans,p)\n            t[candies[l]]-=1\n            p-=candies[l]\n            if t[candies[l]]==0:\n                del t[candies[l]]\n            l+=1\n    return ans", "source_code_block": "", "target_Lan": "cpp###candyShop.cpp", "reference_code": "    int candyShop(int n, vector<int> &candies) {\n        int answer = INT_MAX;\n        unordered_map<int, int> m;\n        for(auto i : candies){\n            m[i] += 1;\n        }\n        int k = m.size();\n        m.clear();\n        int l = 0, r = 0;\n        int total = 0;\n        while(r < n){\n            m[candies[r]] += 1;\n            total += candies[r];\n            while(m[candies[l]] > 1){\n                m[candies[l]] -= 1;\n                total -= candies[l];\n                l += 1;\n            }\n            if(m.size() == k){\n                answer = min(answer, total);\n            }\n            r += 1;\n        }\n        return answer;\n    }", "target_method_signature": "candyShop", "source_method_signature": "candyShop", "target_allMS": "    int candyShop(int n, vector<int> &candies) {", "source_allMS": "def candyShop( n : int, candies : List[int]) -> int:", "source_import": "from typing import List\nfrom collections import Counter", "target_import": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;", "commentTag": "//", "source_code_shell": "from typing import List\nfrom collections import Counter\nfrom collections import Counter\nfrom typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(candyShop(0, []))\n    print(candyShop(1, [5]))\n    print(candyShop(5, [1, 2, 3, 4, 5]))\n    print(candyShop(6, [1, 1, 2, 2, 3, 3]))\n    print(candyShop(8, [1, 2, 2, 3, 4, 5, 1, 5]))\n    print(candyShop(10, [1, 2, 3, 4, 5, 1, 6, 6, 7, 8]))", "all_input_output_value": "\ninput1: n=0, candies=[]\noutput1: inf\n--------\ninput2: n=1, candies=[5]\noutput2: 5\n--------\ninput3: n=5, candies=[1, 2, 3, 4, 5]\noutput3: 15\n--------\ninput4: n=6, candies=[1, 1, 2, 2, 3, 3]\noutput4: 8\n--------\ninput5: n=8, candies=[1, 2, 2, 3, 4, 5, 1, 5]\noutput5: 15\n--------\ninput6: n=10, candies=[1, 2, 3, 4, 5, 1, 6, 6, 7, 8]\noutput6: 42\n", "input_output_value": ["\ninput1: n=0, candies=[]\noutput1: inf\n", "\ninput2: n=1, candies=[5]\noutput2: 5\n", "\ninput3: n=5, candies=[1, 2, 3, 4, 5]\noutput3: 15\n"], "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <climits>\n// TOFILL\nint main() {\n    vector<int> candies1 = {};\n    cout << candyShop(0, candies1) << endl;\n\n    vector<int> candies2 = {5};\n    cout << candyShop(1, candies2) << endl;\n\n    vector<int> candies3 = {1, 2, 3, 4, 5};\n    cout << candyShop(5, candies3) << endl;\n\n    vector<int> candies4 = {1, 1, 2, 2, 3, 3};\n    cout << candyShop(6, candies4) << endl;\n\n    vector<int> candies5 = {1, 2, 2, 3, 4, 5, 1, 5};\n    cout << candyShop(8, candies5) << endl;\n\n    vector<int> candies6 = {1, 2, 3, 4, 5, 1, 6, 6, 7, 8};\n    cout << candyShop(10, candies6) << endl;\n\n    return 0;\n}", "TAG": "Success"}
{"source_Lan": "python###minimizeArr.py", "source_code_str": "def minimizeArr( n: int, arr: List[int]) -> int:\n    min_element = min(arr)\n    if arr.count(min_element) == 1:\n        return 1\n    else:\n        count = arr.count(min_element)\n        for el in arr:\n            if el % min_element != 0:\n                return 1\n        return (count + 1) // 2", "source_code_block": "", "target_Lan": "cpp###minimizeArr.cpp", "reference_code": "    int minimizeArr(int n, vector<int>&arr){\n        int mi=INT_MAX;\n        for (auto j:arr) mi=min(mi,j);\n        int ct=0;\n        for (auto j:arr){\n            if (j==mi)ct+=1;\n        }\n        if (ct==1) return 1;\n        for (auto j:arr){\n            if (j%mi!=0) return 1;\n        }\n        return ceil((float)ct / 2);\n    }", "target_method_signature": "minimizeArr", "source_method_signature": "minimizeArr", "target_allMS": "    int minimizeArr(int n, vector<int>&arr){", "source_allMS": "def minimizeArr( n: int, arr: List[int]) -> int:", "source_import": "from typing import List", "target_import": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;", "commentTag": "//", "source_code_shell": "from typing import List\nfrom typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(minimizeArr(5, [7, 7, 7, 7, 7]))  # Test Input 2\n    print(minimizeArr(4, [2, 3, 2, 5]))      # Test Input 3\n    print(minimizeArr(3, [2, 4, 3]))          # Test Input 4\n    print(minimizeArr(7, [2, 2, 2, 3, 3, 5, 5]))  # Test Input 5", "all_input_output_value": "\ninput1: n=5, arr=[7, 7, 7, 7, 7]\noutput1: 3\n--------\ninput2: n=4, arr=[2, 3, 2, 5]\noutput2: 1\n--------\ninput3: n=3, arr=[2, 4, 3]\noutput3: 1\n--------\ninput4: n=7, arr=[2, 2, 2, 3, 3, 5, 5]\noutput4: 1\n", "input_output_value": ["\ninput1: n=5, arr=[7, 7, 7, 7, 7]\noutput1: 3\n", "\ninput2: n=4, arr=[2, 3, 2, 5]\noutput2: 1\n", "\ninput3: n=3, arr=[2, 4, 3]\noutput3: 1\n"], "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n#include <cmath>\n// TOFILL\nint main() {\n    vector<int> arr1 = {7, 7, 7, 7, 7};\n    cout << minimizeArr(5, arr1) << endl; // Test Input 1\n\n    vector<int> arr2 = {2, 3, 2, 5};\n    cout << minimizeArr(4, arr2) << endl; // Test Input 2\n\n    vector<int> arr3 = {2, 4, 3};\n    cout << minimizeArr(3, arr3) << endl; // Test Input 3\n\n    vector<int> arr4 = {2, 2, 2, 3, 3, 5, 5};\n    cout << minimizeArr(7, arr4) << endl; // Test Input 4\n\n    return 0;\n}", "TAG": "Success"}
{"source_Lan": "python###minElements.py", "source_code_str": "def minElements( n : int, m : int, arr1 : List[int], arr2 : List[int]) -> int:\n    s=sum(arr1)\n    arr2.sort(reverse=True)\n    ind=0\n    curr=0\n    for el in arr2:\n        curr+=el\n        if curr>=s:\n            return ind+1\n        ind+=1\n    return -1", "source_code_block": "", "target_Lan": "cpp###minElements.cpp", "reference_code": "    int minElements(int n, int m, vector<int> &arr1, vector<int> &arr2) {\n        long long s=0;\n        for (auto j:arr1) s+=j;\n        sort(arr2.begin(),arr2.end());\n        long long cur=0;\n        int ans=0;\n        for (int i=m-1;i>=0;i--){\n            cur+=arr2[i];\n            ans+=1;\n            if (cur>=s)break;\n        }\n        if (cur>=s) return ans;\n        return -1;\n    }", "target_method_signature": "minElements", "source_method_signature": "minElements", "target_allMS": "    int minElements(int n, int m, vector<int> &arr1, vector<int> &arr2) {", "source_allMS": "def minElements( n : int, m : int, arr1 : List[int], arr2 : List[int]) -> int:", "source_import": "from typing import List", "target_import": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;", "commentTag": "//", "source_code_shell": "from typing import List\nfrom typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(minElements(4, 5, [1, 2, 3, 4], [4, 5, 6, 7, 8]))  # Test Input 1\n    print(minElements(3, 4, [10, 10, 10], [1, 2, 3, 4]))      # Test Input 2\n    print(minElements(5, 3, [0, 0, 0, 0], [1, 2, 3]))         # Test Input 3\n    print(minElements(0, 5, [], [1, 2, 3, 4, 5]))             # Test Input 4\n    print(minElements(4, 4, [-1, -1, -1, -1], [-1, -2, -3, -4]))  # Test Input 5", "all_input_output_value": "\ninput1: n=4, m=5, arr1=[1, 2, 3, 4], arr2=[4, 5, 6, 7, 8]\noutput1: 2\n--------\ninput2: n=3, m=4, arr1=[10, 10, 10], arr2=[1, 2, 3, 4]\noutput2: -1\n--------\ninput3: n=5, m=3, arr1=[0, 0, 0, 0], arr2=[1, 2, 3]\noutput3: 1\n--------\ninput4: n=0, m=5, arr1=[], arr2=[1, 2, 3, 4, 5]\noutput4: 1\n--------\ninput5: n=4, m=4, arr1=[-1, -1, -1, -1], arr2=[-1, -2, -3, -4]\noutput5: 1\n", "input_output_value": ["\ninput1: n=4, m=5, arr1=[1, 2, 3, 4], arr2=[4, 5, 6, 7, 8]\noutput1: 2\n", "\ninput2: n=3, m=4, arr1=[10, 10, 10], arr2=[1, 2, 3, 4]\noutput2: -1\n", "\ninput3: n=5, m=3, arr1=[0, 0, 0, 0], arr2=[1, 2, 3]\noutput3: 1\n"], "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <algorithm>\n// TOFILL\nint main() {\n    vector<int> arr1_1 = {1, 2, 3, 4};\n    vector<int> arr2_1 = {4, 5, 6, 7, 8};\n    cout << minElements(4, 5, arr1_1, arr2_1) << endl;\n\n    vector<int> arr1_2 = {10, 10, 10};\n    vector<int> arr2_2 = {1, 2, 3, 4};\n    cout << minElements(3, 4, arr1_2, arr2_2) << endl;\n\n    vector<int> arr1_3 = {0, 0, 0, 0};\n    vector<int> arr2_3 = {1, 2, 3};\n    cout << minElements(5, 3, arr1_3, arr2_3) << endl;\n\n    vector<int> arr1_4 = {};\n    vector<int> arr2_4 = {1, 2, 3, 4, 5};\n    cout << minElements(0, 5, arr1_4, arr2_4) << endl;\n\n    vector<int> arr1_5 = {-1, -1, -1, -1};\n    vector<int> arr2_5 = {-1, -2, -3, -4};\n    cout << minElements(4, 4, arr1_5, arr2_5) << endl;\n\n    return 0;\n}", "TAG": "Success"}
{"source_Lan": "python###minJumps.py", "source_code_str": "def minJumps( n: int, arr: List[int]) -> int:\n    occ = {}\n    ans = float('inf')\n    for i in range(n):\n        if arr[i] not in occ:\n            ans = min(ans, n - 1)\n            occ[arr[i]] = i\n        else:\n            ans = min(occ[arr[i]] + n - i, ans)\n    return ans", "source_code_block": "", "target_Lan": "cpp###minJumps.cpp", "reference_code": "    int minJumps(int n, vector<int> &arr) {\n        map<int, int> m;\n        int ans = n - 1;\n        for (int i = n - 1; i >= 0; i--) {\n            if (m.count(arr[i])) {\n                ans = min(ans, n - (m[arr[i]] - i));\n            } else {\n                m[arr[i]] = i;\n            }\n        }\n        return ans;\n    }", "target_method_signature": "minJumps", "source_method_signature": "minJumps", "target_allMS": "    int minJumps(int n, vector<int> &arr) {", "source_allMS": "def minJumps( n: int, arr: List[int]) -> int:", "source_import": "from typing import List", "target_import": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;", "commentTag": "//", "source_code_shell": "from typing import List\nfrom typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(minJumps(5, [10, 5, 5, 10, 1]))\n    print(minJumps(6, [1, 3, 5, 3, 2, 1]))\n    print(minJumps(4, [1, 2, 3, 4]))\n    print(minJumps(3, [1, 1, 1]))\n    print(minJumps(7, [2, 3, 3, 2, 4, 0, 5]))", "all_input_output_value": "\ninput1: n=5, arr=[10, 5, 5, 10, 1]\noutput1: 2\n--------\ninput2: n=6, arr=[1, 3, 5, 3, 2, 1]\noutput2: 1\n--------\ninput3: n=4, arr=[1, 2, 3, 4]\noutput3: 3\n--------\ninput4: n=3, arr=[1, 1, 1]\noutput4: 1\n--------\ninput5: n=7, arr=[2, 3, 3, 2, 4, 0, 5]\noutput5: 4\n", "input_output_value": ["\ninput1: n=5, arr=[10, 5, 5, 10, 1]\noutput1: 2\n", "\ninput2: n=6, arr=[1, 3, 5, 3, 2, 1]\noutput2: 1\n", "\ninput3: n=4, arr=[1, 2, 3, 4]\noutput3: 3\n"], "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <map>\n// TOFILL\nint main() {\n    vector<int> input1 = {10, 5, 5, 10, 1};\n    vector<int> input2 = {1, 3, 5, 3, 2, 1};\n    vector<int> input3 = {1, 2, 3, 4};\n    vector<int> input4 = {1, 1, 1};\n    vector<int> input5 = {2, 3, 3, 2, 4, 0, 5};\n\n    cout << minJumps(5, input1) << endl;\n    cout << minJumps(6, input2) << endl;\n    cout << minJumps(4, input3) << endl;\n    cout << minJumps(3, input4) << endl;\n    cout << minJumps(7, input5) << endl;\n\n    return 0;\n}", "TAG": "Success"}
{"source_Lan": "python###minimumPushes.py", "source_code_str": "def minimumPushes( word: str) -> int:\n    k, rem = divmod(len(word), 8)\n    return (k * 4 + rem) * (k + 1)", "source_code_block": "", "target_Lan": "cpp###minimumPushes.cpp", "reference_code": "    int minimumPushes(string &word) {\n        int n = word.length();\n        int k = n / 8;\n        return (k * 4 + n % 8) * (k + 1);\n    }", "target_method_signature": "minimumPushes", "source_method_signature": "minimumPushes", "target_allMS": "    int minimumPushes(string &word) {", "source_allMS": "def minimumPushes( word: str) -> int:", "source_import": "", "target_import": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;", "commentTag": "//", "source_code_shell": "# TOFILL\nif __name__ == \"__main__\":\n    print(minimumPushes(\"\"))  # Test Input 1\n    print(minimumPushes(\"00000000\"))  # Test Input 2\n    print(minimumPushes(\"00000001\"))  # Test Input 3\n    print(minimumPushes(\"00000010\"))  # Test Input 4\n    print(minimumPushes(\"00000010000000\"))  # Test Input 5", "all_input_output_value": "\ninput1: word=\"\"\noutput1: 0\n--------\ninput2: word=\"00000000\"\noutput2: 8\n--------\ninput3: word=\"00000001\"\noutput3: 8\n--------\ninput4: word=\"00000010\"\noutput4: 8\n--------\ninput5: word=\"00000010000000\"\noutput5: 20\n", "input_output_value": ["\ninput1: word=\"\"\noutput1: 0\n", "\ninput2: word=\"00000000\"\noutput2: 8\n", "\ninput3: word=\"00000001\"\noutput3: 8\n"], "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <string>\n// TOFILL\nint main() {\n    string input1 = \"\";\n    string input2 = \"00000000\";\n    string input3 = \"00000001\";\n    string input4 = \"00000010\";\n    string input5 = \"00000010000000\";\n\n    cout << minimumPushes(input1) << endl;\n    cout << minimumPushes(input2) << endl;\n    cout << minimumPushes(input3) << endl;\n    cout << minimumPushes(input4) << endl;\n    cout << minimumPushes(input5) << endl;\n\n    return 0;\n}", "TAG": "Success"}
{"source_Lan": "python###sumDigitDifferences.py", "source_code_str": "def sumDigitDifferences( nums: List[int]) -> int:\n    ans = 0\n    cnt = [[0] * 10 for _ in str(nums[0])]\n    for k, x in enumerate(nums):\n        i = 0\n        while x:\n            x, d = divmod(x, 10)\n            ans += k - cnt[i][d]\n            cnt[i][d] += 1\n            i += 1\n    return ans", "source_code_block": "", "target_Lan": "cpp###sumDigitDifferences.cpp", "reference_code": "    long long sumDigitDifferences(vector<int>& nums) {\n        long long ans = 0;\n        vector<array<int, 10>> cnt(to_string(nums[0]).length());\n        for (int k = 0; k < nums.size(); k++) {\n            int x = nums[k];\n            for (int i = 0; x; x /= 10, i++) {\n                int d = x % 10;\n                ans += k - cnt[i][d]++;\n            }\n        }\n        return ans;\n    }", "target_method_signature": "sumDigitDifferences", "source_method_signature": "sumDigitDifferences", "target_allMS": "    long long sumDigitDifferences(vector<int>& nums) {", "source_allMS": "def sumDigitDifferences( nums: List[int]) -> int:", "source_import": "", "target_import": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;", "commentTag": "//", "source_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(sumDigitDifferences([0]))                    # Single digit case\n    print(sumDigitDifferences([10, 20, 30, 40]))      # Multiple elements with consistent digit length", "all_input_output_value": "\ninput1: nums=[0]\noutput1: 0\n--------\ninput2: nums=[10, 20, 30, 40]\noutput2: 6\n", "input_output_value": ["\ninput1: nums=[0]\noutput1: 0\n", "\ninput2: nums=[10, 20, 30, 40]\noutput2: 6\n"], "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <array>\n// TOFILL\nint main() {\n    vector<int> input1 = {0};\n    vector<int> input2 = {10, 20, 30, 40};\n\n    cout << sumDigitDifferences(input1) << endl;\n    cout << sumDigitDifferences(input2) << endl;\n\n    return 0;\n}", "TAG": "Success"}
{"source_Lan": "python###minimumLevels.py", "source_code_str": "def minimumLevels( possible: List[int]) -> int:\n    \n    s = sum(possible) * 2 - len(possible)\n    pre = 0\n    for i, x in enumerate(possible[:-1]):\n        pre += 2 if x else -2\n        if pre > s:\n            return i + 1\n    return -1", "source_code_block": "", "target_Lan": "cpp###minimumLevels.cpp", "reference_code": "    int minimumLevels(vector<int> &possible) {\n        \n        int n = possible.size();\n        int s = accumulate(possible.begin(), possible.end(), 0) * 2 - n;\n        int pre = 0;\n        for (int i = 0; i < n - 1; i++) {\n            pre += possible[i] ? 2 : -2;\n            if (pre > s) {\n                return i + 1;\n            }\n        }\n        return -1;\n    }", "target_method_signature": "minimumLevels", "source_method_signature": "minimumLevels", "target_allMS": "    int minimumLevels(vector<int> &possible) {", "source_allMS": "def minimumLevels( possible: List[int]) -> int:", "source_import": "", "target_import": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;", "commentTag": "//", "source_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(minimumLevels([]))  # Test input 1: possible = {}\n    print(minimumLevels([0, 0, 0]))  # Test input 2: possible = {0, 0, 0}\n    print(minimumLevels([1, 1, 1, 1]))  # Test input 3: possible = {1, 1, 1, 1}\n    print(minimumLevels([1, 0, -1, 1, 0]))  # Test input 4: possible = {1, 0, -1, 1, 0}\n    print(minimumLevels([1, -1, 1, -1, 1]))  # Test input 5: possible = {1, -1, 1, -1, 1}", "all_input_output_value": "\ninput1: possible=[]\noutput1: -1\n--------\ninput2: possible=[0, 0, 0]\noutput2: 1\n--------\ninput3: possible=[1, 1, 1, 1]\noutput3: 3\n--------\ninput4: possible=[1, 0, -1, 1, 0]\noutput4: 1\n--------\ninput5: possible=[1, -1, 1, -1, 1]\noutput5: 1\n", "input_output_value": ["\ninput1: possible=[]\noutput1: -1\n", "\ninput2: possible=[0, 0, 0]\noutput2: 1\n", "\ninput3: possible=[1, 1, 1, 1]\noutput3: 3\n"], "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <numeric>\n// TOFILL\nint main() {\n    vector<int> input1 = {};\n    vector<int> input2 = {0, 0, 0};\n    vector<int> input3 = {1, 1, 1, 1};\n    vector<int> input4 = {1, 0, -1, 1, 0};\n    vector<int> input5 = {1, -1, 1, -1, 1};\n\n    cout << minimumLevels(input1) << endl;\n    cout << minimumLevels(input2) << endl;\n    cout << minimumLevels(input3) << endl;\n    cout << minimumLevels(input4) << endl;\n    cout << minimumLevels(input5) << endl;\n\n    return 0;\n}", "TAG": "Success"}
{"source_Lan": "python###garbageCollection.py", "source_code_str": "def garbageCollection( garbage: List[str], travel: List[int]) -> int:\n    distance = {}\n    res = 0\n    cur_dis = 0\n    for i in range(len(garbage)):\n        res += len(garbage[i])\n        if i > 0:\n            cur_dis += travel[i - 1]\n        for c in garbage[i]:\n            distance[c] = cur_dis\n    return res + sum(distance.values())", "source_code_block": "", "target_Lan": "cpp###garbageCollection.cpp", "reference_code": "    int garbageCollection(vector<string>& garbage, vector<int>& travel) {\n        unordered_map<char, int> distance;\n        int res = 0, cur_dis = 0;\n        for (int i = 0; i < garbage.size(); i++) {\n            res += garbage[i].size();\n            if (i > 0) {\n                cur_dis += travel[i - 1];\n            }\n            for (auto c : garbage[i]) {\n                distance[c] = cur_dis;\n            }\n        }\n        for (auto &[k, v] : distance) {\n            res += v;\n        }\n        return res;\n    }", "target_method_signature": "garbageCollection", "source_method_signature": "garbageCollection", "target_allMS": "    int garbageCollection(vector<string>& garbage, vector<int>& travel) {", "source_allMS": "def garbageCollection( garbage: List[str], travel: List[int]) -> int:", "source_import": "", "target_import": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;", "commentTag": "//", "source_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(garbageCollection([\"G\", \"P\", \"G\", \"M\"], [1, 2, 3]))    # Normal case with different garbage types\n    print(garbageCollection([\"G\", \"G\", \"G\"], [1, 1]))            # All same type of garbage, testing accumulation of distance\n    print(garbageCollection([\"\", \"P\", \"M\"], [0, 0]))             # Edge case with empty string and no travel\n    print(garbageCollection([\"Z\"], []))                            # Single type of garbage and no travel\n    print(garbageCollection([\"G\", \"P\"], [2]))                     # Two types of garbage with one travel distance", "all_input_output_value": "\ninput1: garbage=[\"G\", \"P\", \"G\", \"M\"], travel=[1, 2, 3]\noutput1: 14\n--------\ninput2: garbage=[\"G\", \"G\", \"G\"], travel=[1, 1]\noutput2: 5\n--------\ninput3: garbage=[\"\", \"P\", \"M\"], travel=[0, 0]\noutput3: 2\n--------\ninput4: garbage=[\"Z\"], travel=[]\noutput4: 1\n--------\ninput5: garbage=[\"G\", \"P\"], travel=[2]\noutput5: 4\n", "input_output_value": ["\ninput1: garbage=[\"G\", \"P\", \"G\", \"M\"], travel=[1, 2, 3]\noutput1: 14\n", "\ninput2: garbage=[\"G\", \"G\", \"G\"], travel=[1, 1]\noutput2: 5\n", "\ninput3: garbage=[\"\", \"P\", \"M\"], travel=[0, 0]\noutput3: 2\n"], "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n// TOFILL\nint main() {\n    vector<string> garbage1 = {\"G\", \"P\", \"G\", \"M\"};\n    vector<int> travel1 = {1, 2, 3};\n    cout << garbageCollection(garbage1, travel1) << endl;\n\n    vector<string> garbage2 = {\"G\", \"G\", \"G\"};\n    vector<int> travel2 = {1, 1};\n    cout << garbageCollection(garbage2, travel2) << endl;\n\n    vector<string> garbage3 = {\"\", \"P\", \"M\"};\n    vector<int> travel3 = {0, 0};\n    cout << garbageCollection(garbage3, travel3) << endl;\n\n    vector<string> garbage4 = {\"Z\"};\n    vector<int> travel4 = {};\n    cout << garbageCollection(garbage4, travel4) << endl;\n\n    vector<string> garbage5 = {\"G\", \"P\"};\n    vector<int> travel5 = {2};\n    cout << garbageCollection(garbage5, travel5) << endl;\n\n    return 0;\n}", "TAG": "Success"}
{"source_Lan": "python###totalCost.py", "source_code_str": "def totalCost( costs: List[int], k: int, candidates: int) -> int:\n    n = len(costs)\n    q = list()\n    left, right = candidates - 1, n - candidates\n    if left + 1 < right:\n        for i in range(left + 1):\n            heappush(q, (costs[i], i))\n        for i in range(right, n):\n            heappush(q, (costs[i], i))\n    else:\n        for i in range(n):\n            heappush(q, (costs[i], i))\n    ans = 0\n    for _ in range(k):\n        cost, idx = heappop(q)\n        ans += cost\n        if left + 1 < right:\n            if idx <= left:\n                left += 1\n                heappush(q, (costs[left], left))\n            else:\n                right -= 1\n                heappush(q, (costs[right], right))\n    return ans", "source_code_block": "", "target_Lan": "cpp###totalCost.cpp", "reference_code": "    long long totalCost(vector<int>& costs, int k, int candidates) {\n        int n = costs.size();\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> q;\n        int left = candidates - 1, right = n - candidates;\n        if (left + 1 < right) {\n            for (int i = 0; i <= left; ++i) {\n                q.emplace(costs[i], i);\n            }\n            for (int i = right; i < n; ++i) {\n                q.emplace(costs[i], i);\n            }\n        }\n        else {\n            for (int i = 0; i < n; ++i) {\n                q.emplace(costs[i], i);\n            }\n        }\n        long long ans = 0;\n        for (int _ = 0; _ < k; ++_) {\n            auto [cost, id] = q.top();\n            q.pop();\n            ans += cost;\n            if (left + 1 < right) {\n                if (id <= left) {\n                    ++left;\n                    q.emplace(costs[left], left);\n                }\n                else {\n                    --right;\n                    q.emplace(costs[right], right);\n                }\n            }\n        }\n        return ans;\n    }", "target_method_signature": "totalCost", "source_method_signature": "totalCost", "target_allMS": "    long long totalCost(vector<int>& costs, int k, int candidates) {", "source_allMS": "def totalCost( costs: List[int], k: int, candidates: int) -> int:", "source_import": "", "target_import": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;", "commentTag": "//", "source_code_shell": "from typing import List\nfrom heapq import heappush, heappop\n# TOFILL\nif __name__ == \"__main__\":\n    print(totalCost([], 0, 0))  # Test case 0\n    print(totalCost([1], 1, 1))  # Test case 1\n    print(totalCost([5, 10], 2, 1))  # Test case 2\n    print(totalCost([1, 2, 3, 4, 5], 3, 1))  # Test case 3\n    print(totalCost([10, 20, 30, 40, 50], 3, 5))  # Test case 4", "all_input_output_value": "\ninput1: costs=[], k=0, candidates=0\noutput1: 0\n--------\ninput2: costs=[1], k=1, candidates=1\noutput2: 1\n--------\ninput3: costs=[5, 10], k=2, candidates=1\noutput3: 15\n--------\ninput4: costs=[1, 2, 3, 4, 5], k=3, candidates=1\noutput4: 6\n--------\ninput5: costs=[10, 20, 30, 40, 50], k=3, candidates=5\noutput5: 60\n", "input_output_value": ["\ninput1: costs=[], k=0, candidates=0\noutput1: 0\n", "\ninput2: costs=[1], k=1, candidates=1\noutput2: 1\n", "\ninput3: costs=[5, 10], k=2, candidates=1\noutput3: 15\n"], "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <queue>\n// TOFILL\nint main() {\n    vector<int> costs1 = {};\n    cout << totalCost(costs1, 0, 0) << endl;\n\n    vector<int> costs2 = {1};\n    cout << totalCost(costs2, 1, 1) << endl;\n\n    vector<int> costs3 = {5, 10};\n    cout << totalCost(costs3, 2, 1) << endl;\n\n    vector<int> costs4 = {1, 2, 3, 4, 5};\n    cout << totalCost(costs4, 3, 1) << endl;\n\n    vector<int> costs5 = {10, 20, 30, 40, 50};\n    cout << totalCost(costs5, 3, 5) << endl;\n\n    return 0;\n}", "TAG": "Success"}
{"source_Lan": "python###distinctIntegers.py", "source_code_str": "def distinctIntegers( n: int) -> int:\n    nums = [0] * (n + 1)\n    nums[n] = 1\n    for _ in range(0, n):\n        for x in range(1, n + 1):\n            if nums[x] == 0:\n                continue\n            for i in range(1, n + 1):\n                if x % i == 1:\n                    nums[i] = 1\n    return sum(nums)", "source_code_block": "", "target_Lan": "cpp###distinctIntegers.cpp", "reference_code": "    int distinctIntegers(int n) {\n        vector<int> nums(n + 1);\n        nums[n] = 1;\n        for (int k = 0; k < n; k++) {\n            for (int x = 1; x <= n; x++) {\n                if (nums[x] == 0) {\n                    continue;\n                }\n                for (int i = 1; i <= n; i++) {\n                    if (x % i == 1) {\n                        nums[i] = 1;\n                    }\n                }\n            }\n        }\n        return accumulate(nums.begin(), nums.end(), 0);\n    }", "target_method_signature": "distinctIntegers", "source_method_signature": "distinctIntegers", "target_allMS": "    int distinctIntegers(int n) {", "source_allMS": "def distinctIntegers( n: int) -> int:", "source_import": "", "target_import": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;", "commentTag": "//", "source_code_shell": "# TOFILL\nif __name__ == \"__main__\":\n    print(distinctIntegers(0))\n    print(distinctIntegers(1))\n    print(distinctIntegers(2))\n    print(distinctIntegers(5))\n    print(distinctIntegers(10))", "all_input_output_value": "\ninput1: n=0\noutput1: 1\n--------\ninput2: n=1\noutput2: 1\n--------\ninput3: n=2\noutput3: 1\n--------\ninput4: n=5\noutput4: 4\n--------\ninput5: n=10\noutput5: 9\n", "input_output_value": ["\ninput1: n=0\noutput1: 1\n", "\ninput2: n=1\noutput2: 1\n", "\ninput3: n=2\noutput3: 1\n"], "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <numeric>\n// TOFILL\nint main() {\n    cout << distinctIntegers(0) << endl;\n    cout << distinctIntegers(1) << endl;\n    cout << distinctIntegers(2) << endl;\n    cout << distinctIntegers(5) << endl;\n    cout << distinctIntegers(10) << endl;\n}", "TAG": "Success"}
{"source_Lan": "python###consecutiveVal.py", "source_code_str": "def consecutiveVal( n: int, a: List[int]) -> str:\n    \n    Set = set(a)\n    ans = \"\"\n    \n    for e in a:\n        \n        if e - 1 in Set or e + 1 in Set:\n            ans += '1'\n        else:\n            ans += '0'\n    return ans", "source_code_block": "", "target_Lan": "cpp###consecutiveVal.cpp", "reference_code": "    string consecutiveVal(int n, vector<int> &a) {\n        \n        string result = \"\";\n        unordered_map<int, bool> mp;\n        for (int i = 0; i < n; i++) {\n            mp[a[i]] = true;\n        }\n        for (int i = 0; i < n; i++) {\n            if (mp[a[i] - 1] == true || mp[a[i] + 1] == true) {\n                result += '1';\n            } else\n                result += '0';\n        }\n        return result;\n    }", "target_method_signature": "consecutiveVal", "source_method_signature": "consecutiveVal", "target_allMS": "    string consecutiveVal(int n, vector<int> &a) {", "source_allMS": "def consecutiveVal( n: int, a: List[int]) -> str:", "source_import": "from typing import List", "target_import": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;", "commentTag": "//", "source_code_shell": "from typing import List\nfrom typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(consecutiveVal(0, []))\n    print(consecutiveVal(1, [5]))\n    print(consecutiveVal(5, [1, 2, 3, 4, 5]))\n    print(consecutiveVal(4, [10, 12, 14, 16]))\n    print(consecutiveVal(3, [-2, -1, 1]))", "all_input_output_value": "\ninput1: n=0, a=[]\noutput1: 0\n--------\ninput2: n=1, a=[5]\noutput2: 11111\n--------\ninput3: n=5, a=[1, 2, 3, 4, 5]\noutput3: 0000\n--------\ninput4: n=4, a=[10, 12, 14, 16]\noutput4: 110\n--------\ninput5: n=3, a=[-2, -1, 1]\noutput5: \n", "input_output_value": ["\ninput1: n=0, a=[]\noutput1: 0\n", "\ninput2: n=1, a=[5]\noutput2: 11111\n", "\ninput3: n=5, a=[1, 2, 3, 4, 5]\noutput3: 0000\n"], "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n// TOFILL\nint main() {\n    vector<int> input1 = {};\n    vector<int> input2 = {5};\n    vector<int> input3 = {1, 2, 3, 4, 5};\n    vector<int> input4 = {10, 12, 14, 16};\n    vector<int> input5 = {-2, -1, 1};\n\n    cout << consecutiveVal(0, input1) << endl;\n    cout << consecutiveVal(1, input2) << endl;\n    cout << consecutiveVal(5, input3) << endl;\n    cout << consecutiveVal(4, input4) << endl;\n    cout << consecutiveVal(3, input5) << endl;\n\n    return 0;\n}", "TAG": "Success"}
{"source_Lan": "python###goodSubsetofBinaryMatrix.py", "source_code_str": "def goodSubsetofBinaryMatrix( grid: List[List[int]]) -> List[int]:\n    ans = []\n    mp = {}\n    m = len(grid)\n    n = len(grid[0])\n    for j in range(m):\n        st = 0\n        for i in range(n):\n            st |= (grid[j][i] << i)\n        mp[st] = j\n    if 0 in mp:\n        ans.append(mp[0])\n        return ans\n    for x, i in mp.items():\n        for y, j in mp.items():\n            if not (x & y):\n                return [min(i, j), max(i, j)]\n    return ans", "source_code_block": "", "target_Lan": "cpp###goodSubsetofBinaryMatrix.cpp", "reference_code": "    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid) {\n        vector<int> ans;\n        unordered_map<int, int> mp;\n        int m = grid.size();\n        int n = grid[0].size();\n        for (int j = 0; j < m; j++) {\n            int st = 0;\n            for (int i = 0; i < n; i++) {\n                st |= (grid[j][i] << i);\n            }\n            mp[st] = j;\n        }\n        if (mp.count(0)) {\n            ans.push_back(mp[0]);\n            return ans;\n        }\n        for (auto [x, i]: mp) {\n            for (auto [y, j]: mp) {\n                if (!(x & y)) {\n                    return {min(i, j), max(i, j)};\n                }\n            }\n        }\n        return ans;\n    }", "target_method_signature": "goodSubsetofBinaryMatrix", "source_method_signature": "goodSubsetofBinaryMatrix", "target_allMS": "    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid) {", "source_allMS": "def goodSubsetofBinaryMatrix( grid: List[List[int]]) -> List[int]:", "source_import": "", "target_import": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;", "commentTag": "//", "source_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    # Test case 1: All zero matrix\n    print(goodSubsetofBinaryMatrix([[0, 0], [0, 0]]))\n    # Test case 2: Two rows with no common '1's\n    print(goodSubsetofBinaryMatrix([[1, 0], [0, 1]]))\n    # Test case 3: Identical rows\n    print(goodSubsetofBinaryMatrix([[1, 1], [1, 1]]))\n    # Test case 4: Only one row (edge case)\n    print(goodSubsetofBinaryMatrix([[1, 0]]))\n    # Test case 5: All rows overlap\n    print(goodSubsetofBinaryMatrix([[1, 1, 1], [1, 1, 1]]))", "all_input_output_value": "\ninput1: grid=[[0, 0], [0, 0]]\noutput1: [1]\n--------\ninput2: grid=[[1, 0], [0, 1]]\noutput2: [0, 1]\n--------\ninput3: grid=[[1, 1], [1, 1]]\noutput3: []\n--------\ninput4: grid=[[1, 0]]\noutput4: []\n--------\ninput5: grid=[[1, 1, 1], [1, 1, 1]]\noutput5: []\n", "input_output_value": ["\ninput1: grid=[[0, 0], [0, 0]]\noutput1: [1]\n", "\ninput2: grid=[[1, 0], [0, 1]]\noutput2: [0, 1]\n", "\ninput3: grid=[[1, 1], [1, 1]]\noutput3: []\n"], "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n// TOFILL\nint main() {\n    vector<vector<int>> grid1 = {{0, 0}, {0, 0}};\n    vector<vector<int>> grid2 = {{1, 0}, {0, 1}};\n    vector<vector<int>> grid3 = {{1, 1}, {1, 1}};\n    vector<vector<int>> grid4 = {{1, 0}};\n    vector<vector<int>> grid5 = {{1, 1, 1}, {1, 1, 1}};\n    \n    vector<int> result1 = goodSubsetofBinaryMatrix(grid1);\n    vector<int> result2 = goodSubsetofBinaryMatrix(grid2);\n    vector<int> result3 = goodSubsetofBinaryMatrix(grid3);\n    vector<int> result4 = goodSubsetofBinaryMatrix(grid4);\n    vector<int> result5 = goodSubsetofBinaryMatrix(grid5);\n    \n    // Print results\n    cout << \"Result for grid1: \";\n    for(int idx : result1) cout << idx << \" \";\n    cout << endl;\n\n    cout << \"Result for grid2: \";\n    for(int idx : result2) cout << idx << \" \";\n    cout << endl;\n\n    cout << \"Result for grid3: \";\n    for(int idx : result3) cout << idx << \" \";\n    cout << endl;\n\n    cout << \"Result for grid4: \";\n    for(int idx : result4) cout << idx << \" \";\n    cout << endl;\n\n    cout << \"Result for grid5: \";\n    for(int idx : result5) cout << idx << \" \";\n    cout << endl;\n\n    return 0;\n}", "TAG": "Success"}
{"source_Lan": "python###maximumBeauty.py", "source_code_str": "def maximumBeauty( nums: List[int], k: int) -> int:\n    res, j, n = 0, 0, len(nums)\n    nums.sort()\n    for i in range(n):\n        while nums[i] - 2 * k > nums[j]:\n            j += 1\n        res = max(res, i - j + 1)\n    return res", "source_code_block": "", "target_Lan": "cpp###maximumBeauty.cpp", "reference_code": "    int maximumBeauty(vector<int>& nums, int k) {\n        int res = 0, n = nums.size();\n        sort(nums.begin(), nums.end());\n        for (int i = 0, j = 0; i < n; i++) {\n            while (nums[i] - 2 * k > nums[j]) {\n                j++;\n            }\n            res = max(res, i - j + 1);\n        }\n        return res;\n    }", "target_method_signature": "maximumBeauty", "source_method_signature": "maximumBeauty", "target_allMS": "    int maximumBeauty(vector<int>& nums, int k) {", "source_allMS": "def maximumBeauty( nums: List[int], k: int) -> int:", "source_import": "", "target_import": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;", "commentTag": "//", "source_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(maximumBeauty([1, 2, 3], 1))\n    print(maximumBeauty([-2, -1, 0, 1, 2], 1))\n    print(maximumBeauty([5, 5, 5, 5], 10))\n    print(maximumBeauty([1, 10, 20], 3))\n    print(maximumBeauty([], 0))", "all_input_output_value": "\ninput1: nums=[1, 2, 3], k=1\noutput1: 3\n--------\ninput2: nums=[-2, -1, 0, 1, 2], k=1\noutput2: 3\n--------\ninput3: nums=[5, 5, 5, 5], k=10\noutput3: 4\n--------\ninput4: nums=[1, 10, 20], k=3\noutput4: 1\n--------\ninput5: nums=[], k=0\noutput5: 0\n", "input_output_value": ["\ninput1: nums=[1, 2, 3], k=1\noutput1: 3\n", "\ninput2: nums=[-2, -1, 0, 1, 2], k=1\noutput2: 3\n", "\ninput3: nums=[5, 5, 5, 5], k=10\noutput3: 4\n"], "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <algorithm>\n// TOFILL\nint main() {\n    vector<int> input1 = {1, 2, 3};\n    cout << maximumBeauty(input1, 1) << endl;\n\n    vector<int> input2 = {-2, -1, 0, 1, 2};\n    cout << maximumBeauty(input2, 1) << endl;\n\n    vector<int> input3 = {5, 5, 5, 5};\n    cout << maximumBeauty(input3, 10) << endl;\n\n    vector<int> input4 = {1, 10, 20};\n    cout << maximumBeauty(input4, 3) << endl;\n\n    vector<int> input5 = {};\n    cout << maximumBeauty(input5, 0) << endl;\n\n    return 0;\n}", "TAG": "Success"}
{"source_Lan": "python###numberOfSubarrays.py", "source_code_str": "def numberOfSubarrays( nums: List[int]) -> int:\n    ans = len(nums)\n    st = [[inf, 0]]  \n    for x in nums:\n        while x > st[-1][0]:\n            st.pop()\n        if x == st[-1][0]:\n            ans += st[-1][1]\n            st[-1][1] += 1\n        else:\n            st.append([x, 1])\n    return ans", "source_code_block": "", "target_Lan": "cpp###numberOfSubarrays.cpp", "reference_code": "    long long numberOfSubarrays(vector<int>& nums) {\n        long long ans = nums.size();\n        stack<pair<int, int>> st;\n        st.emplace(INT_MAX, 0); \n        for (int x : nums) {\n            while (x > st.top().first) {\n                st.pop();\n            }\n            if (x == st.top().first) {\n                ans += st.top().second++;\n            } else {\n                st.emplace(x, 1);\n            }\n        }\n        return ans;\n    }", "target_method_signature": "numberOfSubarrays", "source_method_signature": "numberOfSubarrays", "target_allMS": "    long long numberOfSubarrays(vector<int>& nums) {", "source_allMS": "def numberOfSubarrays( nums: List[int]) -> int:", "source_import": "", "target_import": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;", "commentTag": "//", "source_code_shell": "from typing import List\nfrom math import inf\n# TOFILL\nif __name__ == \"__main__\":\n    print(numberOfSubarrays([]))                      # Test with empty vector\n    print(numberOfSubarrays([1, 2, 3, 4, 5]))        # Test with strictly increasing values\n    print(numberOfSubarrays([5, 4, 3, 2, 1]))        # Test with strictly decreasing values\n    print(numberOfSubarrays([1, 1, 1, 1]))           # Test with all elements equal\n    print(numberOfSubarrays([1, 3, 2, 4, 3, 5]))     # Test with mixed increasing and decreasing values", "all_input_output_value": "\ninput1: nums=[]\noutput1: 0\n--------\ninput2: nums=[1, 2, 3, 4, 5]\noutput2: 5\n--------\ninput3: nums=[5, 4, 3, 2, 1]\noutput3: 5\n--------\ninput4: nums=[1, 1, 1, 1]\noutput4: 10\n--------\ninput5: nums=[1, 3, 2, 4, 3, 5]\noutput5: 6\n", "input_output_value": ["\ninput1: nums=[]\noutput1: 0\n", "\ninput2: nums=[1, 2, 3, 4, 5]\noutput2: 5\n", "\ninput3: nums=[5, 4, 3, 2, 1]\noutput3: 5\n"], "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <stack>\n#include <utility>\n#include <limits.h>\n// TOFILL\nint main() {\n    vector<int> nums1 = {};\n    vector<int> nums2 = {1, 2, 3, 4, 5};\n    vector<int> nums3 = {5, 4, 3, 2, 1};\n    vector<int> nums4 = {1, 1, 1, 1};\n    vector<int> nums5 = {1, 3, 2, 4, 3, 5};\n\n    cout << numberOfSubarrays(nums1) << endl;\n    cout << numberOfSubarrays(nums2) << endl;\n    cout << numberOfSubarrays(nums3) << endl;\n    cout << numberOfSubarrays(nums4) << endl;\n    cout << numberOfSubarrays(nums5) << endl;\n\n    return 0;\n}", "TAG": "Success"}
{"source_Lan": "python###numberOfStableArrays.py", "source_code_str": "def numberOfStableArrays( zero: int, one: int, limit: int) -> int:\n        dp = [[[0, 0] for _ in range(one + 1)] for _ in range(zero + 1)]\n        mod = int(1e9 + 7)\n        for i in range(min(zero, limit) + 1):\n            dp[i][0][0] = 1\n        for j in range(min(one, limit) + 1):\n            dp[0][j][1] = 1\n        for i in range(1, zero + 1):\n            for j in range(1, one + 1):\n                if i > limit:\n                    dp[i][j][0] = dp[i - 1][j][0] + dp[i - 1][j][1] - dp[i - limit - 1][j][1]\n                else:\n                    dp[i][j][0] = dp[i - 1][j][0] + dp[i - 1][j][1]\n                dp[i][j][0] = (dp[i][j][0] % mod + mod) % mod\n                if j > limit:\n                    dp[i][j][1] = dp[i][j - 1][1] + dp[i][j - 1][0] - dp[i][j - limit - 1][0]\n                else:\n                    dp[i][j][1] = dp[i][j - 1][1] + dp[i][j - 1][0]\n                dp[i][j][1] = (dp[i][j][1] % mod + mod) % mod\n        return (dp[zero][one][0] + dp[zero][one][1]) % mod\n", "source_code_block": "", "target_Lan": "cpp###numberOfStableArrays.cpp", "reference_code": "int numberOfStableArrays(int zero, int one, int limit) {\n        vector<vector<vector<long long>>> dp(zero + 1, vector<vector<long long>>(one + 1, vector<long long>(2)));\n        long long mod = 1e9 + 7;\n        for (int i = 0; i <= min(zero, limit); i++) {\n            dp[i][0][0] = 1;\n        }\n        for (int j = 0; j <= min(one, limit); j++) {\n            dp[0][j][1] = 1;\n        }\n        for (int i = 1; i <= zero; i++) {\n            for (int j = 1; j <= one; j++) {\n                if (i > limit) {\n                    dp[i][j][0] = dp[i - 1][j][0] + dp[i - 1][j][1] - dp[i - limit - 1][j][1];\n                } else {\n                    dp[i][j][0] = dp[i - 1][j][0] + dp[i - 1][j][1];\n                }\n                dp[i][j][0] = (dp[i][j][0] % mod + mod) % mod;\n                if (j > limit) {\n                    dp[i][j][1] = dp[i][j - 1][1] + dp[i][j - 1][0] - dp[i][j - limit - 1][0];\n                } else {\n                    dp[i][j][1] = dp[i][j - 1][1] + dp[i][j - 1][0];\n                }\n                dp[i][j][1] = (dp[i][j][1] % mod + mod) % mod;\n            }\n        }\n        return (dp[zero][one][0] + dp[zero][one][1]) % mod;\n    }", "target_method_signature": "numberOfStableArrays", "source_method_signature": "numberOfStableArrays", "target_allMS": "", "source_allMS": "", "source_import": "", "target_import": "#include <iostream>\n#include <vector>\nusing namespace std;", "commentTag": "", "target_code_shell": "#include <iostream>\n#include <vector>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    cout << numberOfStableArrays(0, 0, 0) << endl;\n    cout << numberOfStableArrays(5, 5, 5) << endl;\n    cout << numberOfStableArrays(6, 2, 4) << endl;\n    cout << numberOfStableArrays(2, 6, 3) << endl;\n    cout << numberOfStableArrays(3, 9, 1) << endl;\n}", "all_input_output_value": "\ninput1: numberOfStableArrays(0, 0, 0)\noutput1: 2\n--------\ninput2: numberOfStableArrays(5, 5, 5)\noutput2: 252\n--------\ninput3: numberOfStableArrays(6, 2, 4)\noutput3: 19\n--------\ninput4: numberOfStableArrays(2, 6, 3)\noutput4: 10\n--------\ninput5: numberOfStableArrays(3, 9, 1)\noutput5: 0\n", "input_output_value": ["\ninput1: numberOfStableArrays(0, 0, 0)\noutput1: 2\n", "\ninput2: numberOfStableArrays(5, 5, 5)\noutput2: 252\n", "\ninput3: numberOfStableArrays(6, 2, 4)\noutput3: 19\n"], "TAG": "Success", "source_code_shell": "# TOFILL\nif __name__ == \"__main__\":\n    print(numberOfStableArrays(0, 0, 0))\n    print(numberOfStableArrays(5, 5, 5))\n    print(numberOfStableArrays(6, 2, 4))\n    print(numberOfStableArrays(2, 6, 3))\n    print(numberOfStableArrays(3, 9, 1))"}
{"source_Lan": "python###minimumOperations.py", "source_code_str": " def minimumOperations( num: str) -> int:\n        n = len(num)\n        find0 = find5 = False\n        for i in range(n - 1, -1, -1):\n            if num[i] in ['0', '5']:\n                if find0:\n                    return n - i - 2\n                if num[i] == '0':\n                    find0 = True\n                else:\n                    find5 = True\n            elif num[i] in ['2', '7']:\n                if find5:\n                    return n - i - 2\n        if find0:\n            return n - 1\n        return n", "source_code_block": "", "target_Lan": "cpp###minimumOperations.cpp", "reference_code": "int minimumOperations(string num) {\n        int n = num.length();\n        bool find0 = false, find5 = false;\n        for (int i = n - 1; i >= 0; --i) {\n            if (num[i] == '0' || num[i] == '5') {\n                if (find0) {\n                    return n - i - 2;\n                }\n                if (num[i] == '0') {\n                    find0 = true;\n                } else {\n                    find5 = true;\n                }\n            } else if (num[i] == '2' || num[i] == '7') {\n                if (find5) {\n                    return n - i - 2;\n                }\n            }\n        }\n        if (find0) {\n            return n - 1;\n        }\n        return n;\n    }", "target_method_signature": "minimumOperations", "source_method_signature": "minimumOperations", "target_allMS": "", "source_allMS": "", "source_import": "", "target_import": "#include <iostream>\n#include <string>\nusing namespace std;", "commentTag": "", "target_code_shell": "#include <iostream>\n#include <string>\nusing namespace std;\n#include <iostream>\n#include <string>\n// TOFILL\nint main() {\n    cout << minimumOperations(\"000\") << endl;\n    cout << minimumOperations(\"500\") << endl;\n    cout << minimumOperations(\"259\") << endl;\n    cout << minimumOperations(\"735\") << endl;\n    cout << minimumOperations(\"1234\") << endl;\n}", "all_input_output_value": "\ninput1: input_str=\"000\"\noutput1: 0\n--------\ninput2: input_str=\"500\"\noutput2: 0\n--------\ninput3: input_str=\"259\"\noutput3: 1\n--------\ninput4: input_str=\"735\"\noutput4: 1\n--------\ninput5: input_str=\"1234\"\noutput5: 4\n", "input_output_value": ["\ninput1: input_str=\"000\"\noutput1: 0\n", "\ninput2: input_str=\"500\"\noutput2: 0\n", "\ninput3: input_str=\"259\"\noutput3: 1\n"], "TAG": "Success", "source_code_shell": "# TOFILL\nif __name__ == \"__main__\":\n    test_inputs = [\"000\", \"500\", \"259\", \"735\", \"1234\"]\n    for input_str in test_inputs:\n        print(minimumOperations(input_str))"}
{"source_Lan": "python###makeSmallestPalindrome.py", "source_code_str": "def makeSmallestPalindrome( s: str) -> str:\n        s = list(s)\n        left, right = 0, len(s) - 1\n        while left < right:\n            if s[left] != s[right]:\n                s[left] = s[right] = min(s[left], s[right])\n            left += 1\n            right -= 1\n        return \"\".join(s)", "source_code_block": "", "target_Lan": "cpp###makeSmallestPalindrome.cpp", "reference_code": "string makeSmallestPalindrome(string s) {\n        int left = 0, right = s.size() - 1;\n        while (left < right) {\n            if (s[left] != s[right]) {\n                s[left] = s[right] = min(s[left], s[right]);\n            }\n            ++left;\n            --right;\n        }\n        return s;\n    }", "target_method_signature": "makeSmallestPalindrome", "source_method_signature": "makeSmallestPalindrome", "target_allMS": "string makeSmallestPalindrome(string s) {", "source_allMS": "def makeSmallestPalindrome( s: str) -> str:", "source_import": "", "target_import": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <string>", "commentTag": "//", "source_code_shell": "# TOFILL\nif __name__ == \"__main__\":\n    print(makeSmallestPalindrome(\"\"))\n    print(makeSmallestPalindrome(\"racecar\"))\n    print(makeSmallestPalindrome(\"aaaaaa\"))\n    print(makeSmallestPalindrome(\"abcdef\"))\n    print(makeSmallestPalindrome(\"abcba\"))", "all_input_output_value": "\ninput1: s=\"\"\noutput1: racecar\n--------\ninput2: s=\"racecar\"\noutput2: aaaaaa\n--------\ninput3: s=\"aaaaaa\"\noutput3: abccba\n--------\ninput4: s=\"abcdef\"\noutput4: abcba\n--------\ninput5: s=\"abcba\"\noutput5: abcba\n", "input_output_value": ["\ninput1: s=\"\"\noutput1: racecar\n", "\ninput2: s=\"racecar\"\noutput2: aaaaaa\n", "\ninput3: s=\"aaaaaa\"\noutput3: abccba\n"], "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <string>\n#include <iostream>\n#include <string>\n// TOFILL\nint main() {\n    cout << makeSmallestPalindrome(\"\") << endl;\n    cout << makeSmallestPalindrome(\"racecar\") << endl;\n    cout << makeSmallestPalindrome(\"aaaaaa\") << endl;\n    cout << makeSmallestPalindrome(\"abcdef\") << endl;\n    cout << makeSmallestPalindrome(\"abcba\") << endl;\n}", "TAG": "Success"}
{"source_Lan": "python###secondGreaterElement.py", "source_code_str": "def secondGreaterElement( nums: List[int]) -> List[int]:\n    res = [-1] * len(nums)\n    stack = []\n    q = []\n    for i in range(len(nums)):\n        while len(q) and q[0][0] < nums[i]:\n            res[q[0][1]] = nums[i]\n            heappop(q)\n        while len(stack) and nums[stack[-1]] < nums[i]:\n            heappush(q, (nums[stack[-1]], stack[-1]))\n            stack.pop()\n        stack.append(i)\n    return res", "source_code_block": "", "target_Lan": "cpp###secondGreaterElement.cpp", "reference_code": "vector<int> secondGreaterElement(vector<int>& nums) {\n        vector<int> res(nums.size(), -1);\n        stack<int> st;\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> q;\n        for (int i = 0; i < nums.size(); ++i) {\n            while (!q.empty() && q.top().first < nums[i]) {\n                res[q.top().second] = nums[i];\n                q.pop();\n            }\n            while (!st.empty() && nums[st.top()] < nums[i]) {\n                q.push({nums[st.top()], st.top()});\n                st.pop();\n            }\n            st.push(i);\n        }\n        return res;\n    }", "target_method_signature": "secondGreaterElement", "source_method_signature": "secondGreaterElement", "target_allMS": "vector<int> secondGreaterElement(vector<int>& nums) {", "source_allMS": "def secondGreaterElement( nums: List[int]) -> List[int]:", "source_import": "from typing import List\nfrom heapq import heappop, heappush", "target_import": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <stack>\n#include <queue>", "commentTag": "//", "source_code_shell": "from typing import List\nfrom heapq import heappop, heappush\nfrom typing import List\nfrom heapq import heappop, heappush\n# TOFILL\nif __name__ == \"__main__\":\n    print(secondGreaterElement([]))            # Test input 1: []\n    print(secondGreaterElement([1]))           # Test input 2: [1]\n    print(secondGreaterElement([1, 2]))        # Test input 3: [1, 2]\n    print(secondGreaterElement([3, 3, 3]))     # Test input 4: [3, 3, 3]\n    print(secondGreaterElement([1, 2, 3, 4]))  # Test input 5: [1, 2, 3, 4]", "all_input_output_value": "\ninput1: nums=[]\noutput1: []\n--------\ninput2: nums=[1]\noutput2: [-1]\n--------\ninput3: nums=[1, 2]\noutput3: [-1, -1]\n--------\ninput4: nums=[3, 3, 3]\noutput4: [-1, -1, -1]\n--------\ninput5: nums=[1, 2, 3, 4]\noutput5: [3, 4, -1, -1]\n", "input_output_value": ["\ninput1: nums=[]\noutput1: []\n", "\ninput2: nums=[1]\noutput2: [-1]\n", "\ninput3: nums=[1, 2]\noutput3: [-1, -1]\n"], "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <iostream>\n#include <vector>\n#include <stack>\n#include <queue>\n// TOFILL\nint main() {\n    vector<int> input1 = {};\n    vector<int> input2 = {1};\n    vector<int> input3 = {1, 2};\n    vector<int> input4 = {3, 3, 3};\n    vector<int> input5 = {1, 2, 3, 4};\n\n    vector<int> result1 = secondGreaterElement(input1);\n    vector<int> result2 = secondGreaterElement(input2);\n    vector<int> result3 = secondGreaterElement(input3);\n    vector<int> result4 = secondGreaterElement(input4);\n    vector<int> result5 = secondGreaterElement(input5);\n\n    cout << \"Output for input1: \";\n    for(int val : result1) cout << val << \" \";\n    cout << endl;\n\n    cout << \"Output for input2: \";\n    for(int val : result2) cout << val << \" \";\n    cout << endl;\n\n    cout << \"Output for input3: \";\n    for(int val : result3) cout << val << \" \";\n    cout << endl;\n\n    cout << \"Output for input4: \";\n    for(int val : result4) cout << val << \" \";\n    cout << endl;\n\n    cout << \"Output for input5: \";\n    for(int val : result5) cout << val << \" \";\n    cout << endl;\n\n    return 0;\n}", "TAG": "Success"}
{"source_Lan": "python###maxTaxiEarnings.py", "source_code_str": "def maxTaxiEarnings( n: int, rides: List[List[int]]) -> int:\n        dp = [0] * (n + 1)\n        rideMap = {}\n        for ride in rides:\n            if ride[1] not in rideMap:\n                rideMap[ride[1]] = []\n            rideMap[ride[1]].append(ride)\n        for i in range(1, n + 1):\n            dp[i] = dp[i - 1]\n            if i not in rideMap:\n                continue\n            for ride in rideMap[i]:\n                dp[i] = max(dp[i], dp[ride[0]] + ride[1] - ride[0] + ride[2])\n        return dp[n]", "source_code_block": "", "target_Lan": "cpp###maxTaxiEarnings.cpp", "reference_code": "long long maxTaxiEarnings(int n, vector<vector<int>> &rides) {\n        vector<long long> dp(n + 1);\n        unordered_map<int, vector<vector<int>>> rideMap;\n        for (const auto &ride : rides) {\n            rideMap[ride[1]].push_back(ride);\n        }\n        for (int i = 1; i <= n; i++) {\n            dp[i] = dp[i - 1];\n            for (const auto &ride : rideMap[i]) {\n                dp[i] = max(dp[i], dp[ride[0]] + ride[1] - ride[0] + ride[2]);\n            }\n        }\n        return dp[n];\n    }", "target_method_signature": "maxTaxiEarnings", "source_method_signature": "maxTaxiEarnings", "target_allMS": "long long maxTaxiEarnings(int n, vector<vector<int>> &rides) {", "source_allMS": "def maxTaxiEarnings( n: int, rides: List[List[int]]) -> int:", "source_import": "from typing import List", "target_import": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <algorithm>", "commentTag": "//", "source_code_shell": "from typing import List\nfrom typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(maxTaxiEarnings(5, [[1, 2, 5], [1, 3, 7], [2, 5, 10], [3, 4, 6]]))\n    print(maxTaxiEarnings(5, [[1, 5, 10], [2, 4, 8], [3, 5, 7]]))\n    print(maxTaxiEarnings(10, [[1, 10, 20], [1, 5, 10], [2, 6, 15]]))\n    print(maxTaxiEarnings(6, []))  # No rides available\n    print(maxTaxiEarnings(3, [[1, 2, 3], [3, 3, 5]]))  # Ride that starts and ends at the same place", "all_input_output_value": "\ninput1: n=5, rides=[[1, 2, 5], [1, 3, 7], [2, 5, 10], [3, 4, 6]]\noutput1: 19\n--------\ninput2: n=5, rides=[[1, 5, 10], [2, 4, 8], [3, 5, 7]]\noutput2: 14\n--------\ninput3: n=10, rides=[[1, 10, 20], [1, 5, 10], [2, 6, 15]]\noutput3: 29\n--------\ninput4: n=6, rides=[]\noutput4: 0\n--------\ninput5: n=3, rides=[[1, 2, 3], [3, 3, 5]]\noutput5: 9\n", "input_output_value": ["\ninput1: n=5, rides=[[1, 2, 5], [1, 3, 7], [2, 5, 10], [3, 4, 6]]\noutput1: 19\n", "\ninput2: n=5, rides=[[1, 5, 10], [2, 4, 8], [3, 5, 7]]\noutput2: 14\n", "\ninput3: n=10, rides=[[1, 10, 20], [1, 5, 10], [2, 6, 15]]\noutput3: 29\n"], "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <algorithm>\n// TOFILL\nint main() {\n    vector<vector<int>> rides1 = {{1, 2, 5}, {1, 3, 7}, {2, 5, 10}, {3, 4, 6}};\n    cout << maxTaxiEarnings(5, rides1) << endl;\n\n    vector<vector<int>> rides2 = {{1, 5, 10}, {2, 4, 8}, {3, 5, 7}};\n    cout << maxTaxiEarnings(5, rides2) << endl;\n\n    vector<vector<int>> rides3 = {{1, 10, 20}, {1, 5, 10}, {2, 6, 15}};\n    cout << maxTaxiEarnings(10, rides3) << endl;\n\n    vector<vector<int>> rides4 = {};\n    cout << maxTaxiEarnings(6, rides4) << endl;\n\n    vector<vector<int>> rides5 = {{1, 2, 3}, {3, 3, 5}};\n    cout << maxTaxiEarnings(3, rides5) << endl;\n\n    return 0;\n}", "TAG": "Success"}
{"source_Lan": "python###carPooling.py", "source_code_str": "def carPooling( trips: List[List[int]], capacity: int) -> bool:\n        to_max = max(trip[2] for trip in trips)\n        diff = [0] * (to_max + 1)\n        for num_i, from_i, to_i in trips:\n            diff[from_i] += num_i\n            diff[to_i] -= num_i\n        count = 0\n        for i in range(to_max + 1):\n            count += diff[i]\n            if count > capacity:\n                return False\n        return True", "source_code_block": "", "target_Lan": "cpp###carPooling.cpp", "reference_code": "bool carPooling(vector<vector<int>>& trips, int capacity) {\n        int to_max = 0;\n        for (const auto& trip: trips) {\n            to_max = max(to_max, trip[2]);\n        }\n        vector<int> diff(to_max + 1);\n        for (const auto& trip: trips) {\n            diff[trip[1]] += trip[0];\n            diff[trip[2]] -= trip[0];\n        }\n        int count = 0;\n        for (int i = 0; i <= to_max; ++i) {\n            count += diff[i];\n            if (count > capacity) {\n                return false;\n            }\n        }\n        return true;\n    }", "target_method_signature": "carPooling", "source_method_signature": "carPooling", "target_allMS": "bool carPooling(vector<vector<int>>& trips, int capacity) {", "source_allMS": "def carPooling( trips: List[List[int]], capacity: int) -> bool:", "source_import": "from typing import List", "target_import": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>", "commentTag": "//", "source_code_shell": "from typing import List\nfrom typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(carPooling([[1, 2, 3]], 5))  # Test input 2\n    print(carPooling([[2, 1, 5]], 1))  # Test input 3\n    print(carPooling([[2, 1, 5], [3, 3, 6]], 10))  # Test input 4\n    print(carPooling([[3, 2, 7], [2, 5, 8], [5, 0, 6]], 3))  # Test input 5", "all_input_output_value": "\ninput1: trips=[[1, 2, 3]], capacity=5\noutput1: True\n--------\ninput2: trips=[[2, 1, 5]], capacity=1\noutput2: False\n--------\ninput3: trips=[[2, 1, 5], [3, 3, 6]], capacity=10\noutput3: True\n--------\ninput4: trips=[[3, 2, 7], [2, 5, 8], [5, 0, 6]], capacity=3\noutput4: False\n", "input_output_value": ["\ninput1: trips=[[1, 2, 3]], capacity=5\noutput1: True\n", "\ninput2: trips=[[2, 1, 5]], capacity=1\noutput2: False\n", "\ninput3: trips=[[2, 1, 5], [3, 3, 6]], capacity=10\noutput3: True\n"], "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    vector<vector<int>> trips1 = {{1, 2, 3}};\n    int capacity1 = 5;\n    cout << carPooling(trips1, capacity1) << endl;  // Expected output: 1(true)\n    \n    vector<vector<int>> trips2 = {{2, 1, 5}};\n    int capacity2 = 1;\n    cout << carPooling(trips2, capacity2) << endl;  // Expected output: 0(false)\n    \n    vector<vector<int>> trips3 = {{2, 1, 5}, {3, 3, 6}};\n    int capacity3 = 10;\n    cout << carPooling(trips3, capacity3) << endl;  // Expected output: 1(true)\n    \n    vector<vector<int>> trips4 = {{3, 2, 7}, {2, 5, 8}, {5, 0, 6}};\n    int capacity4 = 3;\n    cout << carPooling(trips4, capacity4) << endl;  // Expected output: 0(false)\n\n    return 0;\n}", "TAG": "Success"}
{"source_Lan": "python###firstCompleteIndex.py", "source_code_str": "def firstCompleteIndex( arr: List[int], mat: List[List[int]]) -> int:\n        n, m = len(mat), len(mat[0])\n        mp = {}\n        for i in range(n):\n            for j in range(m):\n                mp[mat[i][j]] = [i, j]\n        rowCnt, colCnt = [0] * n, [0] * m\n        for i in range(len(arr)):\n            v = mp[arr[i]]\n            rowCnt[v[0]] += 1\n            if rowCnt[v[0]] == m:\n                return i\n            colCnt[v[1]] += 1\n            if colCnt[v[1]] == n:\n                return i\n        return -1", "source_code_block": "", "target_Lan": "cpp###firstCompleteIndex.cpp", "reference_code": "int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\n        int n = mat.size();\n        int m = mat[0].size();\n        unordered_map<int, pair<int, int>> mp;\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                mp[mat[i][j]] = {i, j};\n            }\n        }\n        vector<int> rowCnt(n, 0);\n        vector<int> colCnt(m, 0);\n        for (int i = 0; i < arr.size(); ++i) {\n            auto& v = mp[arr[i]];\n            ++rowCnt[v.first];\n            if (rowCnt[v.first] == m) {\n                return i;\n            }\n            ++colCnt[v.second];\n            if (colCnt[v.second] == n) {\n                return i;\n            }\n        }\n        return -1;\n    }", "target_method_signature": "firstCompleteIndex", "source_method_signature": "firstCompleteIndex", "target_allMS": "int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {", "source_allMS": "def firstCompleteIndex( arr: List[int], mat: List[List[int]]) -> int:", "source_import": "from typing import List", "target_import": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <unordered_map>", "commentTag": "//", "source_code_shell": "from typing import List\nfrom typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(firstCompleteIndex([1, 2, 3, 4], [[1, 2], [3, 4]]))\n    print(firstCompleteIndex([1, 3, 2, 4], [[1, 2], [3, 4]]))\n    print(firstCompleteIndex([1, 2, 3, 4, 5], [[1, 2], [3, 4], [5, 6]]))\n    print(firstCompleteIndex([], [[1]]))", "all_input_output_value": "\ninput1: arr=[1, 2, 3, 4], mat=[[1, 2], [3, 4]]\noutput1: 1\n--------\ninput2: arr=[1, 3, 2, 4], mat=[[1, 2], [3, 4]]\noutput2: 1\n--------\ninput3: arr=[1, 2, 3, 4, 5], mat=[[1, 2], [3, 4], [5, 6]]\noutput3: 1\n--------\ninput4: arr=[], mat=[[1]]\noutput4: -1\n", "input_output_value": ["\ninput1: arr=[1, 2, 3, 4], mat=[[1, 2], [3, 4]]\noutput1: 1\n", "\ninput2: arr=[1, 3, 2, 4], mat=[[1, 2], [3, 4]]\noutput2: 1\n", "\ninput3: arr=[1, 2, 3, 4, 5], mat=[[1, 2], [3, 4], [5, 6]]\noutput3: 1\n"], "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n// TOFILL\nint main() {\n    vector<int> arr1 = {1, 2, 3, 4};\n    vector<vector<int>> mat1 = {{1, 2}, {3, 4}};\n    cout << firstCompleteIndex(arr1, mat1) << endl;\n\n    vector<int> arr2 = {1, 3, 2, 4};\n    vector<vector<int>> mat2 = {{1, 2}, {3, 4}};\n    cout << firstCompleteIndex(arr2, mat2) << endl;\n\n    vector<int> arr3 = {1, 2, 3, 4, 5};\n    vector<vector<int>> mat3 = {{1, 2}, {3, 4}, {5, 6}};\n    cout << firstCompleteIndex(arr3, mat3) << endl;\n\n    vector<int> arr4 = {};\n    vector<vector<int>> mat4 = {{1}};\n    cout << firstCompleteIndex(arr4, mat4) << endl;\n\n    return 0;\n}", "TAG": "Success"}
{"source_Lan": "python###maximumSum.py", "source_code_str": "def maximumSum( nums: List[int]) -> int:\n        d = defaultdict(int)\n        res = -1\n        for i in nums:\n            digitsSum = sum(int(c) for c in str(i))\n            if digitsSum in d:\n                res = max(res, d[digitsSum] + i)\n                d[digitsSum] = max(d[digitsSum], i)\n            else:\n                d[digitsSum] = i\n        return res", "source_code_block": "", "target_Lan": "cpp###maximumSum.cpp", "reference_code": "int maximumSum(vector<int>& nums) {\n        unordered_map<int, int> dict;\n        int res = -1;\n        for (int i : nums) {\n            int digitsSum = 0;\n            int temp = i;\n            while (temp > 0) {\n                digitsSum += temp % 10;\n                temp /= 10;\n            }\n            if (dict.count(digitsSum)) {\n                res = max(res, dict[digitsSum] + i);\n                dict[digitsSum] = max(dict[digitsSum], i);\n            } else {\n                dict[digitsSum] = i;\n            }\n        }\n        return res;\n    }", "target_method_signature": "maximumSum", "source_method_signature": "maximumSum", "target_allMS": "int maximumSum(vector<int>& nums) {", "source_allMS": "def maximumSum( nums: List[int]) -> int:", "source_import": "from collections import defaultdict\nfrom typing import List", "target_import": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <algorithm>", "commentTag": "//", "source_code_shell": "from collections import defaultdict\nfrom typing import List\nfrom collections import defaultdict\nfrom typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(maximumSum([51, 15, 99, 44, 5]))      # Expect 66\n    print(maximumSum([12, 21, 123, 231]))       # Expect 39\n    print(maximumSum([10, 20, 30, 40, 50]))     # Expect -1\n    print(maximumSum([5, 5, 5, 5]))              # Expect 10", "all_input_output_value": "\ninput1: nums=[51, 15, 99, 44, 5]\noutput1: 66\n--------\ninput2: nums=[12, 21, 123, 231]\noutput2: 354\n--------\ninput3: nums=[10, 20, 30, 40, 50]\noutput3: -1\n--------\ninput4: nums=[5, 5, 5, 5]\noutput4: 10\n", "input_output_value": ["\ninput1: nums=[51, 15, 99, 44, 5]\noutput1: 66\n", "\ninput2: nums=[12, 21, 123, 231]\noutput2: 354\n", "\ninput3: nums=[10, 20, 30, 40, 50]\noutput3: -1\n"], "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n// TOFILL\nint main() {\n    vector<int> test1 = {51, 15, 99, 44, 5};\n    vector<int> test2 = {12, 21, 123, 231};\n    vector<int> test3 = {10, 20, 30, 40, 50};\n    vector<int> test4 = {5, 5, 5, 5};\n    \n    cout << maximumSum(test1) << endl;\n    cout << maximumSum(test2) << endl;\n    cout << maximumSum(test3) << endl;\n    cout << maximumSum(test4) << endl;\n\n    return 0;\n}", "TAG": "Success"}
{"source_Lan": "python###minPathCost.py", "source_code_str": "def minPathCost( grid: List[List[int]], moveCost: List[List[int]]) -> int:\n       m, n = len(grid), len(grid[0])\n       dp = grid[0]\n       for i in range(1, len(grid)):\n           dp = [grid[i][j] + min(dp[k] + moveCost[grid[i - 1][k]][j] for k in range(n)) for j in range(n)]\n       return min(dp)", "source_code_block": "", "target_Lan": "cpp###minPathCost.cpp", "reference_code": "int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\n        int m = grid.size(), n = grid[0].size();\n        vector<vector<int>> dp(2, vector<int>(n));\n        dp[0] = grid[0];\n        int cur = 0;\n        for (int i = 1; i < m; i++) {\n            int next = 1 - cur;\n            for (int j = 0; j < n; j++) {\n                dp[next][j] = INT_MAX;\n                for (int k = 0; k < n; k++) {\n                    dp[next][j] = min(dp[next][j], dp[cur][k] + moveCost[grid[i - 1][k]][j] + grid[i][j]);\n                }\n            }\n            cur = next;\n        }\n        return *min_element(dp[cur].begin(), dp[cur].end());\n    }", "target_method_signature": "minPathCost", "source_method_signature": "minPathCost", "target_allMS": "int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {", "source_allMS": "def minPathCost( grid: List[List[int]], moveCost: List[List[int]]) -> int:", "source_import": "from typing import List", "target_import": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>", "commentTag": "//", "source_code_shell": "from typing import List\nfrom typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(minPathCost([[1]], [[0]]))\n    print(minPathCost([[1, 1], [1, 1], [1, 1]], [[0, 0], [0, 0]]))", "all_input_output_value": "\ninput1: grid=[[1]], moveCost=[[0]]\noutput1: 1\n--------\ninput2: grid=[[1, 1], [1, 1], [1, 1]], moveCost=[[0, 0], [0, 0]]\noutput2: 3\n", "input_output_value": ["\ninput1: grid=[[1]], moveCost=[[0]]\noutput1: 1\n", "\ninput2: grid=[[1, 1], [1, 1], [1, 1]], moveCost=[[0, 0], [0, 0]]\noutput2: 3\n"], "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n// TOFILL\nint main() {\n    vector<vector<int>> grid1 = {{1}};\n    vector<vector<int>> moveCost1 = {{0}};\n    cout << minPathCost(grid1, moveCost1) << endl;\n    \n    vector<vector<int>> grid2 = {{1, 1}, {1, 1}, {1, 1}};\n    vector<vector<int>> moveCost2 = {{0, 0}, {0, 0}};\n    cout << minPathCost(grid2, moveCost2) << endl;\n\n    return 0;\n}", "TAG": "Success"}
{"source_Lan": "python###pickGifts.py", "source_code_str": "def pickGifts(gifts: List[int], k: int) -> int:\n    q = [-gift for gift in gifts]\n    heapify(q)\n    while k:\n        x = heappop(q)\n        heappush(q, -int(sqrt(-x)))\n        k -= 1\n    return -sum(q)\n", "source_code_block": "", "target_Lan": "cpp###pickGifts.cpp", "reference_code": "    long long pickGifts(vector<int>& gifts, int k) {\n        priority_queue<int> q(gifts.begin(), gifts.end());\n        while (k--) {\n            int x = q.top(); \n            q.pop();\n            q.push(int(sqrt(x)));\n        }\n        long long res = 0;\n        while (q.size()) {\n            res += q.top(); \n            q.pop();\n        }\n        return res;\n    }", "target_method_signature": "pickGifts", "source_method_signature": "pickGifts", "target_allMS": "    long long pickGifts(vector<int>& gifts, int k) {", "source_allMS": "def pickGifts( gifts: List[int], k: int) -> int:", "source_import": "from typing import List\nfrom heapq import heapify, heappop, heappush\nfrom math import sqrt", "target_import": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <cmath>", "commentTag": "//", "source_code_shell": "from typing import List\nfrom heapq import heapify, heappop, heappush\nfrom math import sqrt\nfrom typing import List\nfrom heapq import heapify, heappop, heappush\nfrom math import sqrt\n# TOFILL\nif __name__ == \"__main__\":\n    print(pickGifts([1], 5))            # Test Input 2\n    print(pickGifts([4, 9, 16], 2))     # Test Input 3\n    print(pickGifts([25, 36, 49], 1))   # Test Input 4\n    print(pickGifts([1, 2, 3, 4, 5], 0)) # Test Input 5", "all_input_output_value": "\ninput1: gifts=[1], k=5\noutput1: 1\n--------\ninput2: gifts=[4, 9, 16], k=2\noutput2: 11\n--------\ninput3: gifts=[25, 36, 49], k=1\noutput3: 68\n--------\ninput4: gifts=[1, 2, 3, 4, 5], k=0\noutput4: 15\n", "input_output_value": ["\ninput1: gifts=[1], k=5\noutput1: 1\n", "\ninput2: gifts=[4, 9, 16], k=2\noutput2: 11\n", "\ninput3: gifts=[25, 36, 49], k=1\noutput3: 68\n"], "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <cmath>\n// TOFILL\nint main() {\n    vector<int> gifts1 = {1};\n    int k1 = 5;\n    cout << pickGifts(gifts1, k1) << endl;\n\n    vector<int> gifts2 = {4, 9, 16};\n    int k2 = 2;\n    cout << pickGifts(gifts2, k2) << endl;\n\n    vector<int> gifts3 = {25, 36, 49};\n    int k3 = 1;\n    cout << pickGifts(gifts3, k3) << endl;\n\n    vector<int> gifts4 = {1, 2, 3, 4, 5};\n    int k4 = 0;\n    cout << pickGifts(gifts4, k4) << endl;\n\n    return 0;\n}", "TAG": "Success"}
{"source_Lan": "python###successfulPairs.py", "source_code_str": "def successfulPairs( spells: List[int], potions: List[int], success: int) -> List[int]:\n        res = [0] * len(spells)\n        idx = [i for i in range(len(spells))]\n        idx.sort(key = lambda x: spells[x])\n        potions.sort(key = lambda x : -x)\n        j = 0\n        for p in idx:\n            v = spells[p]\n            while j < len(potions) and potions[j] * v >= success:\n                j += 1\n            res[p] = j\n        return res", "source_code_block": "", "target_Lan": "cpp###successfulPairs.cpp", "reference_code": "vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\n        vector<int> res(spells.size());\n        vector<int> idx(spells.size());\n        iota(idx.begin(), idx.end(), 0);\n        sort(idx.begin(), idx.end(), [&](int a, int b) {\n            return spells[a] < spells[b];\n        });\n        sort(potions.begin(), potions.end(), [](int a, int b) {\n            return a > b;\n        });\n        for (int i = 0, j = 0; i < spells.size(); ++i) {\n            int p = idx[i];\n            int v = spells[p];\n            while (j < potions.size() && (long long) potions[j] * v >= success) {\n                ++j;\n            }\n            res[p] = j;\n        }\n        return res;\n    }", "target_method_signature": "successfulPairs", "source_method_signature": "successfulPairs", "target_allMS": "vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {", "source_allMS": "def successfulPairs( spells: List[int], potions: List[int], success: int) -> List[int]:", "source_import": "from typing import List", "target_import": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <numeric>\n#include <algorithm>", "commentTag": "//", "source_code_shell": "from typing import List\nfrom typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(successfulPairs([0, 1, 2], [0, 1, 2], 0))\n    print(successfulPairs([1, 2, 3], [2, 3], 7))\n    print(successfulPairs([1, -1, 3], [0, 4, 5], 3))\n    print(successfulPairs([5, 10, 15], [1, 1, 2], 10))\n    print(successfulPairs([0, 5], [0, 0], 1))", "all_input_output_value": "\ninput1: spells=[0, 1, 2], potions=[0, 1, 2], success=0\noutput1: [3, 3, 3]\n--------\ninput2: spells=[1, 2, 3], potions=[2, 3], success=7\noutput2: [0, 0, 1]\n--------\ninput3: spells=[1, -1, 3], potions=[0, 4, 5], success=3\noutput3: [2, 0, 2]\n--------\ninput4: spells=[5, 10, 15], potions=[1, 1, 2], success=10\noutput4: [1, 3, 3]\n--------\ninput5: spells=[0, 5], potions=[0, 0], success=1\noutput5: [0, 0]\n", "input_output_value": ["\ninput1: spells=[0, 1, 2], potions=[0, 1, 2], success=0\noutput1: [3, 3, 3]\n", "\ninput2: spells=[1, 2, 3], potions=[2, 3], success=7\noutput2: [0, 0, 1]\n", "\ninput3: spells=[1, -1, 3], potions=[0, 4, 5], success=3\noutput3: [2, 0, 2]\n"], "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <numeric>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n// TOFILL\nint main() {\n    vector<int> spells1 = {0, 1, 2};\n    vector<int> potions1 = {0, 1, 2};\n    long long success1 = 0;\n    vector<int> result1 = successfulPairs(spells1, potions1, success1);\n    for(int r : result1) {\n        cout << r << \" \";\n    }\n    cout << endl;\n\n    vector<int> spells2 = {1, 2, 3};\n    vector<int> potions2 = {2, 3};\n    long long success2 = 7;\n    vector<int> result2 = successfulPairs(spells2, potions2, success2);\n    for(int r : result2) {\n        cout << r << \" \";\n    }\n    cout << endl;\n\n    vector<int> spells3 = {1, -1, 3};\n    vector<int> potions3 = {0, 4, 5};\n    long long success3 = 3;\n    vector<int> result3 = successfulPairs(spells3, potions3, success3);\n    for(int r : result3) {\n        cout << r << \" \";\n    }\n    cout << endl;\n\n    vector<int> spells4 = {5, 10, 15};\n    vector<int> potions4 = {1, 1, 2};\n    long long success4 = 10;\n    vector<int> result4 = successfulPairs(spells4, potions4, success4);\n    for(int r : result4) {\n        cout << r << \" \";\n    }\n    cout << endl;\n\n    vector<int> spells5 = {0, 5};\n    vector<int> potions5 = {0, 0};\n    long long success5 = 1;\n    vector<int> result5 = successfulPairs(spells5, potions5, success5);\n    for(int r : result5) {\n        cout << r << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}", "TAG": "Success"}
{"source_Lan": "python###countPairs.py", "source_code_str": "def countPairs(nums: List[int], target: int) -> int:\n    return sum(x + y < target for x, y in combinations(nums, 2))\n", "source_code_block": "", "target_Lan": "cpp###countPairs.cpp", "reference_code": "int countPairs(vector<int>& nums, int target) {\n        int res = 0;\n        for (int i = 0; i < nums.size(); i++) {\n            for (int j = i + 1; j < nums.size(); j++) {\n                if (nums[i] + nums[j] < target) {\n                    res++;\n                }\n            }\n        }\n        return res;\n    }", "target_method_signature": "countPairs", "source_method_signature": "countPairs", "target_allMS": "int countPairs(vector<int>& nums, int target) {", "source_allMS": "def countPairs( nums: List[int], target: int) -> int:", "source_import": "from typing import List\nfrom itertools import combinations", "target_import": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>", "commentTag": "//", "source_code_shell": "from typing import List\nfrom itertools import combinations\nfrom itertools import combinations\nfrom typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(countPairs([1, 2, 3, 4], 8))    # Expected output: 6\n    print(countPairs([5, 3, 4, 2], 5))    # Expected output: 1\n    print(countPairs([10, 20, 30, 40], 100)) # Expected output: 0\n    print(countPairs([-1, -2, 0, 1, 2], 1)) # Expected output: 7\n    print(countPairs([3, 1, 4, 1, 5, 9, 2, 6], 10)) # Expected output: ?", "all_input_output_value": "\ninput1: nums=[1, 2, 3, 4], target=8\noutput1: 6\n--------\ninput2: nums=[5, 3, 4, 2], target=5\noutput2: 0\n--------\ninput3: nums=[10, 20, 30, 40], target=100\noutput3: 6\n--------\ninput4: nums=[-1, -2, 0, 1, 2], target=1\noutput4: 6\n--------\ninput5: nums=[3, 1, 4, 1, 5, 9, 2, 6], target=10\noutput5: 19\n", "input_output_value": ["\ninput1: nums=[1, 2, 3, 4], target=8\noutput1: 6\n", "\ninput2: nums=[5, 3, 4, 2], target=5\noutput2: 0\n", "\ninput3: nums=[10, 20, 30, 40], target=100\noutput3: 6\n"], "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    vector<int> nums1 = {1, 2, 3, 4};\n    int target1 = 8;\n    cout << countPairs(nums1, target1) << endl;\n\n    vector<int> nums2 = {5, 3, 4, 2};\n    int target2 = 5;\n    cout << countPairs(nums2, target2) << endl;\n\n    vector<int> nums3 = {10, 20, 30, 40};\n    int target3 = 100;\n    cout << countPairs(nums3, target3) << endl;\n\n    vector<int> nums4 = {-1, -2, 0, 1, 2};\n    int target4 = 1;\n    cout << countPairs(nums4, target4) << endl;\n\n    vector<int> nums5 = {3, 1, 4, 1, 5, 9, 2, 6};\n    int target5 = 10;\n    cout << countPairs(nums5, target5) << endl;\n\n    return 0;\n}", "TAG": "Success"}
{"source_Lan": "python###passThePillow.py", "source_code_str": "def passThePillow( n: int, time: int) -> int:\n        time %= (n - 1) * 2\n        return time + 1 if time < n else n * 2 - time - 1", "source_code_block": "", "target_Lan": "cpp###passThePillow.cpp", "reference_code": "    int passThePillow(int n, int time) {\n        time %= (n - 1) * 2;\n        return time < n ? time + 1 : n * 2 - time - 1;\n    }", "target_method_signature": "passThePillow", "source_method_signature": "passThePillow", "target_allMS": "    int passThePillow(int n, int time) {", "source_allMS": "def passThePillow( n: int, time: int) -> int:", "source_import": "", "target_import": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>", "commentTag": "//", "source_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    from typing import List\n    print(passThePillow(2, 1))\n    print(passThePillow(5, 6))\n    print(passThePillow(5, 12))\n    print(passThePillow(10, 20))", "all_input_output_value": "\ninput1: n=2, time=1\noutput1: 2\n--------\ninput2: n=5, time=6\noutput2: 3\n--------\ninput3: n=5, time=12\noutput3: 5\n--------\ninput4: n=10, time=20\noutput4: 3\n", "input_output_value": ["\ninput1: n=2, time=1\noutput1: 2\n", "\ninput2: n=5, time=6\noutput2: 3\n", "\ninput3: n=5, time=12\noutput3: 5\n"], "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <iostream>\n// TOFILL\nint main() {\n    cout << passThePillow(2, 1) << endl;\n    cout << passThePillow(5, 6) << endl;\n    cout << passThePillow(5, 12) << endl;\n    cout << passThePillow(10, 20) << endl;\n}", "TAG": "Success"}
{"source_Lan": "python###checkIfPrerequisite.py", "source_code_str": "def checkIfPrerequisite( numCourses: int, prerequisites: List[List[int]], queries: List[List[int]]) -> List[bool]:\n        g = [[] for _ in range(numCourses)]\n        indgree = [0] * numCourses\n        isPre = [[False] * numCourses for _ in range(numCourses)]\n        for p in prerequisites:\n            indgree[p[1]] += 1\n            g[p[0]].append(p[1])\n        q = []\n        for i in range(numCourses):\n            if indgree[i] == 0:\n                q.append(i)\n        while len(q) > 0:\n            cur = q[0]\n            q.pop(0)\n            for ne in g[cur]:\n                isPre[cur][ne] = True\n                for i in range(numCourses):\n                    isPre[i][ne] = isPre[i][ne] or isPre[i][cur]\n                indgree[ne] -= 1\n                if indgree[ne] == 0:\n                    q.append(ne)\n        res = []\n        for query in queries:\n            res.append(isPre[query[0]][query[1]])\n        return res", "source_code_block": "", "target_Lan": "cpp###checkIfPrerequisite.cpp", "reference_code": "vector<bool> checkIfPrerequisite(int numCourses, vector<vector<int>>& prerequisites, vector<vector<int>>& queries) {\n        vector<vector<int>> g(numCourses);\n        vector<int> indgree(numCourses, 0);\n        vector<vector<bool>> isPre(numCourses, vector<bool>(numCourses, false));\n        for (auto& p : prerequisites) {\n            ++indgree[p[1]];\n            g[p[0]].push_back(p[1]);\n        }\n        queue<int> q;\n        for (int i = 0; i < numCourses; ++i) {\n            if (indgree[i] == 0) {\n                q.push(i);\n            }\n        }\n        while (!q.empty()) {\n            auto cur = q.front();\n            q.pop();\n            for (auto& ne : g[cur]) {\n                isPre[cur][ne] = true;\n                for (int i = 0; i < numCourses; ++i) {\n                    isPre[i][ne] = isPre[i][ne] | isPre[i][cur];\n                }\n                --indgree[ne];\n                if (indgree[ne] == 0) {\n                    q.push(ne);\n                }\n            }\n        }\n        vector<bool> res;\n        for (auto& query : queries) {\n            res.push_back(isPre[query[0]][query[1]]);\n        }\n        return res;\n    }", "target_method_signature": "checkIfPrerequisite", "source_method_signature": "checkIfPrerequisite", "target_allMS": "vector<bool> checkIfPrerequisite(int numCourses, vector<vector<int>>& prerequisites, vector<vector<int>>& queries) {", "source_allMS": "def checkIfPrerequisite( numCourses: int, prerequisites: List[List[int]], queries: List[List[int]]) -> List[bool]:", "source_import": "from typing import List", "target_import": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <queue>", "commentTag": "//", "source_code_shell": "from typing import List\nfrom typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(checkIfPrerequisite(2, [[0, 1]], [[0, 1], [1, 0]]))\n    print(checkIfPrerequisite(3, [[0, 1], [1, 2]], [[0, 2], [1, 0], [2, 0]]))\n    print(checkIfPrerequisite(4, [[0, 1], [1, 2], [2, 3]], [[0, 3], [3, 0], [1, 2], [2, 1]]))\n    print(checkIfPrerequisite(3, [[0, 1], [0, 2]], [[1, 0], [2, 0], [0, 1], [0, 2]]))", "all_input_output_value": "\ninput1: numCourses=2, prerequisites=[[0, 1]], queries=[[0, 1], [1, 0]]\noutput1: [True, False]\n--------\ninput2: numCourses=3, prerequisites=[[0, 1], [1, 2]], queries=[[0, 2], [1, 0], [2, 0]]\noutput2: [True, False, False]\n--------\ninput3: numCourses=4, prerequisites=[[0, 1], [1, 2], [2, 3]], queries=[[0, 3], [3, 0], [1, 2], [2, 1]]\noutput3: [True, False, True, False]\n--------\ninput4: numCourses=3, prerequisites=[[0, 1], [0, 2]], queries=[[1, 0], [2, 0], [0, 1], [0, 2]]\noutput4: [False, False, True, True]\n", "input_output_value": ["\ninput1: numCourses=2, prerequisites=[[0, 1]], queries=[[0, 1], [1, 0]]\noutput1: [True, False]\n", "\ninput2: numCourses=3, prerequisites=[[0, 1], [1, 2]], queries=[[0, 2], [1, 0], [2, 0]]\noutput2: [True, False, False]\n", "\ninput3: numCourses=4, prerequisites=[[0, 1], [1, 2], [2, 3]], queries=[[0, 3], [3, 0], [1, 2], [2, 1]]\noutput3: [True, False, True, False]\n"], "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <iostream>\n#include <vector>\n#include <queue>\n// TOFILL\nint main() {\n    // Test input 1\n    vector<vector<int>> prerequisites1 = {{0, 1}};\n    vector<vector<int>> queries1 = {{0, 1}, {1, 0}};\n    vector<bool> result1 = checkIfPrerequisite(2, prerequisites1, queries1);\n    for(bool r : result1) {\n        cout <<(r ? \"true\" : \"false\") << endl;\n    }\n\n    // Test input 2\n    vector<vector<int>> prerequisites2 = {{0, 1}, {1, 2}};\n    vector<vector<int>> queries2 = {{0, 2}, {1, 0}, {2, 0}};\n    vector<bool> result2 = checkIfPrerequisite(3, prerequisites2, queries2);\n    for(bool r : result2) {\n        cout <<(r ? \"true\" : \"false\") << endl;\n    }\n\n    // Test input 3\n    vector<vector<int>> prerequisites3 = {{0, 1}, {1, 2}, {2, 3}};\n    vector<vector<int>> queries3 = {{0, 3}, {3, 0}, {1, 2}, {2, 1}};\n    vector<bool> result3 = checkIfPrerequisite(4, prerequisites3, queries3);\n    for(bool r : result3) {\n        cout <<(r ? \"true\" : \"false\") << endl;\n    }\n\n    // Test input 4\n    vector<vector<int>> prerequisites4 = {{0, 1}, {0, 2}};\n    vector<vector<int>> queries4 = {{1, 0}, {2, 0}, {0, 1}, {0, 2}};\n    vector<bool> result4 = checkIfPrerequisite(3, prerequisites4, queries4);\n    for(bool r : result4) {\n        cout <<(r ? \"true\" : \"false\") << endl;\n    }\n\n    return 0;\n}", "TAG": "Success"}
{"source_Lan": "python###numFactoredBinaryTrees.py", "source_code_str": "def numFactoredBinaryTrees( arr: List[int]) -> int:\n        n = len(arr)\n        arr = sorted(arr)\n        dp = [1] * n\n        res, mod = 0, 10**9 + 7\n        for i in range(n):\n            left, right = 0, i - 1\n            while left <= right:\n                while right >= left and arr[left] * arr[right] > arr[i]:\n                    right -= 1\n                if right >= left and arr[left] * arr[right] == arr[i]:\n                    if right != left:\n                        dp[i] = (dp[i] + dp[left] * dp[right] * 2) % mod\n                    else:\n                        dp[i] = (dp[i] + dp[left] * dp[right]) % mod\n                left += 1\n            res = (res + dp[i]) % mod\n        return res", "source_code_block": "", "target_Lan": "cpp###numFactoredBinaryTrees.cpp", "reference_code": "int numFactoredBinaryTrees(vector<int>& arr) {\n        sort(arr.begin(), arr.end());\n        int n = arr.size();\n        vector<long long> dp(n);\n        long long res = 0, mod = 1e9 + 7;\n        for (int i = 0; i < n; i++) {\n            dp[i] = 1;\n            for (int left = 0, right = i - 1; left <= right; left++) {\n                while (right >= left && (long long)arr[left] * arr[right] > arr[i]) {\n                    right--;\n                }\n                if (right >= left && (long long)arr[left] * arr[right] == arr[i]) {\n                    if (right != left) {\n                        dp[i] = (dp[i] + dp[left] * dp[right] * 2) % mod;\n                    } else {\n                        dp[i] = (dp[i] + dp[left] * dp[right]) % mod;\n                    }\n                }\n            }\n            res = (res + dp[i]) % mod;\n        }\n        return res;\n    }", "target_method_signature": "numFactoredBinaryTrees", "source_method_signature": "numFactoredBinaryTrees", "target_allMS": "int numFactoredBinaryTrees(vector<int>& arr) {", "source_allMS": "def numFactoredBinaryTrees( arr: List[int]) -> int:", "source_import": "from typing import List", "target_import": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <algorithm>", "commentTag": "//", "source_code_shell": "from typing import List\nfrom typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(numFactoredBinaryTrees([]))  # Test case for empty input\n    print(numFactoredBinaryTrees([1]))  # Test case with a single element\n    print(numFactoredBinaryTrees([2, 3, 5, 7]))  # Test case with prime numbers\n    print(numFactoredBinaryTrees([1, 2, 4, 8]))  # Test case with powers of 2\n    print(numFactoredBinaryTrees([2, 4, 8, 16, 32]))  # Test case with factors yielding valid products", "all_input_output_value": "\ninput1: arr=[]\noutput1: 0\n--------\ninput2: arr=[1]\noutput2: 1\n--------\ninput3: arr=[2, 3, 5, 7]\noutput3: 4\n--------\ninput4: arr=[1, 2, 4, 8]\noutput4: 9\n--------\ninput5: arr=[2, 4, 8, 16, 32]\noutput5: 74\n", "input_output_value": ["\ninput1: arr=[]\noutput1: 0\n", "\ninput2: arr=[1]\noutput2: 1\n", "\ninput3: arr=[2, 3, 5, 7]\noutput3: 4\n"], "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n// TOFILL\nint main() {\n    vector<int> input1 = {};\n    vector<int> input2 = {1};\n    vector<int> input3 = {2, 3, 5, 7};\n    vector<int> input4 = {1, 2, 4, 8};\n    vector<int> input5 = {2, 4, 8, 16, 32};\n\n    cout << numFactoredBinaryTrees(input1) << endl;\n    cout << numFactoredBinaryTrees(input2) << endl;\n    cout << numFactoredBinaryTrees(input3) << endl;\n    cout << numFactoredBinaryTrees(input4) << endl;\n    cout << numFactoredBinaryTrees(input5) << endl;\n\n    return 0;\n}", "TAG": "Success"}
{"source_Lan": "python###maxDistToClosest.py", "source_code_str": "def maxDistToClosest( seats: List[int]) -> int:\n        res, l = 0, 0\n        while l < len(seats) and seats[l] == 0:\n            l += 1\n        res = max(res, l)\n        while l < len(seats):\n            r = l + 1\n            while r < len(seats) and seats[r] == 0:\n                r += 1\n            if r == len(seats):\n                res = max(res, r - l - 1)\n            else:\n                res = max(res, (r - l) // 2)\n            l = r\n        return res", "source_code_block": "", "target_Lan": "cpp###maxDistToClosest.cpp", "reference_code": "int maxDistToClosest(vector<int>& seats) {\n        int res = 0;\n        int l = 0;\n        while (l < seats.size() && seats[l] == 0) {\n            ++l;\n        }\n        res = max(res, l);\n        while (l < seats.size()) {\n            int r = l + 1;\n            while (r < seats.size() && seats[r] == 0) {\n                ++r;\n            }\n            if (r == seats.size()) {\n                res = max(res, r - l - 1);\n            } else {\n                res = max(res, (r - l) / 2);\n            }\n            l = r;\n        }\n        return res;\n    }", "target_method_signature": "maxDistToClosest", "source_method_signature": "maxDistToClosest", "target_allMS": "int maxDistToClosest(vector<int>& seats) {", "source_allMS": "def maxDistToClosest( seats: List[int]) -> int:", "source_import": "from typing import List", "target_import": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <algorithm>", "commentTag": "//", "source_code_shell": "from typing import List\nfrom typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(maxDistToClosest([0, 0, 0, 0, 0, 0]))  # Test input 1\n    print(maxDistToClosest([1, 1, 1, 1, 1, 1]))  # Test input 2\n    print(maxDistToClosest([0, 0, 1, 1, 0, 0, 1]))  # Test input 3\n    print(maxDistToClosest([1, 0, 1, 0, 1, 0]))  # Test input 4\n    print(maxDistToClosest([0, 1, 0, 0, 1, 0, 0, 0, 1]))  # Test input 5", "all_input_output_value": "\ninput1: seats=[0, 0, 0, 0, 0, 0]\noutput1: 6\n--------\ninput2: seats=[1, 1, 1, 1, 1, 1]\noutput2: 0\n--------\ninput3: seats=[0, 0, 1, 1, 0, 0, 1]\noutput3: 2\n--------\ninput4: seats=[1, 0, 1, 0, 1, 0]\noutput4: 1\n--------\ninput5: seats=[0, 1, 0, 0, 1, 0, 0, 0, 1]\noutput5: 2\n", "input_output_value": ["\ninput1: seats=[0, 0, 0, 0, 0, 0]\noutput1: 6\n", "\ninput2: seats=[1, 1, 1, 1, 1, 1]\noutput2: 0\n", "\ninput3: seats=[0, 0, 1, 1, 0, 0, 1]\noutput3: 2\n"], "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    vector<int> seats1 = {0, 0, 0, 0, 0, 0};\n    vector<int> seats2 = {1, 1, 1, 1, 1, 1};\n    vector<int> seats3 = {0, 0, 1, 1, 0, 0, 1};\n    vector<int> seats4 = {1, 0, 1, 0, 1, 0};\n    vector<int> seats5 = {0, 1, 0, 0, 1, 0, 0, 0, 1};\n\n    cout << maxDistToClosest(seats1) << endl;\n    cout << maxDistToClosest(seats2) << endl;\n    cout << maxDistToClosest(seats3) << endl;\n    cout << maxDistToClosest(seats4) << endl;\n    cout << maxDistToClosest(seats5) << endl;\n\n    return 0;\n}", "TAG": "Success"}
{"source_Lan": "python###maxAbsoluteSum.py", "source_code_str": "def maxAbsoluteSum( nums: List[int]) -> int:\n        positiveMax, negativeMin = 0, 0\n        positiveSum, negativeSum = 0, 0\n        for n in nums:\n            positiveSum += n\n            positiveMax = max(positiveMax, positiveSum)\n            positiveSum = max(0, positiveSum)\n            negativeSum += n\n            negativeMin = min(negativeMin, negativeSum)\n            negativeSum = min(0, negativeSum)\n        return max(positiveMax, -negativeMin)", "source_code_block": "", "target_Lan": "cpp###maxAbsoluteSum.cpp", "reference_code": "int maxAbsoluteSum(vector<int>& nums) {\n        int positiveMax = 0, negativeMin = 0;\n        int positiveSum = 0, negativeSum = 0;\n        for (int num : nums) {\n            positiveSum += num;\n            positiveMax = max(positiveMax, positiveSum);\n            positiveSum = max(0, positiveSum);\n            negativeSum += num;\n            negativeMin = min(negativeMin, negativeSum);\n            negativeSum = min(0, negativeSum);\n        }\n        return max(positiveMax, -negativeMin);\n    }", "target_method_signature": "maxAbsoluteSum", "source_method_signature": "maxAbsoluteSum", "target_allMS": "int maxAbsoluteSum(vector<int>& nums) {", "source_allMS": "def maxAbsoluteSum( nums: List[int]) -> int:", "source_import": "from typing import List", "target_import": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;", "commentTag": "//", "source_code_shell": "from typing import List\nfrom typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(maxAbsoluteSum([]))                # Testing with an empty array\n    print(maxAbsoluteSum([1, 2, 3]))        # Testing with all positive numbers\n    print(maxAbsoluteSum([-1, -2, -3]))     # Testing with all negative numbers\n    print(maxAbsoluteSum([1, -2, 3, -4]))   # Testing with a mix of positive and negative numbers\n    print(maxAbsoluteSum([0, 1, -1, 2, -2])) # Testing with a mix including zeros", "all_input_output_value": "\ninput1: nums=[]\noutput1: 0\n--------\ninput2: nums=[1, 2, 3]\noutput2: 6\n--------\ninput3: nums=[-1, -2, -3]\noutput3: 6\n--------\ninput4: nums=[1, -2, 3, -4]\noutput4: 4\n--------\ninput5: nums=[0, 1, -1, 2, -2]\noutput5: 2\n", "input_output_value": ["\ninput1: nums=[]\noutput1: 0\n", "\ninput2: nums=[1, 2, 3]\noutput2: 6\n", "\ninput3: nums=[-1, -2, -3]\noutput3: 6\n"], "target_code_shell": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <algorithm>\n// TOFILL\nint main() {\n    vector<int> input1 = {};\n    vector<int> input2 = {1, 2, 3};\n    vector<int> input3 = {-1, -2, -3};\n    vector<int> input4 = {1, -2, 3, -4};\n    vector<int> input5 = {0, 1, -1, 2, -2};\n\n    cout << maxAbsoluteSum(input1) << endl;\n    cout << maxAbsoluteSum(input2) << endl;\n    cout << maxAbsoluteSum(input3) << endl;\n    cout << maxAbsoluteSum(input4) << endl;\n    cout << maxAbsoluteSum(input5) << endl;\n\n    return 0;\n}", "TAG": "Success"}
{"source_Lan": "python###shortestDistanceAfterQueries.py", "source_code_str": "def shortestDistanceAfterQueries(n: int, queries: List[List[int]]) -> List[int]:\n    frm = [[] for _ in range(n)]\n    f = list(range(n))\n    ans = []\n    for l, r in queries:\n        frm[r].append(l)\n        if f[l] + 1 < f[r]:\n            f[r] = f[l] + 1\n            for i in range(r + 1, n):\n                f[i] = min(f[i], f[i - 1] + 1, min((f[j] for j in frm[i]), default=inf) + 1)\n        ans.append(f[-1])\n    return ans\n", "source_code_block": "", "target_Lan": "cpp###shortestDistanceAfterQueries.cpp", "reference_code": "vector<int> shortestDistanceAfterQueries(int n, vector<vector<int>>& queries) {\n        vector<vector<int>> from(n);\n        vector<int> f(n);\n        iota(f.begin(), f.end(), 0);\n        vector<int> ans(queries.size());\n        for (int qi = 0; qi < queries.size(); qi++) {\n            int l = queries[qi][0], r = queries[qi][1];\n            from[r].push_back(l);\n            if (f[l] + 1 < f[r]) {\n                f[r] = f[l] + 1;\n                for (int i = r + 1; i < n; i++) {\n                    f[i] = min(f[i], f[i - 1] + 1);\n                    for (int j : from[i]) {\n                        f[i] = min(f[i], f[j] + 1);\n                    }\n                }\n            }\n            ans[qi] = f[n - 1];\n        }\n        return ans;\n    }", "target_method_signature": "shortestDistanceAfterQueries", "source_method_signature": "shortestDistanceAfterQueries", "target_allMS": "vector<int> shortestDistanceAfterQueries(int n, vector<vector<int>>& queries) {", "source_allMS": "def shortestDistanceAfterQueries( n: int, queries: List[List[int]]) -> List[int]:", "source_import": "from typing import List", "target_import": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <numeric>", "commentTag": "//", "source_code_shell": "from typing import List\nfrom typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(shortestDistanceAfterQueries(3, [[0, 1], [1, 2]]))\n    print(shortestDistanceAfterQueries(5, []))\n    print(shortestDistanceAfterQueries(3, [[1, 2], [0, 1], [1, 0]]))\n    print(shortestDistanceAfterQueries(10, [[0, 1], [1, 2], [2, 9], [8, 9]]))", "all_input_output_value": "\ninput1: n=3, queries=[[0, 1], [1, 2]]\noutput1: [2, 2]\n--------\ninput2: n=5, queries=[]\noutput2: []\n--------\ninput3: n=3, queries=[[1, 2], [0, 1], [1, 0]]\noutput3: [2, 2, 2]\n--------\ninput4: n=10, queries=[[0, 1], [1, 2], [2, 9], [8, 9]]\noutput4: [9, 9, 3, 3]\n", "input_output_value": ["\ninput1: n=3, queries=[[0, 1], [1, 2]]\noutput1: [2, 2]\n", "\ninput2: n=5, queries=[]\noutput2: []\n", "\ninput3: n=3, queries=[[1, 2], [0, 1], [1, 0]]\noutput3: [2, 2, 2]\n"], "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <numeric>\n#include <iostream>\n#include <vector>\n#include <numeric>\n// TOFILL\nint main() {\n    vector<vector<int>> queries1 = {{0, 1}, {1, 2}};\n    vector<vector<int>> queries2 = {};\n    vector<vector<int>> queries3 = {{1, 2}, {0, 1}, {1, 0}};\n    vector<vector<int>> queries4 = {{0, 1}, {1, 2}, {2, 9}, {8, 9}};\n    \n    vector<int> result1 = shortestDistanceAfterQueries(3, queries1);\n    vector<int> result2 = shortestDistanceAfterQueries(5, queries2);\n    vector<int> result3 = shortestDistanceAfterQueries(3, queries3);\n    vector<int> result4 = shortestDistanceAfterQueries(10, queries4);\n    \n    for(int res : result1) {\n        cout << res << \" \";\n    }\n    cout << endl;\n    \n    for(int res : result2) {\n        cout << res << \" \";\n    }\n    cout << endl;\n    \n    for(int res : result3) {\n        cout << res << \" \";\n    }\n    cout << endl;\n\n    for(int res : result4) {\n        cout << res << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}", "TAG": "Success"}
{"source_Lan": "python###shortestDistanceAfterQueries2.py", "source_code_str": "def shortestDistanceAfterQueries2(n: int, queries: List[List[int]]) -> List[int]:\n    ans = []\n    nxt = list(range(1, n))\n    cnt = n - 1\n    for l, r in queries:\n        if 0 < nxt[l] < r:\n            i = nxt[l]\n            while i < r:\n                cnt -= 1\n                nxt[i], i = 0, nxt[i]\n            nxt[l] = r\n        ans.append(cnt)\n    return ans\n    ", "source_code_block": "", "target_Lan": "cpp###shortestDistanceAfterQueries2.cpp", "reference_code": "vector<int> shortestDistanceAfterQueries2(int n, vector<vector<int>>& queries) {\n        vector<int> nxt(n - 1);\n        iota(nxt.begin(), nxt.end(), 1);\n        vector<int> ans(queries.size());\n        int cnt = n - 1;\n        for (int qi = 0; qi < queries.size(); qi++) {\n            int l = queries[qi][0], r = queries[qi][1];\n            if (nxt[l] && nxt[l] < r) {\n                for (int i = nxt[l]; i < r;) {\n                    cnt--;\n                    int tmp = nxt[i];\n                    nxt[i] = 0;\n                    i = tmp;\n                }\n                nxt[l] = r;\n            }\n            ans[qi] = cnt;\n        }\n        return ans;\n    }", "target_method_signature": "shortestDistanceAfterQueries2", "source_method_signature": "shortestDistanceAfterQueries2", "target_allMS": "vector<int> shortestDistanceAfterQueries2(int n, vector<vector<int>>& queries) {", "source_allMS": "def shortestDistanceAfterQueries2( n: int, queries: List[List[int]]) -> List[int]:", "source_import": "from typing import List", "target_import": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <numeric> // For iota", "commentTag": "//", "source_code_shell": "from typing import List\nfrom typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    n = 6\n    queries = [[1, 3], [0, 5], [2, 4], [1, 1], [0, 4]]\n    print(shortestDistanceAfterQueries2(n, queries))", "all_input_output_value": "\ninput1: n=6, queries=[[1, 3], [0, 5], [2, 4], [1, 1], [0, 4]]\noutput1: [4, 1, 1, 1, 1]\n", "input_output_value": ["\ninput1: n=6, queries=[[1, 3], [0, 5], [2, 4], [1, 1], [0, 4]]\noutput1: [4, 1, 1, 1, 1]\n"], "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <numeric> // For iota\n#include <iostream>\n#include <vector>\n#include <numeric>\n// TOFILL\nint main() {\n    int n = 6;\n    vector<vector<int>> queries = {{1, 3}, {0, 5}, {2, 4}, {1, 1}, {0, 4}};\n    vector<int> result = shortestDistanceAfterQueries2(n, queries);\n    \n    for(int res : result) {\n        cout << res << endl;\n    }\n\n    return 0;\n}", "TAG": "Success"}
{"source_Lan": "python###getMax.py", "source_code_str": "def getMax( x: int) -> int:\n        \n        flag = False\n        prev = -1\n        cnt = 0\n        for i in range(30, -1, -1):\n            if cnt >= 2:\n                break\n            if not flag and (x & (1 << i)) > 0:\n                flag = True\n                continue\n            if flag:\n                if (x & (1 << i)) == 0 and prev == -1:\n                    prev = i\n                    x |= (1 << i)\n                    cnt += 1\n                if (x & (1 << i)) == 0 and prev - i > 1:\n                    x |= (1 << i)\n                    cnt += 1\n        return x", "source_code_block": "", "target_Lan": "cpp###getMax.cpp", "reference_code": "    int getMax(int x) {\n        \n        bool flag = false;\n        int prev = -1;\n        int cnt = 0;\n        for (int i = 30; i >= 0; i--) {\n            if (cnt >= 2)\n                break;\n            if (flag == false and (x & (1 << i)) > 0) {\n                flag = true;\n                continue;\n            }\n            if (flag) {\n                if ((x & (1 << i)) == 0 and prev == -1) {\n                    prev = i;\n                    x |= (1 << i);\n                    cnt++;\n                }\n                if ((x & (1 << i)) == 0 and prev - i > 1) {\n                    x |= (1 << i);\n                    cnt++;\n                }\n            }\n        }\n        return x;\n    }", "target_method_signature": "getMax", "source_method_signature": "getMax", "target_allMS": "    int getMax(int x) {", "source_allMS": "def getMax( x: int) -> int:", "source_import": "", "target_import": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>", "commentTag": "//", "source_code_shell": "# TOFILL\nif __name__ == \"__main__\":\n    print(getMax(0))\n    print(getMax(1))\n    print(getMax(15))\n    print(getMax(8))\n    print(getMax(31))", "all_input_output_value": "\ninput1: x=0\noutput1: 0\n--------\ninput2: x=1\noutput2: 1\n--------\ninput3: x=15\noutput3: 15\n--------\ninput4: x=8\noutput4: 13\n--------\ninput5: x=31\noutput5: 31\n", "input_output_value": ["\ninput1: x=0\noutput1: 0\n", "\ninput2: x=1\noutput2: 1\n", "\ninput3: x=15\noutput3: 15\n"], "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <iostream>\n// TOFILL\nint main() {\n    cout << getMax(0) << endl;\n    cout << getMax(1) << endl;\n    cout << getMax(15) << endl;\n    cout << getMax(8) << endl;\n    cout << getMax(31) << endl;\n}", "TAG": "Success"}
{"source_Lan": "python###minSwaps.py", "source_code_str": "def minSwaps( S):\n        even_sum, odd_sum = 0, 0\n        n = len(S)\n        \n        for i in range(n):\n            if i % 2 == 1:\n                odd_sum += (S[i] == '1')\n            else:\n                even_sum += (S[i] == '1')\n        \n        difference = abs(odd_sum - even_sum)\n        \n        if difference % 2 == 1:\n            return -1\n        \n        return difference // 2", "source_code_block": "", "target_Lan": "cpp###minSwaps.cpp", "reference_code": "int minSwaps(string S) {\n        int evenSum = 0, oddSum = 0;\n        int n = S.size();\n        \n        for (int i = 0; i < n; i++) {\n            if (i & 1)\n                oddSum += (S[i] == '1');\n            else\n                evenSum += (S[i] == '1');\n        }\n        \n        int difference = abs(oddSum - evenSum);\n        \n        if (difference & 1)\n            return -1;\n        \n        return difference / 2;\n    }", "target_method_signature": "minSwaps", "source_method_signature": "minSwaps", "target_allMS": "int minSwaps(string S) {", "source_allMS": "def minSwaps( S):", "source_import": "", "target_import": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <string>\n#include <cstdlib> // For abs function", "commentTag": "//", "source_code_shell": "# TOFILL\nif __name__ == \"__main__\":\n    print(minSwaps(\"1010\"))      # balanced, expects 0 swaps\n    print(minSwaps(\"101\"))       # unbalanced (odd), expects -1\n    print(minSwaps(\"1100\"))      # unbalanced, expects 1 swap\n    print(minSwaps(\"111000\"))    # unbalanced, expects 1 swap\n    print(minSwaps(\"0000000\"))   # no '1's, expects 0 swaps", "all_input_output_value": "\ninput1: S=\"1010\"\noutput1: 1\n--------\ninput2: S=\"101\"\noutput2: 1\n--------\ninput3: S=\"1100\"\noutput3: 0\n--------\ninput4: S=\"111000\"\noutput4: -1\n--------\ninput5: S=\"0000000\"\noutput5: 0\n", "input_output_value": ["\ninput1: S=\"1010\"\noutput1: 1\n", "\ninput2: S=\"101\"\noutput2: 1\n", "\ninput3: S=\"1100\"\noutput3: 0\n"], "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <string>\n#include <cstdlib> // For abs function\n#include <iostream>\n#include <string>\n#include <cstdlib> // for abs\n// TOFILL\nint main() {\n    cout << minSwaps(\"1010\") << endl;\n    cout << minSwaps(\"101\") << endl;\n    cout << minSwaps(\"1100\") << endl;\n    cout << minSwaps(\"111000\") << endl;\n    cout << minSwaps(\"0000000\") << endl;\n    return 0;\n}", "TAG": "Success"}
{"source_Lan": "python###maxLength.py", "source_code_str": "def maxLength( arr):\n        \n        N = len(arr)\n        ans = 0\n        for i in range(N):\n            or_val = 0\n            for j in range(i, n):\n                or_val |= arr[j]\n                x = bin(or_val).count('1')\n                if x == len(bin(or_val)) - 2:  \n                    ans = max(ans, j - i + 1)\n        return ans", "source_code_block": "", "target_Lan": "cpp###maxLength.cpp", "reference_code": "int maxLength(vector<int> arr) {\n        \n        int ans = 0;\n        int N = arr.size();\n        for (int i = 0; i < N; i++) {\n            int or_val = 0;\n            for (int j = i; j < N; j++) {\n                or_val = or_val | arr[j];\n                int x = __builtin_popcount(or_val);\n                if (x == (int)log2(or_val) + 1) {\n                    ans = max(ans, j - i + 1);\n                }\n            }\n        }\n        return ans;\n    }", "target_method_signature": "maxLength", "source_method_signature": "maxLength", "target_allMS": "int maxLength(vector<int> arr) {", "source_allMS": "def maxLength( arr):", "source_import": "", "target_import": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>", "commentTag": "//", "source_code_shell": "# TOFILL\nif __name__ == \"__main__\":\n    print(maxLength([]))                   # Test Input 1", "all_input_output_value": "\ninput1: arr=[]\noutput1: 0\n", "input_output_value": ["\ninput1: arr=[]\noutput1: 0\n"], "TAG": "Success", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <iostream>\n#include <vector>\n#include <cmath>\n// TOFILL\nint main() {\n    vector<int> test_input1 = {};\n    cout << maxLength(test_input1) << endl;\n}"}
{"source_Lan": "python###minIncrements.py", "source_code_str": "def minIncrements( n: int, cost: List[int]) -> int:\n    ans = 0\n    for i in range(n - 2, 0, -2):\n        ans += abs(cost[i] - cost[i + 1])\n        \n        cost[i // 2] += max(cost[i], cost[i + 1])\n    return ans", "source_code_block": "", "target_Lan": "cpp###minIncrements.cpp", "reference_code": "    int minIncrements(int n, vector<int>& cost) {\n        int ans = 0;\n        for (int i = n - 2; i > 0; i -= 2) {\n            ans += abs(cost[i] - cost[i + 1]);\n            \n            cost[i / 2] += max(cost[i], cost[i + 1]);\n        }\n        return ans;\n    }", "target_method_signature": "minIncrements", "source_method_signature": "minIncrements", "target_allMS": "    int minIncrements(int n, vector<int>& cost) {", "source_allMS": "def minIncrements( n: int, cost: List[int]) -> int:", "source_import": "", "target_import": "#include <iostream>\nusing namespace std;", "commentTag": "//", "source_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(minIncrements(3, [1, 2, 3]))\n    print(minIncrements(4, [1, 2, 3, 4]))\n    print(minIncrements(5, [5, 3, 6, 2, 1]))\n    print(minIncrements(2, [1, 10]))\n    print(minIncrements(0, []))", "all_input_output_value": "\ninput1: n=3, cost=[1, 2, 3]\noutput1: 1\n--------\ninput2: n=4, cost=[1, 2, 3, 4]\noutput2: 1\n--------\ninput3: n=5, cost=[5, 3, 6, 2, 1]\noutput3: 2\n--------\ninput4: n=2, cost=[1, 10]\noutput4: 0\n--------\ninput5: n=0, cost=[]\noutput5: 0\n", "input_output_value": ["\ninput1: n=3, cost=[1, 2, 3]\noutput1: 1\n", "\ninput2: n=4, cost=[1, 2, 3, 4]\noutput2: 1\n", "\ninput3: n=5, cost=[5, 3, 6, 2, 1]\noutput3: 2\n"], "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <cmath>\n// TOFILL\nint main() {\n    vector<int> cost1 = {1, 2, 3};\n    cout << minIncrements(3, cost1) << endl;\n\n    vector<int> cost2 = {1, 2, 3, 4};\n    cout << minIncrements(4, cost2) << endl;\n    \n    vector<int> cost3 = {5, 3, 6, 2, 1};\n    cout << minIncrements(5, cost3) << endl;\n\n    vector<int> cost4 = {1, 10};\n    cout << minIncrements(2, cost4) << endl;\n\n    vector<int> cost5 = {};\n    cout << minIncrements(0, cost5) << endl;\n\n    return 0;\n}", "TAG": "Success"}
{"source_Lan": "python###maximumPrimeDifference.py", "source_code_str": "def maximumPrimeDifference( nums: List[int]) -> int:\n    primes = {\n        2, 3, 5, 7, 11,\n        13, 17, 19, 23, 29,\n        31, 37, 41, 43, 47,\n        53, 59, 61, 67, 71,\n        73, 79, 83, 89, 97\n    }\n    first, ans = -1, 0\n    for i, num in enumerate(nums):\n        if num in primes:\n            if first != -1:\n                ans = max(ans, i - first)\n            else:\n                first = i\n    return ans", "source_code_block": "", "target_Lan": "cpp###maximumPrimeDifference.cpp", "reference_code": "    int maximumPrimeDifference(vector<int>& nums) {\n        unordered_set<int> primes = {\n            2, 3, 5, 7, 11,\n            13, 17, 19, 23, 29,\n            31, 37, 41, 43, 47,\n            53, 59, 61, 67, 71,\n            73, 79, 83, 89, 97\n        };\n        int n = nums.size();\n        int first = -1, ans = 0;\n        for (int i = 0; i < n; ++i) {\n            if (primes.count(nums[i])) {\n                if (first != -1) {\n                    ans = max(ans, i - first);\n                }\n                else {\n                    first = i;\n                }\n            }\n        }\n        return ans;\n    }", "target_method_signature": "maximumPrimeDifference", "source_method_signature": "maximumPrimeDifference", "target_allMS": "    int maximumPrimeDifference(vector<int>& nums) {", "source_allMS": "def maximumPrimeDifference( nums: List[int]) -> int:", "source_import": "", "target_import": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;", "commentTag": "//", "source_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(maximumPrimeDifference([1, 4, 6, 8, 9]))  # Test input 1: No primes\n    print(maximumPrimeDifference([10, 23]))          # Test input 2: One prime (should be index 1)\n    print(maximumPrimeDifference([3, 5, 2, 9]))      # Test input 3: Multiple primes with maximum difference (indexes 0 and 2)\n    print(maximumPrimeDifference([11, 11, 13]))      # Test input 4: Repeated prime numbers\n    print(maximumPrimeDifference([4, -6, 1, 0, 7]))  # Test input 5: Mixed numbers with one prime (only 7)", "all_input_output_value": "\ninput1: nums=[1, 4, 6, 8, 9]\noutput1: 0\n--------\ninput2: nums=[10, 23]\noutput2: 0\n--------\ninput3: nums=[3, 5, 2, 9]\noutput3: 2\n--------\ninput4: nums=[11, 11, 13]\noutput4: 2\n--------\ninput5: nums=[4, -6, 1, 0, 7]\noutput5: 0\n", "input_output_value": ["\ninput1: nums=[1, 4, 6, 8, 9]\noutput1: 0\n", "\ninput2: nums=[10, 23]\noutput2: 0\n", "\ninput3: nums=[3, 5, 2, 9]\noutput3: 2\n"], "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <unordered_set>\n// TOFILL\nint main() {\n    vector<int> test1 = {1, 4, 6, 8, 9};\n    vector<int> test2 = {10, 23};\n    vector<int> test3 = {3, 5, 2, 9};\n    vector<int> test4 = {11, 11, 13};\n    vector<int> test5 = {4, -6, 1, 0, 7};\n\n    cout << maximumPrimeDifference(test1) << endl; // Output for first test\n    cout << maximumPrimeDifference(test2) << endl; // Output for second test\n    cout << maximumPrimeDifference(test3) << endl; // Output for third test\n    cout << maximumPrimeDifference(test4) << endl; // Output for fourth test\n    cout << maximumPrimeDifference(test5) << endl; // Output for fifth test\n}", "TAG": "Success"}
{"source_Lan": "python###candyShop2.py", "source_code_str": "def candyShop2( n : int, candies : List[int]) -> int:\n    s=set(el for el in candies)\n    return sum(s)", "source_code_block": "", "target_Lan": "cpp###candyShop2.cpp", "reference_code": "    int candyShop2(int n, vector<int> &candies) {\n        int answer = 0;\n        unordered_map<int, int> m;\n        for(auto i : candies){\n            if(m.find(i) == m.end()){\n                answer += i;\n                m[i] = 1;\n            }\n        }\n        return answer;\n    }", "target_method_signature": "candyShop2", "source_method_signature": "candyShop2", "target_allMS": "    int candyShop2(int n, vector<int> &candies) {", "source_allMS": "def candyShop2( n : int, candies : List[int]) -> int:", "source_import": "from typing import List\nfrom collections import Counter", "target_import": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;", "commentTag": "//", "source_code_shell": "from typing import List\nfrom collections import Counter\nfrom typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(candyShop2(0, []))                # Case 1: No candies (empty case)\n    print(candyShop2(3, [1, 2, 3]))         # Case 2: All unique candies\n    print(candyShop2(4, [1, 2, 2, 3]))      # Case 3: Some repeated candies\n    print(candyShop2(3, [3, 3, 3]))         # Case 4: All candies are the same\n    print(candyShop2(5, [1, 2, 2, 3, 4]))   # Case 5: A mixture of unique and repeated candies", "all_input_output_value": "\ninput1: n=0, candies=[]\noutput1: 0\n--------\ninput2: n=3, candies=[1, 2, 3]\noutput2: 6\n--------\ninput3: n=4, candies=[1, 2, 2, 3]\noutput3: 6\n--------\ninput4: n=3, candies=[3, 3, 3]\noutput4: 3\n--------\ninput5: n=5, candies=[1, 2, 2, 3, 4]\noutput5: 10\n", "input_output_value": ["\ninput1: n=0, candies=[]\noutput1: 0\n", "\ninput2: n=3, candies=[1, 2, 3]\noutput2: 6\n", "\ninput3: n=4, candies=[1, 2, 2, 3]\noutput3: 6\n"], "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n// TOFILL\nint main() {\n    vector<int> candies1 = {};\n    cout << candyShop2(0, candies1) << endl;\n    \n    vector<int> candies2 = {1, 2, 3};\n    cout << candyShop2(3, candies2) << endl;\n    \n    vector<int> candies3 = {1, 2, 2, 3};\n    cout << candyShop2(4, candies3) << endl;\n    \n    vector<int> candies4 = {3, 3, 3};\n    cout << candyShop2(3, candies4) << endl;\n    \n    vector<int> candies5 = {1, 2, 2, 3, 4};\n    cout << candyShop2(5, candies5) << endl;\n\n    return 0;\n}", "TAG": "Success"}
{"source_Lan": "python###maxFrequencyElements.py", "source_code_str": "def maxFrequencyElements( nums: List[int]) -> int:\n    ans = max_cnt = 0\n    cnt = Counter()\n    for x in nums:\n        cnt[x] += 1\n        c = cnt[x]\n        if c > max_cnt:\n            max_cnt = ans = c\n        elif c == max_cnt:\n            ans += c\n    return ans", "source_code_block": "", "target_Lan": "cpp###maxFrequencyElements.cpp", "reference_code": "    int maxFrequencyElements(vector<int> &nums) {\n        int ans = 0, maxCnt = 0;\n        unordered_map<int, int> cnt;\n        for (int x : nums) {\n            int c = ++cnt[x];\n            if (c > maxCnt) {\n                maxCnt = ans = c;\n            } else if (c == maxCnt) {\n                ans += c;\n            }\n        }\n        return ans;\n    }", "target_method_signature": "maxFrequencyElements", "source_method_signature": "maxFrequencyElements", "target_allMS": "    int maxFrequencyElements(vector<int> &nums) {", "source_allMS": "def maxFrequencyElements( nums: List[int]) -> int:", "source_import": "", "target_import": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;", "commentTag": "//", "source_code_shell": "from collections import Counter\nfrom typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(maxFrequencyElements([]))              # Test input: nums=[]\n    print(maxFrequencyElements([1]))             # Test input: nums=[1]\n    print(maxFrequencyElements([1, 2, 3]))       # Test input: nums=[1, 2, 3]\n    print(maxFrequencyElements([1, 1, 2, 2, 3])) # Test input: nums=[1, 1, 2, 2, 3]\n    print(maxFrequencyElements([-1, -1, 2, 2, 2])) # Test input: nums=[-1, -1, 2, 2, 2]", "all_input_output_value": "\ninput1: nums=[]\noutput1: 0\n--------\ninput2: nums=[1]\noutput2: 1\n--------\ninput3: nums=[1, 2, 3]\noutput3: 3\n--------\ninput4: nums=[1, 1, 2, 2, 3]\noutput4: 4\n--------\ninput5: nums=[-1, -1, 2, 2, 2]\noutput5: 3\n", "input_output_value": ["\ninput1: nums=[]\noutput1: 0\n", "\ninput2: nums=[1]\noutput2: 1\n", "\ninput3: nums=[1, 2, 3]\noutput3: 3\n"], "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n// TOFILL\nint main() {\n    vector<int> input1 = {};\n    vector<int> input2 = {1};\n    vector<int> input3 = {1, 2, 3};\n    vector<int> input4 = {1, 1, 2, 2, 3};\n    vector<int> input5 = {-1, -1, 2, 2, 2};\n\n    cout << maxFrequencyElements(input1) << endl; // Expected output for empty input\n    cout << maxFrequencyElements(input2) << endl; // Expected output for input with a single element\n    cout << maxFrequencyElements(input3) << endl; // Expected output for input with unique elements\n    cout << maxFrequencyElements(input4) << endl; // Expected output for input with two most frequent elements\n    cout << maxFrequencyElements(input5) << endl; // Expected output for input with one dominant element\n}", "TAG": "Success"}
{"source_Lan": "python###minOPs.py", "source_code_str": "def minOPs( n : int, A : List[int]) -> int:\n    c=Counter(A)\n    t=[]\n    for el in c.values():\n        t.append(el)\n    t.sort()\n    s=0\n    ans=0\n    while s<=(n/2):\n        s+=t.pop()\n        ans+=1\n    return ans-1", "source_code_block": "", "target_Lan": "cpp###minOPs.cpp", "reference_code": "    int minOPs(int n, vector<int> &A)\n    {\n        map<int,int> m;\n        for(auto it:A) m[it]++;\n        vector<int> v;\n        for(auto it:m) v.push_back(it.second);\n        sort(v.begin(),v.end());\n        int sum=0;\n        for(int i=v.size()-1;i>=0;i--)\n        {\n          sum+=v[i];\n          if(sum>(n/2)) return v.size()-1-i;\n        }\n    }", "target_method_signature": "minOPs", "source_method_signature": "minOPs", "target_allMS": "    int minOPs(int n, vector<int> &A)", "source_allMS": "def minOPs( n : int, A : List[int]) -> int:", "source_import": "from typing import List\nfrom collections import Counter", "target_import": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;", "commentTag": "//", "source_code_shell": "from typing import List\nfrom collections import Counter\nfrom collections import Counter\nfrom typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(minOPs(10, [3, 1, 4, 1, 5, 9, 2, 6, 5, 3]))", "all_input_output_value": "\ninput1: n=10, A=[3, 1, 4, 1, 5, 9, 2, 6, 5, 3]\noutput1: 2\n", "input_output_value": ["\ninput1: n=10, A=[3, 1, 4, 1, 5, 9, 2, 6, 5, 3]\noutput1: 2\n"], "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\n// TOFILL\nint main() {\n    vector<int> A = {3, 1, 4, 1, 5, 9, 2, 6, 5, 3};\n    int n = 10;\n    cout << minOPs(n, A) << endl;\n}", "TAG": "Success"}
{"source_Lan": "python###minRectanglesToCoverPoints.py", "source_code_str": "def minRectanglesToCoverPoints( points: List[List[int]], w: int) -> int:\n        points.sort()\n        res = 0\n        bound = -1\n        for p in points:\n            if p[0] > bound:\n                bound = p[0] + w\n                res += 1\n        return res\n", "source_code_block": "", "target_Lan": "cpp###minRectanglesToCoverPoints.cpp", "reference_code": "int minRectanglesToCoverPoints(vector<vector<int>>& points, int w) {\n        sort(points.begin(), points.end());\n        int res = 0;\n        int bound = -1;\n        for (auto &p : points) {\n            if (p[0] > bound) {\n                bound = p[0] + w;\n                res++;\n            }\n        }\n        return res;\n    }", "target_method_signature": "minRectanglesToCoverPoints", "source_method_signature": "minRectanglesToCoverPoints", "target_allMS": "", "source_allMS": "", "source_import": "from typing import List", "target_import": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;", "commentTag": "", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <algorithm>\n// TOFILL\nint main() {\n    vector<vector<int>> points1 = {{0, 0}, {1, 1}};\n    cout << minRectanglesToCoverPoints(points1, 3) << endl;\n\n    vector<vector<int>> points2 = {{0, 0}, {4, 1}};\n    cout << minRectanglesToCoverPoints(points2, 2) << endl;\n\n    vector<vector<int>> points3 = {{-1, -1}, {0, 0}, {1, 1}};\n    cout << minRectanglesToCoverPoints(points3, 2) << endl;\n\n    vector<vector<int>> points4 = {{0, 0}, {2, 2}, {3, 3}, {4, 4}};\n    cout << minRectanglesToCoverPoints(points4, 3) << endl;\n\n    vector<vector<int>> points5 = {};\n    cout << minRectanglesToCoverPoints(points5, 1) << endl;\n\n    return 0;\n}", "all_input_output_value": "\ninput1: points=[[0, 0], [1, 1], n=3\noutput1: 1\n--------\ninput2: points=[[0, 0], [4, 1], n=2\noutput2: 2\n--------\ninput3: points=[[-1, -1], [0, 0], [1, 1]], n=2\noutput3: 1\n--------\ninput4: points=[[0, 0], [2, 2], [3, 3], [4, 4]], n=3\noutput4: 2\n--------\ninput5: points=[], n=1\noutput5: 0\n", "input_output_value": ["\ninput1: points=[[0, 0], [1, 1], n=3\noutput1: 1\n", "\ninput2: points=[[0, 0], [4, 1], n=2\noutput2: 2\n", "\ninput3: points=[[-1, -1], [0, 0], [1, 1]], n=2\noutput3: 1\n"], "TAG": "Success", "source_code_shell": "from typing import List\nfrom typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(minRectanglesToCoverPoints([[0, 0], [1, 1], [2, 2]], 3))  # Expected output: 1\n    print(minRectanglesToCoverPoints([[0, 0], [4, 1], [5, 2]], 2))  # Expected output: 2\n    print(minRectanglesToCoverPoints([[ -1, -1], [0, 0], [1, 1]], 2))  # Expected output: 2\n    print(minRectanglesToCoverPoints([[0, 0], [2, 2], [3, 3], [4, 4]], 3))  # Expected output: 3\n    print(minRectanglesToCoverPoints([], 1))  # Expected output: 0"}
{"source_Lan": "python###relocateMarbles.py", "source_code_str": "def relocateMarbles( nums: List[int], moveFrom: List[int], moveTo: List[int]) -> List[int]:\n        mp = {}\n        ans = []\n        for num in nums:\n            mp[num] = True\n        for i in range(len(moveFrom)):\n            if moveFrom[i] in mp:\n                del mp[moveFrom[i]]\n            mp[moveTo[i]] = True\n        ans = list(mp.keys())\n        ans.sort()\n        return ans", "source_code_block": "", "target_Lan": "cpp###relocateMarbles.cpp", "reference_code": "vector<int> relocateMarbles(vector<int>& nums, vector<int>& moveFrom, vector<int>& moveTo) {\n        vector<int> ans;\n        unordered_map<int, bool> mp;\n\n        for (int i = 0; i < nums.size(); i++) {\n            mp[nums[i]] = true;\n        }\n\n        for (int i = 0; i < moveFrom.size(); i++) {\n            mp.erase(moveFrom[i]);\n            mp[moveTo[i]] = true;\n        }\n\n        for (const auto& pair : mp) {\n            ans.push_back(pair.first);\n        }\n        sort(ans.begin(), ans.end());\n        return ans;\n    }", "target_method_signature": "relocateMarbles", "source_method_signature": "relocateMarbles", "target_allMS": "", "source_allMS": "", "source_import": "from typing import List", "target_import": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <algorithm>\nusing namespace std;", "commentTag": "", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <algorithm>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <algorithm>\n// TOFILL\nint main() {\n    vector<int> marbles1 = {1, 2, 3};\n    vector<int> marbles2 = {1, 2};\n    vector<int> marbles3 = {4, 5};\n    vector<int> result1 = relocateMarbles(marbles1, marbles2, marbles3);\n    for(int num : result1) {\n        cout << num << \" \";\n    }\n    cout << endl;\n\n    marbles1 = {1, 2, 3};\n    marbles2 = {};\n    marbles3 = {};\n    vector<int> result2 = relocateMarbles(marbles1, marbles2, marbles3);\n    for(int num : result2) {\n        cout << num << \" \";\n    }\n    cout << endl;\n\n    marbles1 = {1, 2, 3};\n    marbles2 = {1, 4};\n    marbles3 = {3, 2};\n    vector<int> result3 = relocateMarbles(marbles1, marbles2, marbles3);\n    for(int num : result3) {\n        cout << num << \" \";\n    }\n    cout << endl;\n\n    marbles1 = {1, 2, 3};\n    marbles2 = {2, 3};\n    marbles3 = {4, 5};\n    vector<int> result4 = relocateMarbles(marbles1, marbles2, marbles3);\n    for(int num : result4) {\n        cout << num << \" \";\n    }\n    cout << endl;\n\n    marbles1 = {};\n    marbles2 = {1};\n    marbles3 = {2};\n    vector<int> result5 = relocateMarbles(marbles1, marbles2, marbles3);\n    for(int num : result5) {\n        cout << num << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}", "all_input_output_value": "\ninput1: marbles1=[1, 2, 3], marbles2=[1, 2], marbles3=[4, 5]\noutput1: [3, 4, 5]\n--------\ninput2: marbles1=[1, 2, 3], marbles2=[], marbles3=[]\noutput2: [1, 2, 3]\n--------\ninput3: marbles1=[1, 2, 3], marbles2=[1, 4], marbles3=[3, 2]\noutput3: [2, 3]\n--------\ninput4: marbles1=[1, 2, 3], marbles2=[2, 3], marbles3=[4, 5]\noutput4: [1, 4, 5]\n--------\ninput5: marbles1=[], marbles2=[1], marbles3=[2]\noutput5: [2]\n", "input_output_value": ["\ninput1: marbles1=[1, 2, 3], marbles2=[1, 2], marbles3=[4, 5]\noutput1: [3, 4, 5]\n", "\ninput2: marbles1=[1, 2, 3], marbles2=[], marbles3=[]\noutput2: [1, 2, 3]\n", "\ninput3: marbles1=[1, 2, 3], marbles2=[1, 4], marbles3=[3, 2]\noutput3: [2, 3]\n"], "TAG": "Success", "source_code_shell": "from typing import List\nfrom typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(relocateMarbles([1, 2, 3], [1, 2], [4, 5]))\n    print(relocateMarbles([1, 2, 3], [], []))\n    print(relocateMarbles([1, 2, 3], [1, 4], [3, 2]))\n    print(relocateMarbles([1, 2, 3], [2, 3], [4, 5]))\n    print(relocateMarbles([], [1], [2]))"}
{"source_Lan": "python###minDeletion.py", "source_code_str": "def minDeletion( nums: List[int]) -> int:\n        n = len(nums)\n        ans, check = 0, True\n        for i in range(n - 1):\n            if nums[i] == nums[i + 1] and check:\n                ans += 1\n            else:\n                check = not check\n        if (n - ans) % 2 != 0:\n            ans += 1\n        return ans", "source_code_block": "", "target_Lan": "cpp###minDeletion.cpp", "reference_code": "int minDeletion(vector<int>& nums) {\n        int n = nums.size();\n        int ans = 0;\n        bool check = true;\n        for (int i = 0; i + 1 < n; ++i) {\n            if (nums[i] == nums[i + 1] && check) {\n                ++ans;\n            }\n            else {\n                check = !check;\n            }\n        }\n        if ((n - ans) % 2 != 0) {\n            ++ans;\n        }\n        return ans;\n    }", "target_method_signature": "minDeletion", "source_method_signature": "minDeletion", "target_allMS": "int minDeletion(vector<int>& nums) {", "source_allMS": "def minDeletion( nums: List[int]) -> int:", "source_import": "from typing import List", "target_import": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>", "commentTag": "//", "source_code_shell": "from typing import List\nfrom typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(minDeletion([]))  # Empty array\n    print(minDeletion([1]))  # Single element\n    print(minDeletion([1, 2, 3]))  # All unique elements\n    print(minDeletion([2, 2, 2, 2, 2]))  # All same elements\n    print(minDeletion([1, 1, 2, 2, 3]))  # Mixed duplicates and unique", "all_input_output_value": "\ninput1: nums=[]\noutput1: 0\n--------\ninput2: nums=[1]\noutput2: 1\n--------\ninput3: nums=[1, 2, 3]\noutput3: 1\n--------\ninput4: nums=[2, 2, 2, 2, 2]\noutput4: 5\n--------\ninput5: nums=[1, 1, 2, 2, 3]\noutput5: 1\n", "input_output_value": ["\ninput1: nums=[]\noutput1: 0\n", "\ninput2: nums=[1]\noutput2: 1\n", "\ninput3: nums=[1, 2, 3]\noutput3: 1\n"], "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    vector<int> input1 = {};\n    vector<int> input2 = {1};\n    vector<int> input3 = {1, 2, 3};\n    vector<int> input4 = {2, 2, 2, 2, 2};\n    vector<int> input5 = {1, 1, 2, 2, 3};\n    \n    cout << minDeletion(input1) << endl;\n    cout << minDeletion(input2) << endl;\n    cout << minDeletion(input3) << endl;\n    cout << minDeletion(input4) << endl;\n    cout << minDeletion(input5) << endl;\n\n    return 0;\n}", "TAG": "Success"}
{"source_Lan": "python###topStudents.py", "source_code_str": "def topStudents( positive_feedback, negative_feedback, report, student_id, k):\n        words = {}\n        for w in positive_feedback:\n            words[w] = 3\n        for w in negative_feedback:\n            words[w] = -1\n        A = []\n        for s, i in zip(report, student_id):\n            score = sum(words.get(w, 0)for w in s.split())\n            A.append([-score, i])\n        A.sort()\n        return [i for v,i in A[:k]]", "source_code_block": "", "target_Lan": "cpp###topStudents.cpp", "reference_code": "vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& student_id, int k) {\n        unordered_map<std::string, int> words;\n        for (const auto& word : positive_feedback) {\n            words[word] = 3;\n        }\n        for (const auto& word : negative_feedback) {\n            words[word] = -1;\n        }\n        vector<vector<int>> A;\n        for (int i = 0; i < report.size(); i++) {\n            stringstream ss; \n            string w;\n            int score = 0;\n            ss << report[i];\n            while (ss >> w) {\n                if (words.count(w)) {\n                    score += words[w];\n                }\n            }\n            A.push_back({-score, student_id[i]});\n        }\n        sort(A.begin(), A.end());\n        vector<int> top_k;\n        for (int i = 0; i < k; i++) {\n            top_k.push_back(A[i][1]);\n        }\n        return top_k;\n    }", "target_method_signature": "topStudents", "source_method_signature": "topStudents", "target_allMS": "vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& student_id, int k) {", "source_allMS": "def topStudents( positive_feedback, negative_feedback, report, student_id, k):", "source_import": "", "target_import": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <unordered_map>\n#include <algorithm>", "commentTag": "//", "source_code_shell": "# TOFILL\nif __name__ == \"__main__\":\n    print(topStudents([\"excellent\", \"good\"], [\"poor\", \"bad\"], [\"excellent work\", \"bad work\"], [1, 2], 1))\n    print(topStudents([\"amazing\"], [\"horrible\"], [\"amazing performance\", \"amazing but horrible\"], [3, 4], 2))\n    print(topStudents([\"great\"], [\"terrible\"], [\"no feedback here\"], [5], 1))\n    print(topStudents([\"brilliant\"], [], [\"brilliant achievement\", \"good job\"], [6, 7], 2))\n    print(topStudents([\"nice\"], [\"average\"], [\"nice presentation\", \"average work\", \"nice effort\"], [8, 9, 10], 2))", "all_input_output_value": "\ninput1: positive_feedback=[\"excellent\", \"good\"], negative_feedback=[\"poor\", \"bad\"], report=[\"excellent work\", \"bad work\"], student_id=[1, 2], k=1\noutput1: [1]\n--------\ninput2: positive_feedback=[\"amazing\"], negative_feedback=[\"horrible\"], report=[\"amazing performance\", \"amazing but horrible\"], student_id=[3, 4], k=2\noutput2: [3, 4]\n--------\ninput3: positive_feedback=[\"great\"], negative_feedback=[\"terrible\"], report=[\"no feedback here\"], student_id=[5], k=1\noutput3: [5]\n--------\ninput4: positive_feedback=[\"brilliant\"], negative_feedback=[], report=[\"brilliant achievement\", \"good job\"], student_id=[6, 7], k=2\noutput4: [6, 7]\n--------\ninput5: positive_feedback=[\"nice\"], negative_feedback=[\"average\"], report=[\"nice presentation\", \"average work\", \"nice effort\"], student_id=[8, 9, 10], k=2\noutput5: [8, 10]\n", "input_output_value": ["\ninput1: positive_feedback=[\"excellent\", \"good\"], negative_feedback=[\"poor\", \"bad\"], report=[\"excellent work\", \"bad work\"], student_id=[1, 2], k=1\noutput1: [1]\n", "\ninput2: positive_feedback=[\"amazing\"], negative_feedback=[\"horrible\"], report=[\"amazing performance\", \"amazing but horrible\"], student_id=[3, 4], k=2\noutput2: [3, 4]\n", "\ninput3: positive_feedback=[\"great\"], negative_feedback=[\"terrible\"], report=[\"no feedback here\"], student_id=[5], k=1\noutput3: [5]\n"], "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <unordered_map>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <sstream>\n#include <algorithm>\n// TOFILL\nint main() {\n    vector<string> positive_feedback1 = {\"excellent\", \"good\"};\n    vector<string> negative_feedback1 = {\"poor\", \"bad\"};\n    vector<string> report1 = {\"excellent work\", \"bad work\"};\n    vector<int> student_id1 = {1, 2};\n    int k1 = 1;\n\n    vector<string> positive_feedback2 = {\"amazing\"};\n    vector<string> negative_feedback2 = {\"horrible\"};\n    vector<string> report2 = {\"amazing performance\", \"amazing but horrible\"};\n    vector<int> student_id2 = {3, 4};\n    int k2 = 2;\n\n    vector<string> positive_feedback3 = {\"great\"};\n    vector<string> negative_feedback3 = {\"terrible\"};\n    vector<string> report3 = {\"no feedback here\"};\n    vector<int> student_id3 = {5};\n    int k3 = 1;\n\n    vector<string> positive_feedback4 = {\"brilliant\"};\n    vector<string> negative_feedback4 = {};\n    vector<string> report4 = {\"brilliant achievement\", \"good job\"};\n    vector<int> student_id4 = {6, 7};\n    int k4 = 2;\n\n    vector<string> positive_feedback5 = {\"nice\"};\n    vector<string> negative_feedback5 = {\"average\"};\n    vector<string> report5 = {\"nice presentation\", \"average work\", \"nice effort\"};\n    vector<int> student_id5 = {8, 9, 10};\n    int k5 = 2;\n\n    vector<int> result1 = topStudents(positive_feedback1, negative_feedback1, report1, student_id1, k1);\n    vector<int> result2 = topStudents(positive_feedback2, negative_feedback2, report2, student_id2, k2);\n    vector<int> result3 = topStudents(positive_feedback3, negative_feedback3, report3, student_id3, k3);\n    vector<int> result4 = topStudents(positive_feedback4, negative_feedback4, report4, student_id4, k4);\n    vector<int> result5 = topStudents(positive_feedback5, negative_feedback5, report5, student_id5, k5);\n\n    for(int id : result1) cout << id << \" \";\n    cout << endl;\n    for(int id : result2) cout << id << \" \";\n    cout << endl;\n    for(int id : result3) cout << id << \" \";\n    cout << endl;\n    for(int id : result4) cout << id << \" \";\n    cout << endl;\n    for(int id : result5) cout << id << \" \";\n    cout << endl;\n\n    return 0;\n}", "TAG": "Success"}
{"source_Lan": "python###captureForts.py", "source_code_str": "def captureForts( forts: List[int]) -> int:\n        ans, pre = 0, -1\n        for i, fort in enumerate(forts):\n            if fort == -1 or fort == 1:\n                if pre >= 0 and fort != forts[pre]:\n                    ans = max(ans, i - pre - 1)\n                pre = i\n        return ans", "source_code_block": "", "target_Lan": "cpp###captureForts.cpp", "reference_code": "int captureForts(vector<int>& forts) {\n        int ans = 0, pre = -1;\n        for (int i = 0; i < forts.size(); i++) {\n            if (forts[i] == 1 || forts[i] == -1) {\n                if (pre >= 0 && forts[i] != forts[pre]) {\n                    ans = max(ans, i - pre - 1);\n                }\n                pre = i;\n            }\n        }\n        return ans;\n    }", "target_method_signature": "captureForts", "source_method_signature": "captureForts", "target_allMS": "int captureForts(vector<int>& forts) {", "source_allMS": "def captureForts( forts: List[int]) -> int:", "source_import": "from typing import List", "target_import": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>", "commentTag": "//", "source_code_shell": "from typing import List\nfrom typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(captureForts([]))\n    print(captureForts([0, 0, 0, 0]))\n    print(captureForts([1, 1, 1, 1]))\n    print(captureForts([0, 1, 0, 0, -1, 0, 0, 1]))\n    print(captureForts([1, -1, 0, 1, -1, 0, 1]))", "all_input_output_value": "\ninput1: forts=[]\noutput1: 0\n--------\ninput2: forts=[0, 0, 0, 0]\noutput2: 0\n--------\ninput3: forts=[1, 1, 1, 1]\noutput3: 0\n--------\ninput4: forts=[0, 1, 0, 0, -1, 0, 0, 1]\noutput4: 2\n--------\ninput5: forts=[1, -1, 0, 1, -1, 0, 1]\noutput5: 1\n", "input_output_value": ["\ninput1: forts=[]\noutput1: 0\n", "\ninput2: forts=[0, 0, 0, 0]\noutput2: 0\n", "\ninput3: forts=[1, 1, 1, 1]\noutput3: 0\n"], "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    vector<int> input1 = {};\n    vector<int> input2 = {0, 0, 0, 0};\n    vector<int> input3 = {1, 1, 1, 1};\n    vector<int> input4 = {0, 1, 0, 0, -1, 0, 0, 1};\n    vector<int> input5 = {1, -1, 0, 1, -1, 0, 1};\n    \n    cout << captureForts(input1) << endl;\n    cout << captureForts(input2) << endl;\n    cout << captureForts(input3) << endl;\n    cout << captureForts(input4) << endl;\n    cout << captureForts(input5) << endl;\n}", "TAG": "Success"}
{"source_Lan": "python###leftmostBuildingQueries.py", "source_code_str": "def leftmostBuildingQueries(heights: List[int], queries: List[List[int]]) -> List[int]:\n    n = len(heights)\n    m = len(queries)\n    query = [[] for _ in range(n)]\n    ans = [-1] * m\n    st = []\n    for i in range(m):\n        a, b = queries[i]\n        if a > b:\n            a, b = b, a\n        if a == b or heights[a] < heights[b]:\n            ans[i] = b\n            continue\n        query[b].append((i, heights[a]))\n    top = -1\n    for i in range(n - 1, -1, -1):\n        for q, val in query[i]:\n            if top == -1 or heights[st[0]] <= val:\n                ans[q] = -1\n                continue\n            l, r = 0, top\n            while l <= r:\n                mid = (l + r) // 2\n                if heights[st[mid]] > val:\n                    l = mid + 1\n                else:\n                    r = mid - 1\n            ans[q] = st[r]\n        while top >= 0 and heights[st[top]] <= heights[i]:\n            st.pop()\n            top -= 1\n        st.append(i)\n        top += 1\n    return ans\n    ", "source_code_block": "", "target_Lan": "cpp###leftmostBuildingQueries.cpp", "reference_code": "vector<int> leftmostBuildingQueries(vector<int>& heights, vector<vector<int>>& queries) {\n        int n = heights.size();\n        int m = queries.size();\n        vector<vector<pair<int, int>>> query(n);\n        vector<int> ans(m);\n        vector<int> st;\n        for (int i = 0; i < m; i++) {\n            int a = queries[i][0];\n            int b = queries[i][1];\n            if (a > b) swap(a, b);\n            if (a == b || heights[a] < heights[b]) {\n                ans[i] = b;\n                continue;\n            }\n            query[b].push_back(make_pair(i, heights[a]));\n        }\n        int top = -1;\n        for (int i = n - 1; i >= 0; i--) {\n            for (int j = 0; j < query[i].size(); j++) {\n                int q = query[i][j].first;\n                int val = query[i][j].second;\n                if (top == -1 || heights[st[0]] <= val) {\n                    ans[q] = -1;\n                    continue;\n                }\n                int l = 0, r = top;\n                while (l <= r) {\n                    int mid = (l + r) >> 1;\n                    if (heights[st[mid]] > val) {\n                        l = mid + 1;\n                    } else {\n                        r = mid - 1;\n                    }\n                }\n                ans[q] = st[r];\n            }\n            while (top >= 0 && heights[st[top]] <= heights[i]) {\n                st.pop_back();\n                top--;\n            }\n            st.push_back(i);\n            top++;\n        }\n        return ans;\n    }", "target_method_signature": "leftmostBuildingQueries", "source_method_signature": "leftmostBuildingQueries", "target_allMS": "vector<int> leftmostBuildingQueries(vector<int>& heights, vector<vector<int>>& queries) {", "source_allMS": "def leftmostBuildingQueries( heights: List[int], queries: List[List[int]]) -> List[int]:", "source_import": "from typing import List", "target_import": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>", "commentTag": "//", "source_code_shell": "from typing import List\nfrom typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    # Test Inputs\n    print(leftmostBuildingQueries([3, 5, 2, 4], [[0, 3], [1, 2], [2, 3], [3, 0]]))\n    print(leftmostBuildingQueries([1, 1, 1, 1], [[0, 1], [1, 2], [2, 3], [0, 2]]))\n    print(leftmostBuildingQueries([10, 20, 15, 30], [[1, 3], [2, 0], [0, 1], [2, 2]]))\n    print(leftmostBuildingQueries([100, 50, 200, 150, 250], [[0, 1], [4, 3], [3, 2], [1, 4]]))\n    print(leftmostBuildingQueries([5], [[0, 0]]))", "all_input_output_value": "\ninput1: heights=[3, 5, 2, 4], queries=[[0, 3], [1, 2], [2, 3], [3, 0]]\noutput1: [3, -1, 3, 3]\n--------\ninput2: heights=[1, 1, 1, 1], queries=[[0, 1], [1, 2], [2, 3], [0, 2]]\noutput2: [-1, -1, -1, -1]\n--------\ninput3: heights=[10, 20, 15, 30], queries=[[1, 3], [2, 0], [0, 1], [2, 2]]\noutput3: [3, 2, 1, 2]\n--------\ninput4: heights=[100, 50, 200, 150, 250], queries=[[0, 1], [4, 3], [3, 2], [1, 4]]\noutput4: [2, 4, 4, 4]\n--------\ninput5: heights=[5], queries=[[0, 0]]\noutput5: [0]\n", "input_output_value": ["\ninput1: heights=[3, 5, 2, 4], queries=[[0, 3], [1, 2], [2, 3], [3, 0]]\noutput1: [3, -1, 3, 3]\n", "\ninput2: heights=[1, 1, 1, 1], queries=[[0, 1], [1, 2], [2, 3], [0, 2]]\noutput2: [-1, -1, -1, -1]\n", "\ninput3: heights=[10, 20, 15, 30], queries=[[1, 3], [2, 0], [0, 1], [2, 2]]\noutput3: [3, 2, 1, 2]\n"], "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <iostream>\n#include <vector>\n#include <utility>\n// TOFILL\nint main() {\n    vector<int> heights1 = {3, 5, 2, 4};\n    vector<vector<int>> queries1 = {{0, 3}, {1, 2}, {2, 3}, {3, 0}};\n    vector<int> result1 = leftmostBuildingQueries(heights1, queries1);\n    for(int res : result1) {\n        cout << res << \" \";\n    }\n    cout << endl;\n\n    vector<int> heights2 = {1, 1, 1, 1};\n    vector<vector<int>> queries2 = {{0, 1}, {1, 2}, {2, 3}, {0, 2}};\n    vector<int> result2 = leftmostBuildingQueries(heights2, queries2);\n    for(int res : result2) {\n        cout << res << \" \";\n    }\n    cout << endl;\n\n    vector<int> heights3 = {10, 20, 15, 30};\n    vector<vector<int>> queries3 = {{1, 3}, {2, 0}, {0, 1}, {2, 2}};\n    vector<int> result3 = leftmostBuildingQueries(heights3, queries3);\n    for(int res : result3) {\n        cout << res << \" \";\n    }\n    cout << endl;\n\n    vector<int> heights4 = {100, 50, 200, 150, 250};\n    vector<vector<int>> queries4 = {{0, 1}, {4, 3}, {3, 2}, {1, 4}};\n    vector<int> result4 = leftmostBuildingQueries(heights4, queries4);\n    for(int res : result4) {\n        cout << res << \" \";\n    }\n    cout << endl;\n\n    vector<int> heights5 = {5};\n    vector<vector<int>> queries5 = {{0, 0}};\n    vector<int> result5 = leftmostBuildingQueries(heights5, queries5);\n    for(int res : result5) {\n        cout << res << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}", "TAG": "Success"}
{"source_Lan": "python###getCount.py", "source_code_str": "def getCount( n : int, arr : List[int], a : int, b : int) -> int:\n        \n        ans = 0\n        for i in range(n):\n            for j in range(i, n):\n                flag = False\n                for k in range(i, j + 1):\n                    for l in range(k + 1, j + 1):\n                        if arr[k] + arr[l] < a or arr[k] + arr[l] > b:\n                            flag = True\n                if not flag:\n                    ans += 1\n        return ans", "source_code_block": "", "target_Lan": "cpp###getCount.cpp", "reference_code": "long long getCount(int n, vector<int> &arr, int a, int b) {\n        \n        int ans=0;\n        for(int i=0;i<n;i++){\n            for(int j=i;j<n;j++){\n                bool flag=false;\n                for(int k=i;k<=j;k++){\n                    for(int l=k+1;l<=j;l++){\n                        if(arr[k]+arr[l]<a || arr[k]+arr[l]>b)\n                        flag=true;\n                    }\n                }\n                if(flag==false)  ans++;\n            }\n        }\n        return ans;\n    }", "target_method_signature": "getCount", "source_method_signature": "getCount", "target_allMS": "long long getCount(int n, vector<int> &arr, int a, int b) {", "source_allMS": "def getCount( n : int, arr : List[int], a : int, b : int) -> int:", "source_import": "from typing import List", "target_import": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>", "commentTag": "//", "source_code_shell": "from typing import List\nfrom typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(getCount(5, [1, 3, 0, -1, 4], 3, 1))  # Corresponds to the first test input\n    print(getCount(3, [1, 5, 2], 2, 2))          # Corresponds to the second test input\n    print(getCount(4, [0, 10, 1, -1, 5, -3], 10, 4))  # Corresponds to the third test input\n    print(getCount(2, [5, 10, 7, 9], 9, 5))       # Corresponds to the fifth test input", "all_input_output_value": "\ninput1: n=5, arr=[1, 3, 0, -1, 4], a=3, b=1\noutput1: 5\n--------\ninput2: n=3, arr=[1, 5, 2], a=2, b=2\noutput2: 3\n--------\ninput3: n=4, arr=[0, 10, 1, -1, 5, -3], a=10, b=4\noutput3: 4\n--------\ninput4: n=2, arr=[5, 10, 7, 9], a=9, b=5\noutput4: 2\n", "input_output_value": ["\ninput1: n=5, arr=[1, 3, 0, -1, 4], a=3, b=1\noutput1: 5\n", "\ninput2: n=3, arr=[1, 5, 2], a=2, b=2\noutput2: 3\n", "\ninput3: n=4, arr=[0, 10, 1, -1, 5, -3], a=10, b=4\noutput3: 4\n"], "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    vector<int> arr1 = {1, 3, 0, -1, 4};\n    cout << getCount(5, arr1, 3, 1) << endl;\n\n    vector<int> arr2 = {1, 5, 2};\n    cout << getCount(3, arr2, 2, 2) << endl;\n\n    vector<int> arr3 = {0, 10, 1, -1, 5, -3};\n    cout << getCount(4, arr3, 10, 4) << endl;\n\n    vector<int> arr4 = {5, 10, 7, 9};\n    cout << getCount(2, arr4, 9, 5) << endl;\n\n    return 0;\n}", "TAG": "Success"}
{"source_Lan": "python###minDifference.py", "source_code_str": "def minDifference( n: int, arr: List[int], x: int) -> int:\n        ans = n + 1\n        for i in range(n - 1):\n            for j in range(i + 1, n):\n                if (arr[i] ^ arr[j]) <= x:\n                    ans = min(ans, j - i)\n        return -1 if ans == n + 1 else ans", "source_code_block": "", "target_Lan": "cpp###minDifference.cpp", "reference_code": "int minDifference(int n, vector<int> &arr, int x) {\n        \n        int ans=n+1;\n        for(int i=0;i<n-1;i++){\n            for(int j=i+1;j<n;j++){\n                if((arr[i]^arr[j]) <= x){\n                    ans = min(ans, j-i);\n                }\n            }\n        }\n        return (ans == n+1 ? -1 : ans);\n    }", "target_method_signature": "minDifference", "source_method_signature": "minDifference", "target_allMS": "int minDifference(int n, vector<int> &arr, int x) {", "source_allMS": "def minDifference( n: int, arr: List[int], x: int) -> int:", "source_import": "from typing import List", "target_import": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <algorithm>", "commentTag": "//", "source_code_shell": "from typing import List\nfrom typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(minDifference(2, [1, 2], 2))\n    print(minDifference(3, [3, 5, 7], 1))\n    print(minDifference(4, [0, 0, 0, 0], 0))\n    print(minDifference(5, [-1, -2, -3, -4, -5], 3))\n    print(minDifference(5, [10, 12, 15, 6, 8], 4))", "all_input_output_value": "\ninput1: n=2, arr=[1, 2], x=2\noutput1: -1\n--------\ninput2: n=3, arr=[3, 5, 7], x=1\noutput2: -1\n--------\ninput3: n=4, arr=[0, 0, 0, 0], x=0\noutput3: 1\n--------\ninput4: n=5, arr=[-1, -2, -3, -4, -5], x=3\noutput4: 1\n--------\ninput5: n=5, arr=[10, 12, 15, 6, 8], x=4\noutput5: 1\n", "input_output_value": ["\ninput1: n=2, arr=[1, 2], x=2\noutput1: -1\n", "\ninput2: n=3, arr=[3, 5, 7], x=1\noutput2: -1\n", "\ninput3: n=4, arr=[0, 0, 0, 0], x=0\noutput3: 1\n"], "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n// TOFILL\nint main() {\n    vector<int> arr1 = {1, 2};\n    cout << minDifference(2, arr1, 2) << endl;\n\n    vector<int> arr2 = {3, 5, 7};\n    cout << minDifference(3, arr2, 1) << endl;\n\n    vector<int> arr3 = {0, 0, 0, 0};\n    cout << minDifference(4, arr3, 0) << endl;\n\n    vector<int> arr4 = {-1, -2, -3, -4, -5};\n    cout << minDifference(5, arr4, 3) << endl;\n\n    vector<int> arr5 = {10, 12, 15, 6, 8};\n    cout << minDifference(5, arr5, 4) << endl;\n\n    return 0;\n}", "TAG": "Success"}
{"source_Lan": "python###pow_mod.py", "source_code_str": "def pow_mod(x, y, mod):\n    res = 1\n    while y:\n        if y & 1:\n            res = res * x % mod\n        x = x * x % mod\n        y >>= 1\n    return res\n\n", "source_code_block": "", "target_Lan": "cpp###pow_mod.cpp", "reference_code": "int pow_mod(long long x, long long y, int mod) {\n        int res = 1;\n        while (y) {\n            if (y & 1) {\n                res = res * x % mod;\n            }\n            x = x * x % mod;\n            y >>= 1;\n        }\n        return res;\n    }\n\n", "target_method_signature": "pow_mod", "source_method_signature": "pow_mod", "target_allMS": "", "source_allMS": "", "source_import": "\n", "target_import": "#include <iostream>\nusing namespace std;\n", "commentTag": "", "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n// TOFILL\nint main() {\n    cout << pow_mod(1, 0, 5) << endl;\n    cout << pow_mod(2, 1, 5) << endl;\n}", "all_input_output_value": "\ninput1: x=1, y=0, mod=5\noutput1: 1\n--------\ninput2: x=2, y=1, mod=5\noutput2: 2\n", "input_output_value": ["\ninput1: x=1, y=0, mod=5\noutput1: 1\n", "\ninput2: x=2, y=1, mod=5\noutput2: 2\n"], "TAG": "Success", "source_code_shell": "# TOFILL\nif __name__ == \"__main__\":\n    x = 1\n    y = 0\n    mod = 5\n    print(pow_mod(x, y, mod))\n    x = 2\n    y = 1\n    mod = 5\n    print(pow_mod(x, y, mod))"}
{"source_Lan": "python###countPow.py", "source_code_str": "def countPow(x):\n    res = 0\n    sum = 0\n\n    for i in range(60, -1, -1):\n        if (1 << i) & x:\n            res += sum * (1 << i)\n            sum += i\n\n            if i > 0:\n                res += i * (i - 1) // 2 * (1 << (i - 1))\n    \n    res += sum\n    return res\n\n", "source_code_block": "", "target_Lan": "cpp###countPow.cpp", "reference_code": "long long countPow(long long x) {\n        long long res = 0;\n        int sum = 0;\n\n        for (int i = 60; i >= 0; i--) {\n            if (1LL << i & x) {\n                res += 1LL * sum * (1LL << i);\n                sum += i;\n                \n                if (i > 0) {\n                    res += 1LL * i * (i - 1) / 2 * (1LL << (i - 1));\n                }\n            }\n        }\n        res += sum;\n        return res;\n    }\n\n", "target_method_signature": "countPow", "source_method_signature": "countPow", "target_allMS": "", "source_allMS": "", "source_import": "\n", "target_import": "#include <iostream>\nusing namespace std;\n", "commentTag": "", "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n// TOFILL\nint main() {\n    cout << countPow(0) << endl;\n    cout << countPow(1) << endl;\n    cout << countPow(2) << endl;\n    cout << countPow(7) << endl;\n    cout << countPow(1000000000000) << endl;\n}", "all_input_output_value": "\ninput1: x=0\noutput1: 0\n--------\ninput2: x=1\noutput2: 0\n--------\ninput3: x=2\noutput3: 1\n--------\ninput4: x=7\noutput4: 12\n--------\ninput5: x=1000000000000\noutput5: 382897640665442\n", "input_output_value": ["\ninput1: x=0\noutput1: 0\n", "\ninput2: x=1\noutput2: 0\n", "\ninput3: x=2\noutput3: 1\n"], "TAG": "Success", "source_code_shell": "# TOFILL\nif __name__ == \"__main__\":\n    test_inputs = [0, 1, 2, 7, 1000000000000]\n    for x in test_inputs:\n        print(countPow(x))"}
{"source_Lan": "python###sumOfEncryptedInt.py", "source_code_str": "def sumOfEncryptedInt( nums: List[int]) -> int:\n    ans = 0\n    for x in nums:\n        mx = base = 0\n        while x:\n            x, d = divmod(x, 10)\n            mx = max(mx, d)\n            base = base * 10 + 1\n        ans += mx * base\n    return ans", "source_code_block": "", "target_Lan": "cpp###sumOfEncryptedInt.cpp", "reference_code": "    int sumOfEncryptedInt(vector<int> &nums) {\n        int ans = 0;\n        for (int x: nums) {\n            int mx = 0, base = 0;\n            for (; x; x /= 10) {\n                mx = max(mx, x % 10);\n                base = base * 10 + 1;\n            }\n            ans += mx * base;\n        }\n        return ans;\n    }", "target_method_signature": "sumOfEncryptedInt", "source_method_signature": "sumOfEncryptedInt", "target_allMS": "    int sumOfEncryptedInt(vector<int> &nums) {", "source_allMS": "def sumOfEncryptedInt( nums: List[int]) -> int:", "source_import": "", "target_import": "#include <iostream>\n#include <vector>\nusing namespace std;", "commentTag": "//", "source_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(sumOfEncryptedInt([1, 2, 3, 4, 5]))\n    print(sumOfEncryptedInt([10, 20, 30, 40, 50]))\n    print(sumOfEncryptedInt([100, 200, 300, 400, 500]))\n    print(sumOfEncryptedInt([1000, 2000, 3000, 4000, 5000]))\n    print(sumOfEncryptedInt([10000, 20000, 30000, 40000, 50000]))", "all_input_output_value": "## Python_code\ndef sumOfEncryptedInt( nums: List[int]) -> int:\n...\nif __name__ == \"__main__\":\n    print(sumOfEncryptedInt([1, 2, 3, 4, 5]))\n    print(sumOfEncryptedInt([10, 20, 30, 40, 50]))\n    print(sumOfEncryptedInt([100, 200, 300, 400, 500]))\n    print(sumOfEncryptedInt([1000, 2000, 3000, 4000, 5000]))\n    print(sumOfEncryptedInt([10000, 20000, 30000, 40000, 50000]))\n    \n## After running the printed result is as follows\n15\n165\n1665\n16665\n166665\n\n## Please match the input in Python_code with the printed result. The match result should be wrapped within ``` ```.##\n## Output\n```\ninput1: nums=[1, 2, 3, 4, 5]\noutput1: 15\n--------\ninput2: nums=[10, 20, 30, 40, 50]\noutput2: 165\n--------\ninput3: nums=[100, 200, 300, 400, 500]\noutput3: 1665\n--------\ninput4: nums=[1000, 2000, 3000, 4000, 5000]\noutput4: 16665\n--------\ninput5: nums=[10000, 20000, 30000, 40000, 50000]\noutput5: 166665\n", "input_output_value": ["## Python_code\ndef sumOfEncryptedInt( nums: List[int]) -> int:\n...\nif __name__ == \"__main__\":\n    print(sumOfEncryptedInt([1, 2, 3, 4, 5]))\n    print(sumOfEncryptedInt([10, 20, 30, 40, 50]))\n    print(sumOfEncryptedInt([100, 200, 300, 400, 500]))\n    print(sumOfEncryptedInt([1000, 2000, 3000, 4000, 5000]))\n    print(sumOfEncryptedInt([10000, 20000, 30000, 40000, 50000]))\n    \n## After running the printed result is as follows\n15\n165\n1665\n16665\n166665\n\n## Please match the input in Python_code with the printed result. The match result should be wrapped within ``` ```.##\n## Output\n```\ninput1: nums=[1, 2, 3, 4, 5]\noutput1: 15\n", "\ninput2: nums=[10, 20, 30, 40, 50]\noutput2: 165\n", "\ninput3: nums=[100, 200, 300, 400, 500]\noutput3: 1665\n"], "target_code_shell": "#include <iostream>\n#include <vector>\nusing namespace std;\n#include <iostream>\n#include <vector>\n// TOFILL\nint main() {\n    vector<int> nums1 = {1, 2, 3, 4, 5};\n    vector<int> nums2 = {10, 20, 30, 40, 50};\n    vector<int> nums3 = {100, 200, 300, 400, 500};\n    vector<int> nums4 = {1000, 2000, 3000, 4000, 5000};\n    vector<int> nums5 = {10000, 20000, 30000, 40000, 50000};\n\n    cout << sumOfEncryptedInt(nums1) << endl;\n    cout << sumOfEncryptedInt(nums2) << endl;\n    cout << sumOfEncryptedInt(nums3) << endl;\n    cout << sumOfEncryptedInt(nums4) << endl;\n    cout << sumOfEncryptedInt(nums5) << endl;\n\n    return 0;\n}", "TAG": "Success"}
{"source_Lan": "python###maxScoreSubseq.py", "source_code_str": "def maxScoreSubseq( n : int, arr : List[int]) -> int:\n    d=defaultdict(int)\n    v=max(arr)\n    for i in range(n):\n        d[arr[i]-i]+=max(0,arr[i])\n    c=(1 if 0 in arr else 0)\n    for el in d:\n        if d[el]>0:\n            v=max(v,d[el])\n        elif d[el]==0 and c:\n            v=max(0,v)\n    return v", "source_code_block": "", "target_Lan": "cpp###maxScoreSubseq.cpp", "reference_code": "    int maxScoreSubseq(int n, vector<int> &arr) {\n        unordered_map<int,int>mp;\n        int ma=INT_MIN;\n        for (int i=0;i<n;i++){\n            if (arr[i]>=0)mp[arr[i]-i]+=arr[i];\n            ma=max(ma,arr[i]);\n        }\n        int ele=INT_MIN;\n        for (auto j:mp) ele=max(ele,j.second);\n        return max(ele,ma);\n    }", "target_method_signature": "maxScoreSubseq", "source_method_signature": "maxScoreSubseq", "target_allMS": "    int maxScoreSubseq(int n, vector<int> &arr) {", "source_allMS": "def maxScoreSubseq( n : int, arr : List[int]) -> int:", "source_import": "from typing import List\nfrom collections import defaultdict", "target_import": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;", "commentTag": "//", "source_code_shell": "from typing import List\nfrom collections import defaultdict\nfrom typing import List\nfrom collections import defaultdict\n# TOFILL\nif __name__ == \"__main__\":\n    print(maxScoreSubseq(1, [1]))\n    print(maxScoreSubseq(2, [-1, 2]))\n    print(maxScoreSubseq(3, [3, -2, 1]))\n    print(maxScoreSubseq(4, [-4, 3, -2, 1]))", "all_input_output_value": "## Python_code\ndef maxScoreSubseq( n : int, arr : List[int]) -> int:\n...\nif __name__ == \"__main__\":\n    print(maxScoreSubseq(1, [1]))\n    print(maxScoreSubseq(2, [-1, 2]))\n    print(maxScoreSubseq(3, [3, -2, 1]))\n    print(maxScoreSubseq(4, [-4, 3, -2, 1]))\n    \n## After running the printed result is as follows\n1\n2\n3\n3\n\n## Please match the input in Python_code with the printed result. The match result should be wrapped within ``` ```.##\n## Output\n```\ninput1: n=1, arr=[1]\noutput1: 1\n--------\ninput2: n=2, arr=[-1, 2]\noutput2: 2\n--------\ninput3: n=3, arr=[3, -2, 1]\noutput3: 3\n--------\ninput4: n=4, arr=[-4, 3, -2, 1]\noutput4: 3\n", "input_output_value": ["## Python_code\ndef maxScoreSubseq( n : int, arr : List[int]) -> int:\n...\nif __name__ == \"__main__\":\n    print(maxScoreSubseq(1, [1]))\n    print(maxScoreSubseq(2, [-1, 2]))\n    print(maxScoreSubseq(3, [3, -2, 1]))\n    print(maxScoreSubseq(4, [-4, 3, -2, 1]))\n    \n## After running the printed result is as follows\n1\n2\n3\n3\n\n## Please match the input in Python_code with the printed result. The match result should be wrapped within ``` ```.##\n## Output\n```\ninput1: n=1, arr=[1]\noutput1: 1\n", "\ninput2: n=2, arr=[-1, 2]\noutput2: 2\n", "\ninput3: n=3, arr=[3, -2, 1]\noutput3: 3\n"], "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <climits>\n// TOFILL\nint main() {\n    vector<int> arr1 = {1};\n    cout << maxScoreSubseq(1, arr1) << endl;\n\n    vector<int> arr2 = {-1, 2};\n    cout << maxScoreSubseq(2, arr2) << endl;\n\n    vector<int> arr3 = {3, -2, 1};\n    cout << maxScoreSubseq(3, arr3) << endl;\n\n    vector<int> arr4 = {-4, 3, -2, 1};\n    cout << maxScoreSubseq(4, arr4) << endl;\n\n    return 0;\n}", "TAG": "Success"}
{"source_Lan": "python###minimumDistance.py", "source_code_str": "def minimumDistance( points: List[List[int]]) -> int:\n    sx = SortedList(p[0] - p[1] for p in points)\n    sy = SortedList(p[0] + p[1] for p in points)\n    res = float('inf')\n    for p in points:\n        sx.remove(p[0] - p[1])\n        sy.remove(p[0] + p[1])\n        res = min(res, max(sx[-1] - sx[0], sy[-1] - sy[0]))\n        sx.add(p[0] - p[1])\n        sy.add(p[0] + p[1])\n    return res", "source_code_block": "", "target_Lan": "cpp###minimumDistance.cpp", "reference_code": "    int minimumDistance(vector<vector<int>>& points) {\n        multiset<int> sx, sy;\n        for (auto & p : points) {\n            sx.emplace(p[0] - p[1]);\n            sy.emplace(p[0] + p[1]);\n        }\n        int res = INT_MAX;\n        for (auto &p : points) {\n            sx.erase(sx.find(p[0] - p[1]));\n            sy.erase(sy.find(p[0] + p[1]));\n            res = min(res, max(*sx.rbegin() - *sx.begin(), *sy.rbegin() - *sy.begin()));\n            sx.emplace(p[0] - p[1]);\n            sy.emplace(p[0] + p[1]);\n        }\n        return res;\n    }", "target_method_signature": "minimumDistance", "source_method_signature": "minimumDistance", "target_allMS": "    int minimumDistance(vector<vector<int>>& points) {", "source_allMS": "def minimumDistance( points: List[List[int]]) -> int:", "source_import": "from sortedcontainers import SortedList", "target_import": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;", "commentTag": "//", "source_code_shell": "from sortedcontainers import SortedList\nfrom typing import List\nfrom sortedcontainers import SortedList\n# TOFILL\nif __name__ == \"__main__\":\n    print(minimumDistance([[1,2],[3,4],[5,6],[7,8]]))\n    print(minimumDistance([[1,1],[2,2],[3,3],[4,4]]))\n    print(minimumDistance([[0,0],[1,1],[2,2],[3,3]]))\n    print(minimumDistance([[1,2],[3,4],[5,6],[7,8],[9,10]]))\n    print(minimumDistance([[0,0],[1,0],[2,0],[3,0]]))", "all_input_output_value": "## Python_code\ndef minimumDistance( points: List[List[int]]) -> int:\n...\nif __name__ == \"__main__\":\n    print(minimumDistance([[1,2],[3,4],[5,6],[7,8]]))\n    print(minimumDistance([[1,1],[2,2],[3,3],[4,4]]))\n    print(minimumDistance([[0,0],[1,1],[2,2],[3,3]]))\n    print(minimumDistance([[1,2],[3,4],[5,6],[7,8],[9,10]]))\n    print(minimumDistance([[0,0],[1,0],[2,0],[3,0]]))\n    \n## After running the printed result is as follows\n8\n4\n4\n12\n2\n\n## Please match the input in Python_code with the printed result. The match result should be wrapped within ``` ```.##\n## Output\n```\ninput1: points=[[1,2],[3,4],[5,6],[7,8]]\noutput1: 8\n--------\ninput2: points=[[1,1],[2,2],[3,3],[4,4]]\noutput2: 4\n--------\ninput3: points=[[0,0],[1,1],[2,2],[3,3]]\noutput3: 4\n--------\ninput4: points=[[1,2],[3,4],[5,6],[7,8],[9,10]]\noutput4: 12\n--------\ninput5: points=[[0,0],[1,0],[2,0],[3,0]]\noutput5: 2\n", "input_output_value": ["## Python_code\ndef minimumDistance( points: List[List[int]]) -> int:\n...\nif __name__ == \"__main__\":\n    print(minimumDistance([[1,2],[3,4],[5,6],[7,8]]))\n    print(minimumDistance([[1,1],[2,2],[3,3],[4,4]]))\n    print(minimumDistance([[0,0],[1,1],[2,2],[3,3]]))\n    print(minimumDistance([[1,2],[3,4],[5,6],[7,8],[9,10]]))\n    print(minimumDistance([[0,0],[1,0],[2,0],[3,0]]))\n    \n## After running the printed result is as follows\n8\n4\n4\n12\n2\n\n## Please match the input in Python_code with the printed result. The match result should be wrapped within ``` ```.##\n## Output\n```\ninput1: points=[[1,2],[3,4],[5,6],[7,8]]\noutput1: 8\n", "\ninput2: points=[[1,1],[2,2],[3,3],[4,4]]\noutput2: 4\n", "\ninput3: points=[[0,0],[1,1],[2,2],[3,3]]\noutput3: 4\n"], "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\n#include <climits>\n// TOFILL\nint main() {\n    vector<vector<int>> points1 = {{1,2},{3,4},{5,6},{7,8}};\n    vector<vector<int>> points2 = {{1,1},{2,2},{3,3},{4,4}};\n    vector<vector<int>> points3 = {{0,0},{1,1},{2,2},{3,3}};\n    vector<vector<int>> points4 = {{1,2},{3,4},{5,6},{7,8},{9,10}};\n    vector<vector<int>> points5 = {{0,0},{1,0},{2,0},{3,0}};\n\n    cout << minimumDistance(points1) << endl;\n    cout << minimumDistance(points2) << endl;\n    cout << minimumDistance(points3) << endl;\n    cout << minimumDistance(points4) << endl;\n    cout << minimumDistance(points5) << endl;\n\n    return 0;\n}", "TAG": "Success"}
{"source_Lan": "python###countSeniors.py", "source_code_str": "def countSeniors( details: List[str]) -> int:\n        return sum(1 for info in details if int(info[11:13]) > 60)", "source_code_block": "", "target_Lan": "cpp###countSeniors.cpp", "reference_code": "int countSeniors(vector<string>& details) {\n        int count = 0;\n        for (string & info : details) {\n            if (stoi(info.substr(11, 2)) > 60) {\n                count++;\n            }\n        }\n        return count;\n    }", "target_method_signature": "countSeniors", "source_method_signature": "countSeniors", "target_allMS": "int countSeniors(vector<string>& details) {", "source_allMS": "def countSeniors( details: List[str]) -> int:", "source_import": "from typing import List", "target_import": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <string>", "commentTag": "//", "source_code_shell": "from typing import List\nfrom typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(countSeniors([\"7868190130M752\",\"7868190131F753\",\"7868190132M754\",\"7868190133F755\",\"7868190134M756\"]))\n    print(countSeniors([\"7868190130M752\",\"7868190131F753\",\"7868190132M754\",\"7868190133F755\",\"7868190134M756\",\"7868190135F757\",\"7868190136M758\",\"7868190137F759\",\"7868190138M760\"]))\n    print(countSeniors([\"7868190130M752\",\"7868190131F753\",\"7868190132M754\",\"7868190133F755\",\"7868190134M756\",\"7868190135F757\",\"7868190136M758\",\"7868190137F759\",\"7868190138M760\",\"7868190139F761\",\"7868190140M762\"]))\n    print(countSeniors([\"7868190130M752\",\"7868190131F753\",\"7868190132M754\",\"7868190133F755\",\"7868190134M756\",\"7868190135F757\",\"7868190136M758\",\"7868190137F759\",\"7868190138M760\",\"7868190139F761\",\"7868190140M762\",\"7868190141F763\",\"7868190142M764\"]))\n    print(countSeniors([\"7868190130M752\",\"7868190131F753\",\"7868190132M754\",\"7868190133F755\",\"7868190134M756\",\"7868190135F757\",\"7868190136M758\",\"7868190137F759\",\"7868190138M760\",\"7868190139F761\",\"7868190140M762\",\"7868190141F763\",\"7868190142M764\",\"7868190143F765\",\"7868190144M766\"]))", "all_input_output_value": "\ninput1: details=[\"7868190130M752\",\"7868190131F753\",\"7868190132M754\",\"7868190133F755\",\"7868190134M756\"]\noutput1: 5\n--------\ninput2: details=[\"7868190130M752\",\"7868190131F753\",\"7868190132M754\",\"7868190133F755\",\"7868190134M756\",\"7868190135F757\",\"7868190136M758\",\"7868190137F759\",\"7868190138M760\"]\noutput2: 9\n--------\ninput3: details=[\"7868190130M752\",\"7868190131F753\",\"7868190132M754\",\"7868190133F755\",\"7868190134M756\",\"7868190135F757\",\"7868190136M758\",\"7868190137F759\",\"7868190138M760\",\"7868190139F761\",\"7868190140M762\"]\noutput3: 11\n--------\ninput4: details=[\"7868190130M752\",\"7868190131F753\",\"7868190132M754\",\"7868190133F755\",\"7868190134M756\",\"7868190135F757\",\"7868190136M758\",\"7868190137F759\",\"7868190138M760\",\"7868190139F761\",\"7868190140M762\",\"7868190141F763\",\"7868190142M764\"]\noutput4: 13\n--------\ninput5: details=[\"7868190130M752\",\"7868190131F753\",\"7868190132M754\",\"7868190133F755\",\"7868190134M756\",\"7868190135F757\",\"7868190136M758\",\"7868190137F759\",\"7868190138M760\",\"7868190139F761\",\"7868190140M762\",\"7868190141F763\",\"7868190142M764\",\"7868190143F765\",\"7868190144M766\"]\noutput5: 15\n", "input_output_value": ["\ninput1: details=[\"7868190130M752\",\"7868190131F753\",\"7868190132M754\",\"7868190133F755\",\"7868190134M756\"]\noutput1: 5\n", "\ninput2: details=[\"7868190130M752\",\"7868190131F753\",\"7868190132M754\",\"7868190133F755\",\"7868190134M756\",\"7868190135F757\",\"7868190136M758\",\"7868190137F759\",\"7868190138M760\"]\noutput2: 9\n", "\ninput3: details=[\"7868190130M752\",\"7868190131F753\",\"7868190132M754\",\"7868190133F755\",\"7868190134M756\",\"7868190135F757\",\"7868190136M758\",\"7868190137F759\",\"7868190138M760\",\"7868190139F761\",\"7868190140M762\"]\noutput3: 11\n"], "TAG": "Success", "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <vector>\n#include <string>\n// TOFILL\nint main() {\n    vector<string> details1 = {\"7868190130M752\",\"7868190131F753\",\"7868190132M754\",\"7868190133F755\",\"7868190134M756\"};\n    vector<string> details2 = {\"7868190130M752\",\"7868190131F753\",\"7868190132M754\",\"7868190133F755\",\"7868190134M756\",\"7868190135F757\",\"7868190136M758\",\"7868190137F759\",\"7868190138M760\"};\n    vector<string> details3 = {\"7868190130M752\",\"7868190131F753\",\"7868190132M754\",\"7868190133F755\",\"7868190134M756\",\"7868190135F757\",\"7868190136M758\",\"7868190137F759\",\"7868190138M760\",\"7868190139F761\",\"7868190140M762\"};\n    vector<string> details4 = {\"7868190130M752\",\"7868190131F753\",\"7868190132M754\",\"7868190133F755\",\"7868190134M756\",\"7868190135F757\",\"7868190136M758\",\"7868190137F759\",\"7868190138M760\",\"7868190139F761\",\"7868190140M762\",\"7868190141F763\",\"7868190142M764\"};\n    vector<string> details5 = {\"7868190130M752\",\"7868190131F753\",\"7868190132M754\",\"7868190133F755\",\"7868190134M756\",\"7868190135F757\",\"7868190136M758\",\"7868190137F759\",\"7868190138M760\",\"7868190139F761\",\"7868190140M762\",\"7868190141F763\",\"7868190142M764\",\"7868190143F765\",\"7868190144M766\"};\n\n    cout << countSeniors(details1) << endl;\n    cout << countSeniors(details2) << endl;\n    cout << countSeniors(details3) << endl;\n    cout << countSeniors(details4) << endl;\n    cout << countSeniors(details5) << endl;\n\n    return 0;\n}"}
{"source_Lan": "python###geeklandElections.py", "source_code_str": "def geeklandElections( n: int, k: int, s: str) -> bool:\n    ans = s.count(\"1\") + min(k, s.count(\"0\"))\n    return ans > n - ans", "source_code_block": "", "target_Lan": "cpp###geeklandElections.cpp", "reference_code": "    bool geeklandElections(int n, int k, string &s) {\n        int votes = 0;\n        for (int i = 0; i < n; i++)\n            votes += (s[i] == '1');\n        return (votes + k) > (n - (votes + k));\n    }", "target_method_signature": "geeklandElections", "source_method_signature": "geeklandElections", "target_allMS": "    bool geeklandElections(int n, int k, string &s) {", "source_allMS": "def geeklandElections( n: int, k: int, s: str) -> bool:", "source_import": "", "target_import": "#include <iostream>\nusing namespace std;", "commentTag": "//", "source_code_shell": "# TOFILL\nif __name__ == \"__main__\":\n    print(geeklandElections(5, 2, \"00000\"))\n    print(geeklandElections(5, 2, \"11111\"))\n    print(geeklandElections(5, 3, \"10101\"))\n    print(geeklandElections(5, 0, \"11011\"))\n    print(geeklandElections(1, 1, \"0\"))", "all_input_output_value": "\ninput1: n=5, k=2, s=\"00000\"\noutput1: False\n--------\ninput2: n=5, k=2, s=\"11111\"\noutput2: True\n--------\ninput3: n=5, k=3, s=\"10101\"\noutput3: True\n--------\ninput4: n=5, k=0, s=\"11011\"\noutput4: True\n--------\ninput5: n=1, k=1, s=\"0\"\noutput5: True\n", "input_output_value": ["\ninput1: n=5, k=2, s=\"00000\"\noutput1: False\n", "\ninput2: n=5, k=2, s=\"11111\"\noutput2: True\n", "\ninput3: n=5, k=3, s=\"10101\"\noutput3: True\n"], "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <string>\n// TOFILL\nint main() {\n    // Test input 1\n    {\n        int n = 5;\n        int k = 2;\n        string s = \"00000\";\n        cout << geeklandElections(n, k, s) << endl;\n    }\n\n    // Test input 2\n    {\n        int n = 5;\n        int k = 2;\n        string s = \"11111\";\n        cout << geeklandElections(n, k, s) << endl;\n    }\n\n    // Test input 3\n    {\n        int n = 5;\n        int k = 3;\n        string s = \"10101\";\n        cout << geeklandElections(n, k, s) << endl;\n    }\n\n    // Test input 4\n    {\n        int n = 5;\n        int k = 0;\n        string s = \"11011\";\n        cout << geeklandElections(n, k, s) << endl;\n    }\n\n    // Test input 5\n    {\n        int n = 1;\n        int k = 1;\n        string s = \"0\";\n        cout << geeklandElections(n, k, s) << endl;\n    }\n\n    return 0;\n}", "TAG": "Success"}
{"source_Lan": "python###validPairs.py", "source_code_str": "def validPairs( n: int, val: List[int], edges: List[List[int]]) -> int:\n    lift=[[0]*(32) for _ in range(n+1)]\n    dis=[0]*(n+1)\n    dis2=[0]*(n+1)\n    adj=[[] for _ in range(n+1)]\n    for i in edges:\n        adj[i[0]].append((i[1],i[2]))\n        adj[i[1]].append((i[0],i[2]))\n    dis[0]=-(10**15)\n    st=[[1,0,0,0]]\n    while st:\n        top=st.pop()\n        i,par,d,d2=top[0],top[1],top[2],top[3]\n        lift[i][0]=par\n        dis[i]=d\n        dis2[i]=d2\n        for j in range(1,32):\n            lift[i][j]=lift[lift[i][j-1]][j-1]\n        for j in adj[i]:\n            if j[0]==par:\n                continue\n            st.append([j[0],i,d+j[1],d2+1])\n    ans=0\n    for i in range(1,n+1):\n        v=val[i-1]\n        p=i\n        for j in range(31,-1,-1):\n            if v>=dis[p]-dis[lift[p][j]]:\n                v-=dis[p]-dis[lift[p][j]]\n                p=lift[p][j]\n        ans+=dis2[i]-dis2[p]\n    return ans", "source_code_block": "", "target_Lan": "cpp###validPairs.cpp", "reference_code": "    long long validPairs(int n, vector<int>& val, vector<vector<int>>& edges) {\n        vector<vector<long long>> lift(n + 1, vector<long long>(32, 0));\n        vector<long long> dis(n + 1, 0);\n        vector<long long> dis2(n + 1, 0);\n        vector<vector<vector<long long>>> adj(n + 1);\n        for (auto i : edges) {\n            adj[i[0]].push_back({ i[1], i[2] });\n            adj[i[1]].push_back({ i[0], i[2] });\n        }\n        dis[0] = -1e15;\n        \n        stack<vector<long long>> st;\n        st.push({ 1, 0, 0, 0 }); \n        while (!st.empty()) {\n            auto top = st.top();\n            st.pop();\n            long long i = top[0], par = top[1], d = top[2], d2 = top[3];\n            lift[i][0] = par;\n            dis[i] = d;\n            dis2[i] = d2;\n            for (long long j = 1; j < 32; j++) {\n                lift[i][j] = lift[lift[i][j - 1]][j - 1];\n            }\n            for (auto j : adj[i]) {\n                if (j[0] == par) continue;\n                st.push({ j[0], i, d + j[1], d2 + 1 });\n            }\n        }\n        long long ans = 0;\n        for (long long i = 1; i <= n; i++) {\n            long long v = val[i-1];\n            long long p = i;\n            for (long long j = 31; j >= 0; j--) {\n                if (v >= dis[p] - dis[lift[p][j]]) {\n                    v -= (dis[p] - dis[lift[p][j]]);\n                    p = lift[p][j];\n                }\n            }\n            ans += dis2[i] - dis2[p];\n        }\n        return ans;\n    }", "target_method_signature": "validPairs", "source_method_signature": "validPairs", "target_allMS": "    long long validPairs(int n, vector<int>& val, vector<vector<int>>& edges) {", "source_allMS": "def validPairs( n: int, val: List[int], edges: List[List[int]]) -> int:", "source_import": "from typing import List\nfrom math import log", "target_import": "#include <iostream>\nusing namespace std;", "commentTag": "//", "source_code_shell": "from typing import List\nfrom math import log\nfrom typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(validPairs(1, [1], []))\n    print(validPairs(2, [5, 10], [[1, 2, 3]]))\n    print(validPairs(3, [8, 12, 14], [[1, 2, 5], [1, 3, 7]]))\n    print(validPairs(4, [100, 200, 50, 25], [[1, 2, 10], [2, 3, 20], [3, 4, 5]]))\n    print(validPairs(5, [15, 25, 35, 45, 55], [[1, 2, 1], [1, 3, 2], [2, 4, 3], [2, 5, 4]]))", "all_input_output_value": "\ninput1: n=1, val=[1], edges=[]\noutput1: 0\n--------\ninput2: n=2, val=[5, 10], edges=[[1, 2, 3]]\noutput2: 1\n--------\ninput3: n=3, val=[8, 12, 14], edges=[[1, 2, 5], [1, 3, 7]]\noutput3: 2\n--------\ninput4: n=4, val=[100, 200, 50, 25], edges=[[1, 2, 10], [2, 3, 20], [3, 4, 5]]\noutput4: 5\n--------\ninput5: n=5, val=[15, 25, 35, 45, 55], edges=[[1, 2, 1], [1, 3, 2], [2, 4, 3], [2, 5, 4]]\noutput5: 6\n", "input_output_value": ["\ninput1: n=1, val=[1], edges=[]\noutput1: 0\n", "\ninput2: n=2, val=[5, 10], edges=[[1, 2, 3]]\noutput2: 1\n", "\ninput3: n=3, val=[8, 12, 14], edges=[[1, 2, 5], [1, 3, 7]]\noutput3: 2\n"], "target_code_shell": "#include <iostream>\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <stack>\n// TOFILL\nint main() {\n    vector<int> val1 = {1};\n    vector<vector<int>> edges1 = {};\n    cout << validPairs(1, val1, edges1) << endl;\n\n    vector<int> val2 = {5, 10};\n    vector<vector<int>> edges2 = {{1, 2, 3}};\n    cout << validPairs(2, val2, edges2) << endl;\n\n    vector<int> val3 = {8, 12, 14};\n    vector<vector<int>> edges3 = {{1, 2, 5}, {1, 3, 7}};\n    cout << validPairs(3, val3, edges3) << endl;\n\n    vector<int> val4 = {100, 200, 50, 25};\n    vector<vector<int>> edges4 = {{1, 2, 10}, {2, 3, 20}, {3, 4, 5}};\n    cout << validPairs(4, val4, edges4) << endl;\n\n    vector<int> val5 = {15, 25, 35, 45, 55};\n    vector<vector<int>> edges5 = {{1, 2, 1}, {1, 3, 2}, {2, 4, 3}, {2, 5, 4}};\n    cout << validPairs(5, val5, edges5) << endl;\n\n    return 0;\n}", "TAG": "Success"}
{"source_Lan": "python###findReplaceString.py", "source_code_str": "def findReplaceString( s: str, indices: List[int], sources: List[str], targets: List[str]) -> str:\n        n, m = len(s), len(indices)\n        ops = list(range(m))\n        ops.sort(key=lambda x: indices[x])\n        ans = list()\n        i = pt = 0\n        while i < n:\n            while pt < m and indices[ops[pt]] < i:\n                pt += 1\n            succeed = False\n            while pt < m and indices[ops[pt]] == i:\n                if s[i:i + len(sources[ops[pt]])] == sources[ops[pt]]:\n                    succeed = True\n                    break\n                pt += 1\n            if succeed:\n                ans.append(targets[ops[pt]])\n                i += len(sources[ops[pt]])\n            else:\n                ans.append(s[i])\n                i += 1\n        return \"\".join(ans)", "source_code_block": "", "target_Lan": "cpp###findReplaceString.cpp", "reference_code": "string findReplaceString(string s, vector<int>& indices, vector<string>& sources, vector<string>& targets) {\n        int n = s.size(), m = indices.size();\n        vector<int> ops(m);\n        iota(ops.begin(), ops.end(), 0);\n        sort(ops.begin(), ops.end(), [&](int i, int j) { return indices[i] < indices[j]; });\n        string ans;\n        int pt = 0;\n        for (int i = 0; i < n;) {\n            while (pt < m && indices[ops[pt]] < i) {\n                ++pt;\n            }\n            bool succeed = false;\n            while (pt < m && indices[ops[pt]] == i) {\n                if (s.substr(i, sources[ops[pt]].size()) == sources[ops[pt]]) {\n                    succeed = true;\n                    break;\n                }\n                ++pt;\n            }\n            if (succeed) {\n                ans += targets[ops[pt]];\n                i += sources[ops[pt]].size();\n            }\n            else {\n                ans += s[i];\n                ++i;\n            }\n        }\n        return ans;\n    }", "target_method_signature": "findReplaceString", "source_method_signature": "findReplaceString", "target_allMS": "string findReplaceString(string s, vector<int>& indices, vector<string>& sources, vector<string>& targets) {", "source_allMS": "def findReplaceString( s: str, indices: List[int], sources: List[str], targets: List[str]) -> str:", "source_import": "from typing import List", "target_import": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <numeric>", "commentTag": "//", "source_code_shell": "from typing import List\nfrom typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(findReplaceString(s=\"hello world\", indices=[0], sources=[\"world\"], targets=[\"planet\"]))\n    print(findReplaceString(s=\"abcde\", indices=[0], sources=[\"abc\"], targets=[\"xyz\"]))\n    print(findReplaceString(s=\"the cat in the hat\", indices=[4, 4], sources=[\"cat\", \"hat\"], targets=[\"dog\", \"cap\"]))\n    print(findReplaceString(s=\"repeat repeat repeat\", indices=[7, 0, 14], sources=[\"repeat\", \"repeat\", \"repeat\"], targets=[\"done\", \"done\", \"done\"]))\n    print(findReplaceString(s=\"goodbye\", indices=[0, 4], sources=[\"good\", \"bye\"], targets=[\"hello\", \"world\"]))", "all_input_output_value": "\ninput1: s=\"hello world\", indices=[0], sources=[\"world\"], targets=[\"planet\"]\noutput1: hello world\n--------\ninput2: s=\"abcde\", indices=[0], sources=[\"abc\"], targets=[\"xyz\"]\noutput2: xyzde\n--------\ninput3: s=\"the cat in the hat\", indices=[4, 4], sources=[\"cat\", \"hat\"], targets=[\"dog\", \"cap\"]\noutput3: the dog in the hat\n--------\ninput4: s=\"repeat repeat repeat\", indices=[7, 0, 14], sources=[\"repeat\", \"repeat\", \"repeat\"], targets=[\"done\", \"done\", \"done\"]\noutput4: done done done\n--------\ninput5: s=\"goodbye\", indices=[0, 4], sources=[\"good\", \"bye\"], targets=[\"hello\", \"world\"]\noutput5: helloworld\n", "input_output_value": ["\ninput1: s=\"hello world\", indices=[0], sources=[\"world\"], targets=[\"planet\"]\noutput1: hello world\n", "\ninput2: s=\"abcde\", indices=[0], sources=[\"abc\"], targets=[\"xyz\"]\noutput2: xyzde\n", "\ninput3: s=\"the cat in the hat\", indices=[4, 4], sources=[\"cat\", \"hat\"], targets=[\"dog\", \"cap\"]\noutput3: the dog in the hat\n"], "target_code_shell": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <numeric> // for iota\n#include <algorithm> // for sort\n// TOFILL\nint main() {\n    vector<int> indices1 = {0};\n    vector<string> sources1 = {\"world\"};\n    vector<string> targets1 = {\"planet\"};\n    cout << findReplaceString(\"hello world\", indices1, sources1, targets1) << endl;\n\n    vector<int> indices2 = {0};\n    vector<string> sources2 = {\"abc\"};\n    vector<string> targets2 = {\"xyz\"};\n    cout << findReplaceString(\"abcde\", indices2, sources2, targets2) << endl;\n\n    vector<int> indices3 = {4, 4};\n    vector<string> sources3 = {\"cat\", \"hat\"};\n    vector<string> targets3 = {\"dog\", \"cap\"};\n    cout << findReplaceString(\"the cat in the hat\", indices3, sources3, targets3) << endl;\n\n    vector<int> indices4 = {7, 0, 14};\n    vector<string> sources4 = {\"repeat\", \"repeat\", \"repeat\"};\n    vector<string> targets4 = {\"done\", \"done\", \"done\"};\n    cout << findReplaceString(\"repeat repeat repeat\", indices4, sources4, targets4) << endl;\n\n    vector<int> indices5 = {0, 4};\n    vector<string> sources5 = {\"good\", \"bye\"};\n    vector<string> targets5 = {\"hello\", \"world\"};\n    cout << findReplaceString(\"goodbye\", indices5, sources5, targets5) << endl;\n\n    return 0;\n}", "TAG": "Success"}
{"source_Lan": "python###doesExists.py", "source_code_str": "def doesExists( S: str) -> str:\n    hsh = [0] * 26\n    for c in S:\n        hsh[ord(c) - ord('a')] += 1\n    curr = [i for i in hsh if i != 0]\n    if len(curr) == 1:\n        return \"NO\"\n    return \"YES\"", "source_code_block": "", "target_Lan": "java###doesExists_Test.java", "reference_code": "    public static String doesExists(String s) {\n        int n = s.length();\n        ArrayList<Integer> hsh = new ArrayList<>(26);\n        for (int i = 0; i < 26; i++) hsh.add(0);\n        for (Character c : s.toCharArray()) hsh.set(c - 'a', hsh.get(c - 'a') + 1);\n        int curr = 0;\n        for (int i = 0; i < 26; i++)\n            if (hsh.get(i) > 0) curr++;\n        if (curr == 1) return \"NO\";\n        return \"YES\";\n    }", "target_method_signature": "doesExists", "source_method_signature": "doesExists", "target_allMS": "    public static String doesExists(String s) {", "source_allMS": "def doesExists( S: str) -> str:", "source_import": "", "target_import": "import java.util.*;\nimport java.lang.*;", "commentTag": "//", "source_code_shell": "# TOFILL\nif __name__ == \"__main__\":\n    test_inputs = [\"\", \"a\", \"aaaa\", \"ab\", \"abc\", \"abcde\", \"x\", \"zzzz\", \"yzy\", \"aabbcc\"]\n    for input_str in test_inputs:\n        print(f\"Input: '{input_str}' Output: {doesExists(input_str)}\")", "all_input_output_value": "\ninput1: S=\"\"\noutput1: YES\n--------\ninput2: S=\"a\"\noutput2: NO\n--------\ninput3: S=\"aaaa\"\noutput3: NO\n--------\ninput4: S=\"ab\"\noutput4: YES\n--------\ninput5: S=\"abc\"\noutput5: YES\n--------\ninput6: S=\"abcde\"\noutput6: YES\n--------\ninput7: S=\"x\"\noutput7: NO\n--------\ninput8: S=\"zzzz\"\noutput8: NO\n--------\ninput9: S=\"yzy\"\noutput9: YES\n--------\ninput10: S=\"aabbcc\"\noutput10: YES\n", "input_output_value": ["\ninput1: S=\"\"\noutput1: YES\n", "\ninput2: S=\"a\"\noutput2: NO\n", "\ninput3: S=\"aaaa\"\noutput3: NO\n"], "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.ArrayList;\npublic class doesExists_Test {\n// TOFILL\npublic static void main(String[] args) {\n        System.out.println(doesExists(\"\"));        // Test input 1\n        System.out.println(doesExists(\"a\"));       // Test input 2\n        System.out.println(doesExists(\"aaaa\"));    // Test input 3\n        System.out.println(doesExists(\"ab\"));      // Test input 4\n        System.out.println(doesExists(\"abc\"));     // Test input 5\n        System.out.println(doesExists(\"abcde\"));   // Test input 6\n        System.out.println(doesExists(\"x\"));       // Test input 7\n        System.out.println(doesExists(\"zzzz\"));    // Test input 8\n        System.out.println(doesExists(\"yzy\"));     // Test input 9\n        System.out.println(doesExists(\"aabbcc\"));  // Test input 10\n    }\n}", "TAG": "Success"}
{"source_Lan": "python###minimumDifference.py", "source_code_str": "def minimumDifference( N : int, M : int, toys : List[List[int]]) -> int:\n    ans=float(\"inf\")\n    for el in toys:\n        el.sort()\n    q=[]\n    q1=[]\n    for i in range(N):\n        q.append((toys[i][0],i,1))\n        q1.append((-toys[i][0],i,1))\n    heapify(q)\n    heapify(q1)\n    while True:\n        ans=min(ans,-q1[0][0]-q[0][0])\n        el,ind,j=heappop(q)\n        if j==M:\n            break\n        heappush(q,(toys[ind][j],ind,j+1))\n        heappush(q1,(-toys[ind][j],ind,j+1))\n    return ans", "source_code_block": "", "target_Lan": "java###minimumDifference_Test.java", "reference_code": "    public static int minimumDifference(int N, int M, int[][] toys) {\n        List<int[]> list = new ArrayList<>();\n        for(int i = 0; i < N; i++){\n            for(int y : toys[i]){\n                list.add(new int[]{y, i});\n}\n        }\n        Collections.sort(list,\n            new Comparator<int[]>(){\n                public int compare(int x[], int y[]){\n                    return x[0] - y[0];\n                }\n            }\n        );\n        Map<Integer, Integer> hm = new HashMap<>();\n        int ans = Integer.MAX_VALUE;\n        int high = 0, low = 0;\n        while(high < list.size()){\n            hm.put(list.get(high)[1], hm.getOrDefault(list.get(high)[1], 0) + 1);\n            while(hm.size() == N){\n                ans = Math.min(ans, list.get(high)[0] - list.get(low)[0]);\n                hm.put(list.get(low)[1], hm.get(list.get(low)[1]) - 1);\n                if(hm.get(list.get(low)[1]) == 0)\n                    hm.remove(list.get(low)[1]);\n                low++;\n            }\n            high++;\n        }\n        return ans;\n    }", "target_method_signature": "minimumDifference", "source_method_signature": "minimumDifference", "target_allMS": "    public static int minimumDifference(int N, int M, int[][] toys) {", "source_allMS": "def minimumDifference( N : int, M : int, toys : List[List[int]]) -> int:", "source_import": "from typing import List\nfrom heapq import *", "target_import": "import java.util.*;\nimport java.lang.*;", "commentTag": "//", "source_code_shell": "from typing import List\nfrom heapq import *\nfrom typing import List\nfrom heapq import heappop, heappush, heapify\n# TOFILL\nif __name__ == \"__main__\":\n    print(minimumDifference(1, 1, [[5]]))                  # Single toy, single category\n    print(minimumDifference(2, 2, [[1, 4], [3, 9]]))       # Two categories, non-overlapping toy values\n    print(minimumDifference(3, 3, [[1, 7, 8], [2, 3, 5], [4, 6]])) # Three categories with overlapping values\n    print(minimumDifference(3, 2, [[10, 20], [30], [40]]))  # Three categories with unequal number of toys", "all_input_output_value": "\ninput1: N=1, M=1, toys=[[5]]\noutput1: 0\n--------\ninput2: N=2, M=2, toys=[[1, 4], [3, 9]]\noutput2: 1\n--------\ninput3: N=3, M=3, toys=[[1, 7, 8], [2, 3, 5], [4, 6]]\noutput3: 2\n--------\ninput4: N=3, M=2, toys=[[10, 20], [30], [40]]\noutput4: 20\n", "input_output_value": ["\ninput1: N=1, M=1, toys=[[5]]\noutput1: 0\n", "\ninput2: N=2, M=2, toys=[[1, 4], [3, 9]]\noutput2: 1\n", "\ninput3: N=3, M=3, toys=[[1, 7, 8], [2, 3, 5], [4, 6]]\noutput3: 2\n"], "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.*;\npublic class minimumDifference_Test {\n// TOFILL\npublic static void main(String[] args) {\n        System.out.println(minimumDifference(1, 1, new int[][]{{5}}));\n        System.out.println(minimumDifference(2, 2, new int[][]{{1, 4}, {3, 9}}));\n        System.out.println(minimumDifference(3, 3, new int[][]{{1, 7, 8}, {2, 3, 5}, {4, 6}}));\n        System.out.println(minimumDifference(3, 2, new int[][]{{10, 20}, {30}, {40}}));\n    }\n}", "TAG": "Success"}
{"source_Lan": "python###minimumPushes2.py", "source_code_str": "def minimumPushes2( word: str) -> int:\n    k, rem = divmod(len(word), 8)\n    return (k * 4 + rem) * (k + 1)", "source_code_block": "", "target_Lan": "java###minimumPushes2_Test.java", "reference_code": "    public static int minimumPushes2(String word) {\n        int n = word.length();\n        int k = n / 8;\n        return (k * 4 + n % 8) * (k + 1);\n    }", "target_method_signature": "minimumPushes2", "source_method_signature": "minimumPushes2", "target_allMS": "    public static int minimumPushes2(String word) {", "source_allMS": "def minimumPushes2( word: str) -> int:", "source_import": "", "target_import": "import java.util.*;\nimport java.lang.*;", "commentTag": "//", "source_code_shell": "# TOFILL\nif __name__ == \"__main__\":\n    test_inputs = [\n        \"\",                      # Test with an empty string\n        \"a\",                     # Test with a single character\n        \"abcdefgh\",              # Test with exactly one full 8-character set\n        \"abcdefghijkl\",          # Test with one full set and 4 extra characters (12 total)\n        \"abcde\",                 # Test with fewer than 8 characters (5 total)\n        \"abcdefg\",               # Test with 7 characters, just short of a full set\n        \"abcdefghabcdefgh\",      # Test with two full sets (16 characters)\n        \"abcdefghabc\",           # Test with one full set and 3 extra characters (11 total)\n        \"a b c d e f g h\",      # Test with spaces in the string, ensuring we're still counting characters correctly\n        \"abcdefghabcd\"           # Test with two full sets and 4 characters (12 total)\n    ]\n    for i, input_str in enumerate(test_inputs):\n        print(f\"Test Input {i + 1}: {input_str} -> Output: {minimumPushes2(input_str)}\")", "all_input_output_value": "\ninput1: word=\"\"\noutput1: 0\n--------\ninput2: word=\"a\"\noutput2: 1\n--------\ninput3: word=\"abcdefgh\"\noutput3: 8\n--------\ninput4: word=\"abcdefghijkl\"\noutput4: 16\n--------\ninput5: word=\"abcde\"\noutput5: 5\n--------\ninput6: word=\"abcdefg\"\noutput6: 7\n--------\ninput7: word=\"abcdefghabcdefgh\"\noutput7: 24\n--------\ninput8: word=\"abcdefghabc\"\noutput8: 14\n--------\ninput9: word=\"a b c d e f g h\"\noutput9: 22\n--------\ninput10: word=\"abcdefghabcd\"\noutput10: 16\n", "input_output_value": ["\ninput1: word=\"\"\noutput1: 0\n", "\ninput2: word=\"a\"\noutput2: 1\n", "\ninput3: word=\"abcdefgh\"\noutput3: 8\n"], "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.Arrays;\npublic class minimumPushes2_Test {\n// TOFILL\npublic static void main(String[] args) {\n        System.out.println(minimumPushes2(\"\")); // Test Input 1\n        System.out.println(minimumPushes2(\"a\")); // Test Input 2\n        System.out.println(minimumPushes2(\"abcdefgh\")); // Test Input 3\n        System.out.println(minimumPushes2(\"abcdefghijkl\")); // Test Input 4\n        System.out.println(minimumPushes2(\"abcde\")); // Test Input 5\n        System.out.println(minimumPushes2(\"abcdefg\")); // Test Input 6\n        System.out.println(minimumPushes2(\"abcdefghabcdefgh\")); // Test Input 7\n        System.out.println(minimumPushes2(\"abcdefghabc\")); // Test Input 8\n        System.out.println(minimumPushes2(\"a b c d e f g h\")); // Test Input 9\n        System.out.println(minimumPushes2(\"abcdefghabcd\")); // Test Input 10\n    }\n}", "TAG": "Success"}
{"source_Lan": "python###maxPalindromesAfterOperations.py", "source_code_str": "def maxPalindromesAfterOperations( words: List[str]) -> int:\n    ans = tot = 0\n    cnt = Counter()\n    for w in words:\n        tot += len(w)\n        cnt += Counter(w)\n    tot -= sum(c % 2 for c in cnt.values())  \n    words.sort(key=len)  \n    for w in words:\n        tot -= len(w) // 2 * 2  \n        if tot < 0: break\n        ans += 1\n    return ans", "source_code_block": "", "target_Lan": "java###maxPalindromesAfterOperations_Test.java", "reference_code": "    public static int maxPalindromesAfterOperations(String[] words) {\n        int tot = 0;\n        int mask = 0; \n        for (String w : words) {\n            tot += w.length();\n            for (char c : w.toCharArray()) {\n                mask ^= 1 << (c - 'a');\n            }\n        }\n        tot -= Integer.bitCount(mask); \n        Arrays.sort(words, (a, b) -> a.length() - b.length());\n        int ans = 0;\n        for (String w : words) {\n            tot -= w.length() / 2 * 2; \n            if (tot < 0) break;\n            ans++;\n        }\n        return ans;\n    }", "target_method_signature": "maxPalindromesAfterOperations", "source_method_signature": "maxPalindromesAfterOperations", "target_allMS": "    public static int maxPalindromesAfterOperations(String[] words) {", "source_allMS": "def maxPalindromesAfterOperations( words: List[str]) -> int:", "source_import": "", "target_import": "import java.util.*;\nimport java.lang.*;", "commentTag": "//", "source_code_shell": "from collections import Counter\nfrom typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    test_inputs = [\n        [\"a\", \"b\", \"ab\", \"abc\", \"abcd\"],\n        [\"\", \"\", \"\"],\n        [\"aaa\", \"bb\", \"cc\", \"de\"],\n        [\"a\", \"bb\", \"ccc\"],\n        [\"abcdefghij\", \"klmnopqrst\"],\n        [\"aa\", \"bb\", \"cc\", \"dd\", \"ee\"],\n        [\"abc\", \"de\", \"fgh\", \"ijkl\"],\n        [\"xyz\", \"xy\", \"abw\", \"wxy\", \"yz\"],\n        [\"a\", \"b\", \"ab\"],\n        [\"zyxw\", \"xyz\", \"abcd\", \"a\"]\n    ]\n    for idx, words in enumerate(test_inputs):\n        print(f\"Test Input {idx + 1}: {words} -> Output: {maxPalindromesAfterOperations(words)}\")", "all_input_output_value": "\ninput1: words=['a', 'b', 'ab', 'abc', 'abcd']\noutput1: 5\n--------\ninput2: words=['', '', '']\noutput2: 3\n--------\ninput3: words=['aaa', 'bb', 'cc', 'de']\noutput3: 3\n--------\ninput4: words=['a', 'bb', 'ccc']\noutput4: 3\n--------\ninput5: words=['abcdefghij', 'klmnopqrst']\noutput5: 0\n--------\ninput6: words=['aa', 'bb', 'cc', 'dd', 'ee']\noutput6: 5\n--------\ninput7: words=['abc', 'de', 'fgh', 'ijkl']\noutput7: 0\n--------\ninput8: words=['xyz', 'xy', 'abw', 'wxy', 'yz']\noutput8: 5\n--------\ninput9: words=['a', 'b', 'ab']\noutput9: 3\n--------\ninput10: words=['zyxw', 'xyz', 'abcd', 'a']\noutput10: 3\n", "input_output_value": ["\ninput1: words=['a', 'b', 'ab', 'abc', 'abcd']\noutput1: 5\n", "\ninput2: words=['', '', '']\noutput2: 3\n", "\ninput3: words=['aaa', 'bb', 'cc', 'de']\noutput3: 3\n"], "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.Arrays;\npublic class maxPalindromesAfterOperations_Test {\n// TOFILL\npublic static void main(String[] args) {\n        System.out.println(maxPalindromesAfterOperations(new String[]{\"a\", \"b\", \"ab\", \"abc\", \"abcd\"}));\n        System.out.println(maxPalindromesAfterOperations(new String[]{\"\", \"\", \"\"}));\n        System.out.println(maxPalindromesAfterOperations(new String[]{\"aaa\", \"bb\", \"cc\", \"de\"}));\n        System.out.println(maxPalindromesAfterOperations(new String[]{\"a\", \"bb\", \"ccc\"}));\n        System.out.println(maxPalindromesAfterOperations(new String[]{\"abcdefghij\", \"klmnopqrst\"}));\n        System.out.println(maxPalindromesAfterOperations(new String[]{\"aa\", \"bb\", \"cc\", \"dd\", \"ee\"}));\n        System.out.println(maxPalindromesAfterOperations(new String[]{\"abc\", \"de\", \"fgh\", \"ijkl\"}));\n        System.out.println(maxPalindromesAfterOperations(new String[]{\"xyz\", \"xy\", \"abw\", \"wxy\", \"yz\"}));\n        System.out.println(maxPalindromesAfterOperations(new String[]{\"a\", \"b\", \"ab\"}));\n        System.out.println(maxPalindromesAfterOperations(new String[]{\"zyxw\", \"xyz\", \"abcd\", \"a\"}));\n    }\n}", "TAG": "Success"}
{"source_Lan": "python###longestCommonPrefix.py", "source_code_str": "def longestCommonPrefix( arr1: List[int], arr2: List[int]) -> int:\n    st = set()\n    for s in map(str, arr1):\n        for i in range(1, len(s) + 1):\n            st.add(s[:i])\n    ans = 0\n    for s in map(str, arr2):\n        for i in range(1, len(s) + 1):\n            if s[:i] not in st:\n                break\n            ans = max(ans, i)\n    return ans", "source_code_block": "", "target_Lan": "java###longestCommonPrefix_Test.java", "reference_code": "    public static int longestCommonPrefix(int[] arr1, int[] arr2) {\n        Set<String> st = new HashSet<>();\n        for (int x : arr1) {\n            String s = Integer.toString(x);\n            for (int i = 1; i <= s.length(); i++) {\n                st.add(s.substring(0, i));\n            }\n        }\n        int ans = 0;\n        for (int x : arr2) {\n            String s = Integer.toString(x);\n            for (int i = 1; i <= s.length(); i++) {\n                if (!st.contains(s.substring(0, i))) {\n                    break;\n                }\n                ans = Math.max(ans, i);\n            }\n        }\n        return ans;\n    }", "target_method_signature": "longestCommonPrefix", "source_method_signature": "longestCommonPrefix", "target_allMS": "    public static int longestCommonPrefix(int[] arr1, int[] arr2) {", "source_allMS": "def longestCommonPrefix( arr1: List[int], arr2: List[int]) -> int:", "source_import": "", "target_import": "import java.util.*;\nimport java.lang.*;", "commentTag": "//", "source_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(longestCommonPrefix([], []))\n    print(longestCommonPrefix([12, 23], []))\n    print(longestCommonPrefix([], [34, 45]))\n    print(longestCommonPrefix([1234, 1235], [123, 12]))\n    print(longestCommonPrefix([456, 789], [123, 4567]))\n    print(longestCommonPrefix([11, 11], [11, 12]))\n    print(longestCommonPrefix([5], [5, 50, 55]))\n    print(longestCommonPrefix([10, 20, 30], [2]))\n    print(longestCommonPrefix([1, 10, 100], [1, 11]))\n    print(longestCommonPrefix([-11, -12], [-1, -2]))", "all_input_output_value": "\ninput1: arr1=[], arr2=[]\noutput1: 0\n--------\ninput2: arr1=[12, 23], arr2=[]\noutput2: 0\n--------\ninput3: arr1=[], arr2=[34, 45]\noutput3: 0\n--------\ninput4: arr1=[1234, 1235], arr2=[123, 12]\noutput4: 3\n--------\ninput5: arr1=[456, 789], arr2=[123, 4567]\noutput5: 3\n--------\ninput6: arr1=[11, 11], arr2=[11, 12]\noutput6: 2\n--------\ninput7: arr1=[5], arr2=[5, 50, 55]\noutput7: 1\n--------\ninput8: arr1=[10, 20, 30], arr2=[2]\noutput8: 1\n--------\ninput9: arr1=[1, 10, 100], arr2=[1, 11]\noutput9: 1\n--------\ninput10: arr1=[-11, -12], arr2=[-1, -2]\noutput10: 2\n", "input_output_value": ["\ninput1: arr1=[], arr2=[]\noutput1: 0\n", "\ninput2: arr1=[12, 23], arr2=[]\noutput2: 0\n", "\ninput3: arr1=[], arr2=[34, 45]\noutput3: 0\n"], "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.HashSet;\nimport java.util.Set;\npublic class longestCommonPrefix_Test {\n// TOFILL\npublic static void main(String[] args) {\n        System.out.println(longestCommonPrefix(new int[]{}, new int[]{})); // Test input 1\n        System.out.println(longestCommonPrefix(new int[]{12, 23}, new int[]{})); // Test input 2\n        System.out.println(longestCommonPrefix(new int[]{}, new int[]{34, 45})); // Test input 3\n        System.out.println(longestCommonPrefix(new int[]{1234, 1235}, new int[]{123, 12})); // Test input 4\n        System.out.println(longestCommonPrefix(new int[]{456, 789}, new int[]{123, 4567})); // Test input 5\n        System.out.println(longestCommonPrefix(new int[]{11, 11}, new int[]{11, 12})); // Test input 6\n        System.out.println(longestCommonPrefix(new int[]{5}, new int[]{5, 50, 55})); // Test input 7\n        System.out.println(longestCommonPrefix(new int[]{10, 20, 30}, new int[]{2})); // Test input 8\n        System.out.println(longestCommonPrefix(new int[]{1, 10, 100}, new int[]{1, 11})); // Test input 9\n        System.out.println(longestCommonPrefix(new int[]{-11, -12}, new int[]{-1, -2})); // Test input 10\n    }\n}", "TAG": "Success"}
{"source_Lan": "python###maximumStrength.py", "source_code_str": "def maximumStrength( nums: List[int], k: int) -> int:\n    n = len(nums)\n    s = list(accumulate(nums, initial=0))\n    f = [[0] * (n + 1) for _ in range(k + 1)]\n    for i in range(1, k + 1):\n        f[i][i - 1] = mx = -inf\n        w = (k - i + 1) * (1 if i % 2 else -1)\n        \n        for j in range(i, n - k + i + 1):\n            mx = max(mx, f[i - 1][j - 1] - s[j - 1] * w)\n            f[i][j] = max(f[i][j - 1], s[j] * w + mx)\n    return f[k][n]", "source_code_block": "", "target_Lan": "java###maximumStrength_Test.java", "reference_code": "    public static long maximumStrength(int[] nums, int k) {\n        int n=nums.length;\n        long ans[][][]=new long[n+1][k+1][2];\n        for(int j=0;j<=k;j++){ans[0][j]=new long[]{-(long)1e18,-(long)1e18};}\n        ans[0][0][0]=0;\n        for(int i=1;i<=n;i++){\n            ans[i][0][1]=-(long)1e14;\n            for(int j=1;j<=k;j++){\n                ans[i][j][0]=Math.max(ans[i-1][j][0],ans[i-1][j][1]);\n                ans[i][j][1]=Math.max(ans[i-1][j-1][1],Math.max(ans[i-1][j-1][0],ans[i-1][j][1]))+(long)nums[i-1]*(j%2*2-1)*(k+1-j);\n            }\n        }\n        return Math.max(ans[n][k][0],ans[n][k][1]);\n    }", "target_method_signature": "maximumStrength", "source_method_signature": "maximumStrength", "target_allMS": "    public static long maximumStrength(int[] nums, int k) {", "source_allMS": "def maximumStrength( nums: List[int], k: int) -> int:", "source_import": "", "target_import": "import java.util.*;\nimport java.lang.*;", "commentTag": "//", "source_code_shell": "from typing import List\nfrom itertools import accumulate\nfrom math import inf\n# TOFILL\nif __name__ == \"__main__\":\n    print(maximumStrength([], 0))\n    print(maximumStrength([1, 2, 3, 4, 5], 0))\n    print(maximumStrength([1, 2, 3, 4, 5], 5))\n    print(maximumStrength([1, 2, 3, 4, 5], 3))\n    print(maximumStrength([5, 4, 3, 2, 1], 2))\n    print(maximumStrength([-1, -2, -3, -4, -5], 3))\n    print(maximumStrength([2**31-1, 2**31-1, 2**31-1], 2))\n    print(maximumStrength([1, -1, 2, -2, 3, -3], 6))\n    print(maximumStrength([10], 1))\n    print(maximumStrength([10, 20, -5, -10, 30], 4))", "all_input_output_value": "\ninput1: nums=[], k=0\noutput1: 0\n--------\ninput2: nums=[1, 2, 3, 4, 5], k=0\noutput2: 0\n--------\ninput3: nums=[1, 2, 3, 4, 5], k=5\noutput3: 3\n--------\ninput4: nums=[1, 2, 3, 4, 5], k=3\noutput4: 15\n--------\ninput5: nums=[5, 4, 3, 2, 1], k=2\noutput5: 27\n--------\ninput6: nums=[-1, -2, -3, -4, -5], k=3\noutput6: 10\n--------\ninput7: nums=[2147483647, 2147483647, 2147483647], k=2\noutput7: 6442450941\n--------\ninput8: nums=[1, -1, 2, -2, 3, -3], k=6\noutput8: 34\n--------\ninput9: nums=[10], k=1\noutput9: 10\n--------\ninput10: nums=[10, 20, -5, -10, 30], k=4\noutput10: 85\n", "input_output_value": ["\ninput1: nums=[], k=0\noutput1: 0\n", "\ninput2: nums=[1, 2, 3, 4, 5], k=0\noutput2: 0\n", "\ninput3: nums=[1, 2, 3, 4, 5], k=5\noutput3: 3\n"], "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.Arrays;\npublic class maximumStrength_Test {\n// TOFILL\npublic static void main(String[] args) {\n        System.out.println(maximumStrength(new int[]{}, 0));\n        System.out.println(maximumStrength(new int[]{1, 2, 3, 4, 5}, 0));\n        System.out.println(maximumStrength(new int[]{1, 2, 3, 4, 5}, 5));\n        System.out.println(maximumStrength(new int[]{1, 2, 3, 4, 5}, 3));\n        System.out.println(maximumStrength(new int[]{5, 4, 3, 2, 1}, 2));\n        System.out.println(maximumStrength(new int[]{-1, -2, -3, -4, -5}, 3));\n        System.out.println(maximumStrength(new int[]{2147483647, 2147483647, 2147483647}, 2));\n        System.out.println(maximumStrength(new int[]{1, -1, 2, -2, 3, -3}, 6));\n        System.out.println(maximumStrength(new int[]{10}, 1));\n        System.out.println(maximumStrength(new int[]{10, 20, -5, -10, 30}, 4));\n    }\n}", "TAG": "Success"}
{"source_Lan": "python###minOperationsToMakeMedianK.py", "source_code_str": "def minOperationsToMakeMedianK( nums: List[int], k: int) -> int:\n    nums.sort()\n    m = len(nums) // 2\n    ans = 0\n    if nums[m] > k:\n        for i in range(m, -1, -1):\n            if nums[i] <= k:\n                break\n            ans += nums[i] - k\n    else:\n        for i in range(m, len(nums)):\n            if nums[i] >= k:\n                break\n            ans += k - nums[i]\n    return ans", "source_code_block": "", "target_Lan": "java###minOperationsToMakeMedianK_Test.java", "reference_code": "    public static long minOperationsToMakeMedianK(int[] nums, int k) {\n        Arrays.sort(nums);\n        long ans = 0;\n        int m = nums.length / 2;\n        if (nums[m] > k) {\n            for (int i = m; i >= 0 && nums[i] > k; i--) {\n                ans += nums[i] - k;\n            }\n        } else {\n            for (int i = m; i < nums.length && nums[i] < k; i++) {\n                ans += k - nums[i];\n            }\n        }\n        return ans;\n    }", "target_method_signature": "minOperationsToMakeMedianK", "source_method_signature": "minOperationsToMakeMedianK", "target_allMS": "    public static long minOperationsToMakeMedianK(int[] nums, int k) {", "source_allMS": "def minOperationsToMakeMedianK( nums: List[int], k: int) -> int:", "source_import": "", "target_import": "import java.util.*;\nimport java.lang.*;", "commentTag": "//", "source_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(minOperationsToMakeMedianK([1, 2, 3, 4, 5], 3))   # Test Input 1\n    print(minOperationsToMakeMedianK([5, 6, 7, 8, 9], 4))   # Test Input 2\n    print(minOperationsToMakeMedianK([3, 3, 3, 3], 3))      # Test Input 3\n    print(minOperationsToMakeMedianK([1], 1))                # Test Input 5\n    print(minOperationsToMakeMedianK([1, 2, 3, 4, 5], 2))   # Test Input 6\n    print(minOperationsToMakeMedianK([-1, -2, -3, -4, -5], -3)) # Test Input 7\n    print(minOperationsToMakeMedianK([10, 10, 10, 10], 5))  # Test Input 8\n    print(minOperationsToMakeMedianK([2147483647, 2147483646], 2147483647)) # Test Input 9\n    print(minOperationsToMakeMedianK([1, 2, 3, 4], 2))      # Test Input 10", "all_input_output_value": "\ninput1: nums=[1, 2, 3, 4, 5], k=3\noutput1: 0\n--------\ninput2: nums=[5, 6, 7, 8, 9], k=4\noutput2: 6\n--------\ninput3: nums=[3, 3, 3, 3], k=3\noutput3: 0\n--------\ninput4: nums=[1], k=1\noutput4: 0\n--------\ninput5: nums=[1, 2, 3, 4, 5], k=2\noutput5: 1\n--------\ninput6: nums=[-1, -2, -3, -4, -5], k=-3\noutput6: 0\n--------\ninput7: nums=[10, 10, 10, 10], k=5\noutput7: 15\n--------\ninput8: nums=[2147483647, 2147483646], k=2147483647\noutput8: 0\n--------\ninput9: nums=[1, 2, 3, 4], k=2\noutput9: 1\n", "input_output_value": ["\ninput1: nums=[1, 2, 3, 4, 5], k=3\noutput1: 0\n", "\ninput2: nums=[5, 6, 7, 8, 9], k=4\noutput2: 6\n", "\ninput3: nums=[3, 3, 3, 3], k=3\noutput3: 0\n"], "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.Arrays;\npublic class minOperationsToMakeMedianK_Test {\n// TOFILL\npublic static void main(String[] args) {\n        System.out.println(minOperationsToMakeMedianK(new int[]{1, 2, 3, 4, 5}, 3));\n        System.out.println(minOperationsToMakeMedianK(new int[]{5, 6, 7, 8, 9}, 4));\n        System.out.println(minOperationsToMakeMedianK(new int[]{3, 3, 3, 3}, 3));\n        System.out.println(minOperationsToMakeMedianK(new int[]{1}, 1));\n        System.out.println(minOperationsToMakeMedianK(new int[]{1, 2, 3, 4, 5}, 2));\n        System.out.println(minOperationsToMakeMedianK(new int[]{-1, -2, -3, -4, -5}, -3));\n        System.out.println(minOperationsToMakeMedianK(new int[]{10, 10, 10, 10}, 5));\n        System.out.println(minOperationsToMakeMedianK(new int[]{2147483647, 2147483646}, 2147483647));\n        System.out.println(minOperationsToMakeMedianK(new int[]{1, 2, 3, 4}, 2));\n    }\n}", "TAG": "Success"}
{"source_Lan": "python###maxTotalReward.py", "source_code_str": "def maxTotalReward( rewardValues: List[int]) -> int:\n    f = 1\n    for v in sorted(set(rewardValues)):\n        f |= (f & ((1 << v) - 1)) << v\n    return f.bit_length() - 1", "source_code_block": "", "target_Lan": "java###maxTotalReward_Test.java", "reference_code": "    public static int maxTotalReward(int[] rewardValues) {\n        BigInteger f = BigInteger.ONE;\n        for (int v : Arrays.stream(rewardValues).distinct().sorted().toArray()) {\n            BigInteger mask = BigInteger.ONE.shiftLeft(v).subtract(BigInteger.ONE);\n            f = f.or(f.and(mask).shiftLeft(v));\n        }\n        return f.bitLength() - 1;\n    }", "target_method_signature": "maxTotalReward", "source_method_signature": "maxTotalReward", "target_allMS": "    public static int maxTotalReward(int[] rewardValues) {", "source_allMS": "def maxTotalReward( rewardValues: List[int]) -> int:", "source_import": "", "target_import": "import java.util.*;\nimport java.lang.*;\nimport java.math.BigInteger;", "commentTag": "//", "source_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(maxTotalReward([]))  # An empty array should handle the case where there are no rewards\n    print(maxTotalReward([0]))  # An array with a single zero value\n    print(maxTotalReward([1, 2, 2, 3]))  # An array with duplicates, one distinct next highest reward\n    print(maxTotalReward([1, 3, 4, 5]))  # A mixed array of distinct values to test normal functionality\n    print(maxTotalReward([10, 15, 10, 20]))  # A case with larger values and duplicates\n    print(maxTotalReward([0, 1, 2, 3]))  # Testing the simplest positive numbers\n    print(maxTotalReward([31, 63, 15]))  # Testing maximal shifts (2^5 - 1) and ensuring they are handled\n    print(maxTotalReward([100, 200, 300]))  # An array with larger values\n    print(maxTotalReward([10, 20, 30, 40, 50]))  # A case with larger, distinct values", "all_input_output_value": "\ninput1: rewardValues=[]\noutput1: 0\n--------\ninput2: rewardValues=[0]\noutput2: 0\n--------\ninput3: rewardValues=[1, 2, 2, 3]\noutput3: 5\n--------\ninput4: rewardValues=[1, 3, 4, 5]\noutput4: 9\n--------\ninput5: rewardValues=[10, 15, 10, 20]\noutput5: 35\n--------\ninput6: rewardValues=[0, 1, 2, 3]\noutput6: 5\n--------\ninput7: rewardValues=[31, 63, 15]\noutput7: 109\n--------\ninput8: rewardValues=[100, 200, 300]\noutput8: 500\n--------\ninput9: rewardValues=[10, 20, 30, 40, 50]\noutput9: 90\n", "input_output_value": ["\ninput1: rewardValues=[]\noutput1: 0\n", "\ninput2: rewardValues=[0]\noutput2: 0\n", "\ninput3: rewardValues=[1, 2, 2, 3]\noutput3: 5\n"], "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.math.BigInteger;\nimport java.math.BigInteger;\nimport java.util.Arrays;\npublic class maxTotalReward_Test {\n// TOFILL\npublic static void main(String[] args) {\n        System.out.println(maxTotalReward(new int[]{})); // Test input 1\n        System.out.println(maxTotalReward(new int[]{0})); // Test input 2\n        System.out.println(maxTotalReward(new int[]{1, 2, 2, 3})); // Test input 3\n        System.out.println(maxTotalReward(new int[]{1, 3, 4, 5})); // Test input 4\n        System.out.println(maxTotalReward(new int[]{10, 15, 10, 20})); // Test input 5\n        System.out.println(maxTotalReward(new int[]{0, 1, 2, 3})); // Test input 6\n        System.out.println(maxTotalReward(new int[]{31, 63, 15})); // Test input 7\n        System.out.println(maxTotalReward(new int[]{100, 200, 300})); // Test input 8\n        System.out.println(maxTotalReward(new int[]{10, 20, 30, 40, 50})); // Test input 9\n    }\n}", "TAG": "Success"}
{"source_Lan": "python###maxSelectedElements.py", "source_code_str": "def maxSelectedElements( nums: List[int]) -> int:\n    nums.sort()\n    f = defaultdict(int)\n    for x in nums:\n        f[x + 1] = f[x] + 1\n        f[x] = f[x - 1] + 1\n    return max(f.values())", "source_code_block": "", "target_Lan": "java###maxSelectedElements_Test.java", "reference_code": "    public static int maxSelectedElements(int[] nums) {\n        Arrays.sort(nums);\n        Map<Integer, Integer> f = new HashMap<>();\n        for (int x : nums) {\n            f.put(x + 1, f.getOrDefault(x, 0) + 1);\n            f.put(x, f.getOrDefault(x - 1, 0) + 1);\n        }\n        int ans = 0;\n        for (int res : f.values()) {\n            ans = Math.max(ans, res);\n        }\n        return ans;\n    }", "target_method_signature": "maxSelectedElements", "source_method_signature": "maxSelectedElements", "target_allMS": "    public static int maxSelectedElements(int[] nums) {", "source_allMS": "def maxSelectedElements( nums: List[int]) -> int:", "source_import": "", "target_import": "import java.util.*;\nimport java.lang.*;", "commentTag": "//", "source_code_shell": "from collections import defaultdict\nfrom typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(maxSelectedElements([1]))\n    print(maxSelectedElements([2, 2, 2, 2]))\n    print(maxSelectedElements([1, 2, 3, 4]))\n    print(maxSelectedElements([1, 3, 5, 10]))\n    print(maxSelectedElements([-3, -2, -1, 0, 1, 2]))\n    print(maxSelectedElements([5, -1, 0, 4, 5, 3, 2]))\n    print(maxSelectedElements([1, 1, 2, 2, 2]))\n    print(maxSelectedElements([10, 15, 20, 25]))\n    print(maxSelectedElements([1, 100, 200, 201, 202]))", "all_input_output_value": "\ninput1: nums=[1]\noutput1: 1\n--------\ninput2: nums=[2, 2, 2, 2]\noutput2: 2\n--------\ninput3: nums=[1, 2, 3, 4]\noutput3: 4\n--------\ninput4: nums=[1, 3, 5, 10]\noutput4: 2\n--------\ninput5: nums=[-3, -2, -1, 0, 1, 2]\noutput5: 6\n--------\ninput6: nums=[5, -1, 0, 4, 5, 3, 2]\noutput6: 7\n--------\ninput7: nums=[1, 1, 2, 2, 2]\noutput7: 3\n--------\ninput8: nums=[10, 15, 20, 25]\noutput8: 1\n--------\ninput9: nums=[1, 100, 200, 201, 202]\noutput9: 3\n", "input_output_value": ["\ninput1: nums=[1]\noutput1: 1\n", "\ninput2: nums=[2, 2, 2, 2]\noutput2: 2\n", "\ninput3: nums=[1, 2, 3, 4]\noutput3: 4\n"], "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Map;\npublic class maxSelectedElements_Test {\n// TOFILL\npublic static void main(String[] args) {\n        System.out.println(maxSelectedElements(new int[]{1}));\n        System.out.println(maxSelectedElements(new int[]{2, 2, 2, 2}));\n        System.out.println(maxSelectedElements(new int[]{1, 2, 3, 4}));\n        System.out.println(maxSelectedElements(new int[]{1, 3, 5, 10}));\n        System.out.println(maxSelectedElements(new int[]{-3, -2, -1, 0, 1, 2}));\n        System.out.println(maxSelectedElements(new int[]{5, -1, 0, 4, 5, 3, 2}));\n        System.out.println(maxSelectedElements(new int[]{1, 1, 2, 2, 2}));\n        System.out.println(maxSelectedElements(new int[]{10, 15, 20, 25}));\n        System.out.println(maxSelectedElements(new int[]{1, 100, 200, 201, 202}));\n    }\n}", "TAG": "Success"}
{"source_Lan": "python###occurrencesOfElement.py", "source_code_str": "def occurrencesOfElement( nums: List[int], queries: List[int], x: int) -> List[int]:\n    pos = [i for i, v in enumerate(nums) if v == x]\n    return [-1 if q > len(pos) else pos[q - 1] for q in queries]", "source_code_block": "", "target_Lan": "java###occurrencesOfElement_Test.java", "reference_code": "    public static int[] occurrencesOfElement(int[] nums, int[] queries, int x) {\n        List<Integer> pos = new ArrayList<>();\n        for (int i = 0; i < nums.length; i++) {\n            if (nums[i] == x) {\n                pos.add(i);\n            }\n        }\n        for (int i = 0; i < queries.length; i++) {\n            if (queries[i] > pos.size()) {\n                queries[i] = -1;\n            } else {\n                queries[i] = pos.get(queries[i] - 1);\n            }\n        }\n        return queries;\n    }", "target_method_signature": "occurrencesOfElement", "source_method_signature": "occurrencesOfElement", "target_allMS": "    public static int[] occurrencesOfElement(int[] nums, int[] queries, int x) {", "source_allMS": "def occurrencesOfElement( nums: List[int], queries: List[int], x: int) -> List[int]:", "source_import": "", "target_import": "import java.util.*;\nimport java.lang.*;", "commentTag": "//", "source_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(occurrencesOfElement([], [1, 2, 3], 1))                       # Test with empty nums\n    print(occurrencesOfElement([1, 2, 3, 4, 5], [1], 6))               # No occurrence of x\n    print(occurrencesOfElement([1, 2, 3, 4, 5], [], 3))                # Empty queries\n    print(occurrencesOfElement([1, 2, 3, 3, 4], [1, 2, 3], 3))        # Multiple occurrences\n    print(occurrencesOfElement([1, 2, 3, 3, 4], [4, 5], 3))            # Out of bounds for queries\n    print(occurrencesOfElement([1, 3, 3, 3, 4], [1], 3))               # One occurrence query\n    print(occurrencesOfElement([3, 3, 3, 3, 3], [1, 2], 3))            # All equal\n    print(occurrencesOfElement([5, 6, 7, 8], [1, 2], 5))               # Single occurrence at the start\n    print(occurrencesOfElement([10, 20, 10, 40, 10], [1, 2, 3], 10))  # Multiple occurrences spread\n    print(occurrencesOfElement([9, 10, 8, 9, 9, 1, 3], [2, 3, 4], 9))  # Testing various valid queries", "all_input_output_value": "\ninput1: nums=[], queries=[1, 2, 3], x=1\noutput1: [-1, -1, -1]\n--------\ninput2: nums=[1, 2, 3, 4, 5], queries=[1], x=6\noutput2: [-1]\n--------\ninput3: nums=[1, 2, 3, 4, 5], queries=[], x=3\noutput3: []\n--------\ninput4: nums=[1, 2, 3, 3, 4], queries=[1, 2, 3], x=3\noutput4: [2, 3, -1]\n--------\ninput5: nums=[1, 2, 3, 3, 4], queries=[4, 5], x=3\noutput5: [-1, -1]\n--------\ninput6: nums=[1, 3, 3, 3, 4], queries=[1], x=3\noutput6: [1]\n--------\ninput7: nums=[3, 3, 3, 3, 3], queries=[1, 2], x=3\noutput7: [0, 1]\n--------\ninput8: nums=[5, 6, 7, 8], queries=[1, 2], x=5\noutput8: [0, -1]\n--------\ninput9: nums=[10, 20, 10, 40, 10], queries=[1, 2, 3], x=10\noutput9: [0, 2, 4]\n--------\ninput10: nums=[9, 10, 8, 9, 9, 1, 3], queries=[2, 3, 4], x=9\noutput10: [3, 4, -1]\n", "input_output_value": ["\ninput1: nums=[], queries=[1, 2, 3], x=1\noutput1: [-1, -1, -1]\n", "\ninput2: nums=[1, 2, 3, 4, 5], queries=[1], x=6\noutput2: [-1]\n", "\ninput3: nums=[1, 2, 3, 4, 5], queries=[], x=3\noutput3: []\n"], "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.ArrayList;\nimport java.util.List;\npublic class occurrencesOfElement_Test {\n// TOFILL\npublic static void main(String[] args) {\n        int[] result1 = occurrencesOfElement(new int[]{}, new int[]{1, 2, 3}, 1);\n        int[] result2 = occurrencesOfElement(new int[]{1, 2, 3, 4, 5}, new int[]{1}, 6);\n        int[] result3 = occurrencesOfElement(new int[]{1, 2, 3, 4, 5}, new int[]{}, 3);\n        int[] result4 = occurrencesOfElement(new int[]{1, 2, 3, 3, 4}, new int[]{1, 2, 3}, 3);\n        int[] result5 = occurrencesOfElement(new int[]{1, 2, 3, 3, 4}, new int[]{4, 5}, 3);\n        int[] result6 = occurrencesOfElement(new int[]{1, 3, 3, 3, 4}, new int[]{1}, 3);\n        int[] result7 = occurrencesOfElement(new int[]{3, 3, 3, 3, 3}, new int[]{1, 2}, 3);\n        int[] result8 = occurrencesOfElement(new int[]{5, 6, 7, 8}, new int[]{1, 2}, 5);\n        int[] result9 = occurrencesOfElement(new int[]{10, 20, 10, 40, 10}, new int[]{1, 2, 3}, 10);\n        int[] result10 = occurrencesOfElement(new int[]{9, 10, 8, 9, 9, 1, 3}, new int[]{2, 3, 4}, 9);\n\n        // Print results\n        for(int res : result1) System.out.print(res + \" \");\n        System.out.println();\n        for(int res : result2) System.out.print(res + \" \");\n        System.out.println();\n        for(int res : result3) System.out.print(res + \" \");\n        System.out.println();\n        for(int res : result4) System.out.print(res + \" \");\n        System.out.println();\n        for(int res : result5) System.out.print(res + \" \");\n        System.out.println();\n        for(int res : result6) System.out.print(res + \" \");\n        System.out.println();\n        for(int res : result7) System.out.print(res + \" \");\n        System.out.println();\n        for(int res : result8) System.out.print(res + \" \");\n        System.out.println();\n        for(int res : result9) System.out.print(res + \" \");\n        System.out.println();\n        for(int res : result10) System.out.print(res + \" \");\n        System.out.println();\n    }\n}", "TAG": "Success"}
{"source_Lan": "python###minOperations2.py", "source_code_str": "def minOperations2( nums: List[int]) -> int:\n    ans = 0\n    for i in range(len(nums) - 2):\n        if nums[i] == 0:\n            nums[i + 1] ^= 1\n            nums[i + 2] ^= 1\n            ans += 1\n    return ans if nums[-2] and nums[-1] else -1", "source_code_block": "", "target_Lan": "java###minOperations2_Test.java", "reference_code": "    public static int minOperations2(int[] nums) {\n        int n = nums.length;\n        int ans = 0;\n        for (int i = 0; i < n - 2; i++) {\n            if (nums[i] == 0) {\n                nums[i + 1] ^= 1;\n                nums[i + 2] ^= 1;\n                ans++;\n            }\n        }\n        return nums[n - 2] != 0 && nums[n - 1] != 0 ? ans : -1;\n    }", "target_method_signature": "minOperations2", "source_method_signature": "minOperations2", "target_allMS": "    public static int minOperations2(int[] nums) {", "source_allMS": "def minOperations2( nums: List[int]) -> int:", "source_import": "", "target_import": "import java.util.*;\nimport java.lang.*;", "commentTag": "//", "source_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(minOperations2([0, 1, 1]))        # Input 1: Basic case with no zeroes\n    print(minOperations2([0, 0, 1, 1]))    # Input 2: Single zero, should trigger an operation\n    print(minOperations2([0, 0, 0, 1]))    # Input 3: Multiple zeros, should require operations\n    print(minOperations2([0, 0, 0]))        # Input 5: All zeros, should return -1\n    print(minOperations2([1, 0, 1, 0]))     # Input 6: Alternating values\n    print(minOperations2([1, 1, 0, 0]))     # Input 7: Could lead to a zero at the end\n    print(minOperations2([-1, 0, 1]))       # Input 8: Negative value to see how it's handled\n    print(minOperations2([2147483647, 0]))  # Input 9: Large positive integer", "all_input_output_value": "\ninput1: nums=[0, 1, 1]\noutput1: -1\n--------\ninput2: nums=[0, 0, 1, 1]\noutput2: -1\n--------\ninput3: nums=[0, 0, 0, 1]\noutput3: 1\n--------\ninput4: nums=[0, 0, 0]\noutput4: 1\n--------\ninput5: nums=[1, 0, 1, 0]\noutput5: -1\n--------\ninput6: nums=[1, 1, 0, 0]\noutput6: -1\n--------\ninput7: nums=[-1, 0, 1]\noutput7: -1\n--------\ninput8: nums=[2147483647, 0]\noutput8: -1\n", "input_output_value": ["\ninput1: nums=[0, 1, 1]\noutput1: -1\n", "\ninput2: nums=[0, 0, 1, 1]\noutput2: -1\n", "\ninput3: nums=[0, 0, 0, 1]\noutput3: 1\n"], "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.Arrays;\npublic class minOperations2_Test {\n// TOFILL\npublic static void main(String[] args) {\n        System.out.println(minOperations2(new int[]{0, 1, 1}));\n        System.out.println(minOperations2(new int[]{0, 0, 1, 1}));\n        System.out.println(minOperations2(new int[]{0, 0, 0, 1}));\n        System.out.println(minOperations2(new int[]{0, 0, 0}));\n        System.out.println(minOperations2(new int[]{1, 0, 1, 0}));\n        System.out.println(minOperations2(new int[]{1, 1, 0, 0}));\n        System.out.println(minOperations2(new int[]{-1, 0, 1}));\n        System.out.println(minOperations2(new int[]{2147483647, 0}));\n    }\n}", "TAG": "Success"}
{"source_Lan": "python###kSum.py", "source_code_str": "def kSum( nums: List[int], k: int) -> int:\n    n = len(nums)\n    total = 0\n    for i in range(n):\n        if nums[i] >= 0:\n            total += nums[i]\n        else:\n            nums[i] = -nums[i]\n    nums.sort()\n    ret = 0\n    pq = [(nums[0], 0)]\n    for j in range(2, k + 1):\n        t, i = heappop(pq)\n        ret = t\n        if i == n - 1:\n            continue\n        heappush(pq, (t + nums[i + 1], i + 1))\n        heappush(pq, (t - nums[i] + nums[i + 1], i + 1))\n    return total - ret", "source_code_block": "", "target_Lan": "java###kSum_Test.java", "reference_code": "    public static long kSum(int[] nums, int k) {\n        int n = nums.length;\n        long total = 0;\n        for (int i = 0; i < n; i++) {\n            if (nums[i] >= 0) {\n                total += nums[i];\n            } else {\n                nums[i] = -nums[i];\n            }\n        }\n        Arrays.sort(nums);\n        long ret = 0;\n        PriorityQueue<long[]> pq = new PriorityQueue<long[]>((a, b) -> Long.compare(a[0], b[0]));\n        pq.offer(new long[]{nums[0], 0});\n        for (int j = 2; j <= k; j++) {\n            long[] arr = pq.poll();\n            long t = arr[0];\n            int i = (int) arr[1];\n            ret = t;\n            if (i == n - 1) {\n                continue;\n            }\n            pq.offer(new long[]{t + nums[i + 1], i + 1});\n            pq.offer(new long[]{t - nums[i] + nums[i + 1], i + 1});\n        }\n        return total - ret;\n    }", "target_method_signature": "kSum", "source_method_signature": "kSum", "target_allMS": "    public static long kSum(int[] nums, int k) {", "source_allMS": "def kSum( nums: List[int], k: int) -> int:", "source_import": "", "target_import": "import java.util.*;\nimport java.lang.*;", "commentTag": "//", "source_code_shell": "from typing import List\nfrom heapq import heappop, heappush\n# TOFILL\nif __name__ == \"__main__\":\n    print(kSum([5, 1, 3, 7], 3))\n    print(kSum([-2, -1, 0, 1, 2], 4))\n    print(kSum([1, 2, 3], 3))\n    print(kSum([10, 20, 30], 4))\n    print(kSum([7, 7, 7], 2))\n    print(kSum([-5], 1))\n    print(kSum([1, 2, 3], 0))\n    print(kSum([2, 4, 6, 8], 2))\n    print(kSum([4, 3, 2, 1], 1))", "all_input_output_value": "\ninput1: nums=[5, 1, 3, 7], k=3\noutput1: 13\n--------\ninput2: nums=[-2, -1, 0, 1, 2], k=4\noutput2: 2\n--------\ninput3: nums=[1, 2, 3], k=3\noutput3: 4\n--------\ninput4: nums=[10, 20, 30], k=4\noutput4: 30\n--------\ninput5: nums=[7, 7, 7], k=2\noutput5: 14\n--------\ninput6: nums=[-5], k=1\noutput6: 0\n--------\ninput7: nums=[1, 2, 3], k=0\noutput7: 6\n--------\ninput8: nums=[2, 4, 6, 8], k=2\noutput8: 18\n--------\ninput9: nums=[4, 3, 2, 1], k=1\noutput9: 10\n", "input_output_value": ["\ninput1: nums=[5, 1, 3, 7], k=3\noutput1: 13\n", "\ninput2: nums=[-2, -1, 0, 1, 2], k=4\noutput2: 2\n", "\ninput3: nums=[1, 2, 3], k=3\noutput3: 4\n"], "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.Arrays;\nimport java.util.PriorityQueue;\npublic class kSum_Test {\n// TOFILL\npublic static void main(String[] args) {\n        System.out.println(kSum(new int[]{5, 1, 3, 7}, 3)); // Test Input 1\n        System.out.println(kSum(new int[]{-2, -1, 0, 1, 2}, 4)); // Test Input 2\n        System.out.println(kSum(new int[]{1, 2, 3}, 3)); // Test Input 3\n        System.out.println(kSum(new int[]{10, 20, 30}, 4)); // Test Input 4\n        System.out.println(kSum(new int[]{7, 7, 7}, 2)); // Test Input 5\n        System.out.println(kSum(new int[]{-5}, 1)); // Test Input 6\n        System.out.println(kSum(new int[]{1, 2, 3}, 0)); // Test Input 7\n        System.out.println(kSum(new int[]{2, 4, 6, 8}, 2)); // Test Input 8\n        System.out.println(kSum(new int[]{4, 3, 2, 1}, 1)); // Test Input 9\n    }\n}", "TAG": "Success"}
{"source_Lan": "python###divisibilityArray.py", "source_code_str": "def divisibilityArray( word, m):\n    cur = 0\n    res = []\n    for c in word:\n        cur = (cur * 10 + int(c)) % m\n        res.append(1 if cur == 0 else 0)\n    return res", "source_code_block": "", "target_Lan": "java###divisibilityArray_Test.java", "reference_code": "    public static int[] divisibilityArray(String word, int m) {\n        int[] res = new int[word.length()];\n        long cur = 0;\n        for (int i = 0; i < word.length(); i++) {\n            char c = word.charAt(i);\n            cur = (cur * 10 + (c - '0')) % m;\n            res[i] = (cur == 0) ? 1 : 0;\n        }\n        return res;\n    }", "target_method_signature": "divisibilityArray", "source_method_signature": "divisibilityArray", "target_allMS": "    public static int[] divisibilityArray(String word, int m) {", "source_allMS": "def divisibilityArray( word, m):", "source_import": "", "target_import": "import java.util.*;\nimport java.lang.*;", "commentTag": "//", "source_code_shell": "# TOFILL\nif __name__ == \"__main__\":\n    print(divisibilityArray(\"0\", 1))\n    print(divisibilityArray(\"123\", 2))\n    print(divisibilityArray(\"456\", 3))\n    print(divisibilityArray(\"999999999\", 999999999))\n    print(divisibilityArray(\"10000000000\", 10))\n    print(divisibilityArray(\"123456789\", 10))\n    print(divisibilityArray(\"0000000000\", 5))\n    print(divisibilityArray(\"987654321\", 7))\n    print(divisibilityArray(\"12345678901234567890\", 9))\n    print(divisibilityArray(\"0\", -1))", "all_input_output_value": "\ninput1: word=\"0\", m=1\noutput1: [1]\n--------\ninput2: word=\"123\", m=2\noutput2: [0, 1, 0]\n--------\ninput3: word=\"456\", m=3\noutput3: [0, 1, 1]\n--------\ninput4: word=\"999999999\", m=999999999\noutput4: [0, 0, 0, 0, 0, 0, 0, 0, 1]\n--------\ninput5: word=\"10000000000\", m=10\noutput5: [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\n--------\ninput6: word=\"123456789\", m=10\noutput6: [0, 0, 0, 0, 0, 0, 0, 0, 0]\n--------\ninput7: word=\"0000000000\", m=5\noutput7: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\n--------\ninput8: word=\"987654321\", m=7\noutput8: [0, 1, 1, 0, 0, 0, 0, 0, 0]\n--------\ninput9: word=\"12345678901234567890\", m=9\noutput9: [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1]\n--------\ninput10: word=\"0\", m=-1\noutput10: [1]\n", "input_output_value": ["\ninput1: word=\"0\", m=1\noutput1: [1]\n", "\ninput2: word=\"123\", m=2\noutput2: [0, 1, 0]\n", "\ninput3: word=\"456\", m=3\noutput3: [0, 1, 1]\n"], "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.Arrays;\npublic class divisibilityArray_Test {\n// TOFILL\npublic static void main(String[] args) {\n        System.out.println(Arrays.toString(divisibilityArray(\"0\", 1)));\n        System.out.println(Arrays.toString(divisibilityArray(\"123\", 2)));\n        System.out.println(Arrays.toString(divisibilityArray(\"456\", 3)));\n        System.out.println(Arrays.toString(divisibilityArray(\"999999999\", 999999999)));\n        System.out.println(Arrays.toString(divisibilityArray(\"10000000000\", 10)));\n        System.out.println(Arrays.toString(divisibilityArray(\"123456789\", 10)));\n        System.out.println(Arrays.toString(divisibilityArray(\"0000000000\", 5)));\n        System.out.println(Arrays.toString(divisibilityArray(\"987654321\", 7)));\n        System.out.println(Arrays.toString(divisibilityArray(\"12345678901234567890\", 9)));\n        System.out.println(Arrays.toString(divisibilityArray(\"0\", -1)));\n    }\n}", "TAG": "Success"}
{"source_Lan": "python###minimumDeletions.py", "source_code_str": "def minimumDeletions( word: str, k: int) -> int:\n    cnt = sorted(Counter(word).values())\n    max_save = max(sum(min(c, base + k) for c in cnt[i:])\n                   for i, base in enumerate(cnt))\n    return len(word) - max_save", "source_code_block": "", "target_Lan": "java###minimumDeletions_Test.java", "reference_code": "    public static int minimumDeletions(String word, int k) {\n        int[] cnt = new int[26];\n        for (char c : word.toCharArray()) {\n            cnt[c - 'a']++;\n        }\n        Arrays.sort(cnt);\n        int maxSave = 0;\n        for (int i = 0; i < 26; i++) {\n            int sum = 0;\n            for (int j = i; j < 26; j++) {\n                sum += Math.min(cnt[j], cnt[i] + k); \n            }\n            maxSave = Math.max(maxSave, sum);\n        }\n        return word.length() - maxSave;\n    }", "target_method_signature": "minimumDeletions", "source_method_signature": "minimumDeletions", "target_allMS": "    public static int minimumDeletions(String word, int k) {", "source_allMS": "def minimumDeletions( word: str, k: int) -> int:", "source_import": "", "target_import": "import java.util.*;\nimport java.lang.*;", "commentTag": "//", "source_code_shell": "from collections import Counter\n# TOFILL\nif __name__ == \"__main__\":\n    print(minimumDeletions(\"a\", 0))                 # Minimum case with one character\n    print(minimumDeletions(\"abc\", 1))               # All unique characters with k=1\n    print(minimumDeletions(\"aaa\", 1))               # All characters the same, can remove 1\n    print(minimumDeletions(\"aabbcc\", 2))            # Duplicate characters, k=2 to see effects on saves\n    print(minimumDeletions(\"aaabb\", 2))             # Mix of duplicates, ensure we can save some\n    print(minimumDeletions(\"abcdabcdabcd\", 3))      # Higher length, same repeating pattern\n    print(minimumDeletions(\"xxyyzz\", 2))            # A string with pairs, all unique on different groups\n    print(minimumDeletions(\"abcdefghijklmnopqrstuvwxy\", 5))  # All unique characters with higher k\n    print(minimumDeletions(\"zzzzyyyyxxxx\", 0))      # All characters the same, with no removals available", "all_input_output_value": "\ninput1: word=\"a\", k=0\noutput1: 0\n--------\ninput2: word=\"abc\", k=1\noutput2: 0\n--------\ninput3: word=\"aaa\", k=1\noutput3: 0\n--------\ninput4: word=\"aabbcc\", k=2\noutput4: 0\n--------\ninput5: word=\"aaabb\", k=2\noutput5: 0\n--------\ninput6: word=\"abcdabcdabcd\", k=3\noutput6: 0\n--------\ninput7: word=\"xxyyzz\", k=2\noutput7: 0\n--------\ninput8: word=\"abcdefghijklmnopqrstuvwxy\", k=5\noutput8: 0\n--------\ninput9: word=\"zzzzyyyyxxxx\", k=0\noutput9: 0\n", "input_output_value": ["\ninput1: word=\"a\", k=0\noutput1: 0\n", "\ninput2: word=\"abc\", k=1\noutput2: 0\n", "\ninput3: word=\"aaa\", k=1\noutput3: 0\n"], "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.Arrays;\npublic class minimumDeletions_Test {\n// TOFILL\npublic static void main(String[] args) {\n        System.out.println(minimumDeletions(\"a\", 0)); // Test input 1\n        System.out.println(minimumDeletions(\"abc\", 1)); // Test input 2\n        System.out.println(minimumDeletions(\"aaa\", 1)); // Test input 3\n        System.out.println(minimumDeletions(\"aabbcc\", 2)); // Test input 4\n        System.out.println(minimumDeletions(\"aaabb\", 2)); // Test input 5\n        System.out.println(minimumDeletions(\"abcdabcdabcd\", 3)); // Test input 6\n        System.out.println(minimumDeletions(\"xxyyzz\", 2)); // Test input 7\n        System.out.println(minimumDeletions(\"abcdefghijklmnopqrstuvwxy\", 5)); // Test input 8\n        System.out.println(minimumDeletions(\"zzzzyyyyxxxx\", 0)); // Test input 9\n    }\n}", "TAG": "Success"}
{"source_Lan": "python###minimumArrayLength.py", "source_code_str": "def minimumArrayLength( nums: List[int]) -> int:\n    m = min(nums)\n    for x in nums:\n        if x % m:\n            return 1\n    return (nums.count(m) + 1) // 2", "source_code_block": "", "target_Lan": "java###minimumArrayLength_Test.java", "reference_code": "    public static int minimumArrayLength(int[] nums) {\n        int m = Integer.MAX_VALUE;\n        for (int x : nums) {\n            m = Math.min(m, x);\n        }\n        for (int x : nums) {\n            if (x % m > 0) {\n                return 1;\n            }\n        }\n        int cnt = 0;\n        for (int x : nums) {\n            if (x == m) {\n                cnt++;\n            }\n        }\n        return (cnt + 1) / 2;\n    }", "target_method_signature": "minimumArrayLength", "source_method_signature": "minimumArrayLength", "target_allMS": "    public static int minimumArrayLength(int[] nums) {", "source_allMS": "def minimumArrayLength( nums: List[int]) -> int:", "source_import": "", "target_import": "import java.util.*;\nimport java.lang.*;", "commentTag": "//", "source_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(minimumArrayLength([1, 2, 3, 4, 5]))        # Case with positive integers\n    print(minimumArrayLength([5, 5, 5, 5]))            # Case with all elements the same\n    print(minimumArrayLength([-1, -2, -3, -4]))        # Case with negative integers\n    print(minimumArrayLength([1, 2, 4, 8, 16]))        # Mixed powers of two\n    print(minimumArrayLength([3, 6, 9, 12]))           # Mixed multiples of 3\n    print(minimumArrayLength([8, 8, 8, 8, 8]))         # All same, testing repeated elements\n    print(minimumArrayLength([7, -7, 9, 5]))            # Mixed positive and negative\n    print(minimumArrayLength([10000, 20000, 30000]))   # Large positive values\n    print(minimumArrayLength([-1, -1, 0, 1]))           # Test case with negatives and zero", "all_input_output_value": "\ninput1: nums=[1, 2, 3, 4, 5]\noutput1: 1\n--------\ninput2: nums=[5, 5, 5, 5]\noutput2: 2\n--------\ninput3: nums=[-1, -2, -3, -4]\noutput3: 1\n--------\ninput4: nums=[1, 2, 4, 8, 16]\noutput4: 1\n--------\ninput5: nums=[3, 6, 9, 12]\noutput5: 1\n--------\ninput6: nums=[8, 8, 8, 8, 8]\noutput6: 3\n--------\ninput7: nums=[7, -7, 9, 5]\noutput7: 1\n--------\ninput8: nums=[10000, 20000, 30000]\noutput8: 1\n--------\ninput9: nums=[-1, -1, 0, 1]\noutput9: 1\n", "input_output_value": ["\ninput1: nums=[1, 2, 3, 4, 5]\noutput1: 1\n", "\ninput2: nums=[5, 5, 5, 5]\noutput2: 2\n", "\ninput3: nums=[-1, -2, -3, -4]\noutput3: 1\n"], "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.Arrays;\npublic class minimumArrayLength_Test {\n// TOFILL\npublic static void main(String[] args) {\n        System.out.println(minimumArrayLength(new int[]{1, 2, 3, 4, 5}));\n        System.out.println(minimumArrayLength(new int[]{5, 5, 5, 5}));\n        System.out.println(minimumArrayLength(new int[]{-1, -2, -3, -4}));\n        System.out.println(minimumArrayLength(new int[]{1, 2, 4, 8, 16}));\n        System.out.println(minimumArrayLength(new int[]{3, 6, 9, 12}));\n        System.out.println(minimumArrayLength(new int[]{8, 8, 8, 8, 8}));\n        System.out.println(minimumArrayLength(new int[]{7, -7, 9, 5}));\n        System.out.println(minimumArrayLength(new int[]{10000, 20000, 30000}));\n        System.out.println(minimumArrayLength(new int[]{-1, -1, 0, 1}));\n    }\n}", "TAG": "Success"}
{"source_Lan": "python###longestMonotonicSubarray.py", "source_code_str": "def longestMonotonicSubarray( a: List[int]) -> int:\n    ans = 1\n    i, n = 0, len(a)\n    while i < n - 1:\n        if a[i + 1] == a[i]:\n            i += 1  \n            continue\n        i0 = i  \n        inc = a[i + 1] > a[i]  \n        i += 2  \n        while i < n and a[i] != a[i - 1] and (a[i] > a[i - 1]) == inc:\n            i += 1\n        \n        ans = max(ans, i - i0)\n        i -= 1\n    return ans", "source_code_block": "", "target_Lan": "java###longestMonotonicSubarray_Test.java", "reference_code": "    public static int longestMonotonicSubarray(int[] a) {\n        int ans = 1;\n        int i = 0, n = a.length;\n        while (i < n - 1) {\n            if (a[i + 1] == a[i]) {\n                i++; \n                continue;\n            }\n            int i0 = i; \n            boolean inc = a[i + 1] > a[i]; \n            i += 2; \n            while (i < n && a[i] != a[i - 1] && (a[i] > a[i - 1]) == inc) {\n                i++;\n            }\n            \n            ans = Math.max(ans, i - i0);\n            i--;\n        }\n        return ans;\n    }", "target_method_signature": "longestMonotonicSubarray", "source_method_signature": "longestMonotonicSubarray", "target_allMS": "    public static int longestMonotonicSubarray(int[] a) {", "source_allMS": "def longestMonotonicSubarray( a: List[int]) -> int:", "source_import": "", "target_import": "import java.util.*;\nimport java.lang.*;", "commentTag": "//", "source_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(longestMonotonicSubarray([]))\n    print(longestMonotonicSubarray([1]))\n    print(longestMonotonicSubarray([1, 2, 3, 4, 5]))\n    print(longestMonotonicSubarray([5, 4, 3, 2, 1]))\n    print(longestMonotonicSubarray([1, 1, 1, 1, 1]))\n    print(longestMonotonicSubarray([1, 2, 2, 3, 3, 4, 5]))\n    print(longestMonotonicSubarray([5, 4, 4, 3, 2, 1]))\n    print(longestMonotonicSubarray([1, 2, 1, 2, 3, 4]))\n    print(longestMonotonicSubarray([1, 2, 3, 2, 1]))\n    print(longestMonotonicSubarray([1, 3, 2, 4, 5]))", "all_input_output_value": "\ninput1: a=[]\noutput1: 1\n--------\ninput2: a=[1]\noutput2: 1\n--------\ninput3: a=[1, 2, 3, 4, 5]\noutput3: 5\n--------\ninput4: a=[5, 4, 3, 2, 1]\noutput4: 5\n--------\ninput5: a=[1, 1, 1, 1, 1]\noutput5: 1\n--------\ninput6: a=[1, 2, 2, 3, 3, 4, 5]\noutput6: 3\n--------\ninput7: a=[5, 4, 4, 3, 2, 1]\noutput7: 4\n--------\ninput8: a=[1, 2, 1, 2, 3, 4]\noutput8: 4\n--------\ninput9: a=[1, 2, 3, 2, 1]\noutput9: 3\n--------\ninput10: a=[1, 3, 2, 4, 5]\noutput10: 3\n", "input_output_value": ["\ninput1: a=[]\noutput1: 1\n", "\ninput2: a=[1]\noutput2: 1\n", "\ninput3: a=[1, 2, 3, 4, 5]\noutput3: 5\n"], "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.Arrays;\npublic class longestMonotonicSubarray_Test {\n// TOFILL\npublic static void main(String[] args) {\n        System.out.println(longestMonotonicSubarray(new int[] {}));\n        System.out.println(longestMonotonicSubarray(new int[] {1}));\n        System.out.println(longestMonotonicSubarray(new int[] {1, 2, 3, 4, 5}));\n        System.out.println(longestMonotonicSubarray(new int[] {5, 4, 3, 2, 1}));\n        System.out.println(longestMonotonicSubarray(new int[] {1, 1, 1, 1, 1}));\n        System.out.println(longestMonotonicSubarray(new int[] {1, 2, 2, 3, 3, 4, 5}));\n        System.out.println(longestMonotonicSubarray(new int[] {5, 4, 4, 3, 2, 1}));\n        System.out.println(longestMonotonicSubarray(new int[] {1, 2, 1, 2, 3, 4}));\n        System.out.println(longestMonotonicSubarray(new int[] {1, 2, 3, 2, 1}));\n        System.out.println(longestMonotonicSubarray(new int[] {1, 3, 2, 4, 5}));\n    }\n}", "TAG": "Success"}
{"source_Lan": "python###numberOfPairs.py", "source_code_str": "def numberOfPairs( points: List[List[int]]) -> int:\n    points.sort(key=lambda p: (p[0], -p[1]))\n    ans = 0\n    for i, (_, y0) in enumerate(points):\n        max_y = -inf\n        for (_, y) in points[i + 1:]:\n            if max_y < y <= y0:\n                max_y = y\n                ans += 1\n    return ans", "source_code_block": "", "target_Lan": "java###numberOfPairs_Test.java", "reference_code": "    public static int numberOfPairs(int[][] points) {\n        Arrays.sort(points, (p, q) -> p[0] != q[0] ? p[0] - q[0] : q[1] - p[1]);\n        int ans = 0;\n        for (int i = 0; i < points.length; i++) {\n            int y0 = points[i][1];\n            int maxY = Integer.MIN_VALUE;\n            for (int j = i + 1; j < points.length; j++) {\n                int y = points[j][1];\n                if (y <= y0 && y > maxY) {\n                    maxY = y;\n                    ans++;\n                }\n            }\n        }\n        return ans;\n    }", "target_method_signature": "numberOfPairs", "source_method_signature": "numberOfPairs", "target_allMS": "    public static int numberOfPairs(int[][] points) {", "source_allMS": "def numberOfPairs( points: List[List[int]]) -> int:", "source_import": "", "target_import": "import java.util.*;\nimport java.lang.*;", "commentTag": "//", "source_code_shell": "from typing import List\nfrom math import inf\n# TOFILL\nif __name__ == \"__main__\":\n    print(numberOfPairs([[0, 0]]))  # Test Input 1\n    print(numberOfPairs([[1, 2], [1, 3], [2, 5]]))  # Test Input 2\n    print(numberOfPairs([[1, 2], [2, 1], [2, 3], [1, 4]]))  # Test Input 3\n    print(numberOfPairs([[-1, 2], [-1, 1], [0, 0], [1, -1], [1, 1]]))  # Test Input 4\n    print(numberOfPairs([[5, 5], [5, 5], [4, 4], [4, 3], [3, 3]]))  # Test Input 5\n    print(numberOfPairs([[1, 2], [1, 2], [1, 2], [1, 2]]))  # Test Input 6\n    print(numberOfPairs([[3, -1], [3, 0], [3, 2], [3, 1]]))  # Test Input 7\n    print(numberOfPairs([[10, 10], [10, 10], [10, 20], [10, 15]]))  # Test Input 8\n    print(numberOfPairs([[2, 1], [2, 2], [3, 0], [1, 3]]))  # Test Input 9\n    print(numberOfPairs([[1, 3], [2, 2], [3, 1], [4, 0]]))  # Test Input 10", "all_input_output_value": "\ninput1: points=[[0, 0]]\noutput1: 0\n--------\ninput2: points=[[1, 2], [1, 3], [2, 5]]\noutput2: 1\n--------\ninput3: points=[[1, 2], [2, 1], [2, 3], [1, 4]]\noutput3: 4\n--------\ninput4: points=[[-1, 2], [-1, 1], [0, 0], [1, -1], [1, 1]]\noutput4: 5\n--------\ninput5: points=[[5, 5], [5, 5], [4, 4], [4, 3], [3, 3]]\noutput5: 3\n--------\ninput6: points=[[1, 2], [1, 2], [1, 2], [1, 2]]\noutput6: 3\n--------\ninput7: points=[[3, -1], [3, 0], [3, 2], [3, 1]]\noutput7: 3\n--------\ninput8: points=[[10, 10], [10, 10], [10, 20], [10, 15]]\noutput8: 3\n--------\ninput9: points=[[2, 1], [2, 2], [3, 0], [1, 3]]\noutput9: 3\n--------\ninput10: points=[[1, 3], [2, 2], [3, 1], [4, 0]]\noutput10: 3\n", "input_output_value": ["\ninput1: points=[[0, 0]]\noutput1: 0\n", "\ninput2: points=[[1, 2], [1, 3], [2, 5]]\noutput2: 1\n", "\ninput3: points=[[1, 2], [2, 1], [2, 3], [1, 4]]\noutput3: 4\n"], "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.Arrays;\npublic class numberOfPairs_Test {\n// TOFILL\npublic static void main(String[] args) {\n        System.out.println(numberOfPairs(new int[][]{{0, 0}}));\n        System.out.println(numberOfPairs(new int[][]{{1, 2}, {1, 3}, {2, 5}}));\n        System.out.println(numberOfPairs(new int[][]{{1, 2}, {2, 1}, {2, 3}, {1, 4}}));\n        System.out.println(numberOfPairs(new int[][]{{-1, 2}, {-1, 1}, {0, 0}, {1, -1}, {1, 1}}));\n        System.out.println(numberOfPairs(new int[][]{{5, 5}, {5, 5}, {4, 4}, {4, 3}, {3, 3}}));\n        System.out.println(numberOfPairs(new int[][]{{1, 2}, {1, 2}, {1, 2}, {1, 2}}));\n        System.out.println(numberOfPairs(new int[][]{{3, -1}, {3, 0}, {3, 2}, {3, 1}}));\n        System.out.println(numberOfPairs(new int[][]{{10, 10}, {10, 10}, {10, 20}, {10, 15}}));\n        System.out.println(numberOfPairs(new int[][]{{2, 1}, {2, 2}, {3, 0}, {1, 3}}));\n        System.out.println(numberOfPairs(new int[][]{{1, 3}, {2, 2}, {3, 1}, {4, 0}}));\n    }\n}", "TAG": "Success"}
{"source_Lan": "python###findPeakGrid.py", "source_code_str": "def findPeakGrid( mat: List[List[int]]) -> List[int]:\n       m = len(mat)\n       low, high = 0, m - 1\n       while low <= high:\n           i = (low + high) // 2\n           j = mat[i].index(max(mat[i]))\n           if i - 1 >= 0 and mat[i][j] < mat[i - 1][j]:\n               high = i - 1\n               continue\n           if i + 1 < m and mat[i][j] < mat[i + 1][j]:\n               low = i + 1\n               continue\n           return [i, j]\n       return None", "source_code_block": "", "target_Lan": "java###findPeakGrid_Test.java", "reference_code": "public static int[] findPeakGrid(int[][] mat) {\n        int m = mat.length, n = mat[0].length;\n        int low = 0, high = m - 1;\n        while (low <= high) {\n            int i = (low + high) / 2;\n            int j = -1, maxElement = -1;\n            for (int k = 0; k < n; k++) {\n                if (mat[i][k] > maxElement) {\n                    j = k;\n                    maxElement = mat[i][k];\n                }\n            }\n            if (i - 1 >= 0 && mat[i][j] < mat[i - 1][j]) {\n                high = i - 1;\n                continue;\n            }\n            if (i + 1 < m && mat[i][j] < mat[i + 1][j]) {\n                low = i + 1;\n                continue;\n            }\n            return new int[]{i, j};\n        }\n        return new int[0]; \n    }", "target_method_signature": "findPeakGrid", "source_method_signature": "findPeakGrid", "source_allMS": "def findPeakGrid( mat: List[List[int]]) -> List[int]:", "source_import": "from typing import List", "target_import": "import java.util.*;\nimport java.lang.*;\nimport java.util.Arrays;", "commentTag": "//", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.Arrays;\nimport java.util.Arrays;\npublic class findPeakGrid_Test {\n// TOFILL\npublic static void main(String[] args) {\n        int[][] input1 = {{1}};\n        int[][] input2 = {{1, 2, 3, 4}};\n        int[][] input3 = {{10}, {20}, {15}};\n        int[][] input4 = {{1, 2, 1}, {3, 4, 5}, {1, 6, 1}};\n        int[][] input5 = {{1, 1, 1}, {1, 1, 1}, {1, 1, 1}};\n        int[][] input6 = {{1, 2, 1}, {0, 3, 0}, {1, 2, 1}};\n        int[][] input7 = {{5, 1, 2}, {4, 7, 3}, {8, 6, 0}};\n        int[][] input8 = {{14, 12}, {19, 20}, {18, 16}};\n        int[][] input9 = {{10, 9, 8}, {10, 7, 6}, {10, 5, 1}};\n        int[][] input10 = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 4, 3, 2}};\n\n        System.out.println(Arrays.toString(findPeakGrid(input1)));\n        System.out.println(Arrays.toString(findPeakGrid(input2)));\n        System.out.println(Arrays.toString(findPeakGrid(input3)));\n        System.out.println(Arrays.toString(findPeakGrid(input4)));\n        System.out.println(Arrays.toString(findPeakGrid(input5)));\n        System.out.println(Arrays.toString(findPeakGrid(input6)));\n        System.out.println(Arrays.toString(findPeakGrid(input7)));\n        System.out.println(Arrays.toString(findPeakGrid(input8)));\n        System.out.println(Arrays.toString(findPeakGrid(input9)));\n        System.out.println(Arrays.toString(findPeakGrid(input10)));\n    }\n}", "all_input_output_value": "\ninput1: mat=[[1]]\noutput1: [0, 0]\n--------\ninput2: mat=[[1, 2, 3, 4]]\noutput2: [0, 3]\n--------\ninput3: mat=[[10], [20], [15]]\noutput3: [1, 0]\n--------\ninput4: mat=[[1, 2, 1], [3, 4, 5], [1, 6, 1]]\noutput4: [1, 2]\n--------\ninput5: mat=[[1, 1, 1], [1, 1, 1], [1, 1, 1]]\noutput5: [1, 0]\n--------\ninput6: mat=[[1, 2, 1], [0, 3, 0], [1, 2, 1]]\noutput6: [1, 1]\n--------\ninput7: mat=[[5, 1, 2], [4, 7, 3], [8, 6, 0]]\noutput7: [1, 1]\n--------\ninput8: mat=[[14, 12], [19, 20], [18, 16]]\noutput8: [1, 1]\n--------\ninput9: mat=[[10, 9, 8], [10, 7, 6], [10, 5, 1]]\noutput9: [1, 0]\n--------\ninput10: mat=[[1, 2, 3, 4], [5, 6, 7, 8], [9, 4, 3, 2]]\noutput10: [1, 3]\n", "target_allMS": "public static int[] findPeakGrid(int[][] mat) {", "input_output_value": ["\ninput1: mat=[[1]]\noutput1: [0, 0]\n", "\ninput2: mat=[[1, 2, 3, 4]]\noutput2: [0, 3]\n", "\ninput3: mat=[[10], [20], [15]]\noutput3: [1, 0]\n"], "TAG": "Success", "source_code_shell": "from typing import List\nfrom typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(findPeakGrid([[1]]))  # Test Input 1\n    print(findPeakGrid([[1, 2, 3, 4]]))  # Test Input 2\n    print(findPeakGrid([[10], [20], [15]]))  # Test Input 3\n    print(findPeakGrid([[1, 2, 1], [3, 4, 5], [1, 6, 1]]))  # Test Input 4\n    print(findPeakGrid([[1, 1, 1], [1, 1, 1], [1, 1, 1]]))  # Test Input 5\n    print(findPeakGrid([[1, 2, 1], [0, 3, 0], [1, 2, 1]]))  # Test Input 6\n    print(findPeakGrid([[5, 1, 2], [4, 7, 3], [8, 6, 0]]))  # Test Input 7\n    print(findPeakGrid([[14, 12], [19, 20], [18, 16]]))  # Test Input 8\n    print(findPeakGrid([[10, 9, 8], [10, 7, 6], [10, 5, 1]]))  # Test Input 9\n    print(findPeakGrid([[1, 2, 3, 4], [5, 6, 7, 8], [9, 4, 3, 2]]))  # Test Input 10"}
{"source_Lan": "python###findTheCity.py", "source_code_str": "def findTheCity( n: int, edges: List[List[int]], distanceThreshold: int) -> int:\n        ans = (inf, -1)\n        mp = [[inf] * n for _ in range(n)]\n        for fr, to, weight in edges:\n            mp[fr][to], mp[to][fr] = weight, weight\n        for k in range(n):\n            mp[k][k] = 0\n            for i in range(n):\n                for j in range(n):\n                    mp[i][j] = min(mp[i][j], mp[i][k] + mp[k][j])\n        for i in range(n):\n            cnt = sum(mp[i][j] <= distanceThreshold for j in range(n))\n            if cnt <= ans[0]:\n                ans = (cnt, i)\n        return ans[1]", "source_code_block": "", "target_Lan": "java###findTheCity_Test.java", "reference_code": "public static int findTheCity(int n, int[][] edges, int distanceThreshold) {\n        int[] ans = {Integer.MAX_VALUE / 2, -1};\n        int[][] mp = new int[n][n];\n        for (int i = 0; i < n; ++i) {\n            Arrays.fill(mp[i], Integer.MAX_VALUE / 2);\n        }\n        for (int[] eg : edges) {\n            int from = eg[0], to = eg[1], weight = eg[2];\n            mp[from][to] = mp[to][from] = weight;\n        }\n        for (int k = 0; k < n; ++k) {\n            mp[k][k] = 0;\n            for (int i = 0; i < n; ++i) {\n                for (int j = 0; j < n; ++j) {\n                    mp[i][j] = Math.min(mp[i][j], mp[i][k] + mp[k][j]);\n                }\n            }\n        }\n        for (int i = 0; i < n; ++i) {\n            int cnt = 0;\n            for (int j = 0; j < n; ++j) {\n                if (mp[i][j] <= distanceThreshold) {\n                    cnt++;\n                }\n            }\n            if (cnt <= ans[0]) {\n                ans[0] = cnt;\n                ans[1] = i;\n            }\n        }\n        return ans[1];\n    }", "target_method_signature": "findTheCity", "source_method_signature": "findTheCity", "source_allMS": "def findTheCity( n: int, edges: List[List[int]], distanceThreshold: int) -> int:", "source_import": "from typing import List\nfrom math import inf", "target_import": "import java.util.Arrays;", "commentTag": "//", "target_code_shell": "import java.util.Arrays;\nimport java.util.Arrays;\npublic class findTheCity_Test {\n// TOFILL\npublic static void main(String[] args) {\n        System.out.println(findTheCity(3, new int[][]{{0, 1, 4}, {1, 2, 1}, {0, 2, 2}}, 3));\n        System.out.println(findTheCity(4, new int[][]{{0, 1, 10}, {0, 2, 10}, {1, 2, 1}, {2, 3, 1}}, 2));\n        System.out.println(findTheCity(5, new int[][]{{0, 1, 1}, {1, 2, 1}, {2, 3, 1}, {3, 4, 1}, {0, 4, 5}}, 3));\n        System.out.println(findTheCity(5, new int[][]{{0, 1, 2}, {1, 2, 2}, {2, 3, 2}, {3, 4, 2}, {0, 4, 10}}, 5));\n        System.out.println(findTheCity(2, new int[][]{{0, 1, 3}}, 4));\n        System.out.println(findTheCity(1, new int[][]{}, 0));\n        System.out.println(findTheCity(3, new int[][]{{0, 1, 2}, {1, 2, 5}}, 5));\n        System.out.println(findTheCity(6, new int[][]{{0, 1, 3}, {1, 2, 2}, {2, 3, 4}, {3, 4, 1}, {4, 5, 6}, {0, 5, 10}}, 8));\n        System.out.println(findTheCity(4, new int[][]{{0, 1, 4}, {1, 3, 5}, {0, 2, 2}, {2, 3, 1}}, 6));\n        System.out.println(findTheCity(4, new int[][]{{0, 1, 2}, {1, 2, 2}, {2, 3, 2}, {0, 3, 7}}, 5));\n    }\n}", "all_input_output_value": "\ninput1: n=3, edges=[[0,1,4],[1,2,1],[0,2,2]], distanceThreshold=3\noutput1: 2\n--------\ninput2: n=4, edges=[[0,1,10],[0,2,10],[1,2,1],[2,3,1]], distanceThreshold=2\noutput2: 0\n--------\ninput3: n=5, edges=[[0,1,1],[1,2,1],[2,3,1],[3,4,1],[0,4,5]], distanceThreshold=3\noutput3: 4\n--------\ninput4: n=5, edges=[[0,1,2],[1,2,2],[2,3,2],[3,4,2],[0,4,10]], distanceThreshold=5\noutput4: 4\n--------\ninput5: n=2, edges=[[0,1,3]], distanceThreshold=4\noutput5: 1\n--------\ninput6: n=1, edges=[], distanceThreshold=0\noutput6: 0\n--------\ninput7: n=3, edges=[[0,1,2],[1,2,5]], distanceThreshold=5\noutput7: 2\n--------\ninput8: n=6, edges=[[0,1,3],[1,2,2],[2,3,4],[3,4,1],[4,5,6],[0,5,10]], distanceThreshold=8\noutput8: 5\n--------\ninput9: n=4, edges=[[0,1,4],[1,3,5],[0,2,2],[2,3,1]], distanceThreshold=6\noutput9: 3\n--------\ninput10: n=4, edges=[[0,1,2],[1,2,2],[2,3,2],[0,3,7]], distanceThreshold=5\noutput10: 3\n", "target_allMS": "public static int findTheCity(int n, int[][] edges, int distanceThreshold) {", "input_output_value": ["\ninput1: n=3, edges=[[0,1,4],[1,2,1],[0,2,2]], distanceThreshold=3\noutput1: 2\n", "\ninput2: n=4, edges=[[0,1,10],[0,2,10],[1,2,1],[2,3,1]], distanceThreshold=2\noutput2: 0\n", "\ninput3: n=5, edges=[[0,1,1],[1,2,1],[2,3,1],[3,4,1],[0,4,5]], distanceThreshold=3\noutput3: 4\n"], "TAG": "Success", "source_code_shell": "from typing import List\nfrom math import inf\nfrom typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(findTheCity(3, [[0,1,4],[1,2,1],[0,2,2]], 3))\n    print(findTheCity(4, [[0,1,10],[0,2,10],[1,2,1],[2,3,1]], 2))\n    print(findTheCity(5, [[0,1,1],[1,2,1],[2,3,1],[3,4,1],[0,4,5]], 3))\n    print(findTheCity(5, [[0,1,2],[1,2,2],[2,3,2],[3,4,2],[0,4,10]], 5))\n    print(findTheCity(2, [[0,1,3]], 4))\n    print(findTheCity(1, [], 0))\n    print(findTheCity(3, [[0,1,2],[1,2,5]], 5))\n    print(findTheCity(6, [[0,1,3],[1,2,2],[2,3,4],[3,4,1],[4,5,6],[0,5,10]], 8))\n    print(findTheCity(4, [[0,1,4],[1,3,5],[0,2,2],[2,3,1]], 6))\n    print(findTheCity(4, [[0,1,2],[1,2,2],[2,3,2],[0,3,7]], 5))"}
{"source_Lan": "python###fullBloomFlowers.py", "source_code_str": "def fullBloomFlowers( flowers: List[List[int]], people: List[int]) -> List[int]:\n        cnt = collections.defaultdict(int)\n        for start, end in flowers:\n            cnt[start] += 1\n            cnt[end + 1] -= 1\n        arr = sorted(cnt.items())\n        m = len(people)\n        ans = [0] * m\n        j, curr = 0, 0\n        for p, i in sorted(zip(people, range(m))):\n            while j < len(arr) and arr[j][0] <= p:\n                curr += arr[j][1]\n                j += 1\n            ans[i] = curr\n        return ans", "source_code_block": "", "target_Lan": "java###fullBloomFlowers_Test.java", "reference_code": " public static int[] fullBloomFlowers(int[][] flowers, int[] persons) {\n        TreeMap<Integer, Integer> cnt = new TreeMap<>();\n        for (int[] flower : flowers) {\n            cnt.put(flower[0], cnt.getOrDefault(flower[0], 0) + 1);\n            cnt.put(flower[1] + 1, cnt.getOrDefault(flower[1] + 1, 0) - 1);\n        }\n        int m = persons.length;\n        Integer[] indices = IntStream.range(0, m).boxed().toArray(Integer[]::new);\n        Arrays.sort(indices, (i, j) -> persons[i] - persons[j]);\n        int[] ans = new int[m];\n        int curr = 0;\n        for (int x : indices) {\n            while (!cnt.isEmpty() && cnt.firstKey() <= persons[x]) {\n                curr += cnt.pollFirstEntry().getValue();\n            }\n            ans[x] = curr;\n        }\n        return ans;\n    }", "target_method_signature": "fullBloomFlowers", "source_method_signature": "fullBloomFlowers", "source_allMS": "def fullBloomFlowers( flowers: List[List[int]], people: List[int]) -> List[int]:", "source_import": "from typing import List\nimport collections", "target_import": "import java.util.*;\nimport java.lang.*;\nimport java.util.Arrays;\nimport java.util.Map;\nimport java.util.TreeMap;\nimport java.util.stream.IntStream;", "commentTag": "//", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.Arrays;\nimport java.util.Map;\nimport java.util.TreeMap;\nimport java.util.stream.IntStream;\nimport java.util.Arrays;\nimport java.util.TreeMap;\nimport java.util.stream.IntStream;\npublic class fullBloomFlowers_Test {\n// TOFILL\npublic static void main(String[] args) {\n        int[][] flowers1 = {{1, 4}, {2, 3}};\n        int[] people1 = {1, 2, 3, 4, 5};\n        System.out.println(Arrays.toString(fullBloomFlowers(flowers1, people1)));\n\n        int[][] flowers2 = {{1, 5}, {2, 6}, {3, 4}};\n        int[] people2 = {2, 3, 4};\n        System.out.println(Arrays.toString(fullBloomFlowers(flowers2, people2)));\n\n        int[][] flowers3 = {{1, 10}, {3, 5}, {6, 9}};\n        int[] people3 = {4, 8, 5};\n        System.out.println(Arrays.toString(fullBloomFlowers(flowers3, people3)));\n\n        int[][] flowers4 = {{0, 1}, {1, 2}, {2, 3}};\n        int[] people4 = {0, 1, 2};\n        System.out.println(Arrays.toString(fullBloomFlowers(flowers4, people4)));\n\n        int[][] flowers5 = {{1, 2}, {1, 3}, {2, 4}};\n        int[] people5 = {0, 4, 5};\n        System.out.println(Arrays.toString(fullBloomFlowers(flowers5, people5)));\n\n        int[][] flowers6 = {{5, 7}, {1, 2}, {10, 12}};\n        int[] people6 = {2, 6, 10, 11};\n        System.out.println(Arrays.toString(fullBloomFlowers(flowers6, people6)));\n\n        int[][] flowers7 = {{0, 1}};\n        int[] people7 = {0, 1, 2};\n        System.out.println(Arrays.toString(fullBloomFlowers(flowers7, people7)));\n\n        int[][] flowers8 = {{0, 0}, {0, 0}};\n        int[] people8 = {0};\n        System.out.println(Arrays.toString(fullBloomFlowers(flowers8, people8)));\n\n        int[][] flowers9 = {{1, 1}};\n        int[] people9 = {0, 1};\n        System.out.println(Arrays.toString(fullBloomFlowers(flowers9, people9)));\n    }\n}", "all_input_output_value": "\ninput1: flowers=[[1, 4], [2, 3]], people=[1, 2, 3, 4, 5]\noutput1: [1, 2, 2, 1, 0]\n--------\ninput2: flowers=[[1, 5], [2, 6], [3, 4]], people=[2, 3, 4]\noutput2: [2, 3, 3]\n--------\ninput3: flowers=[[1, 10], [3, 5], [6, 9]], people=[4, 8, 5]\noutput3: [2, 2, 2]\n--------\ninput4: flowers=[[0, 1], [1, 2], [2, 3]], people=[0, 1, 2]\noutput4: [1, 2, 2]\n--------\ninput5: flowers=[[1, 2], [1, 3], [2, 4]], people=[0, 4, 5]\noutput5: [0, 1, 0]\n--------\ninput6: flowers=[[5, 7], [1, 2], [10, 12]], people=[2, 6, 10, 11]\noutput6: [1, 1, 1, 1]\n--------\ninput7: flowers=[[0, 1]], people=[0, 1, 2]\noutput7: [1, 1, 0]\n--------\ninput8: flowers=[[0, 0], [0, 0]], people=[0]\noutput8: [2]\n--------\ninput9: flowers=[[1, 1]], people=[0, 1]\noutput9: [0, 1]\n", "target_allMS": " public static int[] fullBloomFlowers(int[][] flowers, int[] persons) {", "input_output_value": ["\ninput1: flowers=[[1, 4], [2, 3]], people=[1, 2, 3, 4, 5]\noutput1: [1, 2, 2, 1, 0]\n", "\ninput2: flowers=[[1, 5], [2, 6], [3, 4]], people=[2, 3, 4]\noutput2: [2, 3, 3]\n", "\ninput3: flowers=[[1, 10], [3, 5], [6, 9]], people=[4, 8, 5]\noutput3: [2, 2, 2]\n"], "TAG": "Success", "source_code_shell": "from typing import List\nimport collections\nfrom typing import List\nimport collections\n# TOFILL\nif __name__ == \"__main__\":\n    print(fullBloomFlowers([[1, 4], [2, 3]], [1, 2, 3, 4, 5]))\n    print(fullBloomFlowers([[1, 5], [2, 6], [3, 4]], [2, 3, 4]))\n    print(fullBloomFlowers([[1, 10], [3, 5], [6, 9]], [4, 8, 5]))\n    print(fullBloomFlowers([[0, 1], [1, 2], [2, 3]], [0, 1, 2]))\n    print(fullBloomFlowers([[1, 2], [1, 3], [2, 4]], [0, 4, 5]))\n    print(fullBloomFlowers([[5, 7], [1, 2], [10, 12]], [2, 6, 10, 11]))\n    print(fullBloomFlowers([[0, 1]], [0, 1, 2]))\n    print(fullBloomFlowers([[0, 0], [0, 0]], [0]))\n    print(fullBloomFlowers([[1, 1]], [0, 1]))"}
{"source_Lan": "python###giveGem.py", "source_code_str": "def giveGem( gem: List[int], operations: List[List[int]]) -> int:\n        for x, y in operations:\n            number = gem[x] // 2\n            gem[x] -= number\n            gem[y] += number\n        mn, mx = gem[0], gem[0]\n        for number in gem:\n            mn = min(number, mn)\n            mx = max(number, mx)\n        return mx - mn", "source_code_block": "", "target_Lan": "java###giveGem_Test.java", "reference_code": "public static int giveGem(int[] gem, int[][] operations) {\n        for (int[] operation : operations) {\n            int x = operation[0], y = operation[1];\n            int number = gem[x] / 2;\n            gem[x] -= number;\n            gem[y] += number;\n        }\n        int mn = gem[0], mx = gem[0];\n        for (int number : gem) {\n            mn = Math.min(number, mn);\n            mx = Math.max(number, mx);\n        }\n        return mx - mn;\n    }", "target_method_signature": "giveGem", "source_method_signature": "giveGem", "source_allMS": "def giveGem( gem: List[int], operations: List[List[int]]) -> int:", "source_import": "from typing import List", "target_import": "import java.util.Arrays;", "commentTag": "//", "target_code_shell": "import java.util.Arrays;\nimport java.util.Arrays;\npublic class giveGem_Test {\n// TOFILL\npublic static void main(String[] args) {\n        System.out.println(giveGem(new int[]{10, 0, 0}, new int[][]{{0, 1}, {0, 2}})); // Expected output: 10\n        System.out.println(giveGem(new int[]{10, 5, 5}, new int[][]{{0, 1}, {1, 2}})); // Expected output: 5\n        System.out.println(giveGem(new int[]{4, 4, 4}, new int[][]{{0, 1}, {1, 0}, {0, 2}})); // Expected output: 0\n        System.out.println(giveGem(new int[]{2, 2, 2}, new int[][]{})); // Expected output: 0\n        System.out.println(giveGem(new int[]{0, 0, 0}, new int[][]{{0, 1}})); // Expected output: 0\n        System.out.println(giveGem(new int[]{9, 1, 0}, new int[][]{{0, 2}, {1, 0}})); // Expected output: 8\n        System.out.println(giveGem(new int[]{8, 8, 8}, new int[][]{{0, 1}, {1, 2}, {2, 0}})); // Expected output: 0\n        System.out.println(giveGem(new int[]{13, 11, 10}, new int[][]{{0, 1}, {1, 2}})); // Expected output: 3\n        System.out.println(giveGem(new int[]{5, 7, 9}, new int[][]{{0, 1}})); // Expected output: 4\n        System.out.println(giveGem(new int[]{100, 250, 350}, new int[][]{{0, 1}, {1, 2}, {2, 0}})); // Expected output: 250\n    }\n}", "all_input_output_value": "\ninput1: gem=[10, 0, 0], operations=[[0, 1], [0, 2]]\noutput1: 3\n--------\ninput2: gem=[10, 5, 5], operations=[[0, 1], [1, 2]]\noutput2: 5\n--------\ninput3: gem=[4, 4, 4], operations=[[0, 1], [1, 0], [0, 2]]\noutput3: 3\n--------\ninput4: gem=[2, 2, 2], operations=[]\noutput4: 0\n--------\ninput5: gem=[0, 0, 0], operations=[[0, 1]]\noutput5: 0\n--------\ninput6: gem=[9, 1, 0], operations=[[0, 2], [1, 0]]\noutput6: 4\n--------\ninput7: gem=[8, 8, 8], operations=[[0, 1], [1, 2], [2, 0]]\noutput7: 5\n--------\ninput8: gem=[13, 11, 10], operations=[[0, 1], [1, 2]]\noutput8: 11\n--------\ninput9: gem=[5, 7, 9], operations=[[0, 1]]\noutput9: 6\n--------\ninput10: gem=[100, 250, 350], operations=[[0, 1], [1, 2], [2, 0]]\noutput10: 150\n", "target_allMS": "public static int giveGem(int[] gem, int[][] operations) {", "input_output_value": ["\ninput1: gem=[10, 0, 0], operations=[[0, 1], [0, 2]]\noutput1: 3\n", "\ninput2: gem=[10, 5, 5], operations=[[0, 1], [1, 2]]\noutput2: 5\n", "\ninput3: gem=[4, 4, 4], operations=[[0, 1], [1, 0], [0, 2]]\noutput3: 3\n"], "TAG": "Success", "source_code_shell": "from typing import List\nfrom typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(giveGem([10, 0, 0], [[0, 1], [0, 2]]))\n    print(giveGem([10, 5, 5], [[0, 1], [1, 2]]))\n    print(giveGem([4, 4, 4], [[0, 1], [1, 0], [0, 2]]))\n    print(giveGem([2, 2, 2], []))\n    print(giveGem([0, 0, 0], [[0, 1]]))\n    print(giveGem([9, 1, 0], [[0, 2], [1, 0]]))\n    print(giveGem([8, 8, 8], [[0, 1], [1, 2], [2, 0]]))\n    print(giveGem([13, 11, 10], [[0, 1], [1, 2]]))\n    print(giveGem([5, 7, 9], [[0, 1]]))\n    print(giveGem([100, 250, 350], [[0, 1], [1, 2], [2, 0]]))"}
{"source_Lan": "python###minTrioDegree2.py", "source_code_str": "def minTrioDegree2(n: int, edges: List[List[int]]) -> int:\n    g = defaultdict(set)\n\n    h = defaultdict(list)\n    degree = [0] * n\n    for x, y in edges:\n        x, y = x - 1, y - 1\n        g[x].add(y)\n        g[y].add(x)\n        degree[x] += 1\n        degree[y] += 1\n    for x, y in edges:\n        x, y = x - 1, y - 1\n        if degree[x] < degree[y] or (degree[x] == degree[y] and x < y):\n            h[x].append(y)\n        else:\n            h[y].append(x)\n    ans = inf\n    for i in range(n):\n        for j in h[i]:\n            for k in h[j]:\n                if k in g[i]:\n                    ans = min(ans, degree[i] + degree[j] + degree[k] - 6)\n    return -1 if ans == inf else ans\n    ", "source_code_block": "", "target_Lan": "java###minTrioDegree2_Test.java", "reference_code": "public static int minTrioDegree2(int n, int[][] edges) {\n        \n        Set<Integer>[] g = new Set[n];\n        for (int i = 0; i < n; ++i) {\n            g[i] = new HashSet<Integer>();\n        }\n        \n        List<Integer>[] h = new List[n];\n        for (int i = 0; i < n; ++i) {\n            h[i] = new ArrayList<Integer>();\n        }\n        int[] degree = new int[n];\n        for (int[] edge : edges) {\n            int x = edge[0] - 1, y = edge[1] - 1;\n            g[x].add(y);\n            g[y].add(x);\n            ++degree[x];\n            ++degree[y];\n        }\n        for (int[] edge : edges) {\n            int x = edge[0] - 1, y = edge[1] - 1;\n            if (degree[x] < degree[y] || (degree[x] == degree[y] && x < y)) {\n                h[x].add(y);\n            } else {\n                h[y].add(x);\n            }\n        }\n        int ans = Integer.MAX_VALUE;\n        for (int i = 0; i < n; ++i) {\n            for (int j : h[i]) {\n                for (int k : h[j]) {\n                    if (g[i].contains(k)) {\n                        ans = Math.min(ans, degree[i] + degree[j] + degree[k] - 6);\n                    }\n                }\n            }\n        }\n        return ans == Integer.MAX_VALUE ? -1 : ans;\n    }", "target_method_signature": "minTrioDegree2", "source_method_signature": "minTrioDegree2", "source_allMS": "def minTrioDegree2( n: int, edges: List[List[int]]) -> int:", "source_import": "from collections import defaultdict\nfrom typing import List\nfrom math import inf", "target_import": "import java.util.*;\nimport java.lang.*;\nimport java.util.*;", "commentTag": "//", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.*;\nimport java.util.*;\npublic class minTrioDegree2_Test {\n// TOFILL\npublic static void main(String[] args) {\n        System.out.println(minTrioDegree2(1, new int[][]{}));\n        System.out.println(minTrioDegree2(3, new int[][]{{1, 2}, {2, 3}}));\n        System.out.println(minTrioDegree2(4, new int[][]{{1, 2}, {2, 3}, {1, 3}, {1, 4}}));\n        System.out.println(minTrioDegree2(5, new int[][]{{1, 2}, {1, 3}, {2, 3}, {3, 4}}));\n        System.out.println(minTrioDegree2(5, new int[][]{{1, 2}, {2, 3}, {3, 4}, {4, 5}, {5, 1}}));\n        System.out.println(minTrioDegree2(6, new int[][]{{1, 2}, {1, 3}, {2, 3}, {2, 4}, {3, 4}}));\n        System.out.println(minTrioDegree2(6, new int[][]{{1, 2}, {1, 3}, {2, 4}, {4, 5}, {5, 6}, {3, 6}}));\n        System.out.println(minTrioDegree2(5, new int[][]{{1, 2}, {2, 3}, {3, 4}, {4, 5}}));\n        System.out.println(minTrioDegree2(3, new int[][]{{1, 2}, {1, 3}, {2, 3}}));\n        System.out.println(minTrioDegree2(4, new int[][]{{1, 2}, {1, 3}, {2, 4}, {3, 4}}));\n    }\n}", "all_input_output_value": "\ninput1: n=1, edges=[]\noutput1: -1\n--------\ninput2: n=3, edges=[[1, 2], [2, 3]]\noutput2: -1\n--------\ninput3: n=4, edges=[[1, 2], [2, 3], [1, 3], [1, 4]]\noutput3: 1\n--------\ninput4: n=5, edges=[[1, 2], [1, 3], [2, 3], [3, 4]]\noutput4: 1\n--------\ninput5: n=5, edges=[[1, 2], [2, 3], [3, 4], [4, 5], [5, 1]]\noutput5: -1\n--------\ninput6: n=6, edges=[[1, 2], [1, 3], [2, 3], [2, 4], [3, 4]]\noutput6: 2\n--------\ninput7: n=6, edges=[[1, 2], [1, 3], [2, 4], [4, 5], [5, 6], [3, 6]]\noutput7: -1\n--------\ninput8: n=5, edges=[[1, 2], [2, 3], [3, 4], [4, 5]]\noutput8: -1\n--------\ninput9: n=3, edges=[[1, 2], [1, 3], [2, 3]]\noutput9: 0\n--------\ninput10: n=4, edges=[[1, 2], [1, 3], [2, 4], [3, 4]]\noutput10: -1\n", "target_allMS": "public static int minTrioDegree2(int n, int[][] edges) {", "input_output_value": ["\ninput1: n=1, edges=[]\noutput1: -1\n", "\ninput2: n=3, edges=[[1, 2], [2, 3]]\noutput2: -1\n", "\ninput3: n=4, edges=[[1, 2], [2, 3], [1, 3], [1, 4]]\noutput3: 1\n"], "TAG": "Success", "source_code_shell": "from collections import defaultdict\nfrom typing import List\nfrom math import inf\nfrom collections import defaultdict\nfrom typing import List\nfrom math import inf\n# TOFILL\nif __name__ == \"__main__\":\n    print(minTrioDegree2(1, []))\n    print(minTrioDegree2(3, [[1, 2], [2, 3]]))\n    print(minTrioDegree2(4, [[1, 2], [2, 3], [1, 3], [1, 4]]))\n    print(minTrioDegree2(5, [[1, 2], [1, 3], [2, 3], [3, 4]]))\n    print(minTrioDegree2(5, [[1, 2], [2, 3], [3, 4], [4, 5], [5, 1]]))\n    print(minTrioDegree2(6, [[1, 2], [1, 3], [2, 3], [2, 4], [3, 4]]))\n    print(minTrioDegree2(6, [[1, 2], [1, 3], [2, 4], [4, 5], [5, 6], [3, 6]]))\n    print(minTrioDegree2(5, [[1, 2], [2, 3], [3, 4], [4, 5]]))\n    print(minTrioDegree2(3, [[1, 2], [1, 3], [2, 3]]))\n    print(minTrioDegree2(4, [[1, 2], [1, 3], [2, 4], [3, 4]]))"}
{"source_Lan": "python###ways.py", "source_code_str": "def ways( pizza: List[str], k: int) -> int:\n        m, n, mod = len(pizza), len(pizza[0]), 10 ** 9 + 7\n        apples = [[0] * (n + 1) for _ in range(m + 1)]\n        dp = [[[0 for j in range(n)] for i in range(m)] for _ in range(k + 1)]\n        \n        for i in range(m - 1, -1, -1):\n            for j in range(n - 1, -1, -1):\n                apples[i][j] = apples[i][j + 1] + apples[i + 1][j] - apples[i + 1][j + 1] + (pizza[i][j] == 'A')\n                dp[1][i][j] = 1 if apples[i][j] > 0 else 0\n        for k in range(1, k + 1):\n            for i in range(m):\n                for j in range(n):\n                    \n                    for i2 in range(i + 1, m):\n                        if apples[i][j] > apples[i2][j]:\n                            dp[k][i][j] = (dp[k][i][j] + dp[k - 1][i2][j]) % mod\n                    \n                    for j2 in range(j + 1, n):\n                        if apples[i][j] > apples[i][j2]:\n                            dp[k][i][j] = (dp[k][i][j] + dp[k - 1][i][j2]) % mod\n        return dp[k][0][0]", "source_code_block": "", "target_Lan": "java###ways_Test.java", "reference_code": "public static int ways(String[] pizza, int k) {\n        int m = pizza.length, n = pizza[0].length(), mod = 1_000_000_007;\n        int[][] apples = new int[m + 1][n + 1];\n        int[][][] dp = new int[k + 1][m + 1][n + 1];\n        \n        for (int i = m - 1; i >= 0; i--) {\n            for (int j = n - 1; j >= 0; j--) {\n                apples[i][j] = apples[i][j + 1] + apples[i + 1][j] - apples[i + 1][j + 1] + (pizza[i].charAt(j) == 'A' ? 1 : 0);\n                dp[1][i][j] = apples[i][j] > 0 ? 1 : 0;\n            }\n        }\n        for (int ki = 2; ki <= k; ki++) {\n            for (int i = 0; i < m; i++) {\n                for (int j = 0; j < n; j++) {\n                    \n                    for (int i2 = i + 1; i2 < m; i2++) {\n                        if (apples[i][j] > apples[i2][j]) {\n                            dp[ki][i][j] = (dp[ki][i][j] + dp[ki - 1][i2][j]) % mod;\n                        }\n                    }\n                    \n                    for (int j2 = j + 1; j2 < n; j2++) {\n                        if (apples[i][j] > apples[i][j2]) {\n                            dp[ki][i][j] = (dp[ki][i][j] + dp[ki - 1][i][j2]) % mod;\n                        }\n                    }\n                }\n            }\n        }\n        return dp[k][0][0];\n    }", "target_method_signature": "ways", "source_method_signature": "ways", "source_allMS": "def ways( pizza: List[str], k: int) -> int:", "source_import": "from typing import List", "target_import": "import java.util.*;\nimport java.lang.*;\nimport java.util.Arrays;", "commentTag": "//", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.Arrays;\nimport java.util.*;\npublic class ways_Test {\n// TOFILL\npublic static void main(String[] args) {\n        String[] pizza1 = {\"A\"};\n        int k1 = 1;\n        System.out.println(ways(pizza1, k1)); // Expected output: 1\n\n        String[] pizza2 = {\"AA\", \"AA\"};\n        int k2 = 1;\n        System.out.println(ways(pizza2, k2)); // Expected output: 1\n\n        String[] pizza3 = {\"A..\", \"AA.\"};\n        int k3 = 2;\n        System.out.println(ways(pizza3, k3)); // Expected output: 2\n\n        String[] pizza4 = {\"A.A\", \".A.\"};\n        int k4 = 2;\n        System.out.println(ways(pizza4, k4)); // Expected output: 1\n\n        String[] pizza5 = {\"AAA\", \"AAA\", \"AAA\"};\n        int k5 = 3;\n        System.out.println(ways(pizza5, k5)); // Expected output: 6\n\n        String[] pizza6 = {\"A..A\", \"....\", \"A.AA\"};\n        int k6 = 3;\n        System.out.println(ways(pizza6, k6)); // Expected output: 3\n\n        String[] pizza7 = {\"AAAA\", \"AAAA\", \"AAAA\"};\n        int k7 = 6;\n        System.out.println(ways(pizza7, k7)); // Expected output: 10\n    }\n}", "all_input_output_value": "\ninput1: pizza=[\"A\"], k=1\noutput1: 1\n--------\ninput2: pizza=[\"AA\", \"AA\"], k=1\noutput2: 1\n--------\ninput3: pizza=[\"A..\", \"AA.\"], k=2\noutput3: 2\n--------\ninput4: pizza=[\"A.A\", \".A.\"], k=2\noutput4: 3\n--------\ninput5: pizza=[\"AAA\", \"AAA\", \"AAA\"], k=3\noutput5: 10\n--------\ninput6: pizza=[\"A..A\", \"....\", \"A.AA\"], k=3\noutput6: 14\n--------\ninput7: pizza=[\"AAAA\", \"AAAA\", \"AAAA\"], k=6\noutput7: 10\n", "target_allMS": "public static int ways(String[] pizza, int k) {", "input_output_value": ["\ninput1: pizza=[\"A\"], k=1\noutput1: 1\n", "\ninput2: pizza=[\"AA\", \"AA\"], k=1\noutput2: 1\n", "\ninput3: pizza=[\"A..\", \"AA.\"], k=2\noutput3: 2\n"], "TAG": "Success", "source_code_shell": "from typing import List\nfrom typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(ways([\"A\"], 1))\n    print(ways([\"AA\", \"AA\"], 1))\n    print(ways([\"A..\", \"AA.\"], 2))\n    print(ways([\"A.A\", \".A.\"], 2))\n    print(ways([\"AAA\", \"AAA\", \"AAA\"], 3))\n    print(ways([\"A..A\", \"....\", \"A.AA\"], 3))\n    print(ways([\"AAAA\", \"AAAA\", \"AAAA\"], 6))"}
{"source_Lan": "python###getMaxProductivity.py", "source_code_str": "def getMaxProductivity( n: int, productivity: List[int]) -> int:\n        total_sum = sum(productivity)\n        \n        dp = [0] * (total_sum + 1)\n        dp[0] = 1\n        \n        for prod in productivity:\n            for j in range(total_sum, prod - 1, -1):\n                dp[j] = dp[j] or dp[j - prod]\n        \n        max_productivity = 0\n        for i in range(1, total_sum):\n            if dp[i]:\n                max_productivity = max(max_productivity, i * (total_sum - i))\n        return max_productivity", "source_code_block": "", "target_Lan": "java###getMaxProductivity_Test.java", "reference_code": "public static int getMaxProductivity(int n, int[] productivity) {\n        int totalSum = 0;\n        for (int val : productivity) {\n            totalSum += val;\n        }\n        int halfSum = totalSum / 2;\n        int[] dp = new int[halfSum + 1];\n        dp[0] = 1;\n        for (int prod : productivity) {\n            for (int j = halfSum; j >= prod; j--) {\n                dp[j] = dp[j] | dp[j - prod];\n            }\n        }\n        int maxProductivity = 0;\n        for (int i = 1; i <= halfSum; i++) {\n            if (dp[i] == 1) {\n                maxProductivity = Math.max(maxProductivity, i * (totalSum - i));\n            }\n        }\n        return maxProductivity;\n    }", "target_method_signature": "getMaxProductivity", "source_method_signature": "getMaxProductivity", "source_allMS": "def getMaxProductivity( n: int, productivity: List[int]) -> int:", "source_import": "from typing import List", "target_import": "import java.util.*;\nimport java.lang.*;\nimport java.util.Arrays;", "commentTag": "//", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.Arrays;\nimport java.util.Arrays;\npublic class getMaxProductivity_Test {\n// TOFILL\npublic static void main(String[] args) {\n        System.out.println(getMaxProductivity(0, new int[] {}));\n        System.out.println(getMaxProductivity(1, new int[] { 5 }));\n        System.out.println(getMaxProductivity(2, new int[] { 10, 20 }));\n        System.out.println(getMaxProductivity(3, new int[] { 10, 20, 30 }));\n        System.out.println(getMaxProductivity(4, new int[] { 1, 1, 1, 1 }));\n        System.out.println(getMaxProductivity(5, new int[] { 1, 2, 3, 4, 5 }));\n        System.out.println(getMaxProductivity(3, new int[] { 1, 5, 10 }));\n        System.out.println(getMaxProductivity(4, new int[] { 100, 200, 300, 400 }));\n        System.out.println(getMaxProductivity(5, new int[] { 1000, 2000, 3000, 4000, 5000 }));\n    }\n}", "all_input_output_value": "\ninput1: n=0, productivity=[]\noutput1: 0\n--------\ninput2: n=1, productivity=[5]\noutput2: 0\n--------\ninput3: n=2, productivity=[10, 20]\noutput3: 200\n--------\ninput4: n=3, productivity=[10, 20, 30]\noutput4: 900\n--------\ninput5: n=4, productivity=[1, 1, 1, 1]\noutput5: 4\n--------\ninput6: n=5, productivity=[1, 2, 3, 4, 5]\noutput6: 56\n--------\ninput7: n=3, productivity=[1, 5, 10]\noutput7: 60\n--------\ninput8: n=4, productivity=[100, 200, 300, 400]\noutput8: 250000\n--------\ninput10: n=5, productivity=[1000, 2000, 3000, 4000, 5000]\noutput10: 56000000\n", "target_allMS": "public static int getMaxProductivity(int n, int[] productivity) {", "input_output_value": ["\ninput1: n=0, productivity=[]\noutput1: 0\n", "\ninput2: n=1, productivity=[5]\noutput2: 0\n", "\ninput3: n=2, productivity=[10, 20]\noutput3: 200\n"], "TAG": "Success", "source_code_shell": "from typing import List\nfrom typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(getMaxProductivity(0, []))                             # Test input 1\n    print(getMaxProductivity(1, [5]))                           # Test input 2\n    print(getMaxProductivity(2, [10, 20]))                      # Test input 3\n    print(getMaxProductivity(3, [10, 20, 30]))                  # Test input 4\n    print(getMaxProductivity(4, [1, 1, 1, 1]))                  # Test input 5\n    print(getMaxProductivity(5, [1, 2, 3, 4, 5]))               # Test input 6\n    print(getMaxProductivity(3, [1, 5, 10]))                    # Test input 7\n    print(getMaxProductivity(4, [100, 200, 300, 400]))          # Test input 8\n    print(getMaxProductivity(5, [1000, 2000, 3000, 4000, 5000])) # Test input 10"}
{"source_Lan": "python###removeOrder.py", "source_code_str": "def removeOrder( n: int, arr: List[int], str: str) -> List[int]:\n        \n        arr.sort()\n        i = 0\n        j = n - 1\n        ans = [0] * n\n        idx = 0\n        for ch in str:\n            if ch == '0':\n                ans[idx] = arr[i]\n                i += 1\n            else:\n                ans[idx] = arr[j]\n                j -= 1\n            idx += 1\n        return ans", "source_code_block": "", "target_Lan": "java###removeOrder_Test.java", "reference_code": "public static int[] removeOrder(int n, int[] arr, String str) {\n        Arrays.sort(arr);\n        int i = 0, j = n - 1;\n        int[] ans = new int[n];\n        int idx = 0;\n        for (char ch : str.toCharArray()) {\n            if (ch == '0')\n                ans[idx++] = arr[i++];\n            else\n                ans[idx++] = arr[j--];\n        }\n        return ans;\n    }", "target_method_signature": "removeOrder", "source_method_signature": "removeOrder", "source_allMS": "def removeOrder( n: int, arr: List[int], str: str) -> List[int]:", "source_import": "from typing import List", "target_import": "import java.util.*;\nimport java.lang.*;\nimport java.util.Arrays;", "commentTag": "//", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.Arrays;\nimport java.util.Arrays;\npublic class removeOrder_Test {\n// TOFILL\npublic static void main(String[] args) {\n        System.out.println(Arrays.toString(removeOrder(0, new int[]{}, \"\")));\n        System.out.println(Arrays.toString(removeOrder(1, new int[]{5}, \"0\")));\n        System.out.println(Arrays.toString(removeOrder(3, new int[]{3, 1, 2}, \"000\")));\n        System.out.println(Arrays.toString(removeOrder(3, new int[]{3, 1, 2}, \"111\")));\n        System.out.println(Arrays.toString(removeOrder(4, new int[]{4, 2, 3, 1}, \"0101\")));\n        System.out.println(Arrays.toString(removeOrder(4, new int[]{2, 2, 1, 1}, \"0010\")));\n        System.out.println(Arrays.toString(removeOrder(5, new int[]{-1, -2, -3, -4, -5}, \"00000\")));\n        System.out.println(Arrays.toString(removeOrder(5, new int[]{10, 20, 30, 40, 50}, \"11111\")));\n        System.out.println(Arrays.toString(removeOrder(5, new int[]{1, 1, 1, 1, 1}, \"10001\")));\n        System.out.println(Arrays.toString(removeOrder(6, new int[]{5, 3, 6, 2, 1, 4}, \"101010\")));\n    }\n}", "all_input_output_value": "\ninput1: n=0, arr=[], str=\"\"\noutput1: []\n--------\ninput2: n=1, arr=[5], str=\"0\"\noutput2: [5]\n--------\ninput3: n=3, arr=[3, 1, 2], str=\"000\"\noutput3: [1, 2, 3]\n--------\ninput4: n=3, arr=[3, 1, 2], str=\"111\"\noutput4: [3, 2, 1]\n--------\ninput5: n=4, arr=[4, 2, 3, 1], str=\"0101\"\noutput5: [1, 4, 2, 3]\n--------\ninput6: n=4, arr=[2, 2, 1, 1], str=\"0010\"\noutput6: [1, 1, 2, 2]\n--------\ninput7: n=5, arr=[-1, -2, -3, -4, -5], str=\"00000\"\noutput7: [-5, -4, -3, -2, -1]\n--------\ninput8: n=5, arr=[10, 20, 30, 40, 50], str=\"11111\"\noutput8: [50, 40, 30, 20, 10]\n--------\ninput9: n=5, arr=[1, 1, 1, 1, 1], str=\"10001\"\noutput9: [1, 1, 1, 1, 1]\n--------\ninput10: n=6, arr=[5, 3, 6, 2, 1, 4], str=\"101010\"\noutput10: [6, 1, 5, 2, 4, 3]\n", "target_allMS": "public static int[] removeOrder(int n, int[] arr, String str) {", "input_output_value": ["\ninput1: n=0, arr=[], str=\"\"\noutput1: []\n", "\ninput2: n=1, arr=[5], str=\"0\"\noutput2: [5]\n", "\ninput3: n=3, arr=[3, 1, 2], str=\"000\"\noutput3: [1, 2, 3]\n"], "TAG": "Success", "source_code_shell": "from typing import List\nfrom typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(removeOrder(0, [], \"\"))\n    print(removeOrder(1, [5], \"0\"))\n    print(removeOrder(3, [3, 1, 2], \"000\"))\n    print(removeOrder(3, [3, 1, 2], \"111\"))\n    print(removeOrder(4, [4, 2, 3, 1], \"0101\"))\n    print(removeOrder(4, [2, 2, 1, 1], \"0010\"))\n    print(removeOrder(5, [-1, -2, -3, -4, -5], \"00000\"))\n    print(removeOrder(5, [10, 20, 30, 40, 50], \"11111\"))\n    print(removeOrder(5, [1, 1, 1, 1, 1], \"10001\"))\n    print(removeOrder(6, [5, 3, 6, 2, 1, 4], \"101010\"))"}
{"source_Lan": "python###minimumAverage.py", "source_code_str": "def minimumAverage( nums: List[int]) -> float:\n    nums.sort()\n    return min(nums[i] + nums[-1 - i] for i in range(len(nums) // 2)) / 2", "source_code_block": "", "target_Lan": "java###minimumAverage_Test.java", "reference_code": "    public static double minimumAverage(int[] nums) {\n        Arrays.sort(nums);\n        int ans = Integer.MAX_VALUE;\n        int n = nums.length;\n        for (int i = 0; i < n / 2; i++) {\n            ans = Math.min(ans, nums[i] + nums[n - 1 - i]);\n        }\n        return ans / 2.0;\n    }", "target_method_signature": "minimumAverage", "source_method_signature": "minimumAverage", "target_allMS": "    public static double minimumAverage(int[] nums) {", "source_allMS": "def minimumAverage( nums: List[int]) -> float:", "source_import": "", "target_import": "import java.util.*;\nimport java.lang.*;", "commentTag": "//", "source_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(minimumAverage([1, 1, 1, 1, 1]))  # Test input 1\n    print(minimumAverage([-2, -1, 0, 1, 2]))  # Test input 2\n    print(minimumAverage([1000000, 999999, 1000001, 1000002]))  # Test input 3", "all_input_output_value": "\ninput1: nums=[1, 1, 1, 1, 1]\noutput1: 1.0\n--------\ninput2: nums=[-2, -1, 0, 1, 2]\noutput2: 0.0\n--------\ninput3: nums=[1000000, 999999, 1000001, 1000002]\noutput3: 1000000.5\n", "input_output_value": ["\ninput1: nums=[1, 1, 1, 1, 1]\noutput1: 1.0\n", "\ninput2: nums=[-2, -1, 0, 1, 2]\noutput2: 0.0\n", "\ninput3: nums=[1000000, 999999, 1000001, 1000002]\noutput3: 1000000.5\n"], "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.Arrays;\npublic class minimumAverage_Test {\n// TOFILL\npublic static void main(String[] args) {\n        System.out.println(minimumAverage(new int[]{1, 1, 1, 1, 1}));\n        System.out.println(minimumAverage(new int[]{-2, -1, 0, 1, 2}));\n        System.out.println(minimumAverage(new int[]{1000000, 999999, 1000001, 1000002}));\n    }\n}", "TAG": "Success"}
{"source_Lan": "python###maximumLength.py", "source_code_str": "def maximumLength( nums: List[int], k: int) -> int:\n    f = [[0] * k for _ in range(k)]\n    for x in nums:\n        x %= k\n        for y, fxy in enumerate(f[x]):\n            f[y][x] = fxy + 1\n    return max(map(max, f))", "source_code_block": "", "target_Lan": "java###maximumLength_Test.java", "reference_code": "    public static int maximumLength(int[] nums, int k) {\n        int ans = 0;\n        int[][] f = new int[k][k];\n        for (int x : nums) {\n            x %= k;\n            for (int y = 0; y < k; y++) {\n                f[y][x] = f[x][y] + 1;\n                ans = Math.max(ans, f[y][x]);\n            }\n        }\n        return ans;\n    }", "target_method_signature": "maximumLength", "source_method_signature": "maximumLength", "target_allMS": "    public static int maximumLength(int[] nums, int k) {", "source_allMS": "def maximumLength( nums: List[int], k: int) -> int:", "source_import": "", "target_import": "import java.util.*;\nimport java.lang.*;", "commentTag": "//", "source_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(maximumLength([1, 2, 3], 2))\n    print(maximumLength([0, 0, 0], 1))\n    print(maximumLength([-3, -6, -9], 3))\n    print(maximumLength([5, 10, 15, 20], 5))\n    print(maximumLength([1, 2, 3, 4, 5], 4))", "all_input_output_value": "\ninput1: nums=[1, 2, 3], k=2\noutput1: 3\n--------\ninput2: nums=[0, 0, 0], k=1\noutput2: 3\n--------\ninput3: nums=[-3, -6, -9], k=3\noutput3: 3\n--------\ninput4: nums=[5, 10, 15, 20], k=5\noutput4: 4\n--------\ninput5: nums=[1, 2, 3, 4, 5], k=4\noutput5: 3\n", "input_output_value": ["\ninput1: nums=[1, 2, 3], k=2\noutput1: 3\n", "\ninput2: nums=[0, 0, 0], k=1\noutput2: 3\n", "\ninput3: nums=[-3, -6, -9], k=3\noutput3: 3\n"], "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.Arrays;\npublic class maximumLength_Test {\n// TOFILL\npublic static void main(String[] args) {\n        System.out.println(maximumLength(new int[]{1, 2, 3}, 2));\n        System.out.println(maximumLength(new int[]{0, 0, 0}, 1));\n        System.out.println(maximumLength(new int[]{-3, -6, -9}, 3));\n        System.out.println(maximumLength(new int[]{5, 10, 15, 20}, 5));\n        System.out.println(maximumLength(new int[]{1, 2, 3, 4, 5}, 4));\n    }\n}", "TAG": "Success"}
{"source_Lan": "python###canSortArray.py", "source_code_str": "def canSortArray( nums: List[int]) -> bool:\n    lastCnt = 0\n    lastGroupMax = 0\n    curGroupMax = 0\n    for num in nums:\n        curCnt = num.bit_count()\n        if curCnt == lastCnt:\n            curGroupMax = max(curGroupMax, num)\n        else:\n            lastCnt = curCnt\n            lastGroupMax = curGroupMax\n            curGroupMax = num\n        if num < lastGroupMax:\n            return False\n    return True", "source_code_block": "", "target_Lan": "java###canSortArray_Test.java", "reference_code": "    public static boolean canSortArray(int[] nums) {\n        int lastCnt = 0;\n        int lastGroupMax = 0;\n        int curGroupMax = 0;\n        for (int num : nums) {\n            int curCnt = Integer.bitCount(num);\n            if (curCnt == lastCnt) {\n                curGroupMax = Math.max(curGroupMax, num);\n            } else {\n                lastCnt = curCnt;\n                lastGroupMax = curGroupMax;\n                curGroupMax = num;\n            }\n            if (num < lastGroupMax) {\n                return false;\n            }\n        }\n        return true;\n    }", "target_method_signature": "canSortArray", "source_method_signature": "canSortArray", "target_allMS": "    public static boolean canSortArray(int[] nums) {", "source_allMS": "def canSortArray( nums: List[int]) -> bool:", "source_import": "", "target_import": "import java.util.*;\nimport java.lang.*;", "commentTag": "//", "source_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(canSortArray([]))                  # Empty array should return true", "all_input_output_value": "\ninput1: nums=[]\noutput1: True\n", "input_output_value": ["\ninput1: nums=[]\noutput1: True\n"], "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.Arrays;\npublic class canSortArray_Test {\n// TOFILL\npublic static void main(String[] args) {\n        int[] nums = {};\n        System.out.println(canSortArray(nums));\n    }\n}", "TAG": "Success"}
{"source_Lan": "python###maxSumII.py", "source_code_str": "def maxSumII( n, arr, brr):\n    ans = [0] * n\n    ma = 0\n    brr.reverse()\n    v = [0] * n\n    vp = [0,0] * n\n    fans = []\n    for i in brr:\n        fans.append(ma)\n        b = i - 1\n        temp = arr[b]\n        left = b\n        right = b\n        if b - 1 >= 0 and v[b - 1] != 0:\n            temp += ans[b - 1]\n            left = min(left, vp[b - 1][0])\n        if b + 1 < n and v[b + 1] != 0:\n            temp += ans[b + 1]\n            right = max(right, vp[b + 1][1])\n        v[b] = arr[b]\n        ans[left] = temp\n        ans[right] = temp\n        vp[left] = (left, right)\n        vp[right] = (left, right)\n        ma = max(temp, ma)\n    fans.reverse()\n    return fans", "source_code_block": "", "target_Lan": "java###maxSumII_Test.java", "reference_code": "    public static ArrayList<Long> maxSumII(int n, int[] arr, int[] brr) {\n        long[] ans = new long[n];     \n        long ma = 0;                  \n        int[] v = new int[n];         \n        long[][] vp = new long[n][2]; \n        ArrayList<Long> fans = new ArrayList<>(); \n        \n        for (int i = brr.length - 1; i >= 0; --i) {\n            fans.add(ma);            \n            long b = brr[i] - 1;     \n            long temp = arr[(int)b]; \n            long left = b;           \n            long right = b;          \n            \n            if (b - 1 >= 0 && v[(int)(b - 1)] != 0) {\n                temp += ans[(int)(b - 1)];\n                left = Math.min(left, vp[(int)(b - 1)][0]);\n            }\n            \n            if (b + 1 < n && v[(int)(b + 1)] != 0) {\n                temp += ans[(int)(b + 1)];\n                right = Math.max(right, vp[(int)(b + 1)][1]);\n            }\n            v[(int)b] = arr[(int)b];                  \n            ans[(int)left] = temp;                    \n            ans[(int)right] = temp;                   \n            vp[(int)left] = new long[] {left, right}; \n            vp[(int)right] = new long[] {left, right}; \n            ma = Math.max(temp, ma);                   \n        }\n        Collections.reverse(fans); \n        return fans;               \n    }", "target_method_signature": "maxSumII", "source_method_signature": "maxSumII", "target_allMS": "    public static ArrayList<Long> maxSumII(int n, int[] arr, int[] brr) {", "source_allMS": "def maxSumII( n, arr, brr):", "source_import": "", "target_import": "import java.util.*;\nimport java.lang.*;", "commentTag": "//", "source_code_shell": "# TOFILL\nif __name__ == \"__main__\":\n    print(maxSumII(5, [1, 2, 3, 4, 5], [5, 4, 3, 2, 1]))\n    print(maxSumII(1, [10], [1]))\n    print(maxSumII(3, [1, 2, 3], [3, 2, 1]))\n    print(maxSumII(4, [10, 20, 30, 40], [4, 3, 2, 1]))\n    print(maxSumII(2, [100, 200], [2, 1]))", "all_input_output_value": "## Python_code\ndef maxSumII( n, arr, brr):\n...\nif __name__ == \"__main__\":\n    print(maxSumII(5, [1, 2, 3, 4, 5], [5, 4, 3, 2, 1]))\n    print(maxSumII(1, [10], [1]))\n    print(maxSumII(3, [1, 2, 3], [3, 2, 1]))\n    print(maxSumII(4, [10, 20, 30, 40], [4, 3, 2, 1]))\n    print(maxSumII(2, [100, 200], [2, 1]))\n    \n## After running the printed result is as follows\n[10, 6, 3, 1, 0]\n[0]\n[3, 1, 0]\n[60, 30, 10, 0]\n[100, 0]\n\n## Please match the input in Python_code with the printed result. The match result should be wrapped within ``` ```.##\n## Output\n```\ninput1: n=5, arr=[1, 2, 3, 4, 5], brr=[5, 4, 3, 2, 1]\noutput1: [10, 6, 3, 1, 0]\n--------\ninput2: n=1, arr=[10], brr=[1]\noutput2: [0]\n--------\ninput3: n=3, arr=[1, 2, 3], brr=[3, 2, 1]\noutput3: [3, 1, 0]\n--------\ninput4: n=4, arr=[10, 20, 30, 40], brr=[4, 3, 2, 1]\noutput4: [60, 30, 10, 0]\n--------\ninput5: n=2, arr=[100, 200], brr=[2, 1]\noutput5: [100, 0]\n", "input_output_value": ["## Python_code\ndef maxSumII( n, arr, brr):\n...\nif __name__ == \"__main__\":\n    print(maxSumII(5, [1, 2, 3, 4, 5], [5, 4, 3, 2, 1]))\n    print(maxSumII(1, [10], [1]))\n    print(maxSumII(3, [1, 2, 3], [3, 2, 1]))\n    print(maxSumII(4, [10, 20, 30, 40], [4, 3, 2, 1]))\n    print(maxSumII(2, [100, 200], [2, 1]))\n    \n## After running the printed result is as follows\n[10, 6, 3, 1, 0]\n[0]\n[3, 1, 0]\n[60, 30, 10, 0]\n[100, 0]\n\n## Please match the input in Python_code with the printed result. The match result should be wrapped within ``` ```.##\n## Output\n```\ninput1: n=5, arr=[1, 2, 3, 4, 5], brr=[5, 4, 3, 2, 1]\noutput1: [10, 6, 3, 1, 0]\n", "\ninput2: n=1, arr=[10], brr=[1]\noutput2: [0]\n", "\ninput3: n=3, arr=[1, 2, 3], brr=[3, 2, 1]\noutput3: [3, 1, 0]\n"], "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.ArrayList;\nimport java.util.Arrays;\npublic class maxSumII_Test {\n// TOFILL\npublic static void main(String[] args) {\n        System.out.println(maxSumII(5, new int[]{1, 2, 3, 4, 5}, new int[]{5, 4, 3, 2, 1}));\n        System.out.println(maxSumII(1, new int[]{10}, new int[]{1}));\n        System.out.println(maxSumII(3, new int[]{1, 2, 3}, new int[]{3, 2, 1}));\n        System.out.println(maxSumII(4, new int[]{10, 20, 30, 40}, new int[]{4, 3, 2, 1}));\n        System.out.println(maxSumII(2, new int[]{100, 200}, new int[]{2, 1}));\n    }\n}", "TAG": "Success"}
{"source_Lan": "python###findTheArrayConcVal.py", "source_code_str": "def findTheArrayConcVal( nums: List[int]) -> int:\n        ans = 0\n        i, j = 0, len(nums) - 1\n        while i <= j:\n            if i != j:\n                ans += int(str(nums[i]) + str(nums[j]))\n            else:\n                ans += nums[i]\n            i += 1\n            j -= 1\n        return ans", "source_code_block": "", "target_Lan": "java###findTheArrayConcVal_Test.java", "reference_code": "public static long findTheArrayConcVal(int[] nums) {\n        long ans = 0;\n        for (int i = 0, j = nums.length - 1; i <= j; i++, j--) {\n            if (i != j) {\n                ans += Integer.parseInt(Integer.toString(nums[i]) + Integer.toString(nums[j]));\n            } else {\n                ans += nums[i];\n            }\n        }\n        return ans;\n    }", "target_method_signature": "findTheArrayConcVal", "source_method_signature": "findTheArrayConcVal", "source_allMS": "def findTheArrayConcVal( nums: List[int]) -> int:", "source_import": "from typing import List", "target_import": "import java.util.*;\nimport java.lang.*;\nimport java.util.Arrays;", "commentTag": "//", "target_code_shell": "import java.util.*;\nimport java.lang.*;\nimport java.util.Arrays;\nimport java.util.Arrays;\npublic class findTheArrayConcVal_Test {\n// TOFILL\npublic static void main(String[] args) {\n        System.out.println(findTheArrayConcVal(new int[]{1,2,3,4,5}));\n        System.out.println(findTheArrayConcVal(new int[]{10,20,30,40,50}));\n        System.out.println(findTheArrayConcVal(new int[]{100,200,300,400,500}));\n        System.out.println(findTheArrayConcVal(new int[]{1000,2000,3000,4000,5000}));\n        System.out.println(findTheArrayConcVal(new int[]{10000,20000,30000,40000,50000}));\n    }\n}", "all_input_output_value": "## Python_code\ndef findTheArrayConcVal( nums: List[int]) -> int:\n...\nif __name__ == \"__main__\":\n    print(findTheArrayConcVal([1,2,3,4,5]))\n    print(findTheArrayConcVal([10,20,30,40,50]))\n    print(findTheArrayConcVal([100,200,300,400,500]))\n    print(findTheArrayConcVal([1000,2000,3000,4000,5000]))\n    print(findTheArrayConcVal([10000,20000,30000,40000,50000]))\n    \n## After running the printed result is as follows\n42\n3120\n301200\n30012000\n3000120000\n\n## Please match the input in Python_code with the printed result. The match result should be wrapped within ``` ```.##\n## Output\n```\ninput1: nums=[1,2,3,4,5]\noutput1: 42\n--------\ninput2: nums=[10,20,30,40,50]\noutput2: 3120\n--------\ninput3: nums=[100,200,300,400,500]\noutput3: 301200\n--------\ninput4: nums=[1000,2000,3000,4000,5000]\noutput4: 30012000\n--------\ninput5: nums=[10000,20000,30000,40000,50000]\noutput5: 3000120000\n", "target_allMS": "public static long findTheArrayConcVal(int[] nums) {", "input_output_value": ["## Python_code\ndef findTheArrayConcVal( nums: List[int]) -> int:\n...\nif __name__ == \"__main__\":\n    print(findTheArrayConcVal([1,2,3,4,5]))\n    print(findTheArrayConcVal([10,20,30,40,50]))\n    print(findTheArrayConcVal([100,200,300,400,500]))\n    print(findTheArrayConcVal([1000,2000,3000,4000,5000]))\n    print(findTheArrayConcVal([10000,20000,30000,40000,50000]))\n    \n## After running the printed result is as follows\n42\n3120\n301200\n30012000\n3000120000\n\n## Please match the input in Python_code with the printed result. The match result should be wrapped within ``` ```.##\n## Output\n```\ninput1: nums=[1,2,3,4,5]\noutput1: 42\n", "\ninput2: nums=[10,20,30,40,50]\noutput2: 3120\n", "\ninput3: nums=[100,200,300,400,500]\noutput3: 301200\n"], "TAG": "Success", "source_code_shell": "from typing import List\nfrom typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(findTheArrayConcVal([1,2,3,4,5]))\n    print(findTheArrayConcVal([10,20,30,40,50]))\n    print(findTheArrayConcVal([100,200,300,400,500]))\n    print(findTheArrayConcVal([1000,2000,3000,4000,5000]))\n    print(findTheArrayConcVal([10000,20000,30000,40000,50000]))"}
{"source_Lan": "python###mostFrequent.py", "source_code_str": "def mostFrequent(n,arr):\n    dic={}\n    for ele in arr:\n        if ele in dic:\n            dic[ele]+=1\n        else:\n            dic[ele]=1\n    mx=0\n    for ele in dic.values():\n        mx=max(mx,ele)\n    ans=0\n    for key in sorted(dic):\n        if dic[key]==mx:\n            ans=key\n    return ans", "source_code_block": "", "target_Lan": "java###mostFrequent_Test.java", "reference_code": "public static int mostFrequent(int a[], int n)\n    {\n        HashMap<Integer, Integer> mp = new HashMap<>();\n        for(int i=0;i<n;i++)\n        {\n            if(mp.containsKey(a[i]))\n                mp.put(a[i], mp.get(a[i])+1);\n            else\n                mp.put(a[i],1);\n        }\n        int ans=-1,res=0;\n        for(Entry<Integer,Integer> val : mp.entrySet())\n            res=Math.max(res,val.getValue());\n        for(Entry<Integer,Integer> val : mp.entrySet())\n        {\n            if (val.getValue()==res&&val.getKey()>ans)\n                ans=val.getKey();\n        }\n        return ans;\n    }", "target_method_signature": "mostFrequent", "source_method_signature": "mostFrequent", "source_allMS": "def mostFrequent(n,arr):", "source_import": "from typing import List", "target_import": "import java.util.HashMap;\nimport java.util.Map;\nimport java.util.Map.Entry;", "commentTag": "//", "target_code_shell": "import java.util.HashMap;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.HashMap;\nimport java.util.Map.Entry;\npublic class mostFrequent_Test {\n// TOFILL\npublic static void main(String[] args) {\n        int[] arr1 = {1, 2, 3, 3, 2, 1, 1, 1, 2, 3, 3, 2, 1};\n        int[] arr2 = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n        int[] arr3 = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1};\n        int[] arr4 = {10, 20, 30, 40, 50, 60, 70, 80, 90, 100};\n        int[] arr5 = {1, 2, 3, 4, 5, 1, 2, 3, 4, 5};\n\n        System.out.println(mostFrequent(arr1, 13));\n        System.out.println(mostFrequent(arr2, 10));\n        System.out.println(mostFrequent(arr3, 10));\n        System.out.println(mostFrequent(arr4, 10));\n        System.out.println(mostFrequent(arr5, 10));\n    }\n}", "all_input_output_value": "\ninput1: n=13, arr=[1, 2, 3, 3, 2, 1, 1, 1, 2, 3, 3, 2, 1]\noutput1: 1\n--------\ninput2: n=10, arr=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\noutput2: 10\n--------\ninput3: n=10, arr=[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\noutput3: 1\n--------\ninput4: n=10, arr=[10, 20, 30, 40, 50, 60, 70, 80, 90, 100]\noutput4: 100\n--------\ninput5: n=10, arr=[1, 2, 3, 4, 5, 1, 2, 3, 4, 5]\noutput5: 5\n", "target_allMS": "public static int mostFrequent(int a[], int n)", "input_output_value": ["\ninput1: n=13, arr=[1, 2, 3, 3, 2, 1, 1, 1, 2, 3, 3, 2, 1]\noutput1: 1\n", "\ninput2: n=10, arr=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\noutput2: 10\n", "\ninput3: n=10, arr=[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\noutput3: 1\n"], "TAG": "Success", "source_code_shell": "from typing import List\n\n# TOFILL\nif __name__ == \"__main__\":\n    print(mostFrequent(13,[1, 2, 3, 3, 2, 1, 1, 1, 2, 3, 3, 2, 1]))\n    print(mostFrequent(10,[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]))\n    print(mostFrequent(10,[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]))\n    print(mostFrequent(10,[10, 20, 30, 40, 50, 60, 70, 80, 90, 100]))\n    print(mostFrequent(10,[1, 2, 3, 4, 5, 1, 2, 3, 4, 5]))"}
{"source_Lan": "python###minimumSubstringsInPartition.py", "source_code_str": "def minimumSubstringsInPartition(s: str) -> int:\n        n = len(s)\n        d = [math.inf] * (n + 1)\n        occ_cnt = defaultdict(int)\n        d[0] = 0\n        for i in range(1, n + 1):\n            occ_cnt.clear()\n            max_cnt = 0\n            for j in range(i, 0, -1):\n                occ_cnt[s[j - 1]] += 1\n                max_cnt = max(max_cnt, occ_cnt[s[j - 1]])\n                if max_cnt * len(occ_cnt) == i - j + 1 and d[j - 1] != math.inf:\n                    d[i] = min(d[i], d[j - 1] + 1)\n        return d[n]\n\n", "source_code_shell": "from collections import defaultdict\nimport math\nimport math\nfrom collections import defaultdict\n# TOFILL\nif __name__ == \"__main__\":\n    print(minimumSubstringsInPartition(\"a\"))\n    print(minimumSubstringsInPartition(\"aaa\"))\n    print(minimumSubstringsInPartition(\"abab\"))\n    print(minimumSubstringsInPartition(\"abcabcabcabc\"))\n    print(minimumSubstringsInPartition(\"abcdabcdabcdabcd\"))"}
{"source_Lan": "python###firstContact.py", "source_code_str": "def firstContact( n: int, m: int) -> int:\n    #just return the LCM of n and m\n    return (n * m) // gcd(n, m)", "source_code_shell": "from math import gcd\nfrom math import gcd\n# TOFILL\nif __name__ == \"__main__\":\n    print(firstContact(0, 5))\n    print(firstContact(12, 15))\n    print(firstContact(7, 7))\n    print(firstContact(14, 21))\n    print(firstContact(11, 13))"}
{"source_Lan": "python###minEnd.py", "source_code_str": "def minEnd( n: int, x: int) -> int:\n    n -= 1  # 先把 n 减一，这样下面讨论的 n 就是原来的 n-1\n    i = j = 0\n    while n >> j:\n        # x 的第 i 个比特值是 0，即「空位」\n        if (x >> i & 1) == 0:\n            # 空位填入 n 的第 j 个比特值\n            x |= (n >> j & 1) << i\n            j += 1\n        i += 1\n    return x", "source_code_shell": "# TOFILL\nif __name__ == \"__main__\":\n    print(minEnd(1, 0))\n    print(minEnd(1023, 1))\n    print(minEnd(15, 8))\n    print(minEnd(255, 127))\n    print(minEnd(10, 6))"}
{"source_Lan": "python###minJumps2.py", "source_code_str": "def minJumps2( n, arr):\n    right_greater = [n] * n\n    right_lesser = [n] * n\n    stack = []\n    for i in range(n):\n        while stack and arr[stack[-1]] < arr[i]:\n            right_greater[stack[-1]] = i\n            stack.pop()\n        stack.append(i)\n    stack.clear()\n    for i in range(n):\n        while stack and arr[stack[-1]] > arr[i]:\n            right_lesser[stack[-1]] = i\n            stack.pop()\n        stack.append(i)\n    queue = deque([(0, 0)])\n    visited = [0] * n\n    while queue:\n        p, d = queue.popleft()\n        if visited[p] == 1:\n            continue\n        visited[p] = 1\n        if p == n - 1:\n            return d\n        temp = p + 1\n        # max(arr[i], arr[j]) < min(arr[i+1], arr[i+2], ......, arr[j-2], arr[j-1])\n        if arr[temp] > arr[p]:\n            while temp != n and arr[temp] > arr[p]:\n                queue.append((temp, d + 1))\n                temp = right_lesser[temp]\n            if temp != n:\n                queue.append((temp, d + 1))\n        # min(arr[i], arr[j]) < max(arr[i+1], arr[i+2], ......, arr[j-2], arr[j-1])\n        else:\n            while temp != n and arr[temp] < arr[p]:\n                queue.append((temp, d + 1))\n                temp = right_greater[temp]\n            if temp != n:\n                queue.append((temp, d + 1))\n    return -1", "source_code_shell": "from collections import deque\nfrom collections import deque\n# TOFILL\nif __name__ == \"__main__\":\n    print(minJumps2(5, [1, 3, 2, 1, 4]))\n    print(minJumps2(6, [6, 5, 4, 3, 2, 1]))\n    print(minJumps2(6, [1, 2, 3, 4, 5, 6]))\n    print(minJumps2(7, [1, 4, 3, 2, 1, 4, 5]))\n    print(minJumps2(3, [1, 2, 1]))\n    print(minJumps2(4, [5, 4, 3, 2]))\n    print(minJumps2(5, [2, 1, 3, 2, 1]))\n    print(minJumps2(2, [1, 1]))\n    print(minJumps2(1, [0]))\n    print(minJumps2(6, [1, 5, 1, 5, 1, 5]))"}
{"source_Lan": "python###firstDayBeenInAllRooms.py", "source_code_str": "def firstDayBeenInAllRooms( nextVisit: List[int]) -> int:\n    mod = 10**9 + 7\n    dp = [0] * (len(nextVisit))\n    #初始化原地待一天+访问下一个房间一天\n    dp[0] = 2 \n    for i in range(1, len(nextVisit)):\n        to = nextVisit[i]\n        dp[i] = 2 + dp[i - 1] \n        if to != 0:\n            dp[i] = (dp[i] - dp[to - 1]) % mod \n        dp[i] = (dp[i] + dp[i - 1]) % mod\n    return dp[len(nextVisit) - 2] # 题目保证n >= 2", "source_code_shell": "from typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(firstDayBeenInAllRooms([1, 2, 0]))               # Test Input 1\n    print(firstDayBeenInAllRooms([1, 0, 0]))               # Test Input 2\n    print(firstDayBeenInAllRooms([1, 2, 3, 4, 0]))         # Test Input 3\n    print(firstDayBeenInAllRooms([1, 0, 0, 0]))            # Test Input 4\n    print(firstDayBeenInAllRooms([0, 1]))                   # Test Input 5\n    print(firstDayBeenInAllRooms([2, 1, 0]))                # Test Input 6\n    print(firstDayBeenInAllRooms([2, 3, 4, 0]))             # Test Input 7\n    print(firstDayBeenInAllRooms([1, 2, 0, 1]))             # Test Input 8\n    print(firstDayBeenInAllRooms([2, 1, 0, 3]))             # Test Input 9\n    print(firstDayBeenInAllRooms([0] * 100))                # Test Input 10"}
{"source_Lan": "python###countSubstrings.py", "source_code_str": "def countSubstrings( s: str, c: str) -> int:\n    return comb(s.count(c) + 1, 2)", "source_code_shell": "from math import comb\n# TOFILL\nif __name__ == \"__main__\":\n    print(countSubstrings(\"hello\", 'l'))\n    print(countSubstrings(\"abcd\", 'e'))\n    print(countSubstrings(\"aaaa\", 'a'))\n    print(countSubstrings(\"abcabc\", 'b'))\n    print(countSubstrings(\"\", 'a'))\n    print(countSubstrings(\"xyzyx\", 'z'))\n    print(countSubstrings(\"ab\", 'a'))\n    print(countSubstrings(\"xxxyyy\", 'x'))\n    print(countSubstrings(\"ababab\", 'a'))\n    print(countSubstrings(\"The quick brown fox\", 'q'))"}
{"source_Lan": "python###distanceTraveled.py", "source_code_str": "def distanceTraveled( mainTank: int, additionalTank: int) -> int:\n    ans = 0\n    while mainTank >= 5:\n        mainTank -= 5\n        ans += 50\n        if additionalTank > 0:\n            additionalTank -= 1\n            mainTank += 1\n    return ans + mainTank * 10", "source_code_shell": "# TOFILL\nif __name__ == \"__main__\":\n    print(distanceTraveled(10, 5))\n    print(distanceTraveled(5, 0))\n    print(distanceTraveled(0, 5))\n    print(distanceTraveled(7, 2))\n    print(distanceTraveled(50, 10))\n    print(distanceTraveled(0, 0))\n    print(distanceTraveled(30, 1))\n    print(distanceTraveled(20, 20))\n    print(distanceTraveled(100, 50))\n    print(distanceTraveled(14, 3))"}
{"source_Lan": "python###bobHappiness.py", "source_code_str": "def bobHappiness( n: int, k: int, q: int, students: List[List[int]],\n                 queries: List[List[int]]) -> int:\n    # Extract and sort the unique values\n    unique_x = sorted(set(a[0] for a in students))\n    unique_y = sorted(set(a[1] for a in students))\n    # Create mapping from value to index\n    map1 = {val: idx + 1 for idx, val in enumerate(unique_x)}\n    map2 = {val: idx + 1 for idx, val in enumerate(unique_y)}\n    # Create the prefix sum array\n    pre = [[0] * (n + 1) for _ in range(n + 1)]\n    for i in range(n):\n        x = map1[students[i][0]]\n        y = map2[students[i][1]]\n        pre[x][y] += 1\n    # Compute 2D prefix sums\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            pre[i][j] += pre[i - 1][j] + pre[i][j - 1] - pre[i - 1][j - 1]\n    sum_happiness = 0\n    for X, Y in queries:\n        X -= 1\n        Y -= 1\n        c = map1[students[Y][0]]\n        d = map2[students[Y][1]]\n        a = map1[students[X][0]]\n        b = map2[students[X][1]]\n        # Ensure c <= a and d <= b for proper submatrix calculation\n        if a < c: c, a = a, c\n        if b < d: d, b = b, d\n        # Number of students in the submatrix\n        people = pre[a][b] - pre[c - 1][b] - pre[a][d - 1] + pre[c - 1][d -\n                                                                        1]\n        # Update happiness count based on the condition\n        if people - 2 <= k:\n            sum_happiness += 1\n    return sum_happiness", "source_code_shell": "from typing import List\nfrom typing import List\n# TOFILL\nif __name__ == \"__main__\":\n    print(bobHappiness(0, 1, 0, [], []))\n    print(bobHappiness(1, 0, 1, [[1, 2]], [[1, 1]]))\n    print(bobHappiness(3, 1, 2, [[1, 2], [2, 3], [3, 4]], [[1, 1], [2, 3]]))\n    print(bobHappiness(3, 2, 1, [[1, 2], [1, 2], [1, 2]], [[1, 3]]))\n    print(bobHappiness(3, 1, 1, [[5, 5], [6, 6], [7, 7]], [[1, 1]]))\n    print(bobHappiness(5, 10, 5, [[1, 2], [3, 4], [5, 6], [7, 8], [9, 10]], [[1, 3], [2, 2], [3, 5], [1, 5], [4, 4]]))\n    print(bobHappiness(4, 2, 0, [[2, 3], [2, 3], [4, 5], [6, 7]], []))\n    print(bobHappiness(6, 5, 3, [[0, 0], [2, 2], [4, 4], [1, 1], [3, 3], [5, 5]], [[1, 6], [2, 5], [3, 4]]))"}
